// @flow
// Types for TDLib v1.8.46 (207f3be7b58b2a2b9f0a066b5b6ef18782b8b517)
// Generated using tdl-install-types v0.3.0
declare module 'tdlib-types' {
  declare export type error = {|
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    _: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    code: number,
    /** Error message; subject to future changes */
    message: string,
  |}

  declare export type error$Input = {|
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    +_: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    +code?: number,
    /** Error message; subject to future changes */
    +message?: string,
  |}

  declare export type ok = {|
    /**
     * An object of this type is returned on a successful function call for certain
     * functions
     */
    _: 'ok',
  |}

  declare export type authenticationCodeTypeTelegramMessage = {|
    /**
     * A digit-only authentication code is delivered via a private Telegram message,
     * which can be viewed from another active session
     */
    _: 'authenticationCodeTypeTelegramMessage',
    /** Length of the code */
    length: number,
  |}

  declare export type authenticationCodeTypeSms = {|
    /**
     * A digit-only authentication code is delivered via an SMS message to the specified
     * phone number; non-official applications may not receive this type of code
     */
    _: 'authenticationCodeTypeSms',
    /** Length of the code */
    length: number,
  |}

  declare export type authenticationCodeTypeSmsWord = {|
    /**
     * An authentication code is a word delivered via an SMS message to the specified
     * phone number; non-official applications may not receive this type of code
     */
    _: 'authenticationCodeTypeSmsWord',
    /** The first letters of the word if known */
    first_letter: string,
  |}

  declare export type authenticationCodeTypeSmsPhrase = {|
    /**
     * An authentication code is a phrase from multiple words delivered via an SMS
     * message to the specified phone number; non-official applications may not receive
     * this type of code
     */
    _: 'authenticationCodeTypeSmsPhrase',
    /** The first word of the phrase if known */
    first_word: string,
  |}

  declare export type authenticationCodeTypeCall = {|
    /**
     * A digit-only authentication code is delivered via a phone call to the specified
     * phone number
     */
    _: 'authenticationCodeTypeCall',
    /** Length of the code */
    length: number,
  |}

  declare export type authenticationCodeTypeFlashCall = {|
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The phone number that calls is the code that must be entered automatically
     */
    _: 'authenticationCodeTypeFlashCall',
    /** Pattern of the phone number from which the call will be made */
    pattern: string,
  |}

  declare export type authenticationCodeTypeMissedCall = {|
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The last digits of the phone number that calls are the code that
     * must be entered manually by the user
     */
    _: 'authenticationCodeTypeMissedCall',
    /** Prefix of the phone number from which the call will be made */
    phone_number_prefix: string,
    /** Number of digits in the code, excluding the prefix */
    length: number,
  |}

  declare export type authenticationCodeTypeFragment = {|
    /**
     * A digit-only authentication code is delivered to https://fragment.com. The user
     * must be logged in there via a wallet owning the phone number's NFT
     */
    _: 'authenticationCodeTypeFragment',
    /** URL to open to receive the code */
    url: string,
    /** Length of the code */
    length: number,
  |}

  declare export type authenticationCodeTypeFirebaseAndroid = {|
    /**
     * A digit-only authentication code is delivered via Firebase Authentication to
     * the official Android application
     */
    _: 'authenticationCodeTypeFirebaseAndroid',
    /** Parameters to be used for device verification */
    device_verification_parameters: FirebaseDeviceVerificationParameters,
    /** Length of the code */
    length: number,
  |}

  declare export type authenticationCodeTypeFirebaseIos = {|
    /**
     * A digit-only authentication code is delivered via Firebase Authentication to
     * the official iOS application
     */
    _: 'authenticationCodeTypeFirebaseIos',
    /**
     * Receipt of successful application token validation to compare with receipt from
     * push notification
     */
    receipt: string,
    /**
     * Time after the next authentication method is expected to be used if verification
     * push notification isn't received, in seconds
     */
    push_timeout: number,
    /** Length of the code */
    length: number,
  |}

  declare export type authenticationCodeInfo = {|
    /** Information about the authentication code that was sent */
    _: 'authenticationCodeInfo',
    /** A phone number that is being authenticated */
    phone_number: string,
    /** The way the code was sent to the user */
    type: AuthenticationCodeType,
    /** The way the next code will be sent to the user; may be null */
    next_type?: AuthenticationCodeType,
    /** Timeout before the code can be re-sent, in seconds */
    timeout: number,
  |}

  declare export type emailAddressAuthenticationCodeInfo = {|
    /** Information about the email address authentication code that was sent */
    _: 'emailAddressAuthenticationCodeInfo',
    /** Pattern of the email address to which an authentication code was sent */
    email_address_pattern: string,
    /** Length of the code; 0 if unknown */
    length: number,
  |}

  declare export type emailAddressAuthenticationCode$Input = {|
    /** An authentication code delivered to a user's email address */
    +_: 'emailAddressAuthenticationCode',
    /** The code */
    +code?: string,
  |}

  declare export type emailAddressAuthenticationAppleId$Input = {|
    /** An authentication token received through Apple ID */
    +_: 'emailAddressAuthenticationAppleId',
    /** The token */
    +token?: string,
  |}

  declare export type emailAddressAuthenticationGoogleId$Input = {|
    /** An authentication token received through Google ID */
    +_: 'emailAddressAuthenticationGoogleId',
    /** The token */
    +token?: string,
  |}

  declare export type emailAddressResetStateAvailable = {|
    /**
     * Email address can be reset after the given period. Call resetAuthenticationEmailAddress
     * to reset it and allow the user to authorize with a code sent to the user's phone
     * number
     */
    _: 'emailAddressResetStateAvailable',
    /**
     * Time required to wait before the email address can be reset; 0 if the user is
     * subscribed to Telegram Premium
     */
    wait_period: number,
  |}

  declare export type emailAddressResetStatePending = {|
    /**
     * Email address reset has already been requested. Call resetAuthenticationEmailAddress
     * to check whether immediate reset is possible
     */
    _: 'emailAddressResetStatePending',
    /**
     * Left time before the email address will be reset, in seconds. updateAuthorizationState
     * is not sent when this field changes
     */
    reset_in: number,
  |}

  declare export type textEntity = {|
    /** Represents a part of the text that needs to be formatted in some unusual way */
    _: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    offset: number,
    /** Length of the entity, in UTF-16 code units */
    length: number,
    /** Type of the entity */
    type: TextEntityType,
  |}

  declare export type textEntity$Input = {|
    /** Represents a part of the text that needs to be formatted in some unusual way */
    +_: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    +offset?: number,
    /** Length of the entity, in UTF-16 code units */
    +length?: number,
    /** Type of the entity */
    +type?: TextEntityType$Input,
  |}

  declare export type textEntities = {|
    /** Contains a list of text entities */
    _: 'textEntities',
    /** List of text entities */
    entities: Array<textEntity>,
  |}

  declare export type formattedText = {|
    /** A text with some entities */
    _: 'formattedText',
    /** The text */
    text: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. BlockQuote entities can't contain other BlockQuote entities. Bold,
     * Italic, Underline, Strikethrough, and Spoiler entities can contain and can be
     * part of any other entities. All other entities can't contain each other
     */
    entities: Array<textEntity>,
  |}

  declare export type formattedText$Input = {|
    /** A text with some entities */
    +_: 'formattedText',
    /** The text */
    +text?: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. BlockQuote entities can't contain other BlockQuote entities. Bold,
     * Italic, Underline, Strikethrough, and Spoiler entities can contain and can be
     * part of any other entities. All other entities can't contain each other
     */
    +entities?: $ReadOnlyArray<textEntity$Input>,
  |}

  declare export type termsOfService = {|
    /** Contains Telegram terms of service */
    _: 'termsOfService',
    /** Text of the terms of service */
    text: formattedText,
    /** The minimum age of a user to be able to accept the terms; 0 if age isn't restricted */
    min_user_age: number,
    /** True, if a blocking popup with terms of service must be shown to the user */
    show_popup: boolean,
  |}

  declare export type authorizationStateWaitTdlibParameters = {|
    /** Initialization parameters are needed. Call setTdlibParameters to provide them */
    _: 'authorizationStateWaitTdlibParameters',
  |}

  declare export type authorizationStateWaitPhoneNumber = {|
    /**
     * TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber
     * to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken
     * for other authentication options
     */
    _: 'authorizationStateWaitPhoneNumber',
  |}

  declare export type authorizationStateWaitEmailAddress = {|
    /**
     * TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress
     * to provide the email address, or directly call checkAuthenticationEmailCode
     * with Apple ID/Google ID token if allowed
     */
    _: 'authorizationStateWaitEmailAddress',
    /** True, if authorization through Apple ID is allowed */
    allow_apple_id: boolean,
    /** True, if authorization through Google ID is allowed */
    allow_google_id: boolean,
  |}

  declare export type authorizationStateWaitEmailCode = {|
    /**
     * TDLib needs the user's authentication code sent to an email address to authorize.
     * Call checkAuthenticationEmailCode to provide the code
     */
    _: 'authorizationStateWaitEmailCode',
    /** True, if authorization through Apple ID is allowed */
    allow_apple_id: boolean,
    /** True, if authorization through Google ID is allowed */
    allow_google_id: boolean,
    /** Information about the sent authentication code */
    code_info: emailAddressAuthenticationCodeInfo,
    /**
     * Reset state of the email address; may be null if the email address can't be
     * reset
     */
    email_address_reset_state?: EmailAddressResetState,
  |}

  declare export type authorizationStateWaitCode = {|
    /**
     * TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode
     * to check the code
     */
    _: 'authorizationStateWaitCode',
    /** Information about the authorization code that was sent */
    code_info: authenticationCodeInfo,
  |}

  declare export type authorizationStateWaitOtherDeviceConfirmation = {|
    /**
     * The user needs to confirm authorization on another logged in device by scanning
     * a QR code with the provided link
     */
    _: 'authorizationStateWaitOtherDeviceConfirmation',
    /** A tg:// URL for the QR code. The link will be updated frequently */
    link: string,
  |}

  declare export type authorizationStateWaitRegistration = {|
    /**
     * The user is unregistered and need to accept terms of service and enter their
     * first name and last name to finish registration. Call registerUser to accept
     * the terms of service and provide the data
     */
    _: 'authorizationStateWaitRegistration',
    /** Telegram terms of service */
    terms_of_service: termsOfService,
  |}

  declare export type authorizationStateWaitPassword = {|
    /**
     * The user has been authorized, but needs to enter a 2-step verification password
     * to start using the application. Call checkAuthenticationPassword to provide
     * the password, or requestAuthenticationPasswordRecovery to recover the password,
     * or deleteAccount to delete the account after a week
     */
    _: 'authorizationStateWaitPassword',
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email address has been set up */
    has_recovery_email_address: boolean,
    /** True, if some Telegram Passport elements were saved */
    has_passport_data: boolean,
    /**
     * Pattern of the email address to which the recovery email was sent; empty until
     * a recovery email has been sent
     */
    recovery_email_address_pattern: string,
  |}

  declare export type authorizationStateReady = {|
    /**
     * The user has been successfully authorized. TDLib is now ready to answer general
     * requests
     */
    _: 'authorizationStateReady',
  |}

  declare export type authorizationStateLoggingOut = {|
    /** The user is currently logging out */
    _: 'authorizationStateLoggingOut',
  |}

  declare export type authorizationStateClosing = {|
    /**
     * TDLib is closing, all subsequent queries will be answered with the error 500.
     * Note that closing TDLib can take a while. All resources will be freed only after
     * authorizationStateClosed has been received
     */
    _: 'authorizationStateClosing',
  |}

  declare export type authorizationStateClosed = {|
    /**
     * TDLib client is in its final state. All databases are closed and all resources
     * are released. No other updates will be received after this. All queries will
     * be responded to with error code 500. To continue working, one must create a
     * new instance of the TDLib client
     */
    _: 'authorizationStateClosed',
  |}

  declare export type firebaseDeviceVerificationParametersSafetyNet = {|
    /** Device verification must be performed with the SafetyNet Attestation API */
    _: 'firebaseDeviceVerificationParametersSafetyNet',
    /** Nonce to pass to the SafetyNet Attestation API */
    nonce: string /* base64 */,
  |}

  declare export type firebaseDeviceVerificationParametersPlayIntegrity = {|
    /**
     * Device verification must be performed with the classic Play Integrity verification
     * (https://developer.android.com/google/play/integrity/classic)
     */
    _: 'firebaseDeviceVerificationParametersPlayIntegrity',
    /** Base64url-encoded nonce to pass to the Play Integrity API */
    nonce: string,
    /** Cloud project number to pass to the Play Integrity API */
    cloud_project_number: string,
  |}

  declare export type passwordState = {|
    /** Represents the current state of 2-step verification */
    _: 'passwordState',
    /** True, if a 2-step verification password is set */
    has_password: boolean,
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email is set */
    has_recovery_email_address: boolean,
    /** True, if some Telegram Passport elements were saved */
    has_passport_data: boolean,
    /**
     * Information about the recovery email address to which the confirmation email
     * was sent; may be null
     */
    recovery_email_address_code_info?: emailAddressAuthenticationCodeInfo,
    /** Pattern of the email address set up for logging in */
    login_email_address_pattern: string,
    /**
     * If not 0, point in time (Unix timestamp) after which the 2-step verification
     * password can be reset immediately using resetPassword
     */
    pending_reset_date: number,
  |}

  declare export type recoveryEmailAddress = {|
    /** Contains information about the current recovery email address */
    _: 'recoveryEmailAddress',
    /** Recovery email address */
    recovery_email_address: string,
  |}

  declare export type temporaryPasswordState = {|
    /**
     * Returns information about the availability of a temporary password, which can
     * be used for payments
     */
    _: 'temporaryPasswordState',
    /** True, if a temporary password is available */
    has_password: boolean,
    /** Time left before the temporary password expires, in seconds */
    valid_for: number,
  |}

  declare export type localFile = {|
    /** Represents a local file */
    _: 'localFile',
    /** Local path to the locally available file part; may be empty */
    path: string,
    /** True, if it is possible to download or generate the file */
    can_be_downloaded: boolean,
    /** True, if the file can be deleted */
    can_be_deleted: boolean,
    /**
     * True, if the file is currently being downloaded (or a local copy is being generated
     * by some other means)
     */
    is_downloading_active: boolean,
    /** True, if the local copy is fully available */
    is_downloading_completed: boolean,
    /**
     * Download will be started from this offset. downloaded_prefix_size is calculated
     * from this offset
     */
    download_offset: number,
    /**
     * If is_downloading_completed is false, then only some prefix of the file starting
     * from download_offset is ready to be read. downloaded_prefix_size is the size
     * of that prefix in bytes
     */
    downloaded_prefix_size: number,
    /**
     * Total downloaded file size, in bytes. Can be used only for calculating download
     * progress. The actual file size may be bigger, and some parts of it may contain
     * garbage
     */
    downloaded_size: number,
  |}

  declare export type remoteFile = {|
    /** Represents a remote file */
    _: 'remoteFile',
    /**
     * Remote file identifier; may be empty. Can be used by the current user across
     * application restarts or even from other devices. Uniquely identifies a file,
     * but a file can have a lot of different valid identifiers. If the identifier
     * starts with "http://" or "https://", it represents the HTTP URL of the file.
     * TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads
     * is called on such a file or if it is sent to a secret chat, TDLib starts a file
     * generation process by sending updateFileGenerationStart to the application with
     * the HTTP URL in the original_path and "#url#" as the conversion string. Application
     * must generate the file by downloading it to the specified location
     */
    id: string,
    /**
     * Unique file identifier; may be empty if unknown. The unique file identifier
     * which is the same for the same file even for different users and is persistent
     * over time
     */
    unique_id: string,
    /**
     * True, if the file is currently being uploaded (or a remote copy is being generated
     * by some other means)
     */
    is_uploading_active: boolean,
    /** True, if a remote copy is fully available */
    is_uploading_completed: boolean,
    /** Size of the remote available part of the file, in bytes; 0 if unknown */
    uploaded_size: number,
  |}

  declare export type file = {|
    /** Represents a file */
    _: 'file',
    /** Unique file identifier */
    id: number,
    /** File size, in bytes; 0 if unknown */
    size: number,
    /**
     * Approximate file size in bytes in case the exact file size is unknown. Can be
     * used to show download/upload progress
     */
    expected_size: number,
    /** Information about the local copy of the file */
    local: localFile,
    /** Information about the remote copy of the file */
    remote: remoteFile,
  |}

  declare export type inputFileId = {|
    /** A file defined by its unique identifier */
    _: 'inputFileId',
    /** Unique file identifier */
    id: number,
  |}

  declare export type inputFileId$Input = {|
    /** A file defined by its unique identifier */
    +_: 'inputFileId',
    /** Unique file identifier */
    +id?: number,
  |}

  declare export type inputFileRemote = {|
    /**
     * A file defined by its remote identifier. The remote identifier is guaranteed
     * to be usable only if the corresponding file is still accessible to the user
     * and known to TDLib. For example, if the file is from a message, then the message
     * must be not deleted and accessible to the user. If the file database is disabled,
     * then the corresponding object with the file must be preloaded by the application
     */
    _: 'inputFileRemote',
    /** Remote file identifier */
    id: string,
  |}

  declare export type inputFileRemote$Input = {|
    /**
     * A file defined by its remote identifier. The remote identifier is guaranteed
     * to be usable only if the corresponding file is still accessible to the user
     * and known to TDLib. For example, if the file is from a message, then the message
     * must be not deleted and accessible to the user. If the file database is disabled,
     * then the corresponding object with the file must be preloaded by the application
     */
    +_: 'inputFileRemote',
    /** Remote file identifier */
    +id?: string,
  |}

  declare export type inputFileLocal = {|
    /** A file defined by a local path */
    _: 'inputFileLocal',
    /** Local path to the file */
    path: string,
  |}

  declare export type inputFileLocal$Input = {|
    /** A file defined by a local path */
    +_: 'inputFileLocal',
    /** Local path to the file */
    +path?: string,
  |}

  declare export type inputFileGenerated = {|
    /**
     * A file generated by the application. The application must handle updates updateFileGenerationStart
     * and updateFileGenerationStop to generate the file when asked by TDLib
     */
    _: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated. The path doesn't have
     * to be a valid path and is used by TDLib only to detect name and MIME type of
     * the generated file
     */
    original_path: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    conversion: string,
    /** Expected size of the generated file, in bytes; pass 0 if unknown */
    expected_size: number,
  |}

  declare export type inputFileGenerated$Input = {|
    /**
     * A file generated by the application. The application must handle updates updateFileGenerationStart
     * and updateFileGenerationStop to generate the file when asked by TDLib
     */
    +_: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated. The path doesn't have
     * to be a valid path and is used by TDLib only to detect name and MIME type of
     * the generated file
     */
    +original_path?: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    +conversion?: string,
    /** Expected size of the generated file, in bytes; pass 0 if unknown */
    +expected_size?: number,
  |}

  declare export type photoSize = {|
    /** Describes an image in JPEG format */
    _: 'photoSize',
    /** Image type (see https://core.telegram.org/constructor/photoSize) */
    type: string,
    /** Information about the image file */
    photo: file,
    /** Image width */
    width: number,
    /** Image height */
    height: number,
    /**
     * Sizes of progressive JPEG file prefixes, which can be used to preliminarily
     * show the image; in bytes
     */
    progressive_sizes: Array<number>,
  |}

  declare export type minithumbnail = {|
    /** Thumbnail image of a very poor quality and low resolution */
    _: 'minithumbnail',
    /** Thumbnail width, usually doesn't exceed 40 */
    width: number,
    /** Thumbnail height, usually doesn't exceed 40 */
    height: number,
    /** The thumbnail in JPEG format */
    data: string /* base64 */,
  |}

  declare export type thumbnailFormatJpeg = {|
    /** The thumbnail is in JPEG format */
    _: 'thumbnailFormatJpeg',
  |}

  declare export type thumbnailFormatGif = {|
    /**
     * The thumbnail is in static GIF format. It will be used only for some bot inline
     * query results
     */
    _: 'thumbnailFormatGif',
  |}

  declare export type thumbnailFormatMpeg4 = {|
    /**
     * The thumbnail is in MPEG4 format. It will be used only for some animations and
     * videos
     */
    _: 'thumbnailFormatMpeg4',
  |}

  declare export type thumbnailFormatPng = {|
    /** The thumbnail is in PNG format. It will be used only for background patterns */
    _: 'thumbnailFormatPng',
  |}

  declare export type thumbnailFormatTgs = {|
    /** The thumbnail is in TGS format. It will be used only for sticker sets */
    _: 'thumbnailFormatTgs',
  |}

  declare export type thumbnailFormatWebm = {|
    /** The thumbnail is in WEBM format. It will be used only for sticker sets */
    _: 'thumbnailFormatWebm',
  |}

  declare export type thumbnailFormatWebp = {|
    /**
     * The thumbnail is in WEBP format. It will be used only for some stickers and
     * sticker sets
     */
    _: 'thumbnailFormatWebp',
  |}

  declare export type thumbnail = {|
    /** Represents a thumbnail */
    _: 'thumbnail',
    /** Thumbnail format */
    format: ThumbnailFormat,
    /** Thumbnail width */
    width: number,
    /** Thumbnail height */
    height: number,
    /** The thumbnail */
    file: file,
  |}

  declare export type maskPointForehead = {|
    /** The mask is placed relatively to the forehead */
    _: 'maskPointForehead',
  |}

  declare export type maskPointForehead$Input = {|
    /** The mask is placed relatively to the forehead */
    +_: 'maskPointForehead',
  |}

  declare export type maskPointEyes = {|
    /** The mask is placed relatively to the eyes */
    _: 'maskPointEyes',
  |}

  declare export type maskPointEyes$Input = {|
    /** The mask is placed relatively to the eyes */
    +_: 'maskPointEyes',
  |}

  declare export type maskPointMouth = {|
    /** The mask is placed relatively to the mouth */
    _: 'maskPointMouth',
  |}

  declare export type maskPointMouth$Input = {|
    /** The mask is placed relatively to the mouth */
    +_: 'maskPointMouth',
  |}

  declare export type maskPointChin = {|
    /** The mask is placed relatively to the chin */
    _: 'maskPointChin',
  |}

  declare export type maskPointChin$Input = {|
    /** The mask is placed relatively to the chin */
    +_: 'maskPointChin',
  |}

  declare export type maskPosition = {|
    /** Position on a photo where a mask is placed */
    _: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    point: MaskPoint,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    x_shift: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    y_shift: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    scale: number,
  |}

  declare export type maskPosition$Input = {|
    /** Position on a photo where a mask is placed */
    +_: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    +point?: MaskPoint$Input,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    +x_shift?: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    +y_shift?: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    +scale?: number,
  |}

  declare export type stickerFormatWebp = {|
    /** The sticker is an image in WEBP format */
    _: 'stickerFormatWebp',
  |}

  declare export type stickerFormatWebp$Input = {|
    /** The sticker is an image in WEBP format */
    +_: 'stickerFormatWebp',
  |}

  declare export type stickerFormatTgs = {|
    /** The sticker is an animation in TGS format */
    _: 'stickerFormatTgs',
  |}

  declare export type stickerFormatTgs$Input = {|
    /** The sticker is an animation in TGS format */
    +_: 'stickerFormatTgs',
  |}

  declare export type stickerFormatWebm = {|
    /** The sticker is a video in WEBM format */
    _: 'stickerFormatWebm',
  |}

  declare export type stickerFormatWebm$Input = {|
    /** The sticker is a video in WEBM format */
    +_: 'stickerFormatWebm',
  |}

  declare export type stickerTypeRegular = {|
    /** The sticker is a regular sticker */
    _: 'stickerTypeRegular',
  |}

  declare export type stickerTypeRegular$Input = {|
    /** The sticker is a regular sticker */
    +_: 'stickerTypeRegular',
  |}

  declare export type stickerTypeMask = {|
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    _: 'stickerTypeMask',
  |}

  declare export type stickerTypeMask$Input = {|
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    +_: 'stickerTypeMask',
  |}

  declare export type stickerTypeCustomEmoji = {|
    /** The sticker is a custom emoji to be used inside message text and caption */
    _: 'stickerTypeCustomEmoji',
  |}

  declare export type stickerTypeCustomEmoji$Input = {|
    /** The sticker is a custom emoji to be used inside message text and caption */
    +_: 'stickerTypeCustomEmoji',
  |}

  declare export type stickerFullTypeRegular = {|
    /** The sticker is a regular sticker */
    _: 'stickerFullTypeRegular',
    /**
     * Premium animation of the sticker; may be null. If present, only Telegram Premium
     * users can use the sticker
     */
    premium_animation?: file,
  |}

  declare export type stickerFullTypeMask = {|
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    _: 'stickerFullTypeMask',
    /** Position where the mask is placed; may be null */
    mask_position?: maskPosition,
  |}

  declare export type stickerFullTypeCustomEmoji = {|
    /**
     * The sticker is a custom emoji to be used inside message text and caption. Currently,
     * only Telegram Premium users can use custom emoji
     */
    _: 'stickerFullTypeCustomEmoji',
    /** Identifier of the custom emoji */
    custom_emoji_id: string,
    /**
     * True, if the sticker must be repainted to a text color in messages, the color
     * of the Telegram Premium badge in emoji status, white color on chat photos, or
     * another appropriate color in other places
     */
    needs_repainting: boolean,
  |}

  declare export type closedVectorPath = {|
    /**
     * Represents a closed vector path. The path begins at the end point of the last
     * command. The coordinate system origin is in the upper-left corner
     */
    _: 'closedVectorPath',
    /** List of vector path commands */
    commands: Array<VectorPathCommand>,
  |}

  declare export type outline = {|
    /** Represents outline of an image */
    _: 'outline',
    /** The list of closed vector paths */
    paths: Array<closedVectorPath>,
  |}

  declare export type pollOption = {|
    /** Describes one answer option of a poll */
    _: 'pollOption',
    /** Option text; 1-100 characters. Only custom emoji entities are allowed */
    text: formattedText,
    /** Number of voters for this option, available only for closed or voted polls */
    voter_count: number,
    /** The percentage of votes for this option; 0-100 */
    vote_percentage: number,
    /** True, if the option was chosen by the user */
    is_chosen: boolean,
    /** True, if the option is being chosen by a pending setPollAnswer request */
    is_being_chosen: boolean,
  |}

  declare export type pollTypeRegular = {|
    /** A regular poll */
    _: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    allow_multiple_answers: boolean,
  |}

  declare export type pollTypeRegular$Input = {|
    /** A regular poll */
    +_: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    +allow_multiple_answers?: boolean,
  |}

  declare export type pollTypeQuiz = {|
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    _: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    correct_option_id: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    explanation: formattedText,
  |}

  declare export type pollTypeQuiz$Input = {|
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    +_: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    +correct_option_id?: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    +explanation?: formattedText$Input,
  |}

  declare export type animation = {|
    /** Describes an animation file. The animation must be encoded in GIF or MPEG4 format */
    _: 'animation',
    /** Duration of the animation, in seconds; as defined by the sender */
    duration: number,
    /** Width of the animation */
    width: number,
    /** Height of the animation */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file, usually "image/gif" or "video/mp4" */
    mime_type: string,
    /**
     * True, if stickers were added to the animation. The list of corresponding sticker
     * set can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Animation minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Animation thumbnail in JPEG or MPEG4 format; may be null */
    thumbnail?: thumbnail,
    /** File containing the animation */
    animation: file,
  |}

  declare export type audio = {|
    /** Describes an audio file. Audio is usually in MP3 or M4A format */
    _: 'audio',
    /** Duration of the audio, in seconds; as defined by the sender */
    duration: number,
    /** Title of the audio; as defined by the sender */
    title: string,
    /** Performer of the audio; as defined by the sender */
    performer: string,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** The MIME type of the file; as defined by the sender */
    mime_type: string,
    /** The minithumbnail of the album cover; may be null */
    album_cover_minithumbnail?: minithumbnail,
    /**
     * The thumbnail of the album cover in JPEG format; as defined by the sender. The
     * full size thumbnail is expected to be extracted from the downloaded audio file;
     * may be null
     */
    album_cover_thumbnail?: thumbnail,
    /**
     * Album cover variants to use if the downloaded audio file contains no album cover.
     * Provided thumbnail dimensions are approximate
     */
    external_album_covers: Array<thumbnail>,
    /** File containing the audio */
    audio: file,
  |}

  declare export type document = {|
    /** Describes a document of any type */
    _: 'document',
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /** Document minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /**
     * Document thumbnail in JPEG or PNG format (PNG will be used only for background
     * patterns); as defined by the sender; may be null
     */
    thumbnail?: thumbnail,
    /** File containing the document */
    document: file,
  |}

  declare export type photo = {|
    /** Describes a photo */
    _: 'photo',
    /**
     * True, if stickers were added to the photo. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo, in different sizes */
    sizes: Array<photoSize>,
  |}

  declare export type sticker = {|
    /** Describes a sticker */
    _: 'sticker',
    /** Unique sticker identifier within the set; 0 if none */
    id: string,
    /** Identifier of the sticker set to which the sticker belongs; 0 if none */
    set_id: string,
    /** Sticker width; as defined by the sender */
    width: number,
    /** Sticker height; as defined by the sender */
    height: number,
    /** Emoji corresponding to the sticker */
    emoji: string,
    /** Sticker format */
    format: StickerFormat,
    /** Sticker's full type */
    full_type: StickerFullType,
    /** Sticker thumbnail in WEBP or JPEG format; may be null */
    thumbnail?: thumbnail,
    /** File containing the sticker */
    sticker: file,
  |}

  declare export type video = {|
    /** Describes a video file */
    _: 'video',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /** Video width; as defined by the sender */
    width: number,
    /** Video height; as defined by the sender */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /**
     * True, if stickers were added to the video. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** True, if the video is expected to be streamed */
    supports_streaming: boolean,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** File containing the video */
    video: file,
  |}

  declare export type videoNote = {|
    /**
     * Describes a video note. The video must be equal in width and height, cropped
     * to a circle, and stored in MPEG4 format
     */
    _: 'videoNote',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /**
     * A waveform representation of the video note's audio in 5-bit format; may be
     * empty if unknown
     */
    waveform: string /* base64 */,
    /** Video width and height; as defined by the sender */
    length: number,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** Result of speech recognition in the video note; may be null */
    speech_recognition_result?: SpeechRecognitionResult,
    /** File containing the video */
    video: file,
  |}

  declare export type voiceNote = {|
    /** Describes a voice note */
    _: 'voiceNote',
    /** Duration of the voice note, in seconds; as defined by the sender */
    duration: number,
    /** A waveform representation of the voice note in 5-bit format */
    waveform: string /* base64 */,
    /**
     * MIME type of the file; as defined by the sender. Usually, one of "audio/ogg"
     * for Opus in an OGG container, "audio/mpeg" for an MP3 audio, or "audio/mp4"
     * for an M4A audio
     */
    mime_type: string,
    /** Result of speech recognition in the voice note; may be null */
    speech_recognition_result?: SpeechRecognitionResult,
    /** File containing the voice note */
    voice: file,
  |}

  declare export type animatedEmoji = {|
    /** Describes an animated or custom representation of an emoji */
    _: 'animatedEmoji',
    /**
     * Sticker for the emoji; may be null if yet unknown for a custom emoji. If the
     * sticker is a custom emoji, then it can have arbitrary format
     */
    sticker?: sticker,
    /** Expected width of the sticker, which can be used if the sticker is null */
    sticker_width: number,
    /** Expected height of the sticker, which can be used if the sticker is null */
    sticker_height: number,
    /** Emoji modifier fitzpatrick type; 0-6; 0 if none */
    fitzpatrick_type: number,
    /**
     * File containing the sound to be played when the sticker is clicked; may be null.
     * The sound is encoded with the Opus codec, and stored inside an OGG container
     */
    sound?: file,
  |}

  declare export type contact = {|
    /** Describes a user contact */
    _: 'contact',
    /** Phone number of the user */
    phone_number: string,
    /** First name of the user; 1-255 characters in length */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    vcard: string,
    /** Identifier of the user, if known; 0 otherwise */
    user_id: number,
  |}

  declare export type contact$Input = {|
    /** Describes a user contact */
    +_: 'contact',
    /** Phone number of the user */
    +phone_number?: string,
    /** First name of the user; 1-255 characters in length */
    +first_name?: string,
    /** Last name of the user */
    +last_name?: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    +vcard?: string,
    /** Identifier of the user, if known; 0 otherwise */
    +user_id?: number,
  |}

  declare export type location = {|
    /** Describes a location on planet Earth */
    _: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    latitude: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    longitude: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    horizontal_accuracy: number,
  |}

  declare export type location$Input = {|
    /** Describes a location on planet Earth */
    +_: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    +latitude?: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    +longitude?: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    +horizontal_accuracy?: number,
  |}

  declare export type venue = {|
    /** Describes a venue */
    _: 'venue',
    /** Venue location; as defined by the sender */
    location: location,
    /** Venue name; as defined by the sender */
    title: string,
    /** Venue address; as defined by the sender */
    address: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    provider: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    id: string,
    /** Type of the venue in the provider database; as defined by the sender */
    type: string,
  |}

  declare export type venue$Input = {|
    /** Describes a venue */
    +_: 'venue',
    /** Venue location; as defined by the sender */
    +location?: location$Input,
    /** Venue name; as defined by the sender */
    +title?: string,
    /** Venue address; as defined by the sender */
    +address?: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    +provider?: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    +id?: string,
    /** Type of the venue in the provider database; as defined by the sender */
    +type?: string,
  |}

  declare export type game = {|
    /**
     * Describes a game. Use getInternalLink with internalLinkTypeGame to share the
     * game
     */
    _: 'game',
    /** Unique game identifier */
    id: string,
    /** Game short name */
    short_name: string,
    /** Game title */
    title: string,
    /** Game text, usually containing scoreboards for a game */
    text: formattedText,
    /** Game description */
    description: string,
    /** Game photo */
    photo: photo,
    /** Game animation; may be null */
    animation?: animation,
  |}

  declare export type webApp = {|
    /**
     * Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share
     * the Web App
     */
    _: 'webApp',
    /** Web App short name */
    short_name: string,
    /** Web App title */
    title: string,
    /** Web App description */
    description: string,
    /** Web App photo */
    photo: photo,
    /** Web App animation; may be null */
    animation?: animation,
  |}

  declare export type poll = {|
    /** Describes a poll */
    _: 'poll',
    /** Unique poll identifier */
    id: string,
    /** Poll question; 1-300 characters. Only custom emoji entities are allowed */
    question: formattedText,
    /** List of poll answer options */
    options: Array<pollOption>,
    /** Total number of voters, participating in the poll */
    total_voter_count: number,
    /** Identifiers of recent voters, if the poll is non-anonymous */
    recent_voter_ids: Array<MessageSender>,
    /** True, if the poll is anonymous */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /** Amount of time the poll will be active after creation, in seconds */
    open_period: number,
    /** Point in time (Unix timestamp) when the poll will automatically be closed */
    close_date: number,
    /** True, if the poll is closed */
    is_closed: boolean,
  |}

  declare export type alternativeVideo = {|
    /** Describes an alternative re-encoded quality of a video file */
    _: 'alternativeVideo',
    /** Unique identifier of the alternative video, which is used in the HLS file */
    id: string,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /** Codec used for video file encoding, for example, "h264", "h265", or "av1" */
    codec: string,
    /** HLS file describing the video */
    hls_file: file,
    /** File containing the video */
    video: file,
  |}

  declare export type background = {|
    /** Describes a chat background */
    _: 'background',
    /** Unique background identifier */
    id: string,
    /** True, if this is one of default backgrounds */
    is_default: boolean,
    /** True, if the background is dark and is recommended to be used with dark theme */
    is_dark: boolean,
    /** Unique background name */
    name: string,
    /**
     * Document with the background; may be null. Null only for filled and chat theme
     * backgrounds
     */
    document?: document,
    /** Type of the background */
    type: BackgroundType,
  |}

  declare export type backgrounds = {|
    /** Contains a list of backgrounds */
    _: 'backgrounds',
    /** A list of backgrounds */
    backgrounds: Array<background>,
  |}

  declare export type chatBackground = {|
    /** Describes a background set for a specific chat */
    _: 'chatBackground',
    /** The background */
    background: background,
    /**
     * Dimming of the background in dark themes, as a percentage; 0-100. Applied only
     * to Wallpaper and Fill types of background
     */
    dark_theme_dimming: number,
  |}

  declare export type profilePhoto = {|
    /** Describes a user profile photo */
    _: 'profilePhoto',
    /**
     * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list
     * of user profile photos
     */
    id: string,
    /**
     * A small (160x160) user profile photo. The file can be downloaded only before
     * the photo is changed
     */
    small: file,
    /**
     * A big (640x640) user profile photo. The file can be downloaded only before the
     * photo is changed
     */
    big: file,
    /** User profile photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
    /** True, if the photo is visible only for the current user */
    is_personal: boolean,
  |}

  declare export type chatPhotoInfo = {|
    /** Contains basic information about the photo of a chat */
    _: 'chatPhotoInfo',
    /**
     * A small (160x160) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    small: file,
    /**
     * A big (640x640) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    big: file,
    /** Chat photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
    /** True, if the photo is visible only for the current user */
    is_personal: boolean,
  |}

  declare export type userTypeRegular = {|
    /** A regular user */
    _: 'userTypeRegular',
  |}

  declare export type userTypeDeleted = {|
    /**
     * A deleted user or deleted bot. No information on the user besides the user identifier
     * is available. It is not possible to perform any active actions on this type
     * of user
     */
    _: 'userTypeDeleted',
  |}

  declare export type userTypeBot = {|
    /** A bot (see https://core.telegram.org/bots) */
    _: 'userTypeBot',
    /**
     * True, if the bot is owned by the current user and can be edited using the methods
     * toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName,
     * setBotInfoDescription, and setBotInfoShortDescription
     */
    can_be_edited: boolean,
    /** True, if the bot can be invited to basic group and supergroup chats */
    can_join_groups: boolean,
    /**
     * True, if the bot can read all messages in basic group or supergroup chats and
     * not just those addressed to the bot. In private and channel chats a bot can
     * always read all messages
     */
    can_read_all_group_messages: boolean,
    /** True, if the bot has the main Web App */
    has_main_web_app: boolean,
    /** True, if the bot supports inline queries */
    is_inline: boolean,
    /** Placeholder for inline queries (displayed on the application input field) */
    inline_query_placeholder: string,
    /**
     * True, if the location of the user is expected to be sent with every inline query
     * to this bot
     */
    need_location: boolean,
    /** True, if the bot supports connection to Telegram Business accounts */
    can_connect_to_business: boolean,
    /** True, if the bot can be added to attachment or side menu */
    can_be_added_to_attachment_menu: boolean,
    /** The number of recently active users of the bot */
    active_user_count: number,
  |}

  declare export type userTypeUnknown = {|
    /**
     * No information on the user besides the user identifier is available, yet this
     * user has not been deleted. This object is extremely rare and must be handled
     * like a deleted user. It is not possible to perform any actions on users of this
     * type
     */
    _: 'userTypeUnknown',
  |}

  declare export type botCommand = {|
    /** Represents a command supported by a bot */
    _: 'botCommand',
    /** Text of the bot command */
    command: string,
    /** Description of the bot command */
    description: string,
  |}

  declare export type botCommand$Input = {|
    /** Represents a command supported by a bot */
    +_: 'botCommand',
    /** Text of the bot command */
    +command?: string,
    /** Description of the bot command */
    +description?: string,
  |}

  declare export type botCommands = {|
    /** Contains a list of bot commands */
    _: 'botCommands',
    /** Bot's user identifier */
    bot_user_id: number,
    /** List of bot commands */
    commands: Array<botCommand>,
  |}

  declare export type botMenuButton = {|
    /** Describes a button to be shown instead of bot commands menu button */
    _: 'botMenuButton',
    /** Text of the button */
    text: string,
    /**
     * URL of a Web App to open when the button is pressed. If the link is of the type
     * internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the
     * link must be passed to openWebApp
     */
    url: string,
  |}

  declare export type botMenuButton$Input = {|
    /** Describes a button to be shown instead of bot commands menu button */
    +_: 'botMenuButton',
    /** Text of the button */
    +text?: string,
    /**
     * URL of a Web App to open when the button is pressed. If the link is of the type
     * internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the
     * link must be passed to openWebApp
     */
    +url?: string,
  |}

  declare export type botVerificationParameters = {|
    /** Describes parameters of verification that is provided by a bot */
    _: 'botVerificationParameters',
    /** Identifier of the custom emoji that is used as the verification sign */
    icon_custom_emoji_id: string,
    /** Name of the organization that provides verification */
    organization_name: string,
    /**
     * Default custom description of verification reason to be used as placeholder
     * in setMessageSenderBotVerification; may be null if none
     */
    default_custom_description?: formattedText,
    /** True, if the bot is allowed to provide custom description for verified entities */
    can_set_custom_description: boolean,
  |}

  declare export type botVerification = {|
    /** Describes verification status provided by a bot */
    _: 'botVerification',
    /** Identifier of the bot that provided the verification */
    bot_user_id: number,
    /** Identifier of the custom emoji that is used as the verification sign */
    icon_custom_emoji_id: string,
    /**
     * Custom description of verification reason set by the bot. Can contain only Mention,
     * Hashtag, Cashtag, PhoneNumber, BankCardNumber, Url, and EmailAddress entities
     */
    custom_description: formattedText,
  |}

  declare export type verificationStatus = {|
    /** Contains information about verification status of a chat or a user */
    _: 'verificationStatus',
    /** True, if the chat or the user is verified by Telegram */
    is_verified: boolean,
    /** True, if the chat or the user is marked as scam by Telegram */
    is_scam: boolean,
    /** True, if the chat or the user is marked as fake by Telegram */
    is_fake: boolean,
    /**
     * Identifier of the custom emoji to be shown as verification sign provided by
     * a bot for the user; 0 if none
     */
    bot_verification_icon_custom_emoji_id: string,
  |}

  declare export type chatLocation = {|
    /** Represents a location to which a chat is connected */
    _: 'chatLocation',
    /** The location */
    location: location,
    /** Location address; 1-64 characters, as defined by the chat owner */
    address: string,
  |}

  declare export type chatLocation$Input = {|
    /** Represents a location to which a chat is connected */
    +_: 'chatLocation',
    /** The location */
    +location?: location$Input,
    /** Location address; 1-64 characters, as defined by the chat owner */
    +address?: string,
  |}

  declare export type birthdate = {|
    /** Represents a birthdate of a user */
    _: 'birthdate',
    /** Day of the month; 1-31 */
    day: number,
    /** Month of the year; 1-12 */
    month: number,
    /** Birth year; 0 if unknown */
    year: number,
  |}

  declare export type birthdate$Input = {|
    /** Represents a birthdate of a user */
    +_: 'birthdate',
    /** Day of the month; 1-31 */
    +day?: number,
    /** Month of the year; 1-12 */
    +month?: number,
    /** Birth year; 0 if unknown */
    +year?: number,
  |}

  declare export type closeBirthdayUser = {|
    /** Describes a user that had or will have a birthday soon */
    _: 'closeBirthdayUser',
    /** User identifier */
    user_id: number,
    /** Birthdate of the user */
    birthdate: birthdate,
  |}

  declare export type businessAwayMessageScheduleAlways = {|
    /** Send away messages always */
    _: 'businessAwayMessageScheduleAlways',
  |}

  declare export type businessAwayMessageScheduleAlways$Input = {|
    /** Send away messages always */
    +_: 'businessAwayMessageScheduleAlways',
  |}

  declare export type businessAwayMessageScheduleOutsideOfOpeningHours = {|
    /** Send away messages outside of the business opening hours */
    _: 'businessAwayMessageScheduleOutsideOfOpeningHours',
  |}

  declare export type businessAwayMessageScheduleOutsideOfOpeningHours$Input = {|
    /** Send away messages outside of the business opening hours */
    +_: 'businessAwayMessageScheduleOutsideOfOpeningHours',
  |}

  declare export type businessAwayMessageScheduleCustom = {|
    /** Send away messages only in the specified time span */
    _: 'businessAwayMessageScheduleCustom',
    /** Point in time (Unix timestamp) when the away messages will start to be sent */
    start_date: number,
    /** Point in time (Unix timestamp) when the away messages will stop to be sent */
    end_date: number,
  |}

  declare export type businessAwayMessageScheduleCustom$Input = {|
    /** Send away messages only in the specified time span */
    +_: 'businessAwayMessageScheduleCustom',
    /** Point in time (Unix timestamp) when the away messages will start to be sent */
    +start_date?: number,
    /** Point in time (Unix timestamp) when the away messages will stop to be sent */
    +end_date?: number,
  |}

  declare export type businessLocation = {|
    /** Represents a location of a business */
    _: 'businessLocation',
    /** The location; may be null if not specified */
    location?: location,
    /** Location address; 1-96 characters */
    address: string,
  |}

  declare export type businessLocation$Input = {|
    /** Represents a location of a business */
    +_: 'businessLocation',
    /** The location; may be null if not specified */
    +location?: location$Input,
    /** Location address; 1-96 characters */
    +address?: string,
  |}

  declare export type businessRecipients = {|
    /** Describes private chats chosen for automatic interaction with a business */
    _: 'businessRecipients',
    /** Identifiers of selected private chats */
    chat_ids: Array<number>,
    /**
     * Identifiers of private chats that are always excluded; for businessConnectedBot
     * only
     */
    excluded_chat_ids: Array<number>,
    /** True, if all existing private chats are selected */
    select_existing_chats: boolean,
    /** True, if all new private chats are selected */
    select_new_chats: boolean,
    /** True, if all private chats with contacts are selected */
    select_contacts: boolean,
    /** True, if all private chats with non-contacts are selected */
    select_non_contacts: boolean,
    /**
     * If true, then all private chats except the selected are chosen. Otherwise, only
     * the selected chats are chosen
     */
    exclude_selected: boolean,
  |}

  declare export type businessRecipients$Input = {|
    /** Describes private chats chosen for automatic interaction with a business */
    +_: 'businessRecipients',
    /** Identifiers of selected private chats */
    +chat_ids?: $ReadOnlyArray<number>,
    /**
     * Identifiers of private chats that are always excluded; for businessConnectedBot
     * only
     */
    +excluded_chat_ids?: $ReadOnlyArray<number>,
    /** True, if all existing private chats are selected */
    +select_existing_chats?: boolean,
    /** True, if all new private chats are selected */
    +select_new_chats?: boolean,
    /** True, if all private chats with contacts are selected */
    +select_contacts?: boolean,
    /** True, if all private chats with non-contacts are selected */
    +select_non_contacts?: boolean,
    /**
     * If true, then all private chats except the selected are chosen. Otherwise, only
     * the selected chats are chosen
     */
    +exclude_selected?: boolean,
  |}

  declare export type businessAwayMessageSettings = {|
    /**
     * Describes settings for messages that are automatically sent by a Telegram Business
     * account when it is away
     */
    _: 'businessAwayMessageSettings',
    /** Unique quick reply shortcut identifier for the away messages */
    shortcut_id: number,
    /** Chosen recipients of the away messages */
    recipients: businessRecipients,
    /** Settings used to check whether the current user is away */
    schedule: BusinessAwayMessageSchedule,
    /**
     * True, if the messages must not be sent if the account was online in the last
     * 10 minutes
     */
    offline_only: boolean,
  |}

  declare export type businessAwayMessageSettings$Input = {|
    /**
     * Describes settings for messages that are automatically sent by a Telegram Business
     * account when it is away
     */
    +_: 'businessAwayMessageSettings',
    /** Unique quick reply shortcut identifier for the away messages */
    +shortcut_id?: number,
    /** Chosen recipients of the away messages */
    +recipients?: businessRecipients$Input,
    /** Settings used to check whether the current user is away */
    +schedule?: BusinessAwayMessageSchedule$Input,
    /**
     * True, if the messages must not be sent if the account was online in the last
     * 10 minutes
     */
    +offline_only?: boolean,
  |}

  declare export type businessGreetingMessageSettings = {|
    /**
     * Describes settings for greeting messages that are automatically sent by a Telegram
     * Business account as response to incoming messages in an inactive private chat
     */
    _: 'businessGreetingMessageSettings',
    /** Unique quick reply shortcut identifier for the greeting messages */
    shortcut_id: number,
    /** Chosen recipients of the greeting messages */
    recipients: businessRecipients,
    /**
     * The number of days after which a chat will be considered as inactive; currently,
     * must be on of 7, 14, 21, or 28
     */
    inactivity_days: number,
  |}

  declare export type businessGreetingMessageSettings$Input = {|
    /**
     * Describes settings for greeting messages that are automatically sent by a Telegram
     * Business account as response to incoming messages in an inactive private chat
     */
    +_: 'businessGreetingMessageSettings',
    /** Unique quick reply shortcut identifier for the greeting messages */
    +shortcut_id?: number,
    /** Chosen recipients of the greeting messages */
    +recipients?: businessRecipients$Input,
    /**
     * The number of days after which a chat will be considered as inactive; currently,
     * must be on of 7, 14, 21, or 28
     */
    +inactivity_days?: number,
  |}

  declare export type businessConnectedBot = {|
    /** Describes a bot connected to a business account */
    _: 'businessConnectedBot',
    /** User identifier of the bot */
    bot_user_id: number,
    /** Private chats that will be accessible to the bot */
    recipients: businessRecipients,
    /** True, if the bot can send messages to the private chats; false otherwise */
    can_reply: boolean,
  |}

  declare export type businessConnectedBot$Input = {|
    /** Describes a bot connected to a business account */
    +_: 'businessConnectedBot',
    /** User identifier of the bot */
    +bot_user_id?: number,
    /** Private chats that will be accessible to the bot */
    +recipients?: businessRecipients$Input,
    /** True, if the bot can send messages to the private chats; false otherwise */
    +can_reply?: boolean,
  |}

  declare export type businessStartPage = {|
    /** Describes settings for a business account start page */
    _: 'businessStartPage',
    /** Title text of the start page */
    title: string,
    /** Message text of the start page */
    message: string,
    /** Greeting sticker of the start page; may be null if none */
    sticker?: sticker,
  |}

  declare export type inputBusinessStartPage$Input = {|
    /** Describes settings for a business account start page to set */
    +_: 'inputBusinessStartPage',
    /**
     * Title text of the start page; 0-getOption("business_start_page_title_length_max")
     * characters
     */
    +title?: string,
    /**
     * Message text of the start page; 0-getOption("business_start_page_message_length_max")
     * characters
     */
    +message?: string,
    /**
     * Greeting sticker of the start page; pass null if none. The sticker must belong
     * to a sticker set and must not be a custom emoji
     */
    +sticker?: InputFile$Input,
  |}

  declare export type businessOpeningHoursInterval = {|
    /** Describes an interval of time when the business is open */
    _: 'businessOpeningHoursInterval',
    /**
     * The minute's sequence number in a week, starting on Monday, marking the start
     * of the time interval during which the business is open; 0-7*24*60
     */
    start_minute: number,
    /**
     * The minute's sequence number in a week, starting on Monday, marking the end
     * of the time interval during which the business is open; 1-8*24*60
     */
    end_minute: number,
  |}

  declare export type businessOpeningHoursInterval$Input = {|
    /** Describes an interval of time when the business is open */
    +_: 'businessOpeningHoursInterval',
    /**
     * The minute's sequence number in a week, starting on Monday, marking the start
     * of the time interval during which the business is open; 0-7*24*60
     */
    +start_minute?: number,
    /**
     * The minute's sequence number in a week, starting on Monday, marking the end
     * of the time interval during which the business is open; 1-8*24*60
     */
    +end_minute?: number,
  |}

  declare export type businessOpeningHours = {|
    /** Describes opening hours of a business */
    _: 'businessOpeningHours',
    /** Unique time zone identifier */
    time_zone_id: string,
    /** Intervals of the time when the business is open */
    opening_hours: Array<businessOpeningHoursInterval>,
  |}

  declare export type businessOpeningHours$Input = {|
    /** Describes opening hours of a business */
    +_: 'businessOpeningHours',
    /** Unique time zone identifier */
    +time_zone_id?: string,
    /** Intervals of the time when the business is open */
    +opening_hours?: $ReadOnlyArray<businessOpeningHoursInterval$Input>,
  |}

  declare export type businessInfo = {|
    /** Contains information about a Telegram Business account */
    _: 'businessInfo',
    /** Location of the business; may be null if none */
    location?: businessLocation,
    /**
     * Opening hours of the business; may be null if none. The hours are guaranteed
     * to be valid and has already been split by week days
     */
    opening_hours?: businessOpeningHours,
    /**
     * Opening hours of the business in the local time; may be null if none. The hours
     * are guaranteed to be valid and has already been split by week days. Local time
     * zone identifier will be empty. An updateUserFullInfo update is not triggered
     * when value of this field changes
     */
    local_opening_hours?: businessOpeningHours,
    /**
     * Time left before the business will open the next time, in seconds; 0 if unknown.
     * An updateUserFullInfo update is not triggered when value of this field changes
     */
    next_open_in: number,
    /**
     * Time left before the business will close the next time, in seconds; 0 if unknown.
     * An updateUserFullInfo update is not triggered when value of this field changes
     */
    next_close_in: number,
    /**
     * The greeting message; may be null if none or the Business account is not of
     * the current user
     */
    greeting_message_settings?: businessGreetingMessageSettings,
    /**
     * The away message; may be null if none or the Business account is not of the
     * current user
     */
    away_message_settings?: businessAwayMessageSettings,
    /** Information about start page of the account; may be null if none */
    start_page?: businessStartPage,
  |}

  declare export type businessChatLink = {|
    /** Contains information about a business chat link */
    _: 'businessChatLink',
    /** The HTTPS link */
    link: string,
    /** Message draft text that will be added to the input field */
    text: formattedText,
    /** Link title */
    title: string,
    /** Number of times the link was used */
    view_count: number,
  |}

  declare export type businessChatLinks = {|
    /** Contains a list of business chat links created by the user */
    _: 'businessChatLinks',
    /** List of links */
    links: Array<businessChatLink>,
  |}

  declare export type inputBusinessChatLink$Input = {|
    /** Describes a business chat link to create or edit */
    +_: 'inputBusinessChatLink',
    /** Message draft text that will be added to the input field */
    +text?: formattedText$Input,
    /** Link title */
    +title?: string,
  |}

  declare export type businessChatLinkInfo = {|
    /** Contains information about a business chat link */
    _: 'businessChatLinkInfo',
    /** Identifier of the private chat that created the link */
    chat_id: number,
    /** Message draft text that must be added to the input field */
    text: formattedText,
  |}

  declare export type chatPhotoStickerTypeRegularOrMask = {|
    /** Information about the sticker, which was used to create the chat photo */
    _: 'chatPhotoStickerTypeRegularOrMask',
    /** Sticker set identifier */
    sticker_set_id: string,
    /** Identifier of the sticker in the set */
    sticker_id: string,
  |}

  declare export type chatPhotoStickerTypeRegularOrMask$Input = {|
    /** Information about the sticker, which was used to create the chat photo */
    +_: 'chatPhotoStickerTypeRegularOrMask',
    /** Sticker set identifier */
    +sticker_set_id?: number | string,
    /** Identifier of the sticker in the set */
    +sticker_id?: number | string,
  |}

  declare export type chatPhotoStickerTypeCustomEmoji = {|
    /** Information about the custom emoji, which was used to create the chat photo */
    _: 'chatPhotoStickerTypeCustomEmoji',
    /** Identifier of the custom emoji */
    custom_emoji_id: string,
  |}

  declare export type chatPhotoStickerTypeCustomEmoji$Input = {|
    /** Information about the custom emoji, which was used to create the chat photo */
    +_: 'chatPhotoStickerTypeCustomEmoji',
    /** Identifier of the custom emoji */
    +custom_emoji_id?: number | string,
  |}

  declare export type chatPhotoSticker = {|
    /**
     * Information about the sticker, which was used to create the chat photo. The
     * sticker is shown at the center of the photo and occupies at most 67% of it
     */
    _: 'chatPhotoSticker',
    /** Type of the sticker */
    type: ChatPhotoStickerType,
    /**
     * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient
     * isn't supported
     */
    background_fill: BackgroundFill,
  |}

  declare export type chatPhotoSticker$Input = {|
    /**
     * Information about the sticker, which was used to create the chat photo. The
     * sticker is shown at the center of the photo and occupies at most 67% of it
     */
    +_: 'chatPhotoSticker',
    /** Type of the sticker */
    +type?: ChatPhotoStickerType$Input,
    /**
     * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient
     * isn't supported
     */
    +background_fill?: BackgroundFill$Input,
  |}

  declare export type animatedChatPhoto = {|
    /** Animated variant of a chat photo in MPEG4 format */
    _: 'animatedChatPhoto',
    /** Animation width and height */
    length: number,
    /** Information about the animation file */
    file: file,
    /** Timestamp of the frame, used as a static chat photo */
    main_frame_timestamp: number,
  |}

  declare export type chatPhoto = {|
    /** Describes a chat or user profile photo */
    _: 'chatPhoto',
    /** Unique photo identifier */
    id: string,
    /** Point in time (Unix timestamp) when the photo has been added */
    added_date: number,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo in JPEG format, in different size */
    sizes: Array<photoSize>,
    /**
     * A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be
     * null
     */
    animation?: animatedChatPhoto,
    /**
     * A small (160x160) animated variant of the photo in MPEG4 format; may be null
     * even the big animation is available
     */
    small_animation?: animatedChatPhoto,
    /** Sticker-based version of the chat photo; may be null */
    sticker?: chatPhotoSticker,
  |}

  declare export type chatPhotos = {|
    /** Contains a list of chat or user profile photos */
    _: 'chatPhotos',
    /** Total number of photos */
    total_count: number,
    /** List of photos */
    photos: Array<chatPhoto>,
  |}

  declare export type inputChatPhotoPrevious$Input = {|
    /** A previously used profile photo of the current user */
    +_: 'inputChatPhotoPrevious',
    /** Identifier of the current user's profile photo to reuse */
    +chat_photo_id?: number | string,
  |}

  declare export type inputChatPhotoStatic$Input = {|
    /** A static photo in JPEG format */
    +_: 'inputChatPhotoStatic',
    /**
     * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    +photo?: InputFile$Input,
  |}

  declare export type inputChatPhotoAnimation$Input = {|
    /**
     * An animation in MPEG4 format; must be square, at most 10 seconds long, have
     * width between 160 and 1280 and be at most 2MB in size
     */
    +_: 'inputChatPhotoAnimation',
    /**
     * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    +animation?: InputFile$Input,
    /** Timestamp of the frame, which will be used as static chat photo */
    +main_frame_timestamp?: number,
  |}

  declare export type inputChatPhotoSticker$Input = {|
    /** A sticker on a custom background */
    +_: 'inputChatPhotoSticker',
    /** Information about the sticker */
    +sticker?: chatPhotoSticker$Input,
  |}

  declare export type chatPermissions = {|
    /** Describes actions that a user is allowed to take in a chat */
    _: 'chatPermissions',
    /**
     * True, if the user can send text messages, contacts, giveaways, giveaway winners,
     * invoices, locations, and venues
     */
    can_send_basic_messages: boolean,
    /** True, if the user can send music files */
    can_send_audios: boolean,
    /** True, if the user can send documents */
    can_send_documents: boolean,
    /** True, if the user can send photos */
    can_send_photos: boolean,
    /** True, if the user can send videos */
    can_send_videos: boolean,
    /** True, if the user can send video notes */
    can_send_video_notes: boolean,
    /** True, if the user can send voice notes */
    can_send_voice_notes: boolean,
    /** True, if the user can send polls */
    can_send_polls: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots
     */
    can_send_other_messages: boolean,
    /** True, if the user may add a link preview to their messages */
    can_add_link_previews: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /** True, if the user can invite new users to the chat */
    can_invite_users: boolean,
    /** True, if the user can pin messages */
    can_pin_messages: boolean,
    /** True, if the user can create topics */
    can_create_topics: boolean,
  |}

  declare export type chatPermissions$Input = {|
    /** Describes actions that a user is allowed to take in a chat */
    +_: 'chatPermissions',
    /**
     * True, if the user can send text messages, contacts, giveaways, giveaway winners,
     * invoices, locations, and venues
     */
    +can_send_basic_messages?: boolean,
    /** True, if the user can send music files */
    +can_send_audios?: boolean,
    /** True, if the user can send documents */
    +can_send_documents?: boolean,
    /** True, if the user can send photos */
    +can_send_photos?: boolean,
    /** True, if the user can send videos */
    +can_send_videos?: boolean,
    /** True, if the user can send video notes */
    +can_send_video_notes?: boolean,
    /** True, if the user can send voice notes */
    +can_send_voice_notes?: boolean,
    /** True, if the user can send polls */
    +can_send_polls?: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots
     */
    +can_send_other_messages?: boolean,
    /** True, if the user may add a link preview to their messages */
    +can_add_link_previews?: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    +can_change_info?: boolean,
    /** True, if the user can invite new users to the chat */
    +can_invite_users?: boolean,
    /** True, if the user can pin messages */
    +can_pin_messages?: boolean,
    /** True, if the user can create topics */
    +can_create_topics?: boolean,
  |}

  declare export type chatAdministratorRights = {|
    /** Describes rights of the administrator */
    _: 'chatAdministratorRights',
    /**
     * True, if the administrator can access the chat event log, get boost list, see
     * hidden supergroup and channel members, report supergroup spam messages and ignore
     * slow mode. Implied by any other privilege; applicable to supergroups and channels
     * only
     */
    can_manage_chat: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /**
     * True, if the administrator can create channel posts or view channel statistics;
     * applicable to channels only
     */
    can_post_messages: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    can_edit_messages: boolean,
    /** True, if the administrator can delete messages of other users */
    can_delete_messages: boolean,
    /** True, if the administrator can invite new users to the chat */
    can_invite_users: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members or view
     * supergroup statistics; always true for channels
     */
    can_restrict_members: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    can_pin_messages: boolean,
    /**
     * True, if the administrator can create, rename, close, reopen, hide, and unhide
     * forum topics; applicable to forum supergroups only
     */
    can_manage_topics: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    can_promote_members: boolean,
    /** True, if the administrator can manage video chats */
    can_manage_video_chats: boolean,
    /**
     * True, if the administrator can create new chat stories, or edit and delete posted
     * stories; applicable to supergroups and channels only
     */
    can_post_stories: boolean,
    /**
     * True, if the administrator can edit stories posted by other users, post stories
     * to the chat page, pin chat stories, and access story archive; applicable to
     * supergroups and channels only
     */
    can_edit_stories: boolean,
    /**
     * True, if the administrator can delete stories posted by other users; applicable
     * to supergroups and channels only
     */
    can_delete_stories: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
  |}

  declare export type chatAdministratorRights$Input = {|
    /** Describes rights of the administrator */
    +_: 'chatAdministratorRights',
    /**
     * True, if the administrator can access the chat event log, get boost list, see
     * hidden supergroup and channel members, report supergroup spam messages and ignore
     * slow mode. Implied by any other privilege; applicable to supergroups and channels
     * only
     */
    +can_manage_chat?: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    +can_change_info?: boolean,
    /**
     * True, if the administrator can create channel posts or view channel statistics;
     * applicable to channels only
     */
    +can_post_messages?: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    +can_edit_messages?: boolean,
    /** True, if the administrator can delete messages of other users */
    +can_delete_messages?: boolean,
    /** True, if the administrator can invite new users to the chat */
    +can_invite_users?: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members or view
     * supergroup statistics; always true for channels
     */
    +can_restrict_members?: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    +can_pin_messages?: boolean,
    /**
     * True, if the administrator can create, rename, close, reopen, hide, and unhide
     * forum topics; applicable to forum supergroups only
     */
    +can_manage_topics?: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    +can_promote_members?: boolean,
    /** True, if the administrator can manage video chats */
    +can_manage_video_chats?: boolean,
    /**
     * True, if the administrator can create new chat stories, or edit and delete posted
     * stories; applicable to supergroups and channels only
     */
    +can_post_stories?: boolean,
    /**
     * True, if the administrator can edit stories posted by other users, post stories
     * to the chat page, pin chat stories, and access story archive; applicable to
     * supergroups and channels only
     */
    +can_edit_stories?: boolean,
    /**
     * True, if the administrator can delete stories posted by other users; applicable
     * to supergroups and channels only
     */
    +can_delete_stories?: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    +is_anonymous?: boolean,
  |}

  declare export type starAmount = {|
    /** Describes a possibly non-integer amount of Telegram Stars */
    _: 'starAmount',
    /** The integer amount of Telegram Stars rounded to 0 */
    star_count: number,
    /** The number of 1/1000000000 shares of Telegram Stars; from -999999999 to 999999999 */
    nanostar_count: number,
  |}

  declare export type starSubscriptionTypeChannel = {|
    /** Describes a subscription to a channel chat */
    _: 'starSubscriptionTypeChannel',
    /**
     * True, if the subscription is active and the user can use the method reuseStarSubscription
     * to join the subscribed chat again
     */
    can_reuse: boolean,
    /**
     * The invite link that can be used to renew the subscription if it has been expired;
     * may be empty, if the link isn't available anymore
     */
    invite_link: string,
  |}

  declare export type starSubscriptionTypeBot = {|
    /** Describes a subscription in a bot or a business account */
    _: 'starSubscriptionTypeBot',
    /** True, if the subscription was canceled by the bot and can't be extended */
    is_canceled_by_bot: boolean,
    /** Subscription invoice title */
    title: string,
    /** Subscription invoice photo */
    photo: photo,
    /** The link to the subscription invoice */
    invoice_link: string,
  |}

  declare export type starSubscriptionPricing = {|
    /** Describes subscription plan paid in Telegram Stars */
    _: 'starSubscriptionPricing',
    /** The number of seconds between consecutive Telegram Star debiting */
    period: number,
    /** The amount of Telegram Stars that must be paid for each period */
    star_count: number,
  |}

  declare export type starSubscriptionPricing$Input = {|
    /** Describes subscription plan paid in Telegram Stars */
    +_: 'starSubscriptionPricing',
    /** The number of seconds between consecutive Telegram Star debiting */
    +period?: number,
    /** The amount of Telegram Stars that must be paid for each period */
    +star_count?: number,
  |}

  declare export type starSubscription = {|
    /**
     * Contains information about subscription to a channel chat, a bot, or a business
     * account that was paid in Telegram Stars
     */
    _: 'starSubscription',
    /** Unique identifier of the subscription */
    id: string,
    /** Identifier of the chat that is subscribed */
    chat_id: number,
    /** Point in time (Unix timestamp) when the subscription will expire or expired */
    expiration_date: number,
    /** True, if the subscription was canceled */
    is_canceled: boolean,
    /**
     * True, if the subscription expires soon and there are no enough Telegram Stars
     * on the user's balance to extend it
     */
    is_expiring: boolean,
    /** The subscription plan */
    pricing: starSubscriptionPricing,
    /** Type of the subscription */
    type: StarSubscriptionType,
  |}

  declare export type starSubscriptions = {|
    /** Represents a list of Telegram Star subscriptions */
    _: 'starSubscriptions',
    /** The amount of owned Telegram Stars */
    star_amount: starAmount,
    /** List of subscriptions for Telegram Stars */
    subscriptions: Array<starSubscription>,
    /**
     * The number of Telegram Stars required to buy to extend subscriptions expiring
     * soon
     */
    required_star_count: number,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type affiliateTypeCurrentUser$Input = {|
    /** The affiliate is the current user */
    +_: 'affiliateTypeCurrentUser',
  |}

  declare export type affiliateTypeBot$Input = {|
    /** The affiliate is a bot owned by the current user */
    +_: 'affiliateTypeBot',
    /** User identifier of the bot */
    +user_id?: number,
  |}

  declare export type affiliateTypeChannel$Input = {|
    /**
     * The affiliate is a channel chat where the current user has can_post_messages
     * administrator right
     */
    +_: 'affiliateTypeChannel',
    /** Identifier of the channel chat */
    +chat_id?: number,
  |}

  declare export type affiliateProgramSortOrderProfitability$Input = {|
    /** The affiliate programs must be sorted by the profitability */
    +_: 'affiliateProgramSortOrderProfitability',
  |}

  declare export type affiliateProgramSortOrderCreationDate$Input = {|
    /** The affiliate programs must be sorted by creation date */
    +_: 'affiliateProgramSortOrderCreationDate',
  |}

  declare export type affiliateProgramSortOrderRevenue$Input = {|
    /** The affiliate programs must be sorted by the expected revenue */
    +_: 'affiliateProgramSortOrderRevenue',
  |}

  declare export type affiliateProgramParameters = {|
    /** Describes parameters of an affiliate program */
    _: 'affiliateProgramParameters',
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner; getOption("affiliate_program_commission_per_mille_min")-getOption("affiliate_program_commission_per_mille_max")
     */
    commission_per_mille: number,
    /**
     * Number of months the program will be active; 0-36. If 0, then the program is
     * eternal
     */
    month_count: number,
  |}

  declare export type affiliateProgramParameters$Input = {|
    /** Describes parameters of an affiliate program */
    +_: 'affiliateProgramParameters',
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner; getOption("affiliate_program_commission_per_mille_min")-getOption("affiliate_program_commission_per_mille_max")
     */
    +commission_per_mille?: number,
    /**
     * Number of months the program will be active; 0-36. If 0, then the program is
     * eternal
     */
    +month_count?: number,
  |}

  declare export type affiliateProgramInfo = {|
    /** Contains information about an active affiliate program */
    _: 'affiliateProgramInfo',
    /** Parameters of the affiliate program */
    parameters: affiliateProgramParameters,
    /**
     * Point in time (Unix timestamp) when the affiliate program will be closed; 0
     * if the affiliate program isn't scheduled to be closed. If positive, then the
     * program can't be connected using connectAffiliateProgram, but active connections
     * will work until the date
     */
    end_date: number,
    /**
     * The amount of daily revenue per user in Telegram Stars of the bot that created
     * the affiliate program
     */
    daily_revenue_per_user_amount: starAmount,
  |}

  declare export type affiliateInfo = {|
    /**
     * Contains information about an affiliate that received commission from a Telegram
     * Star transaction
     */
    _: 'affiliateInfo',
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner
     */
    commission_per_mille: number,
    /** Identifier of the chat which received the commission */
    affiliate_chat_id: number,
    /**
     * The amount of Telegram Stars that were received by the affiliate; can be negative
     * for refunds
     */
    star_amount: starAmount,
  |}

  declare export type foundAffiliateProgram = {|
    /** Describes a found affiliate program */
    _: 'foundAffiliateProgram',
    /** User identifier of the bot created the program */
    bot_user_id: number,
    /** Information about the affiliate program */
    info: affiliateProgramInfo,
  |}

  declare export type foundAffiliatePrograms = {|
    /** Represents a list of found affiliate programs */
    _: 'foundAffiliatePrograms',
    /** The total number of found affiliate programs */
    total_count: number,
    /** The list of affiliate programs */
    programs: Array<foundAffiliateProgram>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type connectedAffiliateProgram = {|
    /** Describes an affiliate program that was connected to an affiliate */
    _: 'connectedAffiliateProgram',
    /** The link that can be used to refer users if the program is still active */
    url: string,
    /** User identifier of the bot created the program */
    bot_user_id: number,
    /** The parameters of the affiliate program */
    parameters: affiliateProgramParameters,
    /** Point in time (Unix timestamp) when the affiliate program was connected */
    connection_date: number,
    /**
     * True, if the program was canceled by the bot, or disconnected by the chat owner
     * and isn't available anymore
     */
    is_disconnected: boolean,
    /** The number of users that used the affiliate program */
    user_count: string,
    /** The number of Telegram Stars that were earned by the affiliate program */
    revenue_star_count: string,
  |}

  declare export type connectedAffiliatePrograms = {|
    /** Represents a list of affiliate programs that were connected to an affiliate */
    _: 'connectedAffiliatePrograms',
    /** The total number of affiliate programs that were connected to the affiliate */
    total_count: number,
    /** The list of connected affiliate programs */
    programs: Array<connectedAffiliateProgram>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type productInfo = {|
    /** Contains information about a product that can be paid with invoice */
    _: 'productInfo',
    /** Product title */
    title: string,
    /** Product description */
    description: formattedText,
    /** Product photo; may be null */
    photo?: photo,
  |}

  declare export type premiumPaymentOption = {|
    /** Describes an option for buying Telegram Premium to a user */
    _: 'premiumPaymentOption',
    /** ISO 4217 currency code for Telegram Premium subscription payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** The discount associated with this option, as a percentage */
    discount_percentage: number,
    /**
     * Number of months the Telegram Premium subscription will be active. Use getPremiumInfoSticker
     * to get the sticker to be used as representation of the Telegram Premium subscription
     */
    month_count: number,
    /** Identifier of the store product associated with the option */
    store_product_id: string,
    /**
     * An internal link to be opened for buying Telegram Premium to the user if store
     * payment isn't possible; may be null if direct payment isn't available
     */
    payment_link?: InternalLinkType,
  |}

  declare export type premiumStatePaymentOption = {|
    /** Describes an option for buying or upgrading Telegram Premium for self */
    _: 'premiumStatePaymentOption',
    /** Information about the payment option */
    payment_option: premiumPaymentOption,
    /** True, if this is the currently used Telegram Premium subscription option */
    is_current: boolean,
    /**
     * True, if the payment option can be used to upgrade the existing Telegram Premium
     * subscription
     */
    is_upgrade: boolean,
    /** Identifier of the last in-store transaction for the currently used option */
    last_transaction_id: string,
  |}

  declare export type premiumGiftPaymentOption = {|
    /**
     * Describes an option for gifting Telegram Premium to a user. Use telegramPaymentPurposePremiumGift
     * for out-of-store payments or payments in Telegram Stars
     */
    _: 'premiumGiftPaymentOption',
    /** ISO 4217 currency code for the payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /**
     * The alternative amount of Telegram Stars to pay; 0 if payment in Telegram Stars
     * is not possible
     */
    star_count: number,
    /** The discount associated with this option, as a percentage */
    discount_percentage: number,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /** Identifier of the store product associated with the option */
    store_product_id: string,
    /** A sticker to be shown along with the option; may be null if unknown */
    sticker?: sticker,
  |}

  declare export type premiumGiftPaymentOptions = {|
    /** Contains a list of options for gifting Telegram Premium to a user */
    _: 'premiumGiftPaymentOptions',
    /** The list of options sorted by Telegram Premium subscription duration */
    options: Array<premiumGiftPaymentOption>,
  |}

  declare export type premiumGiveawayPaymentOption = {|
    /**
     * Describes an option for creating of Telegram Premium giveaway or manual distribution
     * of Telegram Premium among chat members. Use telegramPaymentPurposePremiumGiftCodes
     * or telegramPaymentPurposePremiumGiveaway for out-of-store payments
     */
    _: 'premiumGiveawayPaymentOption',
    /** ISO 4217 currency code for Telegram Premium gift code payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** Number of users which will be able to activate the gift codes */
    winner_count: number,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /**
     * Identifier of the store product associated with the option; may be empty if
     * none
     */
    store_product_id: string,
    /** Number of times the store product must be paid */
    store_product_quantity: number,
  |}

  declare export type premiumGiveawayPaymentOptions = {|
    /**
     * Contains a list of options for creating of Telegram Premium giveaway or manual
     * distribution of Telegram Premium among chat members
     */
    _: 'premiumGiveawayPaymentOptions',
    /** The list of options */
    options: Array<premiumGiveawayPaymentOption>,
  |}

  declare export type premiumGiftCodeInfo = {|
    /** Contains information about a Telegram Premium gift code */
    _: 'premiumGiftCodeInfo',
    /**
     * Identifier of a chat or a user that created the gift code; may be null if unknown.
     * If null and the code is from messagePremiumGiftCode message, then creator_id
     * from the message can be used
     */
    creator_id?: MessageSender,
    /** Point in time (Unix timestamp) when the code was created */
    creation_date: number,
    /** True, if the gift code was created for a giveaway */
    is_from_giveaway: boolean,
    /**
     * Identifier of the corresponding giveaway message in the creator_id chat; can
     * be 0 or an identifier of a deleted message
     */
    giveaway_message_id: number,
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
    /** Identifier of a user for which the code was created; 0 if none */
    user_id: number,
    /** Point in time (Unix timestamp) when the code was activated; 0 if none */
    use_date: number,
  |}

  declare export type starPaymentOption = {|
    /**
     * Describes an option for buying Telegram Stars. Use telegramPaymentPurposeStars
     * for out-of-store payments
     */
    _: 'starPaymentOption',
    /** ISO 4217 currency code for the payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** Number of Telegram Stars that will be purchased */
    star_count: number,
    /**
     * Identifier of the store product associated with the option; may be empty if
     * none
     */
    store_product_id: string,
    /** True, if the option must be shown only in the full list of payment options */
    is_additional: boolean,
  |}

  declare export type starPaymentOptions = {|
    /** Contains a list of options for buying Telegram Stars */
    _: 'starPaymentOptions',
    /** The list of options */
    options: Array<starPaymentOption>,
  |}

  declare export type starGiveawayWinnerOption = {|
    /** Describes an option for the number of winners of a Telegram Star giveaway */
    _: 'starGiveawayWinnerOption',
    /** The number of users that will be chosen as winners */
    winner_count: number,
    /** The number of Telegram Stars that will be won by the winners of the giveaway */
    won_star_count: number,
    /** True, if the option must be chosen by default */
    is_default: boolean,
  |}

  declare export type starGiveawayPaymentOption = {|
    /**
     * Describes an option for creating of Telegram Star giveaway. Use telegramPaymentPurposeStarGiveaway
     * for out-of-store payments
     */
    _: 'starGiveawayPaymentOption',
    /** ISO 4217 currency code for the payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** Number of Telegram Stars that will be distributed among winners */
    star_count: number,
    /**
     * Identifier of the store product associated with the option; may be empty if
     * none
     */
    store_product_id: string,
    /** Number of times the chat will be boosted for one year if the option is chosen */
    yearly_boost_count: number,
    /** Allowed options for the number of giveaway winners */
    winner_options: Array<starGiveawayWinnerOption>,
    /** True, if the option must be chosen by default */
    is_default: boolean,
    /** True, if the option must be shown only in the full list of payment options */
    is_additional: boolean,
  |}

  declare export type starGiveawayPaymentOptions = {|
    /** Contains a list of options for creating of Telegram Star giveaway */
    _: 'starGiveawayPaymentOptions',
    /** The list of options */
    options: Array<starGiveawayPaymentOption>,
  |}

  declare export type upgradedGiftModel = {|
    /** Describes a model of an upgraded gift */
    _: 'upgradedGiftModel',
    /** Name of the model */
    name: string,
    /** The sticker representing the upgraded gift */
    sticker: sticker,
    /** The number of upgraded gift that receive this model for each 1000 gifts upgraded */
    rarity_per_mille: number,
  |}

  declare export type upgradedGiftSymbol = {|
    /** Describes a symbol shown on the pattern of an upgraded gift */
    _: 'upgradedGiftSymbol',
    /** Name of the symbol */
    name: string,
    /** The sticker representing the upgraded gift */
    sticker: sticker,
    /** The number of upgraded gift that receive this symbol for each 1000 gifts upgraded */
    rarity_per_mille: number,
  |}

  declare export type upgradedGiftBackdropColors = {|
    /** Describes colors of a backdrop of an upgraded gift */
    _: 'upgradedGiftBackdropColors',
    /** A color in the center of the backdrop in the RGB format */
    center_color: number,
    /** A color on the edges of the backdrop in the RGB format */
    edge_color: number,
    /** A color to be applied for the symbol in the RGB format */
    symbol_color: number,
    /** A color for the text on the backdrop in the RGB format */
    text_color: number,
  |}

  declare export type upgradedGiftBackdropColors$Input = {|
    /** Describes colors of a backdrop of an upgraded gift */
    +_: 'upgradedGiftBackdropColors',
    /** A color in the center of the backdrop in the RGB format */
    +center_color?: number,
    /** A color on the edges of the backdrop in the RGB format */
    +edge_color?: number,
    /** A color to be applied for the symbol in the RGB format */
    +symbol_color?: number,
    /** A color for the text on the backdrop in the RGB format */
    +text_color?: number,
  |}

  declare export type upgradedGiftBackdrop = {|
    /** Describes a backdrop of an upgraded gift */
    _: 'upgradedGiftBackdrop',
    /** Name of the backdrop */
    name: string,
    /** Colors of the backdrop */
    colors: upgradedGiftBackdropColors,
    /** The number of upgraded gift that receive this backdrop for each 1000 gifts upgraded */
    rarity_per_mille: number,
  |}

  declare export type upgradedGiftOriginalDetails = {|
    /** Describes the original details about the gift */
    _: 'upgradedGiftOriginalDetails',
    /**
     * Identifier of the user or the chat that sent the gift; may be null if the gift
     * was private
     */
    sender_id?: MessageSender,
    /** Identifier of the user or the chat that received the gift */
    receiver_id: MessageSender,
    /** Message added to the gift */
    text: formattedText,
    /** Point in time (Unix timestamp) when the gift was sent */
    date: number,
  |}

  declare export type gift = {|
    /** Describes a gift that can be sent to another user or channel chat */
    _: 'gift',
    /** Unique identifier of the gift */
    id: string,
    /** The sticker representing the gift */
    sticker: sticker,
    /** Number of Telegram Stars that must be paid for the gift */
    star_count: number,
    /**
     * Number of Telegram Stars that can be claimed by the receiver instead of the
     * regular gift by default. If the gift was paid with just bought Telegram Stars,
     * then full value can be claimed
     */
    default_sell_star_count: number,
    /**
     * Number of Telegram Stars that must be paid to upgrade the gift; 0 if upgrade
     * isn't possible
     */
    upgrade_star_count: number,
    /** True, if the gift is a birthday gift */
    is_for_birthday: boolean,
    /**
     * Number of remaining times the gift can be purchased; 0 if not limited or the
     * gift was sold out
     */
    remaining_count: number,
    /** Number of total times the gift can be purchased; 0 if not limited */
    total_count: number,
    /**
     * Point in time (Unix timestamp) when the gift was send for the first time; for
     * sold out gifts only
     */
    first_send_date: number,
    /**
     * Point in time (Unix timestamp) when the gift was send for the last time; for
     * sold out gifts only
     */
    last_send_date: number,
  |}

  declare export type gifts = {|
    /** Contains a list of gifts that can be sent to another user or channel chat */
    _: 'gifts',
    /** The list of gifts */
    gifts: Array<gift>,
  |}

  declare export type upgradedGift = {|
    /**
     * Describes an upgraded gift that can be transferred to another owner or transferred
     * to the TON blockchain as an NFT
     */
    _: 'upgradedGift',
    /** Unique identifier of the gift */
    id: string,
    /** The title of the upgraded gift */
    title: string,
    /** Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift */
    name: string,
    /** Unique number of the upgraded gift among gifts upgraded from the same gift */
    number: number,
    /** Total number of gifts that were upgraded from the same gift */
    total_upgraded_count: number,
    /** The maximum number of gifts that can be upgraded from the same gift */
    max_upgraded_count: number,
    /**
     * Identifier of the user or the chat that owns the upgraded gift; may be null
     * if none or unknown
     */
    owner_id?: MessageSender,
    /** Address of the gift NFT owner in TON blockchain; may be empty if none */
    owner_address: string,
    /** Name of the owner for the case when owner identifier and address aren't known */
    owner_name: string,
    /** Address of the gift NFT in TON blockchain; may be empty if none */
    gift_address: string,
    /** Model of the upgraded gift */
    model: upgradedGiftModel,
    /** Symbol of the upgraded gift */
    symbol: upgradedGiftSymbol,
    /** Backdrop of the upgraded gift */
    backdrop: upgradedGiftBackdrop,
    /** Information about the originally sent gift; may be null if unknown */
    original_details?: upgradedGiftOriginalDetails,
  |}

  declare export type upgradeGiftResult = {|
    /** Contains result of gift upgrading */
    _: 'upgradeGiftResult',
    /** The upgraded gift */
    gift: upgradedGift,
    /** Unique identifier of the received gift for the current user */
    received_gift_id: string,
    /** True, if the gift is displayed on the user's or the channel's profile page */
    is_saved: boolean,
    /** True, if the gift can be transferred to another owner */
    can_be_transferred: boolean,
    /** Number of Telegram Stars that must be paid to transfer the upgraded gift */
    transfer_star_count: number,
    /**
     * Point in time (Unix timestamp) when the gift can be transferred to the TON blockchain
     * as an NFT
     */
    export_date: number,
  |}

  declare export type sentGiftRegular = {|
    /** Regular gift */
    _: 'sentGiftRegular',
    /** The gift */
    gift: gift,
  |}

  declare export type sentGiftUpgraded = {|
    /** Upgraded gift */
    _: 'sentGiftUpgraded',
    /** The gift */
    gift: upgradedGift,
  |}

  declare export type receivedGift = {|
    /** Represents a gift received by a user or a chat */
    _: 'receivedGift',
    /**
     * Unique identifier of the received gift for the current user; only for the receiver
     * of the gift
     */
    received_gift_id: string,
    /** Identifier of a user or a chat that sent the gift; may be null if unknown */
    sender_id?: MessageSender,
    /** Message added to the gift */
    text: formattedText,
    /**
     * True, if the sender and gift text are shown only to the gift receiver; otherwise,
     * everyone are able to see them
     */
    is_private: boolean,
    /**
     * True, if the gift is displayed on the chat's profile page; only for the receiver
     * of the gift
     */
    is_saved: boolean,
    /** True, if the gift is pinned to the top of the chat's profile page */
    is_pinned: boolean,
    /**
     * True, if the gift is a regular gift that can be upgraded to a unique gift; only
     * for the receiver of the gift
     */
    can_be_upgraded: boolean,
    /**
     * True, if the gift is an upgraded gift that can be transferred to another owner;
     * only for the receiver of the gift
     */
    can_be_transferred: boolean,
    /** True, if the gift was refunded and isn't available anymore */
    was_refunded: boolean,
    /** Point in time (Unix timestamp) when the gift was sent */
    date: number,
    /** The gift */
    gift: SentGift,
    /**
     * Number of Telegram Stars that can be claimed by the receiver instead of the
     * regular gift; 0 if the gift can't be sold by the current user
     */
    sell_star_count: number,
    /**
     * Number of Telegram Stars that were paid by the sender for the ability to upgrade
     * the gift
     */
    prepaid_upgrade_star_count: number,
    /**
     * Number of Telegram Stars that must be paid to transfer the upgraded gift; only
     * for the receiver of the gift
     */
    transfer_star_count: number,
    /**
     * Point in time (Unix timestamp) when the upgraded gift can be transferred to
     * the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver
     * of the gift
     */
    export_date: number,
  |}

  declare export type receivedGifts = {|
    /** Represents a list of gifts received by a user or a chat */
    _: 'receivedGifts',
    /** The total number of received gifts */
    total_count: number,
    /** The list of gifts */
    gifts: Array<receivedGift>,
    /** True, if notifications about new gifts of the owner are enabled */
    are_notifications_enabled: boolean,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type giftUpgradePreview = {|
    /** Contains examples of possible upgraded gifts for the given regular gift */
    _: 'giftUpgradePreview',
    /** Examples of possible models that can be chosen for the gift after upgrade */
    models: Array<upgradedGiftModel>,
    /** Examples of possible symbols that can be chosen for the gift after upgrade */
    symbols: Array<upgradedGiftSymbol>,
    /** Examples of possible backdrops that can be chosen for the gift after upgrade */
    backdrops: Array<upgradedGiftBackdrop>,
  |}

  declare export type starTransactionDirectionIncoming$Input = {|
    /** The transaction is incoming and increases the number of owned Telegram Stars */
    +_: 'starTransactionDirectionIncoming',
  |}

  declare export type starTransactionDirectionOutgoing$Input = {|
    /** The transaction is outgoing and decreases the number of owned Telegram Stars */
    +_: 'starTransactionDirectionOutgoing',
  |}

  declare export type starTransactionTypePremiumBotDeposit = {|
    /**
     * The transaction is a deposit of Telegram Stars from the Premium bot; for regular
     * users only
     */
    _: 'starTransactionTypePremiumBotDeposit',
  |}

  declare export type starTransactionTypeAppStoreDeposit = {|
    /**
     * The transaction is a deposit of Telegram Stars from App Store; for regular users
     * only
     */
    _: 'starTransactionTypeAppStoreDeposit',
  |}

  declare export type starTransactionTypeGooglePlayDeposit = {|
    /**
     * The transaction is a deposit of Telegram Stars from Google Play; for regular
     * users only
     */
    _: 'starTransactionTypeGooglePlayDeposit',
  |}

  declare export type starTransactionTypeFragmentDeposit = {|
    /**
     * The transaction is a deposit of Telegram Stars from Fragment; for regular users
     * and bots only
     */
    _: 'starTransactionTypeFragmentDeposit',
  |}

  declare export type starTransactionTypeUserDeposit = {|
    /**
     * The transaction is a deposit of Telegram Stars by another user; for regular
     * users only
     */
    _: 'starTransactionTypeUserDeposit',
    /** Identifier of the user that gifted Telegram Stars; 0 if the user was anonymous */
    user_id: number,
    /** The sticker to be shown in the transaction information; may be null if unknown */
    sticker?: sticker,
  |}

  declare export type starTransactionTypeGiveawayDeposit = {|
    /**
     * The transaction is a deposit of Telegram Stars from a giveaway; for regular
     * users only
     */
    _: 'starTransactionTypeGiveawayDeposit',
    /** Identifier of a supergroup or a channel chat that created the giveaway */
    chat_id: number,
    /**
     * Identifier of the message with the giveaway; can be 0 or an identifier of a
     * deleted message
     */
    giveaway_message_id: number,
  |}

  declare export type starTransactionTypeFragmentWithdrawal = {|
    /**
     * The transaction is a withdrawal of earned Telegram Stars to Fragment; for regular
     * users, bots, supergroup and channel chats only
     */
    _: 'starTransactionTypeFragmentWithdrawal',
    /** State of the withdrawal; may be null for refunds from Fragment */
    withdrawal_state?: RevenueWithdrawalState,
  |}

  declare export type starTransactionTypeTelegramAdsWithdrawal = {|
    /**
     * The transaction is a withdrawal of earned Telegram Stars to Telegram Ad platform;
     * for bots and channel chats only
     */
    _: 'starTransactionTypeTelegramAdsWithdrawal',
  |}

  declare export type starTransactionTypeTelegramApiUsage = {|
    /** The transaction is a payment for Telegram API usage; for bots only */
    _: 'starTransactionTypeTelegramApiUsage',
    /** The number of billed requests */
    request_count: number,
  |}

  declare export type starTransactionTypeBotPaidMediaPurchase = {|
    /**
     * The transaction is a purchase of paid media from a bot or a business account
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeBotPaidMediaPurchase',
    /** Identifier of the bot or the business account user that sent the paid media */
    user_id: number,
    /** The bought media if the transaction wasn't refunded */
    media: Array<PaidMedia>,
  |}

  declare export type starTransactionTypeBotPaidMediaSale = {|
    /**
     * The transaction is a sale of paid media by the bot or a business account managed
     * by the bot; for bots only
     */
    _: 'starTransactionTypeBotPaidMediaSale',
    /** Identifier of the user that bought the media */
    user_id: number,
    /** The bought media */
    media: Array<PaidMedia>,
    /** Bot-provided payload */
    payload: string,
    /**
     * Information about the affiliate which received commission from the transaction;
     * may be null if none
     */
    affiliate?: affiliateInfo,
  |}

  declare export type starTransactionTypeChannelPaidMediaPurchase = {|
    /**
     * The transaction is a purchase of paid media from a channel by the current user;
     * for regular users only
     */
    _: 'starTransactionTypeChannelPaidMediaPurchase',
    /** Identifier of the channel chat that sent the paid media */
    chat_id: number,
    /**
     * Identifier of the corresponding message with paid media; can be 0 or an identifier
     * of a deleted message
     */
    message_id: number,
    /** The bought media if the transaction wasn't refunded */
    media: Array<PaidMedia>,
  |}

  declare export type starTransactionTypeChannelPaidMediaSale = {|
    /**
     * The transaction is a sale of paid media by the channel chat; for channel chats
     * only
     */
    _: 'starTransactionTypeChannelPaidMediaSale',
    /** Identifier of the user that bought the media */
    user_id: number,
    /**
     * Identifier of the corresponding message with paid media; can be 0 or an identifier
     * of a deleted message
     */
    message_id: number,
    /** The bought media */
    media: Array<PaidMedia>,
  |}

  declare export type starTransactionTypeBotInvoicePurchase = {|
    /**
     * The transaction is a purchase of a product from a bot or a business account
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeBotInvoicePurchase',
    /** Identifier of the bot or the business account user that created the invoice */
    user_id: number,
    /** Information about the bought product */
    product_info: productInfo,
  |}

  declare export type starTransactionTypeBotInvoiceSale = {|
    /** The transaction is a sale of a product by the bot; for bots only */
    _: 'starTransactionTypeBotInvoiceSale',
    /** Identifier of the user that bought the product */
    user_id: number,
    /** Information about the bought product */
    product_info: productInfo,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /**
     * Information about the affiliate which received commission from the transaction;
     * may be null if none
     */
    affiliate?: affiliateInfo,
  |}

  declare export type starTransactionTypeBotSubscriptionPurchase = {|
    /**
     * The transaction is a purchase of a subscription from a bot or a business account
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeBotSubscriptionPurchase',
    /**
     * Identifier of the bot or the business account user that created the subscription
     * link
     */
    user_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
    /** Information about the bought subscription */
    product_info: productInfo,
  |}

  declare export type starTransactionTypeBotSubscriptionSale = {|
    /** The transaction is a sale of a subscription by the bot; for bots only */
    _: 'starTransactionTypeBotSubscriptionSale',
    /** Identifier of the user that bought the subscription */
    user_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
    /** Information about the bought subscription */
    product_info: productInfo,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /**
     * Information about the affiliate which received commission from the transaction;
     * may be null if none
     */
    affiliate?: affiliateInfo,
  |}

  declare export type starTransactionTypeChannelSubscriptionPurchase = {|
    /**
     * The transaction is a purchase of a subscription to a channel chat by the current
     * user; for regular users only
     */
    _: 'starTransactionTypeChannelSubscriptionPurchase',
    /** Identifier of the channel chat that created the subscription */
    chat_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
  |}

  declare export type starTransactionTypeChannelSubscriptionSale = {|
    /**
     * The transaction is a sale of a subscription by the channel chat; for channel
     * chats only
     */
    _: 'starTransactionTypeChannelSubscriptionSale',
    /** Identifier of the user that bought the subscription */
    user_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
  |}

  declare export type starTransactionTypeGiftPurchase = {|
    /**
     * The transaction is a purchase of a regular gift; for regular users and bots
     * only
     */
    _: 'starTransactionTypeGiftPurchase',
    /** Identifier of the user or the channel that received the gift */
    owner_id: MessageSender,
    /** The gift */
    gift: gift,
  |}

  declare export type starTransactionTypeGiftTransfer = {|
    /** The transaction is a transfer of an upgraded gift; for regular users only */
    _: 'starTransactionTypeGiftTransfer',
    /** Identifier of the user or the channel that received the gift */
    owner_id: MessageSender,
    /** The gift */
    gift: upgradedGift,
  |}

  declare export type starTransactionTypeGiftSale = {|
    /**
     * The transaction is a sale of a received gift; for regular users and channel
     * chats only
     */
    _: 'starTransactionTypeGiftSale',
    /** Identifier of the user that sent the gift */
    user_id: number,
    /** The gift */
    gift: gift,
  |}

  declare export type starTransactionTypeGiftUpgrade = {|
    /** The transaction is an upgrade of a gift; for regular users only */
    _: 'starTransactionTypeGiftUpgrade',
    /** Identifier of the user that initially sent the gift */
    user_id: number,
    /** The upgraded gift */
    gift: upgradedGift,
  |}

  declare export type starTransactionTypeChannelPaidReactionSend = {|
    /**
     * The transaction is a sending of a paid reaction to a message in a channel chat
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeChannelPaidReactionSend',
    /** Identifier of the channel chat */
    chat_id: number,
    /** Identifier of the reacted message; can be 0 or an identifier of a deleted message */
    message_id: number,
  |}

  declare export type starTransactionTypeChannelPaidReactionReceive = {|
    /**
     * The transaction is a receiving of a paid reaction to a message by the channel
     * chat; for channel chats only
     */
    _: 'starTransactionTypeChannelPaidReactionReceive',
    /** Identifier of the user that added the paid reaction */
    user_id: number,
    /** Identifier of the reacted message; can be 0 or an identifier of a deleted message */
    message_id: number,
  |}

  declare export type starTransactionTypeAffiliateProgramCommission = {|
    /**
     * The transaction is a receiving of a commission from an affiliate program; for
     * regular users, bots and channel chats only
     */
    _: 'starTransactionTypeAffiliateProgramCommission',
    /** Identifier of the chat that created the affiliate program */
    chat_id: number,
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner
     */
    commission_per_mille: number,
  |}

  declare export type starTransactionTypePaidMessageSend = {|
    /** The transaction is a sending of a paid message; for regular users only */
    _: 'starTransactionTypePaidMessageSend',
    /** Identifier of the chat that received the payment */
    chat_id: number,
    /** Number of sent paid messages */
    message_count: number,
  |}

  declare export type starTransactionTypePaidMessageReceive = {|
    /**
     * The transaction is a receiving of a paid message; for regular users and supergroup
     * chats only
     */
    _: 'starTransactionTypePaidMessageReceive',
    /** Identifier of the sender of the message */
    sender_id: MessageSender,
    /** Number of received paid messages */
    message_count: number,
    /**
     * The number of Telegram Stars received by the Telegram for each 1000 Telegram
     * Stars paid for message sending
     */
    commission_per_mille: number,
    /**
     * The amount of Telegram Stars that were received by Telegram; can be negative
     * for refunds
     */
    commission_star_amount: starAmount,
  |}

  declare export type starTransactionTypePremiumPurchase = {|
    /**
     * The transaction is a purchase of Telegram Premium subscription; for regular
     * users only
     */
    _: 'starTransactionTypePremiumPurchase',
    /** Identifier of the user that received the Telegram Premium subscription */
    user_id: number,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /** A sticker to be shown in the transaction information; may be null if unknown */
    sticker?: sticker,
  |}

  declare export type starTransactionTypeUnsupported = {|
    /** The transaction is a transaction of an unsupported type */
    _: 'starTransactionTypeUnsupported',
  |}

  declare export type starTransaction = {|
    /** Represents a transaction changing the amount of owned Telegram Stars */
    _: 'starTransaction',
    /** Unique identifier of the transaction */
    id: string,
    /** The amount of added owned Telegram Stars; negative for outgoing transactions */
    star_amount: starAmount,
    /** True, if the transaction is a refund of a previous transaction */
    is_refund: boolean,
    /** Point in time (Unix timestamp) when the transaction was completed */
    date: number,
    /** Type of the transaction */
    type: StarTransactionType,
  |}

  declare export type starTransactions = {|
    /** Represents a list of Telegram Star transactions */
    _: 'starTransactions',
    /** The amount of owned Telegram Stars */
    star_amount: starAmount,
    /** List of transactions with Telegram Stars */
    transactions: Array<starTransaction>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type giveawayParticipantStatusEligible = {|
    /** The user is eligible for the giveaway */
    _: 'giveawayParticipantStatusEligible',
  |}

  declare export type giveawayParticipantStatusParticipating = {|
    /** The user participates in the giveaway */
    _: 'giveawayParticipantStatusParticipating',
  |}

  declare export type giveawayParticipantStatusAlreadyWasMember = {|
    /**
     * The user can't participate in the giveaway, because they have already been member
     * of the chat
     */
    _: 'giveawayParticipantStatusAlreadyWasMember',
    /** Point in time (Unix timestamp) when the user joined the chat */
    joined_chat_date: number,
  |}

  declare export type giveawayParticipantStatusAdministrator = {|
    /**
     * The user can't participate in the giveaway, because they are an administrator
     * in one of the chats that created the giveaway
     */
    _: 'giveawayParticipantStatusAdministrator',
    /** Identifier of the chat administered by the user */
    chat_id: number,
  |}

  declare export type giveawayParticipantStatusDisallowedCountry = {|
    /**
     * The user can't participate in the giveaway, because they phone number is from
     * a disallowed country
     */
    _: 'giveawayParticipantStatusDisallowedCountry',
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    user_country_code: string,
  |}

  declare export type giveawayInfoOngoing = {|
    /** Describes an ongoing giveaway */
    _: 'giveawayInfoOngoing',
    /** Point in time (Unix timestamp) when the giveaway was created */
    creation_date: number,
    /** Status of the current user in the giveaway */
    status: GiveawayParticipantStatus,
    /** True, if the giveaway has ended and results are being prepared */
    is_ended: boolean,
  |}

  declare export type giveawayInfoCompleted = {|
    /** Describes a completed giveaway */
    _: 'giveawayInfoCompleted',
    /** Point in time (Unix timestamp) when the giveaway was created */
    creation_date: number,
    /**
     * Point in time (Unix timestamp) when the winners were selected. May be bigger
     * than winners selection date specified in parameters of the giveaway
     */
    actual_winners_selection_date: number,
    /** True, if the giveaway was canceled and was fully refunded */
    was_refunded: boolean,
    /** True, if the current user is a winner of the giveaway */
    is_winner: boolean,
    /** Number of winners in the giveaway */
    winner_count: number,
    /**
     * Number of winners, which activated their gift codes; for Telegram Premium giveaways
     * only
     */
    activation_count: number,
    /**
     * Telegram Premium gift code that was received by the current user; empty if the
     * user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium
     * giveaway
     */
    gift_code: string,
    /**
     * The amount of Telegram Stars won by the current user; 0 if the user isn't a
     * winner in the giveaway or the giveaway isn't a Telegram Star giveaway
     */
    won_star_count: number,
  |}

  declare export type giveawayPrizePremium = {|
    /** The giveaway sends Telegram Premium subscriptions to the winners */
    _: 'giveawayPrizePremium',
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
  |}

  declare export type giveawayPrizeStars = {|
    /** The giveaway sends Telegram Stars to the winners */
    _: 'giveawayPrizeStars',
    /** Number of Telegram Stars that will be shared by all winners */
    star_count: number,
  |}

  declare export type accentColor = {|
    /**
     * Contains information about supported accent color for user/chat name, background
     * of empty chat photo, replies to messages and link previews
     */
    _: 'accentColor',
    /** Accent color identifier */
    id: number,
    /**
     * Identifier of a built-in color to use in places, where only one color is needed;
     * 0-6
     */
    built_in_accent_color_id: number,
    /**
     * The list of 1-3 colors in RGB format, describing the accent color, as expected
     * to be shown in light themes
     */
    light_theme_colors: Array<number>,
    /**
     * The list of 1-3 colors in RGB format, describing the accent color, as expected
     * to be shown in dark themes
     */
    dark_theme_colors: Array<number>,
    /** The minimum chat boost level required to use the color in a channel chat */
    min_channel_chat_boost_level: number,
  |}

  declare export type profileAccentColors = {|
    /**
     * Contains information about supported accent colors for user profile photo background
     * in RGB format
     */
    _: 'profileAccentColors',
    /**
     * The list of 1-2 colors in RGB format, describing the colors, as expected to
     * be shown in the color palette settings
     */
    palette_colors: Array<number>,
    /**
     * The list of 1-2 colors in RGB format, describing the colors, as expected to
     * be used for the profile photo background
     */
    background_colors: Array<number>,
    /**
     * The list of 2 colors in RGB format, describing the colors of the gradient to
     * be used for the unread active story indicator around profile photo
     */
    story_colors: Array<number>,
  |}

  declare export type profileAccentColor = {|
    /** Contains information about supported accent color for user profile photo background */
    _: 'profileAccentColor',
    /** Profile accent color identifier */
    id: number,
    /** Accent colors expected to be used in light themes */
    light_theme_colors: profileAccentColors,
    /** Accent colors expected to be used in dark themes */
    dark_theme_colors: profileAccentColors,
    /** The minimum chat boost level required to use the color in a supergroup chat */
    min_supergroup_chat_boost_level: number,
    /** The minimum chat boost level required to use the color in a channel chat */
    min_channel_chat_boost_level: number,
  |}

  declare export type emojiStatusTypeCustomEmoji = {|
    /** A custom emoji set as emoji status */
    _: 'emojiStatusTypeCustomEmoji',
    /** Identifier of the custom emoji in stickerFormatTgs format */
    custom_emoji_id: string,
  |}

  declare export type emojiStatusTypeCustomEmoji$Input = {|
    /** A custom emoji set as emoji status */
    +_: 'emojiStatusTypeCustomEmoji',
    /** Identifier of the custom emoji in stickerFormatTgs format */
    +custom_emoji_id?: number | string,
  |}

  declare export type emojiStatusTypeUpgradedGift = {|
    /** An upgraded gift set as emoji status */
    _: 'emojiStatusTypeUpgradedGift',
    /** Identifier of the upgraded gift */
    upgraded_gift_id: string,
    /** The title of the upgraded gift */
    gift_title: string,
    /** Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift */
    gift_name: string,
    /** Custom emoji identifier of the model of the upgraded gift */
    model_custom_emoji_id: string,
    /** Custom emoji identifier of the symbol of the upgraded gift */
    symbol_custom_emoji_id: string,
    /** Colors of the backdrop of the upgraded gift */
    backdrop_colors: upgradedGiftBackdropColors,
  |}

  declare export type emojiStatusTypeUpgradedGift$Input = {|
    /** An upgraded gift set as emoji status */
    +_: 'emojiStatusTypeUpgradedGift',
    /** Identifier of the upgraded gift */
    +upgraded_gift_id?: number | string,
    /** The title of the upgraded gift */
    +gift_title?: string,
    /** Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift */
    +gift_name?: string,
    /** Custom emoji identifier of the model of the upgraded gift */
    +model_custom_emoji_id?: number | string,
    /** Custom emoji identifier of the symbol of the upgraded gift */
    +symbol_custom_emoji_id?: number | string,
    /** Colors of the backdrop of the upgraded gift */
    +backdrop_colors?: upgradedGiftBackdropColors$Input,
  |}

  declare export type emojiStatus = {|
    /** Describes an emoji to be shown instead of the Telegram Premium badge */
    _: 'emojiStatus',
    /** Type of the emoji status */
    type: EmojiStatusType,
    /** Point in time (Unix timestamp) when the status will expire; 0 if never */
    expiration_date: number,
  |}

  declare export type emojiStatus$Input = {|
    /** Describes an emoji to be shown instead of the Telegram Premium badge */
    +_: 'emojiStatus',
    /** Type of the emoji status */
    +type?: EmojiStatusType$Input,
    /** Point in time (Unix timestamp) when the status will expire; 0 if never */
    +expiration_date?: number,
  |}

  declare export type emojiStatuses = {|
    /** Contains a list of emoji statuses */
    _: 'emojiStatuses',
    /** The list of emoji statuses identifiers */
    emoji_statuses: Array<emojiStatus>,
  |}

  declare export type emojiStatusCustomEmojis = {|
    /** Contains a list of custom emoji identifiers for emoji statuses */
    _: 'emojiStatusCustomEmojis',
    /** The list of custom emoji identifiers */
    custom_emoji_ids: Array<string>,
  |}

  declare export type usernames = {|
    /** Describes usernames assigned to a user, a supergroup, or a channel */
    _: 'usernames',
    /**
     * List of active usernames; the first one must be shown as the primary username.
     * The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames
     * or reorderSupergroupActiveUsernames
     */
    active_usernames: Array<string>,
    /**
     * List of currently disabled usernames; the username can be activated with toggleUsernameIsActive,
     * toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
     */
    disabled_usernames: Array<string>,
    /**
     * The active username, which can be changed with setUsername or setSupergroupUsername.
     * Information about other active usernames can be received using getCollectibleItemInfo
     */
    editable_username: string,
  |}

  declare export type user = {|
    /** Represents a user */
    _: 'user',
    /** User identifier */
    id: number,
    /** First name of the user */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Usernames of the user; may be null */
    usernames?: usernames,
    /** Phone number of the user */
    phone_number: string,
    /** Current online status of the user */
    status: UserStatus,
    /** Profile photo of the user; may be null */
    profile_photo?: profilePhoto,
    /**
     * Identifier of the accent color for name, and backgrounds of profile photo, reply
     * header, and link preview
     */
    accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background; 0 if none
     */
    background_custom_emoji_id: string,
    /** Identifier of the accent color for the user's profile; -1 if none */
    profile_accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the background of the user's profile;
     * 0 if none
     */
    profile_background_custom_emoji_id: string,
    /**
     * Emoji status to be shown instead of the default Telegram Premium badge; may
     * be null
     */
    emoji_status?: emojiStatus,
    /** The user is a contact of the current user */
    is_contact: boolean,
    /**
     * The user is a contact of the current user and the current user is a contact
     * of the user
     */
    is_mutual_contact: boolean,
    /** The user is a close friend of the current user; implies that the user is a contact */
    is_close_friend: boolean,
    /** Information about verification status of the user; may be null if none */
    verification_status?: verificationStatus,
    /** True, if the user is a Telegram Premium user */
    is_premium: boolean,
    /** True, if the user is Telegram support account */
    is_support: boolean,
    /**
     * If non-empty, it contains a human-readable description of the reason why access
     * to this user must be restricted
     */
    restriction_reason: string,
    /** True, if the user has non-expired stories available to the current user */
    has_active_stories: boolean,
    /** True, if the user has unread non-expired stories available to the current user */
    has_unread_active_stories: boolean,
    /**
     * True, if the user may restrict new chats with non-contacts. Use canSendMessageToUser
     * to check whether the current user can message the user or try to create a chat
     * with them
     */
    restricts_new_chats: boolean,
    /**
     * Number of Telegram Stars that must be paid by general user for each sent message
     * to the user. If positive and userFullInfo is unknown, use canSendMessageToUser
     * to check whether the current user must pay
     */
    paid_message_star_count: number,
    /**
     * If false, the user is inaccessible, and the only information known about the
     * user is inside this class. Identifier of the user can't be passed to any method
     */
    have_access: boolean,
    /** Type of the user */
    type: UserType,
    /** IETF language tag of the user's language; only available to bots */
    language_code: string,
    /**
     * True, if the user added the current bot to attachment menu; only available to
     * bots
     */
    added_to_attachment_menu: boolean,
  |}

  declare export type botInfo = {|
    /** Contains information about a bot */
    _: 'botInfo',
    /**
     * The text that is shown on the bot's profile page and is sent together with the
     * link when users share the bot
     */
    short_description: string,
    /** The text shown in the chat with the bot if the chat is empty */
    description: string,
    /** Photo shown in the chat with the bot if the chat is empty; may be null */
    photo?: photo,
    /** Animation shown in the chat with the bot if the chat is empty; may be null */
    animation?: animation,
    /**
     * Information about a button to show instead of the bot commands menu button;
     * may be null if ordinary bot commands menu must be shown
     */
    menu_button?: botMenuButton,
    /** List of the bot commands */
    commands: Array<botCommand>,
    /**
     * The HTTP link to the privacy policy of the bot. If empty, then /privacy command
     * must be used if supported by the bot. If the command isn't supported, then https://telegram.org/privacy-tpa
     * must be opened
     */
    privacy_policy_url: string,
    /**
     * Default administrator rights for adding the bot to basic group and supergroup
     * chats; may be null
     */
    default_group_administrator_rights?: chatAdministratorRights,
    /** Default administrator rights for adding the bot to channels; may be null */
    default_channel_administrator_rights?: chatAdministratorRights,
    /** Information about the affiliate program of the bot; may be null if none */
    affiliate_program?: affiliateProgramInfo,
    /** Default light background color for bot Web Apps; -1 if not specified */
    web_app_background_light_color: number,
    /** Default dark background color for bot Web Apps; -1 if not specified */
    web_app_background_dark_color: number,
    /** Default light header color for bot Web Apps; -1 if not specified */
    web_app_header_light_color: number,
    /** Default dark header color for bot Web Apps; -1 if not specified */
    web_app_header_dark_color: number,
    /**
     * Parameters of the verification that can be provided by the bot; may be null
     * if none or the current user isn't the owner of the bot
     */
    verification_parameters?: botVerificationParameters,
    /** True, if the bot's revenue statistics are available to the current user */
    can_get_revenue_statistics: boolean,
    /** True, if the bot can manage emoji status of the current user */
    can_manage_emoji_status: boolean,
    /** True, if the bot has media previews */
    has_media_previews: boolean,
    /** The internal link, which can be used to edit bot commands; may be null */
    edit_commands_link?: InternalLinkType,
    /** The internal link, which can be used to edit bot description; may be null */
    edit_description_link?: InternalLinkType,
    /**
     * The internal link, which can be used to edit the photo or animation shown in
     * the chat with the bot if the chat is empty; may be null
     */
    edit_description_media_link?: InternalLinkType,
    /** The internal link, which can be used to edit bot settings; may be null */
    edit_settings_link?: InternalLinkType,
  |}

  declare export type userFullInfo = {|
    /** Contains full information about a user */
    _: 'userFullInfo',
    /**
     * User profile photo set by the current user for the contact; may be null. If
     * null and user.profile_photo is null, then the photo is empty; otherwise, it
     * is unknown. If non-null, then it is the same photo as in user.profile_photo
     * and chat.photo. This photo isn't returned in the list of user photos
     */
    personal_photo?: chatPhoto,
    /**
     * User profile photo; may be null. If null and user.profile_photo is null, then
     * the photo is empty; otherwise, it is unknown. If non-null and personal_photo
     * is null, then it is the same photo as in user.profile_photo and chat.photo
     */
    photo?: chatPhoto,
    /**
     * User profile photo visible if the main photo is hidden by privacy settings;
     * may be null. If null and user.profile_photo is null, then the photo is empty;
     * otherwise, it is unknown. If non-null and both photo and personal_photo are
     * null, then it is the same photo as in user.profile_photo and chat.photo. This
     * photo isn't returned in the list of user photos
     */
    public_photo?: chatPhoto,
    /** Block list to which the user is added; may be null if none */
    block_list?: BlockList,
    /** True, if the user can be called */
    can_be_called: boolean,
    /** True, if a video call can be created with the user */
    supports_video_calls: boolean,
    /** True, if the user can't be called due to their privacy settings */
    has_private_calls: boolean,
    /**
     * True, if the user can't be linked in forwarded messages due to their privacy
     * settings
     */
    has_private_forwards: boolean,
    /** True, if voice and video notes can't be sent or forwarded to the user */
    has_restricted_voice_and_video_note_messages: boolean,
    /** True, if the user has posted to profile stories */
    has_posted_to_profile_stories: boolean,
    /**
     * True, if the user always enabled sponsored messages; known only for the current
     * user
     */
    has_sponsored_messages_enabled: boolean,
    /**
     * True, if the current user needs to explicitly allow to share their phone number
     * with the user when the method addContact is used
     */
    need_phone_number_privacy_exception: boolean,
    /**
     * True, if the user set chat background for both chat users and it wasn't reverted
     * yet
     */
    set_chat_background: boolean,
    /** A short user bio; may be null for bots */
    bio?: formattedText,
    /** Birthdate of the user; may be null if unknown */
    birthdate?: birthdate,
    /** Identifier of the personal chat of the user; 0 if none */
    personal_chat_id: number,
    /**
     * Number of saved to profile gifts for other users or the total number of received
     * gifts for the current user
     */
    gift_count: number,
    /**
     * Number of group chats where both the other user and the current user are a member;
     * 0 for the current user
     */
    group_in_common_count: number,
    /**
     * Number of Telegram Stars that must be paid by the user for each sent message
     * to the current user
     */
    incoming_paid_message_star_count: number,
    /**
     * Number of Telegram Stars that must be paid by the current user for each sent
     * message to the user
     */
    outgoing_paid_message_star_count: number,
    /**
     * Information about verification status of the user provided by a bot; may be
     * null if none or unknown
     */
    bot_verification?: botVerification,
    /**
     * Information about business settings for Telegram Business accounts; may be null
     * if none
     */
    business_info?: businessInfo,
    /** For bots, information about the bot; may be null if the user isn't a bot */
    bot_info?: botInfo,
  |}

  declare export type users = {|
    /** Represents a list of users */
    _: 'users',
    /** Approximate total number of users found */
    total_count: number,
    /** A list of user identifiers */
    user_ids: Array<number>,
  |}

  declare export type foundUsers = {|
    /** Represents a list of found users */
    _: 'foundUsers',
    /** Identifiers of the found users */
    user_ids: Array<number>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type chatAdministrator = {|
    /** Contains information about a chat administrator */
    _: 'chatAdministrator',
    /** User identifier of the administrator */
    user_id: number,
    /** Custom title of the administrator */
    custom_title: string,
    /** True, if the user is the owner of the chat */
    is_owner: boolean,
  |}

  declare export type chatAdministrators = {|
    /** Represents a list of chat administrators */
    _: 'chatAdministrators',
    /** A list of chat administrators */
    administrators: Array<chatAdministrator>,
  |}

  declare export type chatMemberStatusCreator = {|
    /** The user is the owner of the chat and has all the administrator privileges */
    _: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emoji; applicable to supergroups
     * only
     */
    custom_title: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
    /** True, if the user is a member of the chat */
    is_member: boolean,
  |}

  declare export type chatMemberStatusCreator$Input = {|
    /** The user is the owner of the chat and has all the administrator privileges */
    +_: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emoji; applicable to supergroups
     * only
     */
    +custom_title?: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    +is_anonymous?: boolean,
    /** True, if the user is a member of the chat */
    +is_member?: boolean,
  |}

  declare export type chatMemberStatusAdministrator = {|
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    _: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emoji; applicable
     * to supergroups only
     */
    custom_title: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    can_be_edited: boolean,
    /** Rights of the administrator */
    rights: chatAdministratorRights,
  |}

  declare export type chatMemberStatusAdministrator$Input = {|
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    +_: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emoji; applicable
     * to supergroups only
     */
    +custom_title?: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    +can_be_edited?: boolean,
    /** Rights of the administrator */
    +rights?: chatAdministratorRights$Input,
  |}

  declare export type chatMemberStatusMember = {|
    /** The user is a member of the chat, without any additional privileges or restrictions */
    _: 'chatMemberStatusMember',
    /**
     * Point in time (Unix timestamp) when the user will be removed from the chat because
     * of the expired subscription; 0 if never. Ignored in setChatMemberStatus
     */
    member_until_date: number,
  |}

  declare export type chatMemberStatusMember$Input = {|
    /** The user is a member of the chat, without any additional privileges or restrictions */
    +_: 'chatMemberStatusMember',
    /**
     * Point in time (Unix timestamp) when the user will be removed from the chat because
     * of the expired subscription; 0 if never. Ignored in setChatMemberStatus
     */
    +member_until_date?: number,
  |}

  declare export type chatMemberStatusRestricted = {|
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    _: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    is_member: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    restricted_until_date: number,
    /** User permissions in the chat */
    permissions: chatPermissions,
  |}

  declare export type chatMemberStatusRestricted$Input = {|
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    +_: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    +is_member?: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    +restricted_until_date?: number,
    /** User permissions in the chat */
    +permissions?: chatPermissions$Input,
  |}

  declare export type chatMemberStatusLeft = {|
    /** The user or the chat is not a chat member */
    _: 'chatMemberStatusLeft',
  |}

  declare export type chatMemberStatusLeft$Input = {|
    /** The user or the chat is not a chat member */
    +_: 'chatMemberStatusLeft',
  |}

  declare export type chatMemberStatusBanned = {|
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    _: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    banned_until_date: number,
  |}

  declare export type chatMemberStatusBanned$Input = {|
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    +_: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    +banned_until_date?: number,
  |}

  declare export type chatMember = {|
    /** Describes a user or a chat as a member of another chat */
    _: 'chatMember',
    /**
     * Identifier of the chat member. Currently, other chats can be only Left or Banned.
     * Only supergroups and channels can have other chats as Left or Banned members
     * and these chats must be supergroups or channels
     */
    member_id: MessageSender,
    /**
     * Identifier of a user that invited/promoted/banned this member in the chat; 0
     * if unknown
     */
    inviter_user_id: number,
    /**
     * Point in time (Unix timestamp) when the user joined/was promoted/was banned
     * in the chat
     */
    joined_chat_date: number,
    /** Status of the member in the chat */
    status: ChatMemberStatus,
  |}

  declare export type chatMembers = {|
    /** Contains a list of chat members */
    _: 'chatMembers',
    /** Approximate total number of chat members found */
    total_count: number,
    /** A list of chat members */
    members: Array<chatMember>,
  |}

  declare export type chatMembersFilterContacts$Input = {|
    /** Returns contacts of the user */
    +_: 'chatMembersFilterContacts',
  |}

  declare export type chatMembersFilterAdministrators$Input = {|
    /** Returns the owner and administrators */
    +_: 'chatMembersFilterAdministrators',
  |}

  declare export type chatMembersFilterMembers$Input = {|
    /** Returns all chat members, including restricted chat members */
    +_: 'chatMembersFilterMembers',
  |}

  declare export type chatMembersFilterMention$Input = {|
    /** Returns users which can be mentioned in the chat */
    +_: 'chatMembersFilterMention',
    /** If non-zero, the identifier of the current message thread */
    +message_thread_id?: number,
  |}

  declare export type chatMembersFilterRestricted$Input = {|
    /**
     * Returns users under certain restrictions in the chat; can be used only by administrators
     * in a supergroup
     */
    +_: 'chatMembersFilterRestricted',
  |}

  declare export type chatMembersFilterBanned$Input = {|
    /**
     * Returns users banned from the chat; can be used only by administrators in a
     * supergroup or in a channel
     */
    +_: 'chatMembersFilterBanned',
  |}

  declare export type chatMembersFilterBots$Input = {|
    /** Returns bot members of the chat */
    +_: 'chatMembersFilterBots',
  |}

  declare export type supergroupMembersFilterRecent$Input = {|
    /** Returns recently active users in reverse chronological order */
    +_: 'supergroupMembersFilterRecent',
  |}

  declare export type supergroupMembersFilterContacts$Input = {|
    /** Returns contacts of the user, which are members of the supergroup or channel */
    +_: 'supergroupMembersFilterContacts',
    /** Query to search for */
    +query?: string,
  |}

  declare export type supergroupMembersFilterAdministrators$Input = {|
    /** Returns the owner and administrators */
    +_: 'supergroupMembersFilterAdministrators',
  |}

  declare export type supergroupMembersFilterSearch$Input = {|
    /** Used to search for supergroup or channel members via a (string) query */
    +_: 'supergroupMembersFilterSearch',
    /** Query to search for */
    +query?: string,
  |}

  declare export type supergroupMembersFilterRestricted$Input = {|
    /** Returns restricted supergroup members; can be used only by administrators */
    +_: 'supergroupMembersFilterRestricted',
    /** Query to search for */
    +query?: string,
  |}

  declare export type supergroupMembersFilterBanned$Input = {|
    /** Returns users banned from the supergroup or channel; can be used only by administrators */
    +_: 'supergroupMembersFilterBanned',
    /** Query to search for */
    +query?: string,
  |}

  declare export type supergroupMembersFilterMention$Input = {|
    /** Returns users which can be mentioned in the supergroup */
    +_: 'supergroupMembersFilterMention',
    /** Query to search for */
    +query?: string,
    /** If non-zero, the identifier of the current message thread */
    +message_thread_id?: number,
  |}

  declare export type supergroupMembersFilterBots$Input = {|
    /** Returns bot members of the supergroup or channel */
    +_: 'supergroupMembersFilterBots',
  |}

  declare export type chatInviteLink = {|
    /** Contains a chat invite link */
    _: 'chatInviteLink',
    /** Chat invite link */
    invite_link: string,
    /** Name of the link */
    name: string,
    /** User identifier of an administrator created the link */
    creator_user_id: number,
    /** Point in time (Unix timestamp) when the link was created */
    date: number,
    /**
     * Point in time (Unix timestamp) when the link was last edited; 0 if never or
     * unknown
     */
    edit_date: number,
    /** Point in time (Unix timestamp) when the link will expire; 0 if never */
    expiration_date: number,
    /**
     * Information about subscription plan that is applied to the users joining the
     * chat by the link; may be null if the link doesn't require subscription
     */
    subscription_pricing?: starSubscriptionPricing,
    /**
     * The maximum number of members, which can join the chat using the link simultaneously;
     * 0 if not limited. Always 0 if the link requires approval
     */
    member_limit: number,
    /** Number of chat members, which joined the chat using the link */
    member_count: number,
    /**
     * Number of chat members, which joined the chat using the link, but have already
     * left because of expired subscription; for subscription links only
     */
    expired_member_count: number,
    /** Number of pending join requests created using this link */
    pending_join_request_count: number,
    /**
     * True, if the link only creates join request. If true, total number of joining
     * members will be unlimited
     */
    creates_join_request: boolean,
    /**
     * True, if the link is primary. Primary invite link can't have name, expiration
     * date, or usage limit. There is exactly one primary invite link for each administrator
     * with can_invite_users right at a given time
     */
    is_primary: boolean,
    /** True, if the link was revoked */
    is_revoked: boolean,
  |}

  declare export type chatInviteLinks = {|
    /** Contains a list of chat invite links */
    _: 'chatInviteLinks',
    /** Approximate total number of chat invite links found */
    total_count: number,
    /** List of invite links */
    invite_links: Array<chatInviteLink>,
  |}

  declare export type chatInviteLinkCount = {|
    /**
     * Describes a chat administrator with a number of active and revoked chat invite
     * links
     */
    _: 'chatInviteLinkCount',
    /** Administrator's user identifier */
    user_id: number,
    /** Number of active invite links */
    invite_link_count: number,
    /** Number of revoked invite links */
    revoked_invite_link_count: number,
  |}

  declare export type chatInviteLinkCounts = {|
    /** Contains a list of chat invite link counts */
    _: 'chatInviteLinkCounts',
    /** List of invite link counts */
    invite_link_counts: Array<chatInviteLinkCount>,
  |}

  declare export type chatInviteLinkMember = {|
    /** Describes a chat member joined a chat via an invite link */
    _: 'chatInviteLinkMember',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    joined_chat_date: number,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
  |}

  declare export type chatInviteLinkMember$Input = {|
    /** Describes a chat member joined a chat via an invite link */
    +_: 'chatInviteLinkMember',
    /** User identifier */
    +user_id?: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    +joined_chat_date?: number,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    +via_chat_folder_invite_link?: boolean,
    /** User identifier of the chat administrator, approved user join request */
    +approver_user_id?: number,
  |}

  declare export type chatInviteLinkMembers = {|
    /** Contains a list of chat members joined a chat via an invite link */
    _: 'chatInviteLinkMembers',
    /** Approximate total number of chat members found */
    total_count: number,
    /** List of chat members, joined a chat via an invite link */
    members: Array<chatInviteLinkMember>,
  |}

  declare export type inviteLinkChatTypeBasicGroup = {|
    /** The link is an invite link for a basic group */
    _: 'inviteLinkChatTypeBasicGroup',
  |}

  declare export type inviteLinkChatTypeSupergroup = {|
    /** The link is an invite link for a supergroup */
    _: 'inviteLinkChatTypeSupergroup',
  |}

  declare export type inviteLinkChatTypeChannel = {|
    /** The link is an invite link for a channel */
    _: 'inviteLinkChatTypeChannel',
  |}

  declare export type chatInviteLinkSubscriptionInfo = {|
    /**
     * Contains information about subscription plan that must be paid by the user to
     * use a chat invite link
     */
    _: 'chatInviteLinkSubscriptionInfo',
    /**
     * Information about subscription plan that must be paid by the user to use the
     * link
     */
    pricing: starSubscriptionPricing,
    /**
     * True, if the user has already paid for the subscription and can use joinChatByInviteLink
     * to join the subscribed chat again
     */
    can_reuse: boolean,
    /**
     * Identifier of the payment form to use for subscription payment; 0 if the subscription
     * can't be paid
     */
    form_id: string,
  |}

  declare export type chatInviteLinkInfo = {|
    /** Contains information about a chat invite link */
    _: 'chatInviteLinkInfo',
    /**
     * Chat identifier of the invite link; 0 if the user has no access to the chat
     * before joining
     */
    chat_id: number,
    /**
     * If non-zero, the amount of time for which read access to the chat will remain
     * available, in seconds
     */
    accessible_for: number,
    /** Type of the chat */
    type: InviteLinkChatType,
    /** Title of the chat */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Identifier of the accent color for chat title and background of chat photo */
    accent_color_id: number,
    /** Chat description */
    description: string,
    /** Number of members in the chat */
    member_count: number,
    /** User identifiers of some chat members that may be known to the current user */
    member_user_ids: Array<number>,
    /**
     * Information about subscription plan that must be paid by the user to use the
     * link; may be null if the link doesn't require subscription
     */
    subscription_info?: chatInviteLinkSubscriptionInfo,
    /** True, if the link only creates join request */
    creates_join_request: boolean,
    /**
     * True, if the chat is a public supergroup or channel, i.e. it has a username
     * or it is a location-based supergroup
     */
    is_public: boolean,
    /** Information about verification status of the chat; may be null if none */
    verification_status?: verificationStatus,
  |}

  declare export type chatJoinRequest = {|
    /** Describes a user that sent a join request and waits for administrator approval */
    _: 'chatJoinRequest',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    date: number,
    /** A short bio of the user */
    bio: string,
  |}

  declare export type chatJoinRequest$Input = {|
    /** Describes a user that sent a join request and waits for administrator approval */
    +_: 'chatJoinRequest',
    /** User identifier */
    +user_id?: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    +date?: number,
    /** A short bio of the user */
    +bio?: string,
  |}

  declare export type chatJoinRequests = {|
    /** Contains a list of requests to join a chat */
    _: 'chatJoinRequests',
    /** Approximate total number of requests found */
    total_count: number,
    /** List of the requests */
    requests: Array<chatJoinRequest>,
  |}

  declare export type chatJoinRequestsInfo = {|
    /** Contains information about pending join requests for a chat */
    _: 'chatJoinRequestsInfo',
    /** Total number of pending join requests */
    total_count: number,
    /** Identifiers of at most 3 users sent the newest pending join requests */
    user_ids: Array<number>,
  |}

  declare export type basicGroup = {|
    /**
     * Represents a basic group of 0-200 users (must be upgraded to a supergroup to
     * accommodate more than 200 users)
     */
    _: 'basicGroup',
    /** Group identifier */
    id: number,
    /** Number of members in the group */
    member_count: number,
    /** Status of the current user in the group */
    status: ChatMemberStatus,
    /** True, if the group is active */
    is_active: boolean,
    /** Identifier of the supergroup to which this group was upgraded; 0 if none */
    upgraded_to_supergroup_id: number,
  |}

  declare export type basicGroupFullInfo = {|
    /** Contains full information about a basic group */
    _: 'basicGroupFullInfo',
    /**
     * Chat photo; may be null if empty or unknown. If non-null, then it is the same
     * photo as in chat.photo
     */
    photo?: chatPhoto,
    /** Group description. Updated only after the basic group is opened */
    description: string,
    /** User identifier of the creator of the group; 0 if unknown */
    creator_user_id: number,
    /** Group members */
    members: Array<chatMember>,
    /**
     * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers
     * and searchChatMembers for non-administrators after upgrading the basic group
     * to a supergroup
     */
    can_hide_members: boolean,
    /**
     * True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
     * after upgrading the basic group to a supergroup
     */
    can_toggle_aggressive_anti_spam: boolean,
    /**
     * Primary invite link for this group; may be null. For chat administrators with
     * can_invite_users right only. Updated only after the basic group is opened
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
  |}

  declare export type supergroup = {|
    /**
     * Represents a supergroup or channel with zero or more members (subscribers in
     * the case of channels). From the point of view of the system, a channel is a
     * special kind of a supergroup: only administrators can post and see the list
     * of members, and posts from all administrators use the name and photo of the
     * channel instead of individual names and profile photos. Unlike supergroups,
     * channels can have an unlimited number of subscribers
     */
    _: 'supergroup',
    /** Supergroup or channel identifier */
    id: number,
    /** Usernames of the supergroup or channel; may be null */
    usernames?: usernames,
    /**
     * Point in time (Unix timestamp) when the current user joined, or the point in
     * time when the supergroup or channel was created, in case the user is not a member
     */
    date: number,
    /**
     * Status of the current user in the supergroup or channel; custom title will always
     * be empty
     */
    status: ChatMemberStatus,
    /**
     * Number of members in the supergroup or channel; 0 if unknown. Currently, it
     * is guaranteed to be known only if the supergroup or channel was received through
     * getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon,
     * getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats,
     * getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchPublicChats,
     * or in chatFolderInviteLinkInfo.missing_chat_ids, or in userFullInfo.personal_chat_id,
     * or for chats with messages or stories from publicForwards and foundStories
     */
    member_count: number,
    /** Approximate boost level for the chat */
    boost_level: number,
    /**
     * True, if the channel has a discussion group, or the supergroup is the designated
     * discussion group for a channel
     */
    has_linked_chat: boolean,
    /**
     * True, if the supergroup is connected to a location, i.e. the supergroup is a
     * location-based supergroup
     */
    has_location: boolean,
    /**
     * True, if messages sent to the channel contains name of the sender. This field
     * is only applicable to channels
     */
    sign_messages: boolean,
    /**
     * True, if messages sent to the channel have information about the sender user.
     * This field is only applicable to channels
     */
    show_message_sender: boolean,
    /**
     * True, if users need to join the supergroup before they can send messages. Always
     * true for channels and non-discussion supergroups
     */
    join_to_send_messages: boolean,
    /**
     * True, if all users directly joining the supergroup need to be approved by supergroup
     * administrators. Always false for channels and supergroups without username,
     * location, or a linked chat
     */
    join_by_request: boolean,
    /** True, if the slow mode is enabled in the supergroup */
    is_slow_mode_enabled: boolean,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
    /**
     * True, if the supergroup is a broadcast group, i.e. only administrators can send
     * messages and there is no limit on the number of members
     */
    is_broadcast_group: boolean,
    /** True, if the supergroup is a forum with topics */
    is_forum: boolean,
    /**
     * Information about verification status of the supergroup or channel; may be null
     * if none
     */
    verification_status?: verificationStatus,
    /**
     * True, if content of media messages in the supergroup or channel chat must be
     * hidden with 18+ spoiler
     */
    has_sensitive_content: boolean,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this supergroup or channel must be restricted
     */
    restriction_reason: string,
    /**
     * Number of Telegram Stars that must be paid by non-administrator users of the
     * supergroup chat for each sent message
     */
    paid_message_star_count: number,
    /**
     * True, if the supergroup or channel has non-expired stories available to the
     * current user
     */
    has_active_stories: boolean,
    /**
     * True, if the supergroup or channel has unread non-expired stories available
     * to the current user
     */
    has_unread_active_stories: boolean,
  |}

  declare export type supergroupFullInfo = {|
    /** Contains full information about a supergroup or channel */
    _: 'supergroupFullInfo',
    /**
     * Chat photo; may be null if empty or unknown. If non-null, then it is the same
     * photo as in chat.photo
     */
    photo?: chatPhoto,
    /** Supergroup or channel description */
    description: string,
    /** Number of members in the supergroup or channel; 0 if unknown */
    member_count: number,
    /** Number of privileged users in the supergroup or channel; 0 if unknown */
    administrator_count: number,
    /** Number of restricted users in the supergroup; 0 if unknown */
    restricted_count: number,
    /** Number of users banned from chat; 0 if unknown */
    banned_count: number,
    /**
     * Chat identifier of a discussion group for the channel, or a channel, for which
     * the supergroup is the designated discussion group; 0 if none or unknown
     */
    linked_chat_id: number,
    /**
     * Delay between consecutive sent messages for non-administrator supergroup members,
     * in seconds
     */
    slow_mode_delay: number,
    /**
     * Time left before next message can be sent in the supergroup, in seconds. An
     * updateSupergroupFullInfo update is not triggered when value of this field changes,
     * but both new and old values are non-zero
     */
    slow_mode_delay_expires_in: number,
    /**
     * True, if paid messages can be enabled in the supergroup chat; for supergroup
     * only
     */
    can_enable_paid_messages: boolean,
    /** True, if paid reaction can be enabled in the channel chat; for channels only */
    can_enable_paid_reaction: boolean,
    /** True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers */
    can_get_members: boolean,
    /**
     * True, if non-administrators can receive only administrators and bots using getSupergroupMembers
     * or searchChatMembers
     */
    has_hidden_members: boolean,
    /**
     * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers
     * and searchChatMembers for non-administrators
     */
    can_hide_members: boolean,
    /** True, if the supergroup sticker set can be changed */
    can_set_sticker_set: boolean,
    /** True, if the supergroup location can be changed */
    can_set_location: boolean,
    /** True, if the supergroup or channel statistics are available */
    can_get_statistics: boolean,
    /** True, if the supergroup or channel revenue statistics are available */
    can_get_revenue_statistics: boolean,
    /** True, if the supergroup or channel Telegram Star revenue statistics are available */
    can_get_star_revenue_statistics: boolean,
    /**
     * True, if the user can send a gift to the supergroup or channel using sendGift
     * or transferGift
     */
    can_send_gift: boolean,
    /** True, if aggressive anti-spam checks can be enabled or disabled in the supergroup */
    can_toggle_aggressive_anti_spam: boolean,
    /**
     * True, if new chat members will have access to old messages. In public, discussion,
     * of forum groups and all channels, old messages are always available, so this
     * option affects only private non-forum supergroups without a linked chat. The
     * value of this field is only available to chat administrators
     */
    is_all_history_available: boolean,
    /**
     * True, if the chat can have sponsored messages. The value of this field is only
     * available to the owner of the chat
     */
    can_have_sponsored_messages: boolean,
    /**
     * True, if aggressive anti-spam checks are enabled in the supergroup. The value
     * of this field is only available to chat administrators
     */
    has_aggressive_anti_spam_enabled: boolean,
    /**
     * True, if paid media can be sent and forwarded to the channel chat; for channels
     * only
     */
    has_paid_media_allowed: boolean,
    /** True, if the supergroup or channel has pinned stories */
    has_pinned_stories: boolean,
    /**
     * Number of saved to profile gifts for channels without can_post_messages administrator
     * right, otherwise, the total number of received gifts
     */
    gift_count: number,
    /** Number of times the current user boosted the supergroup or channel */
    my_boost_count: number,
    /**
     * Number of times the supergroup must be boosted by a user to ignore slow mode
     * and chat permission restrictions; 0 if unspecified
     */
    unrestrict_boost_count: number,
    /**
     * Identifier of the supergroup sticker set that must be shown before user sticker
     * sets; 0 if none
     */
    sticker_set_id: string,
    /**
     * Identifier of the custom emoji sticker set that can be used in the supergroup
     * without Telegram Premium subscription; 0 if none
     */
    custom_emoji_sticker_set_id: string,
    /** Location to which the supergroup is connected; may be null if none */
    location?: chatLocation,
    /**
     * Primary invite link for the chat; may be null. For chat administrators with
     * can_invite_users right only
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
    /**
     * Information about verification status of the supergroup or the channel provided
     * by a bot; may be null if none or unknown
     */
    bot_verification?: botVerification,
    /** Identifier of the basic group from which supergroup was upgraded; 0 if none */
    upgraded_from_basic_group_id: number,
    /**
     * Identifier of the last message in the basic group from which supergroup was
     * upgraded; 0 if none
     */
    upgraded_from_max_message_id: number,
  |}

  declare export type secretChatStatePending = {|
    /** The secret chat is not yet created; waiting for the other user to get online */
    _: 'secretChatStatePending',
  |}

  declare export type secretChatStateReady = {|
    /** The secret chat is ready to use */
    _: 'secretChatStateReady',
  |}

  declare export type secretChatStateClosed = {|
    /** The secret chat is closed */
    _: 'secretChatStateClosed',
  |}

  declare export type secretChat = {|
    /** Represents a secret chat */
    _: 'secretChat',
    /** Secret chat identifier */
    id: number,
    /** Identifier of the chat partner */
    user_id: number,
    /** State of the secret chat */
    state: SecretChatState,
    /** True, if the chat was created by the current user; false otherwise */
    is_outbound: boolean,
    /**
     * Hash of the currently used key for comparison with the hash of the chat partner's
     * key. This is a string of 36 little-endian bytes, which must be split into groups
     * of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775,
     * and 2F99C9. The pixels must be used to make a 12x12 square image filled from
     * left to right, top to bottom. Alternatively, the first 32 bytes of the hash
     * can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
     */
    key_hash: string /* base64 */,
    /**
     * Secret chat layer; determines features supported by the chat partner's application.
     * Nested text entities and underline and strikethrough entities are supported
     * if the layer >= 101, files bigger than 2000MB are supported if the layer >=
     * 143, spoiler and custom emoji text entities are supported if the layer >= 144
     */
    layer: number,
  |}

  declare export type messageSenderUser = {|
    /** The message was sent by a known user */
    _: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    user_id: number,
  |}

  declare export type messageSenderUser$Input = {|
    /** The message was sent by a known user */
    +_: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    +user_id?: number,
  |}

  declare export type messageSenderChat = {|
    /** The message was sent on behalf of a chat */
    _: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    chat_id: number,
  |}

  declare export type messageSenderChat$Input = {|
    /** The message was sent on behalf of a chat */
    +_: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    +chat_id?: number,
  |}

  declare export type messageSenders = {|
    /** Represents a list of message senders */
    _: 'messageSenders',
    /** Approximate total number of messages senders found */
    total_count: number,
    /** List of message senders */
    senders: Array<MessageSender>,
  |}

  declare export type chatMessageSender = {|
    /** Represents a message sender, which can be used to send messages in a chat */
    _: 'chatMessageSender',
    /** The message sender */
    sender: MessageSender,
    /** True, if Telegram Premium is needed to use the message sender */
    needs_premium: boolean,
  |}

  declare export type chatMessageSenders = {|
    /**
     * Represents a list of message senders, which can be used to send messages in
     * a chat
     */
    _: 'chatMessageSenders',
    /** List of available message senders */
    senders: Array<chatMessageSender>,
  |}

  declare export type messageReadDateRead = {|
    /** Contains read date of the message */
    _: 'messageReadDateRead',
    /** Point in time (Unix timestamp) when the message was read by the other user */
    read_date: number,
  |}

  declare export type messageReadDateUnread = {|
    /** The message is unread yet */
    _: 'messageReadDateUnread',
  |}

  declare export type messageReadDateTooOld = {|
    /** The message is too old to get read date */
    _: 'messageReadDateTooOld',
  |}

  declare export type messageReadDateUserPrivacyRestricted = {|
    /** The read date is unknown due to privacy settings of the other user */
    _: 'messageReadDateUserPrivacyRestricted',
  |}

  declare export type messageReadDateMyPrivacyRestricted = {|
    /**
     * The read date is unknown due to privacy settings of the current user, but will
     * be known if the user subscribes to Telegram Premium
     */
    _: 'messageReadDateMyPrivacyRestricted',
  |}

  declare export type messageViewer = {|
    /** Represents a viewer of a message */
    _: 'messageViewer',
    /** User identifier of the viewer */
    user_id: number,
    /** Approximate point in time (Unix timestamp) when the message was viewed */
    view_date: number,
  |}

  declare export type messageViewers = {|
    /** Represents a list of message viewers */
    _: 'messageViewers',
    /** List of message viewers */
    viewers: Array<messageViewer>,
  |}

  declare export type messageOriginUser = {|
    /** The message was originally sent by a known user */
    _: 'messageOriginUser',
    /** Identifier of the user that originally sent the message */
    sender_user_id: number,
  |}

  declare export type messageOriginHiddenUser = {|
    /**
     * The message was originally sent by a user, which is hidden by their privacy
     * settings
     */
    _: 'messageOriginHiddenUser',
    /** Name of the sender */
    sender_name: string,
  |}

  declare export type messageOriginChat = {|
    /** The message was originally sent on behalf of a chat */
    _: 'messageOriginChat',
    /** Identifier of the chat that originally sent the message */
    sender_chat_id: number,
    /**
     * For messages originally sent by an anonymous chat administrator, original message
     * author signature
     */
    author_signature: string,
  |}

  declare export type messageOriginChannel = {|
    /** The message was originally a post in a channel */
    _: 'messageOriginChannel',
    /** Identifier of the channel chat to which the message was originally sent */
    chat_id: number,
    /** Message identifier of the original message */
    message_id: number,
    /** Original post author signature */
    author_signature: string,
  |}

  declare export type forwardSource = {|
    /**
     * Contains information about the last message from which a new message was forwarded
     * last time
     */
    _: 'forwardSource',
    /**
     * Identifier of the chat to which the message that was forwarded belonged; may
     * be 0 if unknown
     */
    chat_id: number,
    /** Identifier of the message; may be 0 if unknown */
    message_id: number,
    /**
     * Identifier of the sender of the message; may be null if unknown or the new message
     * was forwarded not to Saved Messages
     */
    sender_id?: MessageSender,
    /** Name of the sender of the message if the sender is hidden by their privacy settings */
    sender_name: string,
    /** Point in time (Unix timestamp) when the message is sent; 0 if unknown */
    date: number,
    /**
     * True, if the message that was forwarded is outgoing; always false if sender
     * is unknown
     */
    is_outgoing: boolean,
  |}

  declare export type reactionTypeEmoji = {|
    /** A reaction with an emoji */
    _: 'reactionTypeEmoji',
    /** Text representation of the reaction */
    emoji: string,
  |}

  declare export type reactionTypeEmoji$Input = {|
    /** A reaction with an emoji */
    +_: 'reactionTypeEmoji',
    /** Text representation of the reaction */
    +emoji?: string,
  |}

  declare export type reactionTypeCustomEmoji = {|
    /** A reaction with a custom emoji */
    _: 'reactionTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    custom_emoji_id: string,
  |}

  declare export type reactionTypeCustomEmoji$Input = {|
    /** A reaction with a custom emoji */
    +_: 'reactionTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    +custom_emoji_id?: number | string,
  |}

  declare export type reactionTypePaid = {|
    /** The paid reaction in a channel chat */
    _: 'reactionTypePaid',
  |}

  declare export type reactionTypePaid$Input = {|
    /** The paid reaction in a channel chat */
    +_: 'reactionTypePaid',
  |}

  declare export type paidReactionTypeRegular = {|
    /** A paid reaction on behalf of the current user */
    _: 'paidReactionTypeRegular',
  |}

  declare export type paidReactionTypeRegular$Input = {|
    /** A paid reaction on behalf of the current user */
    +_: 'paidReactionTypeRegular',
  |}

  declare export type paidReactionTypeAnonymous = {|
    /** An anonymous paid reaction */
    _: 'paidReactionTypeAnonymous',
  |}

  declare export type paidReactionTypeAnonymous$Input = {|
    /** An anonymous paid reaction */
    +_: 'paidReactionTypeAnonymous',
  |}

  declare export type paidReactionTypeChat = {|
    /** A paid reaction on behalf of an owned chat */
    _: 'paidReactionTypeChat',
    /** Identifier of the chat */
    chat_id: number,
  |}

  declare export type paidReactionTypeChat$Input = {|
    /** A paid reaction on behalf of an owned chat */
    +_: 'paidReactionTypeChat',
    /** Identifier of the chat */
    +chat_id?: number,
  |}

  declare export type paidReactor = {|
    /** Contains information about a user that added paid reactions */
    _: 'paidReactor',
    /**
     * Identifier of the user or chat that added the reactions; may be null for anonymous
     * reactors that aren't the current user
     */
    sender_id?: MessageSender,
    /** Number of Telegram Stars added */
    star_count: number,
    /**
     * True, if the reactor is one of the most active reactors; may be false if the
     * reactor is the current user
     */
    is_top: boolean,
    /** True, if the paid reaction was added by the current user */
    is_me: boolean,
    /** True, if the reactor is anonymous */
    is_anonymous: boolean,
  |}

  declare export type messageForwardInfo = {|
    /** Contains information about a forwarded message */
    _: 'messageForwardInfo',
    /** Origin of the forwarded message */
    origin: MessageOrigin,
    /** Point in time (Unix timestamp) when the message was originally sent */
    date: number,
    /**
     * For messages forwarded to the chat with the current user (Saved Messages), to
     * the Replies bot chat, or to the channel's discussion group, information about
     * the source message from which the message was forwarded last time; may be null
     * for other forwards or if unknown
     */
    source?: forwardSource,
    /** The type of public service announcement for the forwarded message */
    public_service_announcement_type: string,
  |}

  declare export type messageImportInfo = {|
    /** Contains information about a message created with importMessages */
    _: 'messageImportInfo',
    /** Name of the original sender */
    sender_name: string,
    /** Point in time (Unix timestamp) when the message was originally sent */
    date: number,
  |}

  declare export type messageReplyInfo = {|
    /** Contains information about replies to a message */
    _: 'messageReplyInfo',
    /** Number of times the message was directly or indirectly replied */
    reply_count: number,
    /**
     * Identifiers of at most 3 recent repliers to the message; available in channels
     * with a discussion supergroup. The users and chats are expected to be inaccessible:
     * only their photo and name will be available
     */
    recent_replier_ids: Array<MessageSender>,
    /** Identifier of the last read incoming reply to the message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing reply to the message */
    last_read_outbox_message_id: number,
    /** Identifier of the last reply to the message */
    last_message_id: number,
  |}

  declare export type messageReaction = {|
    /** Contains information about a reaction to a message */
    _: 'messageReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Number of times the reaction was added */
    total_count: number,
    /** True, if the reaction is chosen by the current user */
    is_chosen: boolean,
    /**
     * Identifier of the message sender used by the current user to add the reaction;
     * may be null if unknown or the reaction isn't chosen
     */
    used_sender_id?: MessageSender,
    /**
     * Identifiers of at most 3 recent message senders, added the reaction; available
     * in private, basic group and supergroup chats
     */
    recent_sender_ids: Array<MessageSender>,
  |}

  declare export type messageReactions = {|
    /** Contains a list of reactions added to a message */
    _: 'messageReactions',
    /** List of added reactions */
    reactions: Array<messageReaction>,
    /**
     * True, if the reactions are tags and Telegram Premium users can filter messages
     * by them
     */
    are_tags: boolean,
    /** Information about top users that added the paid reaction */
    paid_reactors: Array<paidReactor>,
    /** True, if the list of added reactions is available using getMessageAddedReactions */
    can_get_added_reactions: boolean,
  |}

  declare export type messageInteractionInfo = {|
    /** Contains information about interactions with a message */
    _: 'messageInteractionInfo',
    /** Number of times the message was viewed */
    view_count: number,
    /** Number of times the message was forwarded */
    forward_count: number,
    /**
     * Information about direct or indirect replies to the message; may be null. Currently,
     * available only in channels with a discussion supergroup and discussion supergroups
     * for messages, which are not replies itself
     */
    reply_info?: messageReplyInfo,
    /** The list of reactions or tags added to the message; may be null */
    reactions?: messageReactions,
  |}

  declare export type unreadReaction = {|
    /** Contains information about an unread reaction to a message */
    _: 'unreadReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Identifier of the sender, added the reaction */
    sender_id: MessageSender,
    /** True, if the reaction was added with a big animation */
    is_big: boolean,
  |}

  declare export type messageEffectTypeEmojiReaction = {|
    /** An effect from an emoji reaction */
    _: 'messageEffectTypeEmojiReaction',
    /** Select animation for the effect in TGS format */
    select_animation: sticker,
    /** Effect animation for the effect in TGS format */
    effect_animation: sticker,
  |}

  declare export type messageEffectTypePremiumSticker = {|
    /** An effect from a premium sticker */
    _: 'messageEffectTypePremiumSticker',
    /** The premium sticker. The effect can be found at sticker.full_type.premium_animation */
    sticker: sticker,
  |}

  declare export type messageEffect = {|
    /** Contains information about an effect added to a message */
    _: 'messageEffect',
    /** Unique identifier of the effect */
    id: string,
    /** Static icon for the effect in WEBP format; may be null if none */
    static_icon?: sticker,
    /** Emoji corresponding to the effect that can be used if static icon isn't available */
    emoji: string,
    /** True, if Telegram Premium subscription is required to use the effect */
    is_premium: boolean,
    /** Type of the effect */
    type: MessageEffectType,
  |}

  declare export type messageSendingStatePending = {|
    /** The message is being sent now, but has not yet been delivered to the server */
    _: 'messageSendingStatePending',
    /** Non-persistent message sending identifier, specified by the application */
    sending_id: number,
  |}

  declare export type messageSendingStateFailed = {|
    /** The message failed to be sent */
    _: 'messageSendingStateFailed',
    /** The cause of the message sending failure */
    error: error,
    /** True, if the message can be re-sent using resendMessages or readdQuickReplyShortcutMessages */
    can_retry: boolean,
    /** True, if the message can be re-sent only on behalf of a different sender */
    need_another_sender: boolean,
    /**
     * True, if the message can be re-sent only if another quote is chosen in the message
     * that is replied by the given message
     */
    need_another_reply_quote: boolean,
    /**
     * True, if the message can be re-sent only if the message to be replied is removed.
     * This will be done automatically by resendMessages
     */
    need_drop_reply: boolean,
    /**
     * The number of Telegram Stars that must be paid to send the message; 0 if the
     * current amount is correct
     */
    required_paid_message_star_count: number,
    /**
     * Time left before the message can be re-sent, in seconds. No update is sent when
     * this field changes
     */
    retry_after: number,
  |}

  declare export type textQuote = {|
    /** Describes manually or automatically chosen quote from another message */
    _: 'textQuote',
    /**
     * Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and
     * CustomEmoji entities can be present in the text
     */
    text: formattedText,
    /**
     * Approximate quote position in the original message in UTF-16 code units as specified
     * by the message sender
     */
    position: number,
    /** True, if the quote was manually chosen by the message sender */
    is_manual: boolean,
  |}

  declare export type inputTextQuote = {|
    /** Describes manually chosen quote from another message */
    _: 'inputTextQuote',
    /**
     * Text of the quote; 0-getOption("message_reply_quote_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities
     * are allowed to be kept and must be kept in the quote
     */
    text: formattedText,
    /** Quote position in the original message in UTF-16 code units */
    position: number,
  |}

  declare export type inputTextQuote$Input = {|
    /** Describes manually chosen quote from another message */
    +_: 'inputTextQuote',
    /**
     * Text of the quote; 0-getOption("message_reply_quote_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities
     * are allowed to be kept and must be kept in the quote
     */
    +text?: formattedText$Input,
    /** Quote position in the original message in UTF-16 code units */
    +position?: number,
  |}

  declare export type messageReplyToMessage = {|
    /** Describes a message replied by a given message */
    _: 'messageReplyToMessage',
    /**
     * The identifier of the chat to which the message belongs; may be 0 if the replied
     * message is in unknown chat
     */
    chat_id: number,
    /**
     * The identifier of the message; may be 0 if the replied message is in unknown
     * chat
     */
    message_id: number,
    /** Chosen quote from the replied message; may be null if none */
    quote?: textQuote,
    /**
     * Information about origin of the message if the message was from another chat
     * or topic; may be null for messages from the same chat
     */
    origin?: MessageOrigin,
    /**
     * Point in time (Unix timestamp) when the message was sent if the message was
     * from another chat or topic; 0 for messages from the same chat
     */
    origin_send_date: number,
    /**
     * Media content of the message if the message was from another chat or topic;
     * may be null for messages from the same chat and messages without media. Can
     * be only one of the following types: messageAnimation, messageAudio, messageContact,
     * messageDice, messageDocument, messageGame, messageGiveaway, messageGiveawayWinners,
     * messageInvoice, messageLocation, messagePaidMedia, messagePhoto, messagePoll,
     * messageSticker, messageStory, messageText (for link preview), messageVenue,
     * messageVideo, messageVideoNote, or messageVoiceNote
     */
    content?: MessageContent,
  |}

  declare export type messageReplyToStory = {|
    /** Describes a story replied by a given message */
    _: 'messageReplyToStory',
    /** The identifier of the sender of the story */
    story_sender_chat_id: number,
    /** The identifier of the story */
    story_id: number,
  |}

  declare export type inputMessageReplyToMessage = {|
    /** Describes a message to be replied in the same chat and forum topic */
    _: 'inputMessageReplyToMessage',
    /**
     * The identifier of the message to be replied in the same chat and forum topic.
     * A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
     */
    message_id: number,
    /**
     * Quote from the message to be replied; pass null if none. Must always be null
     * for replies in secret chats
     */
    quote: inputTextQuote,
  |}

  declare export type inputMessageReplyToMessage$Input = {|
    /** Describes a message to be replied in the same chat and forum topic */
    +_: 'inputMessageReplyToMessage',
    /**
     * The identifier of the message to be replied in the same chat and forum topic.
     * A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
     */
    +message_id?: number,
    /**
     * Quote from the message to be replied; pass null if none. Must always be null
     * for replies in secret chats
     */
    +quote?: inputTextQuote$Input,
  |}

  declare export type inputMessageReplyToExternalMessage = {|
    /**
     * Describes a message to be replied that is from a different chat or a forum topic;
     * not supported in secret chats
     */
    _: 'inputMessageReplyToExternalMessage',
    /** The identifier of the chat to which the message to be replied belongs */
    chat_id: number,
    /**
     * The identifier of the message to be replied in the specified chat. A message
     * can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
     */
    message_id: number,
    /** Quote from the message to be replied; pass null if none */
    quote: inputTextQuote,
  |}

  declare export type inputMessageReplyToExternalMessage$Input = {|
    /**
     * Describes a message to be replied that is from a different chat or a forum topic;
     * not supported in secret chats
     */
    +_: 'inputMessageReplyToExternalMessage',
    /** The identifier of the chat to which the message to be replied belongs */
    +chat_id?: number,
    /**
     * The identifier of the message to be replied in the specified chat. A message
     * can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
     */
    +message_id?: number,
    /** Quote from the message to be replied; pass null if none */
    +quote?: inputTextQuote$Input,
  |}

  declare export type inputMessageReplyToStory = {|
    /** Describes a story to be replied */
    _: 'inputMessageReplyToStory',
    /**
     * The identifier of the sender of the story. Currently, stories can be replied
     * only in the sender's chat and channel stories can't be replied
     */
    story_sender_chat_id: number,
    /** The identifier of the story */
    story_id: number,
  |}

  declare export type inputMessageReplyToStory$Input = {|
    /** Describes a story to be replied */
    +_: 'inputMessageReplyToStory',
    /**
     * The identifier of the sender of the story. Currently, stories can be replied
     * only in the sender's chat and channel stories can't be replied
     */
    +story_sender_chat_id?: number,
    /** The identifier of the story */
    +story_id?: number,
  |}

  declare export type factCheck = {|
    /** Describes a fact-check added to the message by an independent checker */
    _: 'factCheck',
    /** Text of the fact-check */
    text: formattedText,
    /**
     * A two-letter ISO 3166-1 alpha-2 country code of the country for which the fact-check
     * is shown
     */
    country_code: string,
  |}

  declare export type message = {|
    /** Describes a message */
    _: 'message',
    /** Message identifier; unique for the chat to which the message belongs */
    id: number,
    /** Identifier of the sender of the message */
    sender_id: MessageSender,
    /** Chat identifier */
    chat_id: number,
    /**
     * The sending state of the message; may be null if the message isn't being sent
     * and didn't fail to be sent
     */
    sending_state?: MessageSendingState,
    /** The scheduling state of the message; may be null if the message isn't scheduled */
    scheduling_state?: MessageSchedulingState,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** True, if the message is pinned */
    is_pinned: boolean,
    /**
     * True, if the message was sent because of a scheduled action by the message sender,
     * for example, as away, or greeting service message
     */
    is_from_offline: boolean,
    /**
     * True, if content of the message can be saved locally or copied using inputMessageForwarded
     * or forwardMessages with copy options
     */
    can_be_saved: boolean,
    /**
     * True, if media timestamp entities refers to a media in this message as opposed
     * to a media in the replied message
     */
    has_timestamped_media: boolean,
    /**
     * True, if the message is a channel post. All messages to channels are channel
     * posts, all other messages are not channel posts
     */
    is_channel_post: boolean,
    /** True, if the message is a forum topic message */
    is_topic_message: boolean,
    /** True, if the message contains an unread mention for the current user */
    contains_unread_mention: boolean,
    /** Point in time (Unix timestamp) when the message was sent; 0 for scheduled messages */
    date: number,
    /**
     * Point in time (Unix timestamp) when the message was last edited; 0 for scheduled
     * messages
     */
    edit_date: number,
    /** Information about the initial message sender; may be null if none or unknown */
    forward_info?: messageForwardInfo,
    /**
     * Information about the initial message for messages created with importMessages;
     * may be null if the message isn't imported
     */
    import_info?: messageImportInfo,
    /** Information about interactions with the message; may be null if none */
    interaction_info?: messageInteractionInfo,
    /** Information about unread reactions added to the message */
    unread_reactions: Array<unreadReaction>,
    /** Information about fact-check added to the message; may be null if none */
    fact_check?: factCheck,
    /**
     * Information about the message or the story this message is replying to; may
     * be null if none
     */
    reply_to?: MessageReplyTo,
    /**
     * If non-zero, the identifier of the message thread the message belongs to; unique
     * within the chat to which the message belongs
     */
    message_thread_id: number,
    /**
     * Identifier of the Saved Messages topic for the message; 0 for messages not from
     * Saved Messages
     */
    saved_messages_topic_id: number,
    /** The message's self-destruct type; may be null if none */
    self_destruct_type?: MessageSelfDestructType,
    /**
     * Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction
     * isn't scheduled yet
     */
    self_destruct_in: number,
    /**
     * Time left before the message will be automatically deleted by message_auto_delete_time
     * setting of the chat, in seconds; 0 if never
     */
    auto_delete_in: number,
    /**
     * If non-zero, the user identifier of the inline bot through which this message
     * was sent
     */
    via_bot_user_id: number,
    /** If non-zero, the user identifier of the business bot that sent this message */
    sender_business_bot_user_id: number,
    /**
     * Number of times the sender of the message boosted the supergroup at the time
     * the message was sent; 0 if none or unknown. For messages sent by the current
     * user, supergroupFullInfo.my_boost_count must be used instead
     */
    sender_boost_count: number,
    /** The number of Telegram Stars the sender paid to send the message */
    paid_message_star_count: number,
    /** For channel posts and anonymous group messages, optional author signature */
    author_signature: string,
    /**
     * Unique identifier of an album this message belongs to; 0 if none. Only audios,
     * documents, photos and videos can be grouped together in albums
     */
    media_album_id: string,
    /** Unique identifier of the effect added to the message; 0 if none */
    effect_id: string,
    /** True, if media content of the message must be hidden with 18+ spoiler */
    has_sensitive_content: boolean,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this message must be restricted
     */
    restriction_reason: string,
    /** Content of the message */
    content: MessageContent,
    /** Reply markup for the message; may be null if none */
    reply_markup?: ReplyMarkup,
  |}

  declare export type messages = {|
    /** Contains a list of messages */
    _: 'messages',
    /** Approximate total number of messages found */
    total_count: number,
    /** List of messages; messages may be null */
    messages: Array<message | null>,
  |}

  declare export type foundMessages = {|
    /** Contains a list of messages found by a search */
    _: 'foundMessages',
    /** Approximate total number of messages found; -1 if unknown */
    total_count: number,
    /** List of messages */
    messages: Array<message>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type foundChatMessages = {|
    /** Contains a list of messages found by a search in a given chat */
    _: 'foundChatMessages',
    /** Approximate total number of messages found; -1 if unknown */
    total_count: number,
    /** List of messages */
    messages: Array<message>,
    /** The offset for the next request. If 0, there are no more results */
    next_from_message_id: number,
  |}

  declare export type messagePosition = {|
    /** Contains information about a message in a specific position */
    _: 'messagePosition',
    /** 0-based message position in the full list of suitable messages */
    position: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was sent */
    date: number,
  |}

  declare export type messagePositions = {|
    /** Contains a list of message positions */
    _: 'messagePositions',
    /** Total number of messages found */
    total_count: number,
    /** List of message positions */
    positions: Array<messagePosition>,
  |}

  declare export type messageCalendarDay = {|
    /** Contains information about found messages sent on a specific day */
    _: 'messageCalendarDay',
    /** Total number of found messages sent on the day */
    total_count: number,
    /** First message sent on the day */
    message: message,
  |}

  declare export type messageCalendar = {|
    /**
     * Contains information about found messages, split by days according to the option
     * "utc_time_offset"
     */
    _: 'messageCalendar',
    /** Total number of found messages */
    total_count: number,
    /** Information about messages sent */
    days: Array<messageCalendarDay>,
  |}

  declare export type businessMessage = {|
    /** Describes a message from a business account as received by a bot */
    _: 'businessMessage',
    /** The message */
    message: message,
    /** Message that is replied by the message in the same chat; may be null if none */
    reply_to_message?: message,
  |}

  declare export type businessMessages = {|
    /** Contains a list of messages from a business account as received by a bot */
    _: 'businessMessages',
    /** List of business messages */
    messages: Array<businessMessage>,
  |}

  declare export type messageSourceChatHistory$Input = {|
    /** The message is from a chat history */
    +_: 'messageSourceChatHistory',
  |}

  declare export type messageSourceMessageThreadHistory$Input = {|
    /** The message is from a message thread history */
    +_: 'messageSourceMessageThreadHistory',
  |}

  declare export type messageSourceForumTopicHistory$Input = {|
    /** The message is from a forum topic history */
    +_: 'messageSourceForumTopicHistory',
  |}

  declare export type messageSourceHistoryPreview$Input = {|
    /** The message is from chat, message thread or forum topic history preview */
    +_: 'messageSourceHistoryPreview',
  |}

  declare export type messageSourceChatList$Input = {|
    /** The message is from a chat list or a forum topic list */
    +_: 'messageSourceChatList',
  |}

  declare export type messageSourceSearch$Input = {|
    /**
     * The message is from search results, including file downloads, local file list,
     * outgoing document messages, calendar
     */
    +_: 'messageSourceSearch',
  |}

  declare export type messageSourceChatEventLog$Input = {|
    /** The message is from a chat event log */
    +_: 'messageSourceChatEventLog',
  |}

  declare export type messageSourceNotification$Input = {|
    /** The message is from a notification */
    +_: 'messageSourceNotification',
  |}

  declare export type messageSourceScreenshot$Input = {|
    /**
     * The message was screenshotted; the source must be used only if the message content
     * was visible during the screenshot
     */
    +_: 'messageSourceScreenshot',
  |}

  declare export type messageSourceOther$Input = {|
    /** The message is from some other source */
    +_: 'messageSourceOther',
  |}

  declare export type messageSponsor = {|
    /** Information about the sponsor of a message */
    _: 'messageSponsor',
    /** URL of the sponsor to be opened when the message is clicked */
    url: string,
    /** Photo of the sponsor; may be null if must not be shown */
    photo?: photo,
    /**
     * Additional optional information about the sponsor to be shown along with the
     * message
     */
    info: string,
  |}

  declare export type sponsoredMessage = {|
    /** Describes a sponsored message */
    _: 'sponsoredMessage',
    /**
     * Message identifier; unique for the chat to which the sponsored message belongs
     * among both ordinary and sponsored messages
     */
    message_id: number,
    /** True, if the message needs to be labeled as "recommended" instead of "sponsored" */
    is_recommended: boolean,
    /** True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage */
    can_be_reported: boolean,
    /**
     * Content of the message. Currently, can be only of the types messageText, messageAnimation,
     * messagePhoto, or messageVideo. Video messages can be viewed fullscreen
     */
    content: MessageContent,
    /** Information about the sponsor of the message */
    sponsor: messageSponsor,
    /** Title of the sponsored message */
    title: string,
    /** Text for the message action button */
    button_text: string,
    /** Identifier of the accent color for title, button text and message background */
    accent_color_id: number,
    /** Identifier of a custom emoji to be shown on the message background; 0 if none */
    background_custom_emoji_id: string,
    /**
     * If non-empty, additional information about the sponsored message to be shown
     * along with the message
     */
    additional_info: string,
  |}

  declare export type sponsoredMessages = {|
    /** Contains a list of sponsored messages */
    _: 'sponsoredMessages',
    /** List of sponsored messages */
    messages: Array<sponsoredMessage>,
    /**
     * The minimum number of messages between shown sponsored messages, or 0 if only
     * one sponsored message must be shown after all ordinary messages
     */
    messages_between: number,
  |}

  declare export type reportOption = {|
    /** Describes an option to report an entity to Telegram */
    _: 'reportOption',
    /** Unique identifier of the option */
    id: string /* base64 */,
    /** Text of the option */
    text: string,
  |}

  declare export type reportChatSponsoredMessageResultOk = {|
    /** The message was reported successfully */
    _: 'reportChatSponsoredMessageResultOk',
  |}

  declare export type reportChatSponsoredMessageResultFailed = {|
    /** The sponsored message is too old or not found */
    _: 'reportChatSponsoredMessageResultFailed',
  |}

  declare export type reportChatSponsoredMessageResultOptionRequired = {|
    /**
     * The user must choose an option to report the message and repeat request with
     * the chosen option
     */
    _: 'reportChatSponsoredMessageResultOptionRequired',
    /** Title for the option choice */
    title: string,
    /** List of available options */
    options: Array<reportOption>,
  |}

  declare export type reportChatSponsoredMessageResultAdsHidden = {|
    /** Sponsored messages were hidden for the user in all chats */
    _: 'reportChatSponsoredMessageResultAdsHidden',
  |}

  declare export type reportChatSponsoredMessageResultPremiumRequired = {|
    /**
     * The user asked to hide sponsored messages, but Telegram Premium is required
     * for this
     */
    _: 'reportChatSponsoredMessageResultPremiumRequired',
  |}

  declare export type fileDownload = {|
    /** Describes a file added to file download list */
    _: 'fileDownload',
    /** File identifier */
    file_id: number,
    /** The message with the file */
    message: message,
    /** Point in time (Unix timestamp) when the file was added to the download list */
    add_date: number,
    /**
     * Point in time (Unix timestamp) when the file downloading was completed; 0 if
     * the file downloading isn't completed
     */
    complete_date: number,
    /** True, if downloading of the file is paused */
    is_paused: boolean,
  |}

  declare export type downloadedFileCounts = {|
    /** Contains number of being downloaded and recently downloaded files found */
    _: 'downloadedFileCounts',
    /** Number of active file downloads found, including paused */
    active_count: number,
    /** Number of paused file downloads found */
    paused_count: number,
    /** Number of completed file downloads found */
    completed_count: number,
  |}

  declare export type foundFileDownloads = {|
    /** Contains a list of downloaded files, found by a search */
    _: 'foundFileDownloads',
    /** Total number of suitable files, ignoring offset */
    total_counts: downloadedFileCounts,
    /** The list of files */
    files: Array<fileDownload>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type notificationSettingsScopePrivateChats = {|
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    _: 'notificationSettingsScopePrivateChats',
  |}

  declare export type notificationSettingsScopePrivateChats$Input = {|
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    +_: 'notificationSettingsScopePrivateChats',
  |}

  declare export type notificationSettingsScopeGroupChats = {|
    /**
     * Notification settings applied to all basic group and supergroup chats when the
     * corresponding chat setting has a default value
     */
    _: 'notificationSettingsScopeGroupChats',
  |}

  declare export type notificationSettingsScopeGroupChats$Input = {|
    /**
     * Notification settings applied to all basic group and supergroup chats when the
     * corresponding chat setting has a default value
     */
    +_: 'notificationSettingsScopeGroupChats',
  |}

  declare export type notificationSettingsScopeChannelChats = {|
    /**
     * Notification settings applied to all channel chats when the corresponding chat
     * setting has a default value
     */
    _: 'notificationSettingsScopeChannelChats',
  |}

  declare export type notificationSettingsScopeChannelChats$Input = {|
    /**
     * Notification settings applied to all channel chats when the corresponding chat
     * setting has a default value
     */
    +_: 'notificationSettingsScopeChannelChats',
  |}

  declare export type chatNotificationSettings = {|
    /** Contains information about notification settings for a chat or a forum topic */
    _: 'chatNotificationSettings',
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of mute_for
     */
    use_default_mute_for: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of sound_id
     */
    use_default_sound: boolean,
    /**
     * Identifier of the notification sound to be played for messages; 0 if sound is
     * disabled
     */
    sound_id: string,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of show_preview
     */
    use_default_show_preview: boolean,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /** If true, the value for the relevant type of chat is used instead of mute_stories */
    use_default_mute_stories: boolean,
    /** True, if story notifications are disabled for the chat */
    mute_stories: boolean,
    /** If true, the value for the relevant type of chat is used instead of story_sound_id */
    use_default_story_sound: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    story_sound_id: string,
    /** If true, the value for the relevant type of chat is used instead of show_story_sender */
    use_default_show_story_sender: boolean,
    /** True, if the sender of stories must be displayed in notifications */
    show_story_sender: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_pinned_message_notifications
     */
    use_default_disable_pinned_message_notifications: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_mention_notifications
     */
    use_default_disable_mention_notifications: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  |}

  declare export type chatNotificationSettings$Input = {|
    /** Contains information about notification settings for a chat or a forum topic */
    +_: 'chatNotificationSettings',
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of mute_for
     */
    +use_default_mute_for?: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    +mute_for?: number,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of sound_id
     */
    +use_default_sound?: boolean,
    /**
     * Identifier of the notification sound to be played for messages; 0 if sound is
     * disabled
     */
    +sound_id?: number | string,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of show_preview
     */
    +use_default_show_preview?: boolean,
    /** True, if message content must be displayed in notifications */
    +show_preview?: boolean,
    /** If true, the value for the relevant type of chat is used instead of mute_stories */
    +use_default_mute_stories?: boolean,
    /** True, if story notifications are disabled for the chat */
    +mute_stories?: boolean,
    /** If true, the value for the relevant type of chat is used instead of story_sound_id */
    +use_default_story_sound?: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    +story_sound_id?: number | string,
    /** If true, the value for the relevant type of chat is used instead of show_story_sender */
    +use_default_show_story_sender?: boolean,
    /** True, if the sender of stories must be displayed in notifications */
    +show_story_sender?: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_pinned_message_notifications
     */
    +use_default_disable_pinned_message_notifications?: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    +disable_pinned_message_notifications?: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_mention_notifications
     */
    +use_default_disable_mention_notifications?: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    +disable_mention_notifications?: boolean,
  |}

  declare export type scopeNotificationSettings = {|
    /** Contains information about notification settings for several chats */
    _: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    sound_id: string,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /**
     * If true, story notifications are received only for the first 5 chats from topChatCategoryUsers
     * regardless of the value of mute_stories
     */
    use_default_mute_stories: boolean,
    /** True, if story notifications are disabled */
    mute_stories: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    story_sound_id: string,
    /** True, if the sender of stories must be displayed in notifications */
    show_story_sender: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  |}

  declare export type scopeNotificationSettings$Input = {|
    /** Contains information about notification settings for several chats */
    +_: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    +mute_for?: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    +sound_id?: number | string,
    /** True, if message content must be displayed in notifications */
    +show_preview?: boolean,
    /**
     * If true, story notifications are received only for the first 5 chats from topChatCategoryUsers
     * regardless of the value of mute_stories
     */
    +use_default_mute_stories?: boolean,
    /** True, if story notifications are disabled */
    +mute_stories?: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    +story_sound_id?: number | string,
    /** True, if the sender of stories must be displayed in notifications */
    +show_story_sender?: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    +disable_pinned_message_notifications?: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    +disable_mention_notifications?: boolean,
  |}

  declare export type reactionNotificationSourceNone = {|
    /** Notifications for reactions are disabled */
    _: 'reactionNotificationSourceNone',
  |}

  declare export type reactionNotificationSourceNone$Input = {|
    /** Notifications for reactions are disabled */
    +_: 'reactionNotificationSourceNone',
  |}

  declare export type reactionNotificationSourceContacts = {|
    /** Notifications for reactions are shown only for reactions from contacts */
    _: 'reactionNotificationSourceContacts',
  |}

  declare export type reactionNotificationSourceContacts$Input = {|
    /** Notifications for reactions are shown only for reactions from contacts */
    +_: 'reactionNotificationSourceContacts',
  |}

  declare export type reactionNotificationSourceAll = {|
    /** Notifications for reactions are shown for all reactions */
    _: 'reactionNotificationSourceAll',
  |}

  declare export type reactionNotificationSourceAll$Input = {|
    /** Notifications for reactions are shown for all reactions */
    +_: 'reactionNotificationSourceAll',
  |}

  declare export type reactionNotificationSettings = {|
    /** Contains information about notification settings for reactions */
    _: 'reactionNotificationSettings',
    /** Source of message reactions for which notifications are shown */
    message_reaction_source: ReactionNotificationSource,
    /** Source of story reactions for which notifications are shown */
    story_reaction_source: ReactionNotificationSource,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    sound_id: string,
    /** True, if reaction sender and emoji must be displayed in notifications */
    show_preview: boolean,
  |}

  declare export type reactionNotificationSettings$Input = {|
    /** Contains information about notification settings for reactions */
    +_: 'reactionNotificationSettings',
    /** Source of message reactions for which notifications are shown */
    +message_reaction_source?: ReactionNotificationSource$Input,
    /** Source of story reactions for which notifications are shown */
    +story_reaction_source?: ReactionNotificationSource$Input,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    +sound_id?: number | string,
    /** True, if reaction sender and emoji must be displayed in notifications */
    +show_preview?: boolean,
  |}

  declare export type draftMessage = {|
    /** Contains information about a message draft */
    _: 'draftMessage',
    /**
     * Information about the message to be replied; must be of the type inputMessageReplyToMessage;
     * may be null if none
     */
    reply_to?: InputMessageReplyTo,
    /** Point in time (Unix timestamp) when the draft was created */
    date: number,
    /**
     * Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote,
     * or inputMessageVoiceNote
     */
    input_message_text: InputMessageContent,
    /** Identifier of the effect to apply to the message when it is sent; 0 if none */
    effect_id: string,
  |}

  declare export type draftMessage$Input = {|
    /** Contains information about a message draft */
    +_: 'draftMessage',
    /**
     * Information about the message to be replied; must be of the type inputMessageReplyToMessage;
     * may be null if none
     */
    +reply_to?: InputMessageReplyTo$Input,
    /** Point in time (Unix timestamp) when the draft was created */
    +date?: number,
    /**
     * Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote,
     * or inputMessageVoiceNote
     */
    +input_message_text?: InputMessageContent$Input,
    /** Identifier of the effect to apply to the message when it is sent; 0 if none */
    +effect_id?: number | string,
  |}

  declare export type chatTypePrivate = {|
    /** An ordinary chat with a user */
    _: 'chatTypePrivate',
    /** User identifier */
    user_id: number,
  |}

  declare export type chatTypeBasicGroup = {|
    /** A basic group (a chat with 0-200 other users) */
    _: 'chatTypeBasicGroup',
    /** Basic group identifier */
    basic_group_id: number,
  |}

  declare export type chatTypeSupergroup = {|
    /** A supergroup or channel (with unlimited members) */
    _: 'chatTypeSupergroup',
    /** Supergroup or channel identifier */
    supergroup_id: number,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
  |}

  declare export type chatTypeSecret = {|
    /** A secret chat with a user */
    _: 'chatTypeSecret',
    /** Secret chat identifier */
    secret_chat_id: number,
    /** User identifier of the other user in the secret chat */
    user_id: number,
  |}

  declare export type chatFolderIcon = {|
    /** Represents an icon for a chat folder */
    _: 'chatFolderIcon',
    /**
     * The chosen icon name for short folder representation; one of "All", "Unread",
     * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat",
     * "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
     * "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money",
     * "Note", "Palette"
     */
    name: string,
  |}

  declare export type chatFolderIcon$Input = {|
    /** Represents an icon for a chat folder */
    +_: 'chatFolderIcon',
    /**
     * The chosen icon name for short folder representation; one of "All", "Unread",
     * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat",
     * "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
     * "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money",
     * "Note", "Palette"
     */
    +name?: string,
  |}

  declare export type chatFolderName = {|
    /** Describes name of a chat folder */
    _: 'chatFolderName',
    /**
     * The text of the chat folder name; 1-12 characters without line feeds. May contain
     * only CustomEmoji entities
     */
    text: formattedText,
    /** True, if custom emoji in the name must be animated */
    animate_custom_emoji: boolean,
  |}

  declare export type chatFolderName$Input = {|
    /** Describes name of a chat folder */
    +_: 'chatFolderName',
    /**
     * The text of the chat folder name; 1-12 characters without line feeds. May contain
     * only CustomEmoji entities
     */
    +text?: formattedText$Input,
    /** True, if custom emoji in the name must be animated */
    +animate_custom_emoji?: boolean,
  |}

  declare export type chatFolder = {|
    /** Represents a folder for user chats */
    _: 'chatFolder',
    /** The name of the folder */
    name: chatFolderName,
    /**
     * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName
     * to get default icon name for the folder
     */
    icon?: chatFolderIcon,
    /**
     * The identifier of the chosen color for the chat folder icon; from -1 to 6. If
     * -1, then color is disabled. Can't be changed if folder tags are disabled or
     * the current user doesn't have Telegram Premium subscription
     */
    color_id: number,
    /** True, if at least one link has been created for the folder */
    is_shareable: boolean,
    /**
     * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max")
     * pinned and always included non-secret chats and the same number of secret chats,
     * but the limit can be increased with Telegram Premium
     */
    pinned_chat_ids: Array<number>,
    /**
     * The chat identifiers of always included chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") pinned and always included
     * non-secret chats and the same number of secret chats, but the limit can be increased
     * with Telegram Premium
     */
    included_chat_ids: Array<number>,
    /**
     * The chat identifiers of always excluded chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret
     * chats and the same number of secret chats, but the limit can be increased with
     * Telegram Premium
     */
    excluded_chat_ids: Array<number>,
    /** True, if muted chats need to be excluded */
    exclude_muted: boolean,
    /** True, if read chats need to be excluded */
    exclude_read: boolean,
    /** True, if archived chats need to be excluded */
    exclude_archived: boolean,
    /** True, if contacts need to be included */
    include_contacts: boolean,
    /** True, if non-contact users need to be included */
    include_non_contacts: boolean,
    /** True, if bots need to be included */
    include_bots: boolean,
    /** True, if basic groups and supergroups need to be included */
    include_groups: boolean,
    /** True, if channels need to be included */
    include_channels: boolean,
  |}

  declare export type chatFolder$Input = {|
    /** Represents a folder for user chats */
    +_: 'chatFolder',
    /** The name of the folder */
    +name?: chatFolderName$Input,
    /**
     * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName
     * to get default icon name for the folder
     */
    +icon?: chatFolderIcon$Input,
    /**
     * The identifier of the chosen color for the chat folder icon; from -1 to 6. If
     * -1, then color is disabled. Can't be changed if folder tags are disabled or
     * the current user doesn't have Telegram Premium subscription
     */
    +color_id?: number,
    /** True, if at least one link has been created for the folder */
    +is_shareable?: boolean,
    /**
     * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max")
     * pinned and always included non-secret chats and the same number of secret chats,
     * but the limit can be increased with Telegram Premium
     */
    +pinned_chat_ids?: $ReadOnlyArray<number>,
    /**
     * The chat identifiers of always included chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") pinned and always included
     * non-secret chats and the same number of secret chats, but the limit can be increased
     * with Telegram Premium
     */
    +included_chat_ids?: $ReadOnlyArray<number>,
    /**
     * The chat identifiers of always excluded chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret
     * chats and the same number of secret chats, but the limit can be increased with
     * Telegram Premium
     */
    +excluded_chat_ids?: $ReadOnlyArray<number>,
    /** True, if muted chats need to be excluded */
    +exclude_muted?: boolean,
    /** True, if read chats need to be excluded */
    +exclude_read?: boolean,
    /** True, if archived chats need to be excluded */
    +exclude_archived?: boolean,
    /** True, if contacts need to be included */
    +include_contacts?: boolean,
    /** True, if non-contact users need to be included */
    +include_non_contacts?: boolean,
    /** True, if bots need to be included */
    +include_bots?: boolean,
    /** True, if basic groups and supergroups need to be included */
    +include_groups?: boolean,
    /** True, if channels need to be included */
    +include_channels?: boolean,
  |}

  declare export type chatFolderInfo = {|
    /** Contains basic information about a chat folder */
    _: 'chatFolderInfo',
    /** Unique chat folder identifier */
    id: number,
    /** The name of the folder */
    name: chatFolderName,
    /** The chosen or default icon for the chat folder */
    icon: chatFolderIcon,
    /**
     * The identifier of the chosen color for the chat folder icon; from -1 to 6. If
     * -1, then color is disabled
     */
    color_id: number,
    /** True, if at least one link has been created for the folder */
    is_shareable: boolean,
    /** True, if the chat folder has invite links created by the current user */
    has_my_invite_links: boolean,
  |}

  declare export type chatFolderInviteLink = {|
    /** Contains a chat folder invite link */
    _: 'chatFolderInviteLink',
    /** The chat folder invite link */
    invite_link: string,
    /** Name of the link */
    name: string,
    /** Identifiers of chats, included in the link */
    chat_ids: Array<number>,
  |}

  declare export type chatFolderInviteLinks = {|
    /** Represents a list of chat folder invite links */
    _: 'chatFolderInviteLinks',
    /** List of the invite links */
    invite_links: Array<chatFolderInviteLink>,
  |}

  declare export type chatFolderInviteLinkInfo = {|
    /** Contains information about an invite link to a chat folder */
    _: 'chatFolderInviteLinkInfo',
    /**
     * Basic information about the chat folder; chat folder identifier will be 0 if
     * the user didn't have the chat folder yet
     */
    chat_folder_info: chatFolderInfo,
    /** Identifiers of the chats from the link, which aren't added to the folder yet */
    missing_chat_ids: Array<number>,
    /** Identifiers of the chats from the link, which are added to the folder already */
    added_chat_ids: Array<number>,
  |}

  declare export type recommendedChatFolder = {|
    /** Describes a recommended chat folder */
    _: 'recommendedChatFolder',
    /** The chat folder */
    folder: chatFolder,
    /** Chat folder description */
    description: string,
  |}

  declare export type recommendedChatFolders = {|
    /** Contains a list of recommended chat folders */
    _: 'recommendedChatFolders',
    /** List of recommended chat folders */
    chat_folders: Array<recommendedChatFolder>,
  |}

  declare export type archiveChatListSettings = {|
    /**
     * Contains settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    _: 'archiveChatListSettings',
    /**
     * True, if new chats from non-contacts will be automatically archived and muted.
     * Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users"
     * is true
     */
    archive_and_mute_new_chats_from_unknown_users: boolean,
    /**
     * True, if unmuted chats will be kept in the Archive chat list when they get a
     * new message
     */
    keep_unmuted_chats_archived: boolean,
    /**
     * True, if unmuted chats, that are always included or pinned in a folder, will
     * be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived
     * == true
     */
    keep_chats_from_folders_archived: boolean,
  |}

  declare export type archiveChatListSettings$Input = {|
    /**
     * Contains settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    +_: 'archiveChatListSettings',
    /**
     * True, if new chats from non-contacts will be automatically archived and muted.
     * Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users"
     * is true
     */
    +archive_and_mute_new_chats_from_unknown_users?: boolean,
    /**
     * True, if unmuted chats will be kept in the Archive chat list when they get a
     * new message
     */
    +keep_unmuted_chats_archived?: boolean,
    /**
     * True, if unmuted chats, that are always included or pinned in a folder, will
     * be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived
     * == true
     */
    +keep_chats_from_folders_archived?: boolean,
  |}

  declare export type chatListMain = {|
    /** A main list of chats */
    _: 'chatListMain',
  |}

  declare export type chatListMain$Input = {|
    /** A main list of chats */
    +_: 'chatListMain',
  |}

  declare export type chatListArchive = {|
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    _: 'chatListArchive',
  |}

  declare export type chatListArchive$Input = {|
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    +_: 'chatListArchive',
  |}

  declare export type chatListFolder = {|
    /** A list of chats added to a chat folder */
    _: 'chatListFolder',
    /** Chat folder identifier */
    chat_folder_id: number,
  |}

  declare export type chatListFolder$Input = {|
    /** A list of chats added to a chat folder */
    +_: 'chatListFolder',
    /** Chat folder identifier */
    +chat_folder_id?: number,
  |}

  declare export type chatLists = {|
    /** Contains a list of chat lists */
    _: 'chatLists',
    /** List of chat lists */
    chat_lists: Array<ChatList>,
  |}

  declare export type chatSourceMtprotoProxy = {|
    /** The chat is sponsored by the user's MTProxy server */
    _: 'chatSourceMtprotoProxy',
  |}

  declare export type chatSourcePublicServiceAnnouncement = {|
    /** The chat contains a public service announcement */
    _: 'chatSourcePublicServiceAnnouncement',
    /** The type of the announcement */
    type: string,
    /** The text of the announcement */
    text: string,
  |}

  declare export type chatPosition = {|
    /** Describes a position of a chat in a chat list */
    _: 'chatPosition',
    /** The chat list */
    list: ChatList,
    /**
     * A parameter used to determine order of the chat in the chat list. Chats must
     * be sorted by the pair (order, chat.id) in descending order
     */
    order: string,
    /** True, if the chat is pinned in the chat list */
    is_pinned: boolean,
    /** Source of the chat in the chat list; may be null */
    source?: ChatSource,
  |}

  declare export type chatAvailableReactionsAll = {|
    /**
     * All reactions are available in the chat, excluding the paid reaction and custom
     * reactions in channel chats
     */
    _: 'chatAvailableReactionsAll',
    /** The maximum allowed number of reactions per message; 1-11 */
    max_reaction_count: number,
  |}

  declare export type chatAvailableReactionsAll$Input = {|
    /**
     * All reactions are available in the chat, excluding the paid reaction and custom
     * reactions in channel chats
     */
    +_: 'chatAvailableReactionsAll',
    /** The maximum allowed number of reactions per message; 1-11 */
    +max_reaction_count?: number,
  |}

  declare export type chatAvailableReactionsSome = {|
    /** Only specific reactions are available in the chat */
    _: 'chatAvailableReactionsSome',
    /** The list of reactions */
    reactions: Array<ReactionType>,
    /** The maximum allowed number of reactions per message; 1-11 */
    max_reaction_count: number,
  |}

  declare export type chatAvailableReactionsSome$Input = {|
    /** Only specific reactions are available in the chat */
    +_: 'chatAvailableReactionsSome',
    /** The list of reactions */
    +reactions?: $ReadOnlyArray<ReactionType$Input>,
    /** The maximum allowed number of reactions per message; 1-11 */
    +max_reaction_count?: number,
  |}

  declare export type savedMessagesTag = {|
    /** Represents a tag used in Saved Messages or a Saved Messages topic */
    _: 'savedMessagesTag',
    /** The tag */
    tag: ReactionType,
    /**
     * Label of the tag; 0-12 characters. Always empty if the tag is returned for a
     * Saved Messages topic
     */
    label: string,
    /** Number of times the tag was used; may be 0 if the tag has non-empty label */
    count: number,
  |}

  declare export type savedMessagesTags = {|
    /** Contains a list of tags used in Saved Messages */
    _: 'savedMessagesTags',
    /** List of tags */
    tags: Array<savedMessagesTag>,
  |}

  declare export type businessBotManageBar = {|
    /** Contains information about a business bot that manages the chat */
    _: 'businessBotManageBar',
    /** User identifier of the bot */
    bot_user_id: number,
    /** URL to be opened to manage the bot */
    manage_url: string,
    /**
     * True, if the bot is paused. Use toggleBusinessConnectedBotChatIsPaused to change
     * the value of the field
     */
    is_bot_paused: boolean,
    /** True, if the bot can reply */
    can_bot_reply: boolean,
  |}

  declare export type videoChat = {|
    /** Describes a video chat */
    _: 'videoChat',
    /**
     * Group call identifier of an active video chat; 0 if none. Full information about
     * the video chat can be received through the method getGroupCall
     */
    group_call_id: number,
    /** True, if the video chat has participants */
    has_participants: boolean,
    /** Default group call participant identifier to join the video chat; may be null */
    default_participant_id?: MessageSender,
  |}

  declare export type chat = {|
    /** A chat. (Can be a private chat, basic group, supergroup, or secret chat) */
    _: 'chat',
    /** Chat unique identifier */
    id: number,
    /** Type of the chat */
    type: ChatType,
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /**
     * Identifier of the accent color for message sender name, and backgrounds of chat
     * photo, reply header, and link preview
     */
    accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background for messages sent by the chat; 0 if none
     */
    background_custom_emoji_id: string,
    /** Identifier of the profile accent color for the chat's profile; -1 if none */
    profile_accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the background of the chat's profile;
     * 0 if none
     */
    profile_background_custom_emoji_id: string,
    /** Actions that non-administrator chat members are allowed to take in the chat */
    permissions: chatPermissions,
    /** Last message in the chat; may be null if none or unknown */
    last_message?: message,
    /** Positions of the chat in chat lists */
    positions: Array<chatPosition>,
    /**
     * Chat lists to which the chat belongs. A chat can have a non-zero position in
     * a chat list even it doesn't belong to the chat list and have no position in
     * a chat list even it belongs to the chat list
     */
    chat_lists: Array<ChatList>,
    /**
     * Identifier of a user or chat that is selected to send messages in the chat;
     * may be null if the user can't change message sender
     */
    message_sender_id?: MessageSender,
    /** Block list to which the chat is added; may be null if none */
    block_list?: BlockList,
    /** True, if chat content can't be saved locally, forwarded, or copied */
    has_protected_content: boolean,
    /** True, if translation of all messages in the chat must be suggested to the user */
    is_translatable: boolean,
    /** True, if the chat is marked as unread */
    is_marked_as_unread: boolean,
    /**
     * True, if the chat is a forum supergroup that must be shown in the "View as topics"
     * mode, or Saved Messages chat that must be shown in the "View as chats"
     */
    view_as_topics: boolean,
    /** True, if the chat has scheduled messages */
    has_scheduled_messages: boolean,
    /**
     * True, if the chat messages can be deleted only for the current user while other
     * users will continue to see the messages
     */
    can_be_deleted_only_for_self: boolean,
    /** True, if the chat messages can be deleted for all users */
    can_be_deleted_for_all_users: boolean,
    /**
     * True, if the chat can be reported to Telegram moderators through reportChat
     * or reportChatPhoto
     */
    can_be_reported: boolean,
    /**
     * Default value of the disable_notification parameter, used when a message is
     * sent to the chat
     */
    default_disable_notification: boolean,
    /** Number of unread messages in the chat */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the chat */
    unread_mention_count: number,
    /** Number of messages with unread reactions in the chat */
    unread_reaction_count: number,
    /** Notification settings for the chat */
    notification_settings: chatNotificationSettings,
    /** Types of reaction, available in the chat */
    available_reactions: ChatAvailableReactions,
    /**
     * Current message auto-delete or self-destruct timer setting for the chat, in
     * seconds; 0 if disabled. Self-destruct timer in secret chats starts after the
     * message or its content is viewed. Auto-delete timer in other chats starts from
     * the send date
     */
    message_auto_delete_time: number,
    /** Emoji status to be shown along with chat title; may be null */
    emoji_status?: emojiStatus,
    /** Background set for the chat; may be null if none */
    background?: chatBackground,
    /** If non-empty, name of a theme, set for the chat */
    theme_name: string,
    /**
     * Information about actions which must be possible to do through the chat action
     * bar; may be null if none
     */
    action_bar?: ChatActionBar,
    /**
     * Information about bar for managing a business bot in the chat; may be null if
     * none
     */
    business_bot_manage_bar?: businessBotManageBar,
    /** Information about video chat of the chat */
    video_chat: videoChat,
    /** Information about pending join requests; may be null if none */
    pending_join_requests?: chatJoinRequestsInfo,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
    /** A draft of a message in the chat; may be null if none */
    draft_message?: draftMessage,
    /**
     * Application-specific data associated with the chat. (For example, the chat scroll
     * position or local chat notification settings can be stored here.) Persistent
     * if the message database is used
     */
    client_data: string,
  |}

  declare export type chats = {|
    /** Represents a list of chats */
    _: 'chats',
    /** Approximate total number of chats found */
    total_count: number,
    /** List of chat identifiers */
    chat_ids: Array<number>,
  |}

  declare export type failedToAddMember = {|
    /** Contains information about a user that has failed to be added to a chat */
    _: 'failedToAddMember',
    /** User identifier */
    user_id: number,
    /**
     * True, if subscription to Telegram Premium would have allowed to add the user
     * to the chat
     */
    premium_would_allow_invite: boolean,
    /**
     * True, if subscription to Telegram Premium is required to send the user chat
     * invite link
     */
    premium_required_to_send_messages: boolean,
  |}

  declare export type failedToAddMembers = {|
    /** Represents a list of users that has failed to be added to a chat */
    _: 'failedToAddMembers',
    /** Information about users that weren't added to the chat */
    failed_to_add_members: Array<failedToAddMember>,
  |}

  declare export type createdBasicGroupChat = {|
    /** Contains information about a newly created basic group chat */
    _: 'createdBasicGroupChat',
    /** Chat identifier */
    chat_id: number,
    /** Information about failed to add members */
    failed_to_add_members: failedToAddMembers,
  |}

  declare export type publicChatTypeHasUsername$Input = {|
    /** The chat is public, because it has an active username */
    +_: 'publicChatTypeHasUsername',
  |}

  declare export type publicChatTypeIsLocationBased$Input = {|
    /** The chat is public, because it is a location-based supergroup */
    +_: 'publicChatTypeIsLocationBased',
  |}

  declare export type accountInfo = {|
    /**
     * Contains basic information about another user that started a chat with the current
     * user
     */
    _: 'accountInfo',
    /** Month when the user was registered in Telegram; 0-12; may be 0 if unknown */
    registration_month: number,
    /** Year when the user was registered in Telegram; 0-9999; may be 0 if unknown */
    registration_year: number,
    /**
     * A two-letter ISO 3166-1 alpha-2 country code based on the phone number of the
     * user; may be empty if unknown
     */
    phone_number_country_code: string,
    /** Point in time (Unix timestamp) when the user changed name last time; 0 if unknown */
    last_name_change_date: number,
    /** Point in time (Unix timestamp) when the user changed photo last time; 0 if unknown */
    last_photo_change_date: number,
  |}

  declare export type chatActionBarReportSpam = {|
    /**
     * The chat can be reported as spam using the method reportChat with an empty option_id
     * and message_ids. If the chat is a private chat with a user with an emoji status,
     * then a notice about emoji status usage must be shown
     */
    _: 'chatActionBarReportSpam',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
  |}

  declare export type chatActionBarInviteMembers = {|
    /** The chat is a recently created group chat to which new members can be invited */
    _: 'chatActionBarInviteMembers',
  |}

  declare export type chatActionBarReportAddBlock = {|
    /**
     * The chat is a private or secret chat, which can be reported using the method
     * reportChat, or the other user can be blocked using the method setMessageSenderBlockList,
     * or the other user can be added to the contact list using the method addContact.
     * If the chat is a private chat with a user with an emoji status, then a notice
     * about emoji status usage must be shown
     */
    _: 'chatActionBarReportAddBlock',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
    /** Basic information about the other user in the chat; may be null if unknown */
    account_info?: accountInfo,
  |}

  declare export type chatActionBarAddContact = {|
    /**
     * The chat is a private or secret chat and the other user can be added to the
     * contact list using the method addContact
     */
    _: 'chatActionBarAddContact',
  |}

  declare export type chatActionBarSharePhoneNumber = {|
    /**
     * The chat is a private or secret chat with a mutual contact and the user's phone
     * number can be shared with the other user using the method sharePhoneNumber
     */
    _: 'chatActionBarSharePhoneNumber',
  |}

  declare export type chatActionBarJoinRequest = {|
    /**
     * The chat is a private chat with an administrator of a chat to which the user
     * sent join request
     */
    _: 'chatActionBarJoinRequest',
    /** Title of the chat to which the join request was sent */
    title: string,
    /** True, if the join request was sent to a channel chat */
    is_channel: boolean,
    /** Point in time (Unix timestamp) when the join request was sent */
    request_date: number,
  |}

  declare export type keyboardButtonTypeText = {|
    /** A simple button, with text that must be sent when the button is pressed */
    _: 'keyboardButtonTypeText',
  |}

  declare export type keyboardButtonTypeText$Input = {|
    /** A simple button, with text that must be sent when the button is pressed */
    +_: 'keyboardButtonTypeText',
  |}

  declare export type keyboardButtonTypeRequestPhoneNumber = {|
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    _: 'keyboardButtonTypeRequestPhoneNumber',
  |}

  declare export type keyboardButtonTypeRequestPhoneNumber$Input = {|
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    +_: 'keyboardButtonTypeRequestPhoneNumber',
  |}

  declare export type keyboardButtonTypeRequestLocation = {|
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    _: 'keyboardButtonTypeRequestLocation',
  |}

  declare export type keyboardButtonTypeRequestLocation$Input = {|
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    +_: 'keyboardButtonTypeRequestLocation',
  |}

  declare export type keyboardButtonTypeRequestPoll = {|
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    _: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    force_regular: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    force_quiz: boolean,
  |}

  declare export type keyboardButtonTypeRequestPoll$Input = {|
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    +_: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    +force_regular?: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    +force_quiz?: boolean,
  |}

  declare export type keyboardButtonTypeRequestUsers = {|
    /**
     * A button that requests users to be shared by the current user; available only
     * in private chats. Use the method shareUsersWithBot to complete the request
     */
    _: 'keyboardButtonTypeRequestUsers',
    /** Unique button identifier */
    id: number,
    /** True, if the shared users must or must not be bots */
    restrict_user_is_bot: boolean,
    /**
     * True, if the shared users must be bots; otherwise, the shared users must not
     * be bots. Ignored if restrict_user_is_bot is false
     */
    user_is_bot: boolean,
    /** True, if the shared users must or must not be Telegram Premium users */
    restrict_user_is_premium: boolean,
    /**
     * True, if the shared users must be Telegram Premium users; otherwise, the shared
     * users must not be Telegram Premium users. Ignored if restrict_user_is_premium
     * is false
     */
    user_is_premium: boolean,
    /** The maximum number of users to share */
    max_quantity: number,
    /** Pass true to request name of the users; bots only */
    request_name: boolean,
    /** Pass true to request username of the users; bots only */
    request_username: boolean,
    /** Pass true to request photo of the users; bots only */
    request_photo: boolean,
  |}

  declare export type keyboardButtonTypeRequestUsers$Input = {|
    /**
     * A button that requests users to be shared by the current user; available only
     * in private chats. Use the method shareUsersWithBot to complete the request
     */
    +_: 'keyboardButtonTypeRequestUsers',
    /** Unique button identifier */
    +id?: number,
    /** True, if the shared users must or must not be bots */
    +restrict_user_is_bot?: boolean,
    /**
     * True, if the shared users must be bots; otherwise, the shared users must not
     * be bots. Ignored if restrict_user_is_bot is false
     */
    +user_is_bot?: boolean,
    /** True, if the shared users must or must not be Telegram Premium users */
    +restrict_user_is_premium?: boolean,
    /**
     * True, if the shared users must be Telegram Premium users; otherwise, the shared
     * users must not be Telegram Premium users. Ignored if restrict_user_is_premium
     * is false
     */
    +user_is_premium?: boolean,
    /** The maximum number of users to share */
    +max_quantity?: number,
    /** Pass true to request name of the users; bots only */
    +request_name?: boolean,
    /** Pass true to request username of the users; bots only */
    +request_username?: boolean,
    /** Pass true to request photo of the users; bots only */
    +request_photo?: boolean,
  |}

  declare export type keyboardButtonTypeRequestChat = {|
    /**
     * A button that requests a chat to be shared by the current user; available only
     * in private chats. Use the method shareChatWithBot to complete the request
     */
    _: 'keyboardButtonTypeRequestChat',
    /** Unique button identifier */
    id: number,
    /**
     * True, if the chat must be a channel; otherwise, a basic group or a supergroup
     * chat is shared
     */
    chat_is_channel: boolean,
    /** True, if the chat must or must not be a forum supergroup */
    restrict_chat_is_forum: boolean,
    /**
     * True, if the chat must be a forum supergroup; otherwise, the chat must not be
     * a forum supergroup. Ignored if restrict_chat_is_forum is false
     */
    chat_is_forum: boolean,
    /** True, if the chat must or must not have a username */
    restrict_chat_has_username: boolean,
    /**
     * True, if the chat must have a username; otherwise, the chat must not have a
     * username. Ignored if restrict_chat_has_username is false
     */
    chat_has_username: boolean,
    /** True, if the chat must be created by the current user */
    chat_is_created: boolean,
    /** Expected user administrator rights in the chat; may be null if they aren't restricted */
    user_administrator_rights?: chatAdministratorRights,
    /** Expected bot administrator rights in the chat; may be null if they aren't restricted */
    bot_administrator_rights?: chatAdministratorRights,
    /**
     * True, if the bot must be a member of the chat; for basic group and supergroup
     * chats only
     */
    bot_is_member: boolean,
    /** Pass true to request title of the chat; bots only */
    request_title: boolean,
    /** Pass true to request username of the chat; bots only */
    request_username: boolean,
    /** Pass true to request photo of the chat; bots only */
    request_photo: boolean,
  |}

  declare export type keyboardButtonTypeRequestChat$Input = {|
    /**
     * A button that requests a chat to be shared by the current user; available only
     * in private chats. Use the method shareChatWithBot to complete the request
     */
    +_: 'keyboardButtonTypeRequestChat',
    /** Unique button identifier */
    +id?: number,
    /**
     * True, if the chat must be a channel; otherwise, a basic group or a supergroup
     * chat is shared
     */
    +chat_is_channel?: boolean,
    /** True, if the chat must or must not be a forum supergroup */
    +restrict_chat_is_forum?: boolean,
    /**
     * True, if the chat must be a forum supergroup; otherwise, the chat must not be
     * a forum supergroup. Ignored if restrict_chat_is_forum is false
     */
    +chat_is_forum?: boolean,
    /** True, if the chat must or must not have a username */
    +restrict_chat_has_username?: boolean,
    /**
     * True, if the chat must have a username; otherwise, the chat must not have a
     * username. Ignored if restrict_chat_has_username is false
     */
    +chat_has_username?: boolean,
    /** True, if the chat must be created by the current user */
    +chat_is_created?: boolean,
    /** Expected user administrator rights in the chat; may be null if they aren't restricted */
    +user_administrator_rights?: chatAdministratorRights$Input,
    /** Expected bot administrator rights in the chat; may be null if they aren't restricted */
    +bot_administrator_rights?: chatAdministratorRights$Input,
    /**
     * True, if the bot must be a member of the chat; for basic group and supergroup
     * chats only
     */
    +bot_is_member?: boolean,
    /** Pass true to request title of the chat; bots only */
    +request_title?: boolean,
    /** Pass true to request username of the chat; bots only */
    +request_username?: boolean,
    /** Pass true to request photo of the chat; bots only */
    +request_photo?: boolean,
  |}

  declare export type keyboardButtonTypeWebApp = {|
    /** A button that opens a Web App by calling getWebAppUrl */
    _: 'keyboardButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    url: string,
  |}

  declare export type keyboardButtonTypeWebApp$Input = {|
    /** A button that opens a Web App by calling getWebAppUrl */
    +_: 'keyboardButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    +url?: string,
  |}

  declare export type keyboardButton = {|
    /** Represents a single button in a bot keyboard */
    _: 'keyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: KeyboardButtonType,
  |}

  declare export type keyboardButton$Input = {|
    /** Represents a single button in a bot keyboard */
    +_: 'keyboardButton',
    /** Text of the button */
    +text?: string,
    /** Type of the button */
    +type?: KeyboardButtonType$Input,
  |}

  declare export type inlineKeyboardButtonTypeUrl = {|
    /** A button that opens a specified URL */
    _: 'inlineKeyboardButtonTypeUrl',
    /**
     * HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp,
     * then the button must be marked as a Web App button
     */
    url: string,
  |}

  declare export type inlineKeyboardButtonTypeUrl$Input = {|
    /** A button that opens a specified URL */
    +_: 'inlineKeyboardButtonTypeUrl',
    /**
     * HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp,
     * then the button must be marked as a Web App button
     */
    +url?: string,
  |}

  declare export type inlineKeyboardButtonTypeLoginUrl = {|
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user by calling getLoginUrlInfo
     */
    _: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to pass to getLoginUrlInfo */
    url: string,
    /** Unique button identifier */
    id: number,
    /** If non-empty, new text of the button in forwarded messages */
    forward_text: string,
  |}

  declare export type inlineKeyboardButtonTypeLoginUrl$Input = {|
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user by calling getLoginUrlInfo
     */
    +_: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to pass to getLoginUrlInfo */
    +url?: string,
    /** Unique button identifier */
    +id?: number,
    /** If non-empty, new text of the button in forwarded messages */
    +forward_text?: string,
  |}

  declare export type inlineKeyboardButtonTypeWebApp = {|
    /** A button that opens a Web App by calling openWebApp */
    _: 'inlineKeyboardButtonTypeWebApp',
    /** An HTTP URL to pass to openWebApp */
    url: string,
  |}

  declare export type inlineKeyboardButtonTypeWebApp$Input = {|
    /** A button that opens a Web App by calling openWebApp */
    +_: 'inlineKeyboardButtonTypeWebApp',
    /** An HTTP URL to pass to openWebApp */
    +url?: string,
  |}

  declare export type inlineKeyboardButtonTypeCallback = {|
    /** A button that sends a callback query to a bot */
    _: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    data: string /* base64 */,
  |}

  declare export type inlineKeyboardButtonTypeCallback$Input = {|
    /** A button that sends a callback query to a bot */
    +_: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    +data?: string /* base64 */,
  |}

  declare export type inlineKeyboardButtonTypeCallbackWithPassword = {|
    /**
     * A button that asks for the 2-step verification password of the current user
     * and then sends a callback query to a bot
     */
    _: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    data: string /* base64 */,
  |}

  declare export type inlineKeyboardButtonTypeCallbackWithPassword$Input = {|
    /**
     * A button that asks for the 2-step verification password of the current user
     * and then sends a callback query to a bot
     */
    +_: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    +data?: string /* base64 */,
  |}

  declare export type inlineKeyboardButtonTypeCallbackGame = {|
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    _: 'inlineKeyboardButtonTypeCallbackGame',
  |}

  declare export type inlineKeyboardButtonTypeCallbackGame$Input = {|
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    +_: 'inlineKeyboardButtonTypeCallbackGame',
  |}

  declare export type inlineKeyboardButtonTypeSwitchInline = {|
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    _: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    query: string,
    /** Target chat from which to send the inline query */
    target_chat: TargetChat,
  |}

  declare export type inlineKeyboardButtonTypeSwitchInline$Input = {|
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    +_: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    +query?: string,
    /** Target chat from which to send the inline query */
    +target_chat?: TargetChat$Input,
  |}

  declare export type inlineKeyboardButtonTypeBuy = {|
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    _: 'inlineKeyboardButtonTypeBuy',
  |}

  declare export type inlineKeyboardButtonTypeBuy$Input = {|
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    +_: 'inlineKeyboardButtonTypeBuy',
  |}

  declare export type inlineKeyboardButtonTypeUser = {|
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    _: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    user_id: number,
  |}

  declare export type inlineKeyboardButtonTypeUser$Input = {|
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    +_: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    +user_id?: number,
  |}

  declare export type inlineKeyboardButtonTypeCopyText = {|
    /** A button that copies specified text to clipboard */
    _: 'inlineKeyboardButtonTypeCopyText',
    /** The text to copy to clipboard */
    text: string,
  |}

  declare export type inlineKeyboardButtonTypeCopyText$Input = {|
    /** A button that copies specified text to clipboard */
    +_: 'inlineKeyboardButtonTypeCopyText',
    /** The text to copy to clipboard */
    +text?: string,
  |}

  declare export type inlineKeyboardButton = {|
    /** Represents a single button in an inline keyboard */
    _: 'inlineKeyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: InlineKeyboardButtonType,
  |}

  declare export type inlineKeyboardButton$Input = {|
    /** Represents a single button in an inline keyboard */
    +_: 'inlineKeyboardButton',
    /** Text of the button */
    +text?: string,
    /** Type of the button */
    +type?: InlineKeyboardButtonType$Input,
  |}

  declare export type replyMarkupRemoveKeyboard = {|
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    _: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    is_personal: boolean,
  |}

  declare export type replyMarkupRemoveKeyboard$Input = {|
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    +_: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    +is_personal?: boolean,
  |}

  declare export type replyMarkupForceReply = {|
    /** Instructs application to force a reply to this message */
    _: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  |}

  declare export type replyMarkupForceReply$Input = {|
    /** Instructs application to force a reply to this message */
    +_: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    +is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    +input_field_placeholder?: string,
  |}

  declare export type replyMarkupShowKeyboard = {|
    /** Contains a custom keyboard layout to quickly reply to bots */
    _: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    rows: Array<Array<keyboardButton>>,
    /**
     * True, if the keyboard is expected to always be shown when the ordinary keyboard
     * is hidden
     */
    is_persistent: boolean,
    /** True, if the application needs to resize the keyboard vertically */
    resize_keyboard: boolean,
    /** True, if the application needs to hide the keyboard after use */
    one_time: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  |}

  declare export type replyMarkupShowKeyboard$Input = {|
    /** Contains a custom keyboard layout to quickly reply to bots */
    +_: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    +rows?: $ReadOnlyArray<$ReadOnlyArray<keyboardButton$Input>>,
    /**
     * True, if the keyboard is expected to always be shown when the ordinary keyboard
     * is hidden
     */
    +is_persistent?: boolean,
    /** True, if the application needs to resize the keyboard vertically */
    +resize_keyboard?: boolean,
    /** True, if the application needs to hide the keyboard after use */
    +one_time?: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    +is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    +input_field_placeholder?: string,
  |}

  declare export type replyMarkupInlineKeyboard = {|
    /** Contains an inline keyboard layout */
    _: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    rows: Array<Array<inlineKeyboardButton>>,
  |}

  declare export type replyMarkupInlineKeyboard$Input = {|
    /** Contains an inline keyboard layout */
    +_: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    +rows?: $ReadOnlyArray<$ReadOnlyArray<inlineKeyboardButton$Input>>,
  |}

  declare export type loginUrlInfoOpen = {|
    /** An HTTP URL needs to be open */
    _: 'loginUrlInfoOpen',
    /** The URL to open */
    url: string,
    /** True, if there is no need to show an ordinary open URL confirmation */
    skip_confirmation: boolean,
  |}

  declare export type loginUrlInfoRequestConfirmation = {|
    /** An authorization confirmation dialog needs to be shown to the user */
    _: 'loginUrlInfoRequestConfirmation',
    /** An HTTP URL to be opened */
    url: string,
    /** A domain of the URL */
    domain: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /** True, if the user must be asked for the permission to the bot to send them messages */
    request_write_access: boolean,
  |}

  declare export type themeParameters$Input = {|
    /** Contains parameters of the application theme */
    +_: 'themeParameters',
    /** A color of the background in the RGB format */
    +background_color?: number,
    /** A secondary color for the background in the RGB format */
    +secondary_background_color?: number,
    /** A color of the header background in the RGB format */
    +header_background_color?: number,
    /** A color of the bottom bar background in the RGB format */
    +bottom_bar_background_color?: number,
    /** A color of the section background in the RGB format */
    +section_background_color?: number,
    /** A color of the section separator in the RGB format */
    +section_separator_color?: number,
    /** A color of text in the RGB format */
    +text_color?: number,
    /** An accent color of the text in the RGB format */
    +accent_text_color?: number,
    /** A color of text on the section headers in the RGB format */
    +section_header_text_color?: number,
    /** A color of the subtitle text in the RGB format */
    +subtitle_text_color?: number,
    /** A color of the text for destructive actions in the RGB format */
    +destructive_text_color?: number,
    /** A color of hints in the RGB format */
    +hint_color?: number,
    /** A color of links in the RGB format */
    +link_color?: number,
    /** A color of the buttons in the RGB format */
    +button_color?: number,
    /** A color of text on the buttons in the RGB format */
    +button_text_color?: number,
  |}

  declare export type webAppOpenModeCompact = {|
    /** The Web App is opened in the compact mode */
    _: 'webAppOpenModeCompact',
  |}

  declare export type webAppOpenModeCompact$Input = {|
    /** The Web App is opened in the compact mode */
    +_: 'webAppOpenModeCompact',
  |}

  declare export type webAppOpenModeFullSize = {|
    /** The Web App is opened in the full-size mode */
    _: 'webAppOpenModeFullSize',
  |}

  declare export type webAppOpenModeFullSize$Input = {|
    /** The Web App is opened in the full-size mode */
    +_: 'webAppOpenModeFullSize',
  |}

  declare export type webAppOpenModeFullScreen = {|
    /** The Web App is opened in the full-screen mode */
    _: 'webAppOpenModeFullScreen',
  |}

  declare export type webAppOpenModeFullScreen$Input = {|
    /** The Web App is opened in the full-screen mode */
    +_: 'webAppOpenModeFullScreen',
  |}

  declare export type foundWebApp = {|
    /** Contains information about a Web App found by its short name */
    _: 'foundWebApp',
    /** The Web App */
    web_app: webApp,
    /** True, if the user must be asked for the permission to the bot to send them messages */
    request_write_access: boolean,
    /**
     * True, if there is no need to show an ordinary open URL confirmation before opening
     * the Web App. The field must be ignored and confirmation must be shown anyway
     * if the Web App link was hidden
     */
    skip_confirmation: boolean,
  |}

  declare export type webAppInfo = {|
    /** Contains information about a Web App */
    _: 'webAppInfo',
    /** Unique identifier for the Web App launch */
    launch_id: string,
    /** A Web App URL to open in a web view */
    url: string,
  |}

  declare export type mainWebApp = {|
    /** Contains information about the main Web App of a bot */
    _: 'mainWebApp',
    /** URL of the Web App to open */
    url: string,
    /** The mode in which the Web App must be opened */
    mode: WebAppOpenMode,
  |}

  declare export type webAppOpenParameters$Input = {|
    /** Options to be used when a Web App is opened */
    +_: 'webAppOpenParameters',
    /** Preferred Web App theme; pass null to use the default theme */
    +theme?: themeParameters$Input,
    /** Short name of the current application; 0-64 English letters, digits, and underscores */
    +application_name?: string,
    /** The mode in which the Web App is opened; pass null to open in webAppOpenModeFullSize */
    +mode?: WebAppOpenMode$Input,
  |}

  declare export type messageThreadInfo = {|
    /** Contains information about a message thread */
    _: 'messageThreadInfo',
    /** Identifier of the chat to which the message thread belongs */
    chat_id: number,
    /** Message thread identifier, unique within the chat */
    message_thread_id: number,
    /** Information about the message thread; may be null for forum topic threads */
    reply_info?: messageReplyInfo,
    /** Approximate number of unread messages in the message thread */
    unread_message_count: number,
    /**
     * The messages from which the thread starts. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    messages: Array<message>,
    /** A draft of a message in the message thread; may be null if none */
    draft_message?: draftMessage,
  |}

  declare export type savedMessagesTopicTypeMyNotes = {|
    /**
     * Topic containing messages sent by the current user of forwarded from an unknown
     * chat
     */
    _: 'savedMessagesTopicTypeMyNotes',
  |}

  declare export type savedMessagesTopicTypeAuthorHidden = {|
    /** Topic containing messages forwarded from a user with hidden privacy */
    _: 'savedMessagesTopicTypeAuthorHidden',
  |}

  declare export type savedMessagesTopicTypeSavedFromChat = {|
    /** Topic containing messages forwarded from a specific chat */
    _: 'savedMessagesTopicTypeSavedFromChat',
    /** Identifier of the chat */
    chat_id: number,
  |}

  declare export type savedMessagesTopic = {|
    /** Contains information about a Saved Messages topic */
    _: 'savedMessagesTopic',
    /** Unique topic identifier */
    id: number,
    /** Type of the topic */
    type: SavedMessagesTopicType,
    /** True, if the topic is pinned */
    is_pinned: boolean,
    /**
     * A parameter used to determine order of the topic in the topic list. Topics must
     * be sorted by the order in descending order
     */
    order: string,
    /** Last message in the topic; may be null if none or unknown */
    last_message?: message,
    /** A draft of a message in the topic; may be null if none */
    draft_message?: draftMessage,
  |}

  declare export type forumTopicIcon = {|
    /** Describes a forum topic icon */
    _: 'forumTopicIcon',
    /** Color of the topic icon in RGB format */
    color: number,
    /** Unique identifier of the custom emoji shown on the topic icon; 0 if none */
    custom_emoji_id: string,
  |}

  declare export type forumTopicIcon$Input = {|
    /** Describes a forum topic icon */
    +_: 'forumTopicIcon',
    /** Color of the topic icon in RGB format */
    +color?: number,
    /** Unique identifier of the custom emoji shown on the topic icon; 0 if none */
    +custom_emoji_id?: number | string,
  |}

  declare export type forumTopicInfo = {|
    /** Contains basic information about a forum topic */
    _: 'forumTopicInfo',
    /** Message thread identifier of the topic */
    message_thread_id: number,
    /** Name of the topic */
    name: string,
    /** Icon of the topic */
    icon: forumTopicIcon,
    /** Point in time (Unix timestamp) when the topic was created */
    creation_date: number,
    /** Identifier of the creator of the topic */
    creator_id: MessageSender,
    /** True, if the topic is the General topic list */
    is_general: boolean,
    /** True, if the topic was created by the current user */
    is_outgoing: boolean,
    /** True, if the topic is closed */
    is_closed: boolean,
    /**
     * True, if the topic is hidden above the topic list and closed; for General topic
     * only
     */
    is_hidden: boolean,
  |}

  declare export type forumTopic = {|
    /** Describes a forum topic */
    _: 'forumTopic',
    /** Basic information about the topic */
    info: forumTopicInfo,
    /** Last message in the topic; may be null if unknown */
    last_message?: message,
    /** True, if the topic is pinned in the topic list */
    is_pinned: boolean,
    /** Number of unread messages in the topic */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the topic */
    unread_mention_count: number,
    /** Number of messages with unread reactions in the topic */
    unread_reaction_count: number,
    /** Notification settings for the topic */
    notification_settings: chatNotificationSettings,
    /** A draft of a message in the topic; may be null if none */
    draft_message?: draftMessage,
  |}

  declare export type forumTopics = {|
    /** Describes a list of forum topics */
    _: 'forumTopics',
    /** Approximate total number of forum topics found */
    total_count: number,
    /** List of forum topics */
    topics: Array<forumTopic>,
    /** Offset date for the next getForumTopics request */
    next_offset_date: number,
    /** Offset message identifier for the next getForumTopics request */
    next_offset_message_id: number,
    /** Offset message thread identifier for the next getForumTopics request */
    next_offset_message_thread_id: number,
  |}

  declare export type linkPreviewOptions = {|
    /** Options to be used for generation of a link preview */
    _: 'linkPreviewOptions',
    /** True, if link preview must be disabled */
    is_disabled: boolean,
    /**
     * URL to use for link preview. If empty, then the first URL found in the message
     * text will be used
     */
    url: string,
    /**
     * True, if shown media preview must be small; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    force_small_media: boolean,
    /**
     * True, if shown media preview must be large; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    force_large_media: boolean,
    /**
     * True, if link preview must be shown above message text; otherwise, the link
     * preview will be shown below the message text; ignored in secret chats
     */
    show_above_text: boolean,
  |}

  declare export type linkPreviewOptions$Input = {|
    /** Options to be used for generation of a link preview */
    +_: 'linkPreviewOptions',
    /** True, if link preview must be disabled */
    +is_disabled?: boolean,
    /**
     * URL to use for link preview. If empty, then the first URL found in the message
     * text will be used
     */
    +url?: string,
    /**
     * True, if shown media preview must be small; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    +force_small_media?: boolean,
    /**
     * True, if shown media preview must be large; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    +force_large_media?: boolean,
    /**
     * True, if link preview must be shown above message text; otherwise, the link
     * preview will be shown below the message text; ignored in secret chats
     */
    +show_above_text?: boolean,
  |}

  declare export type sharedUser = {|
    /** Contains information about a user shared with a bot */
    _: 'sharedUser',
    /** User identifier */
    user_id: number,
    /** First name of the user; for bots only */
    first_name: string,
    /** Last name of the user; for bots only */
    last_name: string,
    /** Username of the user; for bots only */
    username: string,
    /** Profile photo of the user; for bots only; may be null */
    photo?: photo,
  |}

  declare export type sharedChat = {|
    /** Contains information about a chat shared with a bot */
    _: 'sharedChat',
    /** Chat identifier */
    chat_id: number,
    /** Title of the chat; for bots only */
    title: string,
    /** Username of the chat; for bots only */
    username: string,
    /** Photo of the chat; for bots only; may be null */
    photo?: photo,
  |}

  declare export type themeSettings = {|
    /** Describes theme settings */
    _: 'themeSettings',
    /** Theme accent color in ARGB format */
    accent_color: number,
    /** The background to be used in chats; may be null */
    background?: background,
    /** The fill to be used as a background for outgoing messages */
    outgoing_message_fill: BackgroundFill,
    /** If true, the freeform gradient fill needs to be animated on every sent message */
    animate_outgoing_message_fill: boolean,
    /** Accent color of outgoing messages in ARGB format */
    outgoing_message_accent_color: number,
  |}

  declare export type richTextPlain = {|
    /** A plain text */
    _: 'richTextPlain',
    /** Text */
    text: string,
  |}

  declare export type richTextBold = {|
    /** A bold rich text */
    _: 'richTextBold',
    /** Text */
    text: RichText,
  |}

  declare export type richTextItalic = {|
    /** An italicized rich text */
    _: 'richTextItalic',
    /** Text */
    text: RichText,
  |}

  declare export type richTextUnderline = {|
    /** An underlined rich text */
    _: 'richTextUnderline',
    /** Text */
    text: RichText,
  |}

  declare export type richTextStrikethrough = {|
    /** A strikethrough rich text */
    _: 'richTextStrikethrough',
    /** Text */
    text: RichText,
  |}

  declare export type richTextFixed = {|
    /** A fixed-width rich text */
    _: 'richTextFixed',
    /** Text */
    text: RichText,
  |}

  declare export type richTextUrl = {|
    /** A rich text URL link */
    _: 'richTextUrl',
    /** Text */
    text: RichText,
    /** URL */
    url: string,
    /** True, if the URL has cached instant view server-side */
    is_cached: boolean,
  |}

  declare export type richTextEmailAddress = {|
    /** A rich text email link */
    _: 'richTextEmailAddress',
    /** Text */
    text: RichText,
    /** Email address */
    email_address: string,
  |}

  declare export type richTextSubscript = {|
    /** A subscript rich text */
    _: 'richTextSubscript',
    /** Text */
    text: RichText,
  |}

  declare export type richTextSuperscript = {|
    /** A superscript rich text */
    _: 'richTextSuperscript',
    /** Text */
    text: RichText,
  |}

  declare export type richTextMarked = {|
    /** A marked rich text */
    _: 'richTextMarked',
    /** Text */
    text: RichText,
  |}

  declare export type richTextPhoneNumber = {|
    /** A rich text phone number */
    _: 'richTextPhoneNumber',
    /** Text */
    text: RichText,
    /** Phone number */
    phone_number: string,
  |}

  declare export type richTextIcon = {|
    /** A small image inside the text */
    _: 'richTextIcon',
    /** The image represented as a document. The image can be in GIF, JPEG or PNG format */
    document: document,
    /** Width of a bounding box in which the image must be shown; 0 if unknown */
    width: number,
    /** Height of a bounding box in which the image must be shown; 0 if unknown */
    height: number,
  |}

  declare export type richTextReference = {|
    /** A reference to a richTexts object on the same page */
    _: 'richTextReference',
    /** The text */
    text: RichText,
    /**
     * The name of a richTextAnchor object, which is the first element of the target
     * richTexts object
     */
    anchor_name: string,
    /** An HTTP URL, opening the reference */
    url: string,
  |}

  declare export type richTextAnchor = {|
    /** An anchor */
    _: 'richTextAnchor',
    /** Anchor name */
    name: string,
  |}

  declare export type richTextAnchorLink = {|
    /** A link to an anchor on the same page */
    _: 'richTextAnchorLink',
    /** The link text */
    text: RichText,
    /** The anchor name. If the name is empty, the link must bring back to top */
    anchor_name: string,
    /** An HTTP URL, opening the anchor */
    url: string,
  |}

  declare export type richTexts = {|
    /** A concatenation of rich texts */
    _: 'richTexts',
    /** Texts */
    texts: Array<RichText>,
  |}

  declare export type pageBlockCaption = {|
    /** Contains a caption of another block */
    _: 'pageBlockCaption',
    /** Content of the caption */
    text: RichText,
    /** Block credit (like HTML tag <cite>) */
    credit: RichText,
  |}

  declare export type pageBlockListItem = {|
    /** Describes an item of a list page block */
    _: 'pageBlockListItem',
    /** Item label */
    label: string,
    /** Item blocks */
    page_blocks: Array<PageBlock>,
  |}

  declare export type pageBlockHorizontalAlignmentLeft = {|
    /** The content must be left-aligned */
    _: 'pageBlockHorizontalAlignmentLeft',
  |}

  declare export type pageBlockHorizontalAlignmentCenter = {|
    /** The content must be center-aligned */
    _: 'pageBlockHorizontalAlignmentCenter',
  |}

  declare export type pageBlockHorizontalAlignmentRight = {|
    /** The content must be right-aligned */
    _: 'pageBlockHorizontalAlignmentRight',
  |}

  declare export type pageBlockVerticalAlignmentTop = {|
    /** The content must be top-aligned */
    _: 'pageBlockVerticalAlignmentTop',
  |}

  declare export type pageBlockVerticalAlignmentMiddle = {|
    /** The content must be middle-aligned */
    _: 'pageBlockVerticalAlignmentMiddle',
  |}

  declare export type pageBlockVerticalAlignmentBottom = {|
    /** The content must be bottom-aligned */
    _: 'pageBlockVerticalAlignmentBottom',
  |}

  declare export type pageBlockTableCell = {|
    /** Represents a cell of a table */
    _: 'pageBlockTableCell',
    /** Cell text; may be null. If the text is null, then the cell must be invisible */
    text?: RichText,
    /** True, if it is a header cell */
    is_header: boolean,
    /** The number of columns the cell spans */
    colspan: number,
    /** The number of rows the cell spans */
    rowspan: number,
    /** Horizontal cell content alignment */
    align: PageBlockHorizontalAlignment,
    /** Vertical cell content alignment */
    valign: PageBlockVerticalAlignment,
  |}

  declare export type pageBlockRelatedArticle = {|
    /** Contains information about a related article */
    _: 'pageBlockRelatedArticle',
    /** Related article URL */
    url: string,
    /** Article title; may be empty */
    title: string,
    /** Article description; may be empty */
    description: string,
    /** Article photo; may be null */
    photo?: photo,
    /** Article author; may be empty */
    author: string,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  |}

  declare export type pageBlockTitle = {|
    /** The title of a page */
    _: 'pageBlockTitle',
    /** Title */
    title: RichText,
  |}

  declare export type pageBlockSubtitle = {|
    /** The subtitle of a page */
    _: 'pageBlockSubtitle',
    /** Subtitle */
    subtitle: RichText,
  |}

  declare export type pageBlockAuthorDate = {|
    /** The author and publishing date of a page */
    _: 'pageBlockAuthorDate',
    /** Author */
    author: RichText,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  |}

  declare export type pageBlockHeader = {|
    /** A header */
    _: 'pageBlockHeader',
    /** Header */
    header: RichText,
  |}

  declare export type pageBlockSubheader = {|
    /** A subheader */
    _: 'pageBlockSubheader',
    /** Subheader */
    subheader: RichText,
  |}

  declare export type pageBlockKicker = {|
    /** A kicker */
    _: 'pageBlockKicker',
    /** Kicker */
    kicker: RichText,
  |}

  declare export type pageBlockParagraph = {|
    /** A text paragraph */
    _: 'pageBlockParagraph',
    /** Paragraph text */
    text: RichText,
  |}

  declare export type pageBlockPreformatted = {|
    /** A preformatted text paragraph */
    _: 'pageBlockPreformatted',
    /** Paragraph text */
    text: RichText,
    /** Programming language for which the text needs to be formatted */
    language: string,
  |}

  declare export type pageBlockFooter = {|
    /** The footer of a page */
    _: 'pageBlockFooter',
    /** Footer */
    footer: RichText,
  |}

  declare export type pageBlockDivider = {|
    /** An empty block separating a page */
    _: 'pageBlockDivider',
  |}

  declare export type pageBlockAnchor = {|
    /**
     * An invisible anchor on a page, which can be used in a URL to open the page from
     * the specified anchor
     */
    _: 'pageBlockAnchor',
    /** Name of the anchor */
    name: string,
  |}

  declare export type pageBlockList = {|
    /** A list of data blocks */
    _: 'pageBlockList',
    /** The items of the list */
    items: Array<pageBlockListItem>,
  |}

  declare export type pageBlockBlockQuote = {|
    /** A block quote */
    _: 'pageBlockBlockQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  |}

  declare export type pageBlockPullQuote = {|
    /** A pull quote */
    _: 'pageBlockPullQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  |}

  declare export type pageBlockAnimation = {|
    /** An animation */
    _: 'pageBlockAnimation',
    /** Animation file; may be null */
    animation?: animation,
    /** Animation caption */
    caption: pageBlockCaption,
    /** True, if the animation must be played automatically */
    need_autoplay: boolean,
  |}

  declare export type pageBlockAudio = {|
    /** An audio file */
    _: 'pageBlockAudio',
    /** Audio file; may be null */
    audio?: audio,
    /** Audio file caption */
    caption: pageBlockCaption,
  |}

  declare export type pageBlockPhoto = {|
    /** A photo */
    _: 'pageBlockPhoto',
    /** Photo file; may be null */
    photo?: photo,
    /** Photo caption */
    caption: pageBlockCaption,
    /** URL that needs to be opened when the photo is clicked */
    url: string,
  |}

  declare export type pageBlockVideo = {|
    /** A video */
    _: 'pageBlockVideo',
    /** Video file; may be null */
    video?: video,
    /** Video caption */
    caption: pageBlockCaption,
    /** True, if the video must be played automatically */
    need_autoplay: boolean,
    /** True, if the video must be looped */
    is_looped: boolean,
  |}

  declare export type pageBlockVoiceNote = {|
    /** A voice note */
    _: 'pageBlockVoiceNote',
    /** Voice note; may be null */
    voice_note?: voiceNote,
    /** Voice note caption */
    caption: pageBlockCaption,
  |}

  declare export type pageBlockCover = {|
    /** A page cover */
    _: 'pageBlockCover',
    /** Cover */
    cover: PageBlock,
  |}

  declare export type pageBlockEmbedded = {|
    /** An embedded web page */
    _: 'pageBlockEmbedded',
    /** URL of the embedded page, if available */
    url: string,
    /** HTML-markup of the embedded page */
    html: string,
    /** Poster photo, if available; may be null */
    poster_photo?: photo,
    /** Block width; 0 if unknown */
    width: number,
    /** Block height; 0 if unknown */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
    /** True, if the block must be full width */
    is_full_width: boolean,
    /** True, if scrolling needs to be allowed */
    allow_scrolling: boolean,
  |}

  declare export type pageBlockEmbeddedPost = {|
    /** An embedded post */
    _: 'pageBlockEmbeddedPost',
    /** URL of the embedded post */
    url: string,
    /** Post author */
    author: string,
    /** Post author photo; may be null */
    author_photo?: photo,
    /** Point in time (Unix timestamp) when the post was created; 0 if unknown */
    date: number,
    /** Post content */
    page_blocks: Array<PageBlock>,
    /** Post caption */
    caption: pageBlockCaption,
  |}

  declare export type pageBlockCollage = {|
    /** A collage */
    _: 'pageBlockCollage',
    /** Collage item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  |}

  declare export type pageBlockSlideshow = {|
    /** A slideshow */
    _: 'pageBlockSlideshow',
    /** Slideshow item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  |}

  declare export type pageBlockChatLink = {|
    /** A link to a chat */
    _: 'pageBlockChatLink',
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Identifier of the accent color for chat title and background of chat photo */
    accent_color_id: number,
    /** Chat username by which all other information about the chat can be resolved */
    username: string,
  |}

  declare export type pageBlockTable = {|
    /** A table */
    _: 'pageBlockTable',
    /** Table caption */
    caption: RichText,
    /** Table cells */
    cells: Array<Array<pageBlockTableCell>>,
    /** True, if the table is bordered */
    is_bordered: boolean,
    /** True, if the table is striped */
    is_striped: boolean,
  |}

  declare export type pageBlockDetails = {|
    /** A collapsible block */
    _: 'pageBlockDetails',
    /** Always visible heading for the block */
    header: RichText,
    /** Block contents */
    page_blocks: Array<PageBlock>,
    /** True, if the block is open by default */
    is_open: boolean,
  |}

  declare export type pageBlockRelatedArticles = {|
    /** Related articles */
    _: 'pageBlockRelatedArticles',
    /** Block header */
    header: RichText,
    /** List of related articles */
    articles: Array<pageBlockRelatedArticle>,
  |}

  declare export type pageBlockMap = {|
    /** A map */
    _: 'pageBlockMap',
    /** Location of the map center */
    location: location,
    /** Map zoom level */
    zoom: number,
    /** Map width */
    width: number,
    /** Map height */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
  |}

  declare export type webPageInstantView = {|
    /** Describes an instant view page for a web page */
    _: 'webPageInstantView',
    /** Content of the instant view page */
    page_blocks: Array<PageBlock>,
    /** Number of the instant view views; 0 if unknown */
    view_count: number,
    /** Version of the instant view; currently, can be 1 or 2 */
    version: number,
    /** True, if the instant view must be shown from right to left */
    is_rtl: boolean,
    /**
     * True, if the instant view contains the full page. A network request might be
     * needed to get the full instant view
     */
    is_full: boolean,
    /** An internal link to be opened to leave feedback about the instant view */
    feedback_link: InternalLinkType,
  |}

  declare export type linkPreviewAlbumMediaPhoto = {|
    /** The media is a photo */
    _: 'linkPreviewAlbumMediaPhoto',
    /** Photo description */
    photo: photo,
  |}

  declare export type linkPreviewAlbumMediaVideo = {|
    /** The media is a video */
    _: 'linkPreviewAlbumMediaVideo',
    /** Video description */
    video: video,
  |}

  declare export type linkPreviewTypeAlbum = {|
    /** The link is a link to a media album consisting of photos and videos */
    _: 'linkPreviewTypeAlbum',
    /** The list of album media */
    media: Array<LinkPreviewAlbumMedia>,
    /** Album caption */
    caption: string,
  |}

  declare export type linkPreviewTypeAnimation = {|
    /** The link is a link to an animation */
    _: 'linkPreviewTypeAnimation',
    /** The animation */
    animation: animation,
  |}

  declare export type linkPreviewTypeApp = {|
    /** The link is a link to an app at App Store or Google Play */
    _: 'linkPreviewTypeApp',
    /** Photo for the app */
    photo: photo,
  |}

  declare export type linkPreviewTypeArticle = {|
    /** The link is a link to a web site */
    _: 'linkPreviewTypeArticle',
    /** Article's main photo; may be null */
    photo?: photo,
  |}

  declare export type linkPreviewTypeAudio = {|
    /** The link is a link to an audio */
    _: 'linkPreviewTypeAudio',
    /** The audio description */
    audio: audio,
  |}

  declare export type linkPreviewTypeBackground = {|
    /**
     * The link is a link to a background. Link preview title and description are available
     * only for filled backgrounds
     */
    _: 'linkPreviewTypeBackground',
    /** Document with the background; may be null for filled backgrounds */
    document?: document,
    /** Type of the background; may be null if unknown */
    background_type?: BackgroundType,
  |}

  declare export type linkPreviewTypeChannelBoost = {|
    /** The link is a link to boost a channel chat */
    _: 'linkPreviewTypeChannelBoost',
    /** Photo of the chat; may be null */
    photo?: chatPhoto,
  |}

  declare export type linkPreviewTypeChat = {|
    /** The link is a link to a chat */
    _: 'linkPreviewTypeChat',
    /** Type of the chat */
    type: InviteLinkChatType,
    /** Photo of the chat; may be null */
    photo?: chatPhoto,
    /** True, if the link only creates join request */
    creates_join_request: boolean,
  |}

  declare export type linkPreviewTypeDocument = {|
    /** The link is a link to a general file */
    _: 'linkPreviewTypeDocument',
    /** The document description */
    document: document,
  |}

  declare export type linkPreviewTypeEmbeddedAnimationPlayer = {|
    /** The link is a link to an animation player */
    _: 'linkPreviewTypeEmbeddedAnimationPlayer',
    /** URL of the external animation player */
    url: string,
    /** Thumbnail of the animation; may be null if unknown */
    thumbnail?: photo,
    /** Duration of the animation, in seconds */
    duration: number,
    /** Expected width of the embedded player */
    width: number,
    /** Expected height of the embedded player */
    height: number,
  |}

  declare export type linkPreviewTypeEmbeddedAudioPlayer = {|
    /** The link is a link to an audio player */
    _: 'linkPreviewTypeEmbeddedAudioPlayer',
    /** URL of the external audio player */
    url: string,
    /** Thumbnail of the audio; may be null if unknown */
    thumbnail?: photo,
    /** Duration of the audio, in seconds */
    duration: number,
    /** Expected width of the embedded player */
    width: number,
    /** Expected height of the embedded player */
    height: number,
  |}

  declare export type linkPreviewTypeEmbeddedVideoPlayer = {|
    /** The link is a link to a video player */
    _: 'linkPreviewTypeEmbeddedVideoPlayer',
    /** URL of the external video player */
    url: string,
    /** Thumbnail of the video; may be null if unknown */
    thumbnail?: photo,
    /** Duration of the video, in seconds */
    duration: number,
    /** Expected width of the embedded player */
    width: number,
    /** Expected height of the embedded player */
    height: number,
  |}

  declare export type linkPreviewTypeExternalAudio = {|
    /** The link is a link to an audio file */
    _: 'linkPreviewTypeExternalAudio',
    /** URL of the audio file */
    url: string,
    /** MIME type of the audio file */
    mime_type: string,
    /** Duration of the audio, in seconds; 0 if unknown */
    duration: number,
  |}

  declare export type linkPreviewTypeExternalVideo = {|
    /** The link is a link to a video file */
    _: 'linkPreviewTypeExternalVideo',
    /** URL of the video file */
    url: string,
    /** MIME type of the video file */
    mime_type: string,
    /** Expected width of the video preview; 0 if unknown */
    width: number,
    /** Expected height of the video preview; 0 if unknown */
    height: number,
    /** Duration of the video, in seconds; 0 if unknown */
    duration: number,
  |}

  declare export type linkPreviewTypeInvoice = {|
    /** The link is a link to an invoice */
    _: 'linkPreviewTypeInvoice',
  |}

  declare export type linkPreviewTypeMessage = {|
    /** The link is a link to a text or a poll Telegram message */
    _: 'linkPreviewTypeMessage',
  |}

  declare export type linkPreviewTypePhoto = {|
    /** The link is a link to a photo */
    _: 'linkPreviewTypePhoto',
    /** The photo */
    photo: photo,
  |}

  declare export type linkPreviewTypePremiumGiftCode = {|
    /** The link is a link to a Telegram Premium gift code */
    _: 'linkPreviewTypePremiumGiftCode',
  |}

  declare export type linkPreviewTypeShareableChatFolder = {|
    /** The link is a link to a shareable chat folder */
    _: 'linkPreviewTypeShareableChatFolder',
  |}

  declare export type linkPreviewTypeSticker = {|
    /** The link is a link to a sticker */
    _: 'linkPreviewTypeSticker',
    /**
     * The sticker. It can be an arbitrary WEBP image and can have dimensions bigger
     * than 512
     */
    sticker: sticker,
  |}

  declare export type linkPreviewTypeStickerSet = {|
    /** The link is a link to a sticker set */
    _: 'linkPreviewTypeStickerSet',
    /** Up to 4 stickers from the sticker set */
    stickers: Array<sticker>,
  |}

  declare export type linkPreviewTypeStory = {|
    /** The link is a link to a story. Link preview description is unavailable */
    _: 'linkPreviewTypeStory',
    /** The identifier of the chat that posted the story */
    story_sender_chat_id: number,
    /** Story identifier */
    story_id: number,
  |}

  declare export type linkPreviewTypeSupergroupBoost = {|
    /** The link is a link to boost a supergroup chat */
    _: 'linkPreviewTypeSupergroupBoost',
    /** Photo of the chat; may be null */
    photo?: chatPhoto,
  |}

  declare export type linkPreviewTypeTheme = {|
    /** The link is a link to a cloud theme. TDLib has no theme support yet */
    _: 'linkPreviewTypeTheme',
    /** The list of files with theme description */
    documents: Array<document>,
    /** Settings for the cloud theme; may be null if unknown */
    settings?: themeSettings,
  |}

  declare export type linkPreviewTypeUnsupported = {|
    /** The link preview type is unsupported yet */
    _: 'linkPreviewTypeUnsupported',
  |}

  declare export type linkPreviewTypeUpgradedGift = {|
    /** The link is a link to an upgraded gift */
    _: 'linkPreviewTypeUpgradedGift',
    /** The gift */
    gift: upgradedGift,
  |}

  declare export type linkPreviewTypeUser = {|
    /** The link is a link to a user */
    _: 'linkPreviewTypeUser',
    /** Photo of the user; may be null if none */
    photo?: chatPhoto,
    /** True, if the user is a bot */
    is_bot: boolean,
  |}

  declare export type linkPreviewTypeVideo = {|
    /** The link is a link to a video */
    _: 'linkPreviewTypeVideo',
    /** The video description */
    video: video,
    /** Cover of the video; may be null if none */
    cover?: photo,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
  |}

  declare export type linkPreviewTypeVideoChat = {|
    /** The link is a link to a video chat */
    _: 'linkPreviewTypeVideoChat',
    /** Photo of the chat with the video chat; may be null if none */
    photo?: chatPhoto,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    is_live_stream: boolean,
  |}

  declare export type linkPreviewTypeVideoNote = {|
    /** The link is a link to a video note message */
    _: 'linkPreviewTypeVideoNote',
    /** The video note */
    video_note: videoNote,
  |}

  declare export type linkPreviewTypeVoiceNote = {|
    /** The link is a link to a voice note message */
    _: 'linkPreviewTypeVoiceNote',
    /** The voice note */
    voice_note: voiceNote,
  |}

  declare export type linkPreviewTypeWebApp = {|
    /** The link is a link to a Web App */
    _: 'linkPreviewTypeWebApp',
    /** Web App photo; may be null if none */
    photo?: photo,
  |}

  declare export type linkPreview = {|
    /** Describes a link preview */
    _: 'linkPreview',
    /** Original URL of the link */
    url: string,
    /** URL to display */
    display_url: string,
    /** Short name of the site (e.g., Google Docs, App Store) */
    site_name: string,
    /** Title of the content */
    title: string,
    /** Description of the content */
    description: formattedText,
    /** Author of the content */
    author: string,
    /** Type of the link preview */
    type: LinkPreviewType,
    /** True, if size of media in the preview can be changed */
    has_large_media: boolean,
    /**
     * True, if large media preview must be shown; otherwise, the media preview must
     * be shown small and only the first frame must be shown for videos
     */
    show_large_media: boolean,
    /**
     * True, if media must be shown above link preview description; otherwise, the
     * media must be shown below the description
     */
    show_media_above_description: boolean,
    /**
     * True, if there is no need to show an ordinary open URL confirmation, when opening
     * the URL from the preview, because the URL is shown in the message text in clear
     */
    skip_confirmation: boolean,
    /**
     * True, if the link preview must be shown above message text; otherwise, the link
     * preview must be shown below the message text
     */
    show_above_text: boolean,
    /** Version of instant view (currently, can be 1 or 2) for the web page; 0 if none */
    instant_view_version: number,
  |}

  declare export type countryInfo = {|
    /** Contains information about a country */
    _: 'countryInfo',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** Native name of the country */
    name: string,
    /** English name of the country */
    english_name: string,
    /** True, if the country must be hidden from the list of all countries */
    is_hidden: boolean,
    /** List of country calling codes */
    calling_codes: Array<string>,
  |}

  declare export type countries = {|
    /** Contains information about countries */
    _: 'countries',
    /** The list of countries */
    countries: Array<countryInfo>,
  |}

  declare export type phoneNumberInfo = {|
    /** Contains information about a phone number */
    _: 'phoneNumberInfo',
    /** Information about the country to which the phone number belongs; may be null */
    country?: countryInfo,
    /** The part of the phone number denoting country calling code or its part */
    country_calling_code: string,
    /**
     * The phone number without country calling code formatted accordingly to local
     * rules. Expected digits are returned as '-', but even more digits might be entered
     * by the user
     */
    formatted_phone_number: string,
    /**
     * True, if the phone number was bought at https://fragment.com and isn't tied
     * to a SIM card. Information about the phone number can be received using getCollectibleItemInfo
     */
    is_anonymous: boolean,
  |}

  declare export type collectibleItemTypeUsername$Input = {|
    /** A username */
    +_: 'collectibleItemTypeUsername',
    /** The username */
    +username?: string,
  |}

  declare export type collectibleItemTypePhoneNumber$Input = {|
    /** A phone number */
    +_: 'collectibleItemTypePhoneNumber',
    /** The phone number */
    +phone_number?: string,
  |}

  declare export type collectibleItemInfo = {|
    /** Contains information about a collectible item and its last purchase */
    _: 'collectibleItemInfo',
    /** Point in time (Unix timestamp) when the item was purchased */
    purchase_date: number,
    /** Currency for the paid amount */
    currency: string,
    /** The paid amount, in the smallest units of the currency */
    amount: number,
    /** Cryptocurrency used to pay for the item */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency */
    cryptocurrency_amount: string,
    /** Individual URL for the item on https://fragment.com */
    url: string,
  |}

  declare export type bankCardActionOpenUrl = {|
    /** Describes an action associated with a bank card number */
    _: 'bankCardActionOpenUrl',
    /** Action text */
    text: string,
    /** The URL to be opened */
    url: string,
  |}

  declare export type bankCardInfo = {|
    /** Information about a bank card */
    _: 'bankCardInfo',
    /** Title of the bank card description */
    title: string,
    /** Actions that can be done with the bank card number */
    actions: Array<bankCardActionOpenUrl>,
  |}

  declare export type address = {|
    /** Describes an address */
    _: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** State, if applicable */
    state: string,
    /** City */
    city: string,
    /** First line of the address */
    street_line1: string,
    /** Second line of the address */
    street_line2: string,
    /** Address postal code */
    postal_code: string,
  |}

  declare export type address$Input = {|
    /** Describes an address */
    +_: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    +country_code?: string,
    /** State, if applicable */
    +state?: string,
    /** City */
    +city?: string,
    /** First line of the address */
    +street_line1?: string,
    /** Second line of the address */
    +street_line2?: string,
    /** Address postal code */
    +postal_code?: string,
  |}

  declare export type locationAddress = {|
    /** Describes an address of a location */
    _: 'locationAddress',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** State, if applicable; empty if unknown */
    state: string,
    /** City; empty if unknown */
    city: string,
    /** The address; empty if unknown */
    street: string,
  |}

  declare export type locationAddress$Input = {|
    /** Describes an address of a location */
    +_: 'locationAddress',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    +country_code?: string,
    /** State, if applicable; empty if unknown */
    +state?: string,
    /** City; empty if unknown */
    +city?: string,
    /** The address; empty if unknown */
    +street?: string,
  |}

  declare export type labeledPricePart = {|
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    _: 'labeledPricePart',
    /** Label for this portion of the product price */
    label: string,
    /** Currency amount in the smallest units of the currency */
    amount: number,
  |}

  declare export type labeledPricePart$Input = {|
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    +_: 'labeledPricePart',
    /** Label for this portion of the product price */
    +label?: string,
    /** Currency amount in the smallest units of the currency */
    +amount?: number,
  |}

  declare export type invoice = {|
    /** Product invoice */
    _: 'invoice',
    /** ISO 4217 currency code */
    currency: string,
    /** A list of objects used to calculate the total price of the product */
    price_parts: Array<labeledPricePart>,
    /**
     * The number of seconds between consecutive Telegram Star debiting for subscription
     * invoices; 0 if the invoice doesn't create subscription
     */
    subscription_period: number,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    max_tip_amount: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    suggested_tip_amounts: Array<number>,
    /**
     * An HTTP URL with terms of service for recurring payments. If non-empty, the
     * invoice payment will result in recurring payments and the user must accept the
     * terms of service before allowed to pay
     */
    recurring_payment_terms_of_service_url: string,
    /**
     * An HTTP URL with terms of service for non-recurring payments. If non-empty,
     * then the user must accept the terms of service before allowed to pay
     */
    terms_of_service_url: string,
    /** True, if the payment is a test payment */
    is_test: boolean,
    /** True, if the user's name is needed for payment */
    need_name: boolean,
    /** True, if the user's phone number is needed for payment */
    need_phone_number: boolean,
    /** True, if the user's email address is needed for payment */
    need_email_address: boolean,
    /** True, if the user's shipping address is needed for payment */
    need_shipping_address: boolean,
    /** True, if the user's phone number will be sent to the provider */
    send_phone_number_to_provider: boolean,
    /** True, if the user's email address will be sent to the provider */
    send_email_address_to_provider: boolean,
    /** True, if the total price depends on the shipping method */
    is_flexible: boolean,
  |}

  declare export type invoice$Input = {|
    /** Product invoice */
    +_: 'invoice',
    /** ISO 4217 currency code */
    +currency?: string,
    /** A list of objects used to calculate the total price of the product */
    +price_parts?: $ReadOnlyArray<labeledPricePart$Input>,
    /**
     * The number of seconds between consecutive Telegram Star debiting for subscription
     * invoices; 0 if the invoice doesn't create subscription
     */
    +subscription_period?: number,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    +max_tip_amount?: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    +suggested_tip_amounts?: $ReadOnlyArray<number>,
    /**
     * An HTTP URL with terms of service for recurring payments. If non-empty, the
     * invoice payment will result in recurring payments and the user must accept the
     * terms of service before allowed to pay
     */
    +recurring_payment_terms_of_service_url?: string,
    /**
     * An HTTP URL with terms of service for non-recurring payments. If non-empty,
     * then the user must accept the terms of service before allowed to pay
     */
    +terms_of_service_url?: string,
    /** True, if the payment is a test payment */
    +is_test?: boolean,
    /** True, if the user's name is needed for payment */
    +need_name?: boolean,
    /** True, if the user's phone number is needed for payment */
    +need_phone_number?: boolean,
    /** True, if the user's email address is needed for payment */
    +need_email_address?: boolean,
    /** True, if the user's shipping address is needed for payment */
    +need_shipping_address?: boolean,
    /** True, if the user's phone number will be sent to the provider */
    +send_phone_number_to_provider?: boolean,
    /** True, if the user's email address will be sent to the provider */
    +send_email_address_to_provider?: boolean,
    /** True, if the total price depends on the shipping method */
    +is_flexible?: boolean,
  |}

  declare export type orderInfo = {|
    /** Order information */
    _: 'orderInfo',
    /** Name of the user */
    name: string,
    /** Phone number of the user */
    phone_number: string,
    /** Email address of the user */
    email_address: string,
    /** Shipping address for this order; may be null */
    shipping_address?: address,
  |}

  declare export type orderInfo$Input = {|
    /** Order information */
    +_: 'orderInfo',
    /** Name of the user */
    +name?: string,
    /** Phone number of the user */
    +phone_number?: string,
    /** Email address of the user */
    +email_address?: string,
    /** Shipping address for this order; may be null */
    +shipping_address?: address$Input,
  |}

  declare export type shippingOption = {|
    /** One shipping option */
    _: 'shippingOption',
    /** Shipping option identifier */
    id: string,
    /** Option title */
    title: string,
    /** A list of objects used to calculate the total shipping costs */
    price_parts: Array<labeledPricePart>,
  |}

  declare export type shippingOption$Input = {|
    /** One shipping option */
    +_: 'shippingOption',
    /** Shipping option identifier */
    +id?: string,
    /** Option title */
    +title?: string,
    /** A list of objects used to calculate the total shipping costs */
    +price_parts?: $ReadOnlyArray<labeledPricePart$Input>,
  |}

  declare export type savedCredentials = {|
    /** Contains information about saved payment credentials */
    _: 'savedCredentials',
    /** Unique identifier of the saved credentials */
    id: string,
    /** Title of the saved credentials */
    title: string,
  |}

  declare export type inputCredentialsSaved$Input = {|
    /**
     * Applies if a user chooses some previously saved payment credentials. To use
     * their previously saved credentials, the user must have a valid temporary password
     */
    +_: 'inputCredentialsSaved',
    /** Identifier of the saved credentials */
    +saved_credentials_id?: string,
  |}

  declare export type inputCredentialsNew$Input = {|
    /** Applies if a user enters new credentials on a payment provider website */
    +_: 'inputCredentialsNew',
    /** JSON-encoded data with the credential identifier from the payment provider */
    +data?: string,
    /** True, if the credential identifier can be saved on the server side */
    +allow_save?: boolean,
  |}

  declare export type inputCredentialsApplePay$Input = {|
    /** Applies if a user enters new credentials using Apple Pay */
    +_: 'inputCredentialsApplePay',
    /** JSON-encoded data with the credential identifier */
    +data?: string,
  |}

  declare export type inputCredentialsGooglePay$Input = {|
    /** Applies if a user enters new credentials using Google Pay */
    +_: 'inputCredentialsGooglePay',
    /** JSON-encoded data with the credential identifier */
    +data?: string,
  |}

  declare export type paymentProviderSmartGlocal = {|
    /** Smart Glocal payment provider */
    _: 'paymentProviderSmartGlocal',
    /** Public payment token */
    public_token: string,
    /** URL for sending card tokenization requests */
    tokenize_url: string,
  |}

  declare export type paymentProviderStripe = {|
    /** Stripe payment provider */
    _: 'paymentProviderStripe',
    /** Stripe API publishable key */
    publishable_key: string,
    /** True, if the user country must be provided */
    need_country: boolean,
    /** True, if the user ZIP/postal code must be provided */
    need_postal_code: boolean,
    /** True, if the cardholder name must be provided */
    need_cardholder_name: boolean,
  |}

  declare export type paymentProviderOther = {|
    /** Some other payment provider, for which a web payment form must be shown */
    _: 'paymentProviderOther',
    /** Payment form URL */
    url: string,
  |}

  declare export type paymentOption = {|
    /** Describes an additional payment option */
    _: 'paymentOption',
    /** Title for the payment option */
    title: string,
    /** Payment form URL to be opened in a web view */
    url: string,
  |}

  declare export type paymentFormTypeRegular = {|
    /** The payment form is for a regular payment */
    _: 'paymentFormTypeRegular',
    /** Full information about the invoice */
    invoice: invoice,
    /** User identifier of the payment provider bot */
    payment_provider_user_id: number,
    /** Information about the payment provider */
    payment_provider: PaymentProvider,
    /** The list of additional payment options */
    additional_payment_options: Array<paymentOption>,
    /** Saved server-side order information; may be null */
    saved_order_info?: orderInfo,
    /** The list of saved payment credentials */
    saved_credentials: Array<savedCredentials>,
    /** True, if the user can choose to save credentials */
    can_save_credentials: boolean,
    /**
     * True, if the user will be able to save credentials, if sets up a 2-step verification
     * password
     */
    need_password: boolean,
  |}

  declare export type paymentFormTypeStars = {|
    /** The payment form is for a payment in Telegram Stars */
    _: 'paymentFormTypeStars',
    /** Number of Telegram Stars that will be paid */
    star_count: number,
  |}

  declare export type paymentFormTypeStarSubscription = {|
    /** The payment form is for a payment in Telegram Stars for subscription */
    _: 'paymentFormTypeStarSubscription',
    /** Information about subscription plan */
    pricing: starSubscriptionPricing,
  |}

  declare export type paymentForm = {|
    /** Contains information about an invoice payment form */
    _: 'paymentForm',
    /** The payment form identifier */
    id: string,
    /** Type of the payment form */
    type: PaymentFormType,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** Information about the product */
    product_info: productInfo,
  |}

  declare export type validatedOrderInfo = {|
    /**
     * Contains a temporary identifier of validated order information, which is stored
     * for one hour, and the available shipping options
     */
    _: 'validatedOrderInfo',
    /** Temporary identifier of the order information */
    order_info_id: string,
    /** Available shipping options */
    shipping_options: Array<shippingOption>,
  |}

  declare export type paymentResult = {|
    /** Contains the result of a payment request */
    _: 'paymentResult',
    /**
     * True, if the payment request was successful; otherwise, the verification_url
     * will be non-empty
     */
    success: boolean,
    /** URL for additional payment credentials verification */
    verification_url: string,
  |}

  declare export type paymentReceiptTypeRegular = {|
    /** The payment was done using a third-party payment provider */
    _: 'paymentReceiptTypeRegular',
    /** User identifier of the payment provider bot */
    payment_provider_user_id: number,
    /** Information about the invoice */
    invoice: invoice,
    /** Order information; may be null */
    order_info?: orderInfo,
    /** Chosen shipping option; may be null */
    shipping_option?: shippingOption,
    /** Title of the saved credentials chosen by the buyer */
    credentials_title: string,
    /** The amount of tip chosen by the buyer in the smallest units of the currency */
    tip_amount: number,
  |}

  declare export type paymentReceiptTypeStars = {|
    /** The payment was done using Telegram Stars */
    _: 'paymentReceiptTypeStars',
    /** Number of Telegram Stars that were paid */
    star_count: number,
    /** Unique identifier of the transaction that can be used to dispute it */
    transaction_id: string,
  |}

  declare export type paymentReceipt = {|
    /** Contains information about a successful payment */
    _: 'paymentReceipt',
    /** Information about the product */
    product_info: productInfo,
    /** Point in time (Unix timestamp) when the payment was made */
    date: number,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** Type of the payment receipt */
    type: PaymentReceiptType,
  |}

  declare export type inputInvoiceMessage$Input = {|
    /**
     * An invoice from a message of the type messageInvoice or paid media purchase
     * from messagePaidMedia
     */
    +_: 'inputInvoiceMessage',
    /** Chat identifier of the message */
    +chat_id?: number,
    /**
     * Message identifier. Use messageProperties.can_be_paid to check whether the message
     * can be used in the method
     */
    +message_id?: number,
  |}

  declare export type inputInvoiceName$Input = {|
    /** An invoice from a link of the type internalLinkTypeInvoice */
    +_: 'inputInvoiceName',
    /** Name of the invoice */
    +name?: string,
  |}

  declare export type inputInvoiceTelegram$Input = {|
    /** An invoice for a payment toward Telegram; must not be used in the in-store apps */
    +_: 'inputInvoiceTelegram',
    /** Transaction purpose */
    +purpose?: TelegramPaymentPurpose$Input,
  |}

  declare export type paidMediaPreview = {|
    /** The media is hidden until the invoice is paid */
    _: 'paidMediaPreview',
    /** Media width; 0 if unknown */
    width: number,
    /** Media height; 0 if unknown */
    height: number,
    /** Media duration, in seconds; 0 if unknown */
    duration: number,
    /** Media minithumbnail; may be null */
    minithumbnail?: minithumbnail,
  |}

  declare export type paidMediaPhoto = {|
    /** The media is a photo */
    _: 'paidMediaPhoto',
    /** The photo */
    photo: photo,
  |}

  declare export type paidMediaVideo = {|
    /** The media is a video */
    _: 'paidMediaVideo',
    /** The video */
    video: video,
    /** Cover of the video; may be null if none */
    cover?: photo,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
  |}

  declare export type paidMediaUnsupported = {|
    /** The media is unsupported */
    _: 'paidMediaUnsupported',
  |}

  declare export type giveawayParameters = {|
    /** Describes parameters of a giveaway */
    _: 'giveawayParameters',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the winners of the giveaway for duration of the Telegram Premium subscription,
     * or for the specified time. If the chat is a channel, then can_post_messages
     * right is required in the channel, otherwise, the user must be an administrator
     * in the supergroup
     */
    boosted_chat_id: number,
    /**
     * Identifiers of other supergroup or channel chats that must be subscribed by
     * the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max")
     * additional chats
     */
    additional_chat_ids: Array<number>,
    /**
     * Point in time (Unix timestamp) when the giveaway is expected to be performed;
     * must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled
     * giveaways
     */
    winners_selection_date: number,
    /** True, if only new members of the chats will be eligible for the giveaway */
    only_new_members: boolean,
    /** True, if the list of winners of the giveaway will be available to everyone */
    has_public_winners: boolean,
    /**
     * The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which
     * will be eligible for the giveaway. If empty, then all users can participate
     * in the giveaway. There can be up to getOption("giveaway_country_count_max")
     * chosen countries. Users with phone number that was bought at https://fragment.com
     * can participate in any giveaway and the country code "FT" must not be specified
     * in the list
     */
    country_codes: Array<string>,
    /** Additional description of the giveaway prize; 0-128 characters */
    prize_description: string,
  |}

  declare export type giveawayParameters$Input = {|
    /** Describes parameters of a giveaway */
    +_: 'giveawayParameters',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the winners of the giveaway for duration of the Telegram Premium subscription,
     * or for the specified time. If the chat is a channel, then can_post_messages
     * right is required in the channel, otherwise, the user must be an administrator
     * in the supergroup
     */
    +boosted_chat_id?: number,
    /**
     * Identifiers of other supergroup or channel chats that must be subscribed by
     * the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max")
     * additional chats
     */
    +additional_chat_ids?: $ReadOnlyArray<number>,
    /**
     * Point in time (Unix timestamp) when the giveaway is expected to be performed;
     * must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled
     * giveaways
     */
    +winners_selection_date?: number,
    /** True, if only new members of the chats will be eligible for the giveaway */
    +only_new_members?: boolean,
    /** True, if the list of winners of the giveaway will be available to everyone */
    +has_public_winners?: boolean,
    /**
     * The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which
     * will be eligible for the giveaway. If empty, then all users can participate
     * in the giveaway. There can be up to getOption("giveaway_country_count_max")
     * chosen countries. Users with phone number that was bought at https://fragment.com
     * can participate in any giveaway and the country code "FT" must not be specified
     * in the list
     */
    +country_codes?: $ReadOnlyArray<string>,
    /** Additional description of the giveaway prize; 0-128 characters */
    +prize_description?: string,
  |}

  declare export type datedFile = {|
    /** File with the date it was uploaded */
    _: 'datedFile',
    /** The file */
    file: file,
    /** Point in time (Unix timestamp) when the file was uploaded */
    date: number,
  |}

  declare export type passportElementTypePersonalDetails = {|
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementTypePersonalDetails',
  |}

  declare export type passportElementTypePersonalDetails$Input = {|
    /** A Telegram Passport element containing the user's personal details */
    +_: 'passportElementTypePersonalDetails',
  |}

  declare export type passportElementTypePassport = {|
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementTypePassport',
  |}

  declare export type passportElementTypePassport$Input = {|
    /** A Telegram Passport element containing the user's passport */
    +_: 'passportElementTypePassport',
  |}

  declare export type passportElementTypeDriverLicense = {|
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementTypeDriverLicense',
  |}

  declare export type passportElementTypeDriverLicense$Input = {|
    /** A Telegram Passport element containing the user's driver license */
    +_: 'passportElementTypeDriverLicense',
  |}

  declare export type passportElementTypeIdentityCard = {|
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementTypeIdentityCard',
  |}

  declare export type passportElementTypeIdentityCard$Input = {|
    /** A Telegram Passport element containing the user's identity card */
    +_: 'passportElementTypeIdentityCard',
  |}

  declare export type passportElementTypeInternalPassport = {|
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementTypeInternalPassport',
  |}

  declare export type passportElementTypeInternalPassport$Input = {|
    /** A Telegram Passport element containing the user's internal passport */
    +_: 'passportElementTypeInternalPassport',
  |}

  declare export type passportElementTypeAddress = {|
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementTypeAddress',
  |}

  declare export type passportElementTypeAddress$Input = {|
    /** A Telegram Passport element containing the user's address */
    +_: 'passportElementTypeAddress',
  |}

  declare export type passportElementTypeUtilityBill = {|
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementTypeUtilityBill',
  |}

  declare export type passportElementTypeUtilityBill$Input = {|
    /** A Telegram Passport element containing the user's utility bill */
    +_: 'passportElementTypeUtilityBill',
  |}

  declare export type passportElementTypeBankStatement = {|
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementTypeBankStatement',
  |}

  declare export type passportElementTypeBankStatement$Input = {|
    /** A Telegram Passport element containing the user's bank statement */
    +_: 'passportElementTypeBankStatement',
  |}

  declare export type passportElementTypeRentalAgreement = {|
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementTypeRentalAgreement',
  |}

  declare export type passportElementTypeRentalAgreement$Input = {|
    /** A Telegram Passport element containing the user's rental agreement */
    +_: 'passportElementTypeRentalAgreement',
  |}

  declare export type passportElementTypePassportRegistration = {|
    /** A Telegram Passport element containing the registration page of the user's passport */
    _: 'passportElementTypePassportRegistration',
  |}

  declare export type passportElementTypePassportRegistration$Input = {|
    /** A Telegram Passport element containing the registration page of the user's passport */
    +_: 'passportElementTypePassportRegistration',
  |}

  declare export type passportElementTypeTemporaryRegistration = {|
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTypeTemporaryRegistration',
  |}

  declare export type passportElementTypeTemporaryRegistration$Input = {|
    /** A Telegram Passport element containing the user's temporary registration */
    +_: 'passportElementTypeTemporaryRegistration',
  |}

  declare export type passportElementTypePhoneNumber = {|
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementTypePhoneNumber',
  |}

  declare export type passportElementTypePhoneNumber$Input = {|
    /** A Telegram Passport element containing the user's phone number */
    +_: 'passportElementTypePhoneNumber',
  |}

  declare export type passportElementTypeEmailAddress = {|
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementTypeEmailAddress',
  |}

  declare export type passportElementTypeEmailAddress$Input = {|
    /** A Telegram Passport element containing the user's email address */
    +_: 'passportElementTypeEmailAddress',
  |}

  declare export type date = {|
    /** Represents a date according to the Gregorian calendar */
    _: 'date',
    /** Day of the month; 1-31 */
    day: number,
    /** Month; 1-12 */
    month: number,
    /** Year; 1-9999 */
    year: number,
  |}

  declare export type date$Input = {|
    /** Represents a date according to the Gregorian calendar */
    +_: 'date',
    /** Day of the month; 1-31 */
    +day?: number,
    /** Month; 1-12 */
    +month?: number,
    /** Year; 1-9999 */
    +year?: number,
  |}

  declare export type personalDetails = {|
    /** Contains the user's personal details */
    _: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    first_name: string,
    /** Middle name of the user written in English; 0-255 characters */
    middle_name: string,
    /** Last name of the user written in English; 1-255 characters */
    last_name: string,
    /** Native first name of the user; 1-255 characters */
    native_first_name: string,
    /** Native middle name of the user; 0-255 characters */
    native_middle_name: string,
    /** Native last name of the user; 1-255 characters */
    native_last_name: string,
    /** Birthdate of the user */
    birthdate: date,
    /** Gender of the user, "male" or "female" */
    gender: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    country_code: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    residence_country_code: string,
  |}

  declare export type personalDetails$Input = {|
    /** Contains the user's personal details */
    +_: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    +first_name?: string,
    /** Middle name of the user written in English; 0-255 characters */
    +middle_name?: string,
    /** Last name of the user written in English; 1-255 characters */
    +last_name?: string,
    /** Native first name of the user; 1-255 characters */
    +native_first_name?: string,
    /** Native middle name of the user; 0-255 characters */
    +native_middle_name?: string,
    /** Native last name of the user; 1-255 characters */
    +native_last_name?: string,
    /** Birthdate of the user */
    +birthdate?: date$Input,
    /** Gender of the user, "male" or "female" */
    +gender?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    +country_code?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    +residence_country_code?: string,
  |}

  declare export type identityDocument = {|
    /** An identity document */
    _: 'identityDocument',
    /** Document number; 1-24 characters */
    number: string,
    /** Document expiration date; may be null if not applicable */
    expiration_date?: date,
    /** Front side of the document */
    front_side: datedFile,
    /**
     * Reverse side of the document; only for driver license and identity card; may
     * be null
     */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  |}

  declare export type inputIdentityDocument$Input = {|
    /** An identity document to be saved to Telegram Passport */
    +_: 'inputIdentityDocument',
    /** Document number; 1-24 characters */
    +number?: string,
    /** Document expiration date; pass null if not applicable */
    +expiration_date?: date$Input,
    /** Front side of the document */
    +front_side?: InputFile$Input,
    /**
     * Reverse side of the document; only for driver license and identity card; pass
     * null otherwise
     */
    +reverse_side?: InputFile$Input,
    /** Selfie with the document; pass null if unavailable */
    +selfie?: InputFile$Input,
    /** List of files containing a certified English translation of the document */
    +translation?: $ReadOnlyArray<InputFile$Input>,
  |}

  declare export type personalDocument = {|
    /** A personal document, containing some information about a user */
    _: 'personalDocument',
    /** List of files containing the pages of the document */
    files: Array<datedFile>,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  |}

  declare export type inputPersonalDocument$Input = {|
    /** A personal document to be saved to Telegram Passport */
    +_: 'inputPersonalDocument',
    /** List of files containing the pages of the document */
    +files?: $ReadOnlyArray<InputFile$Input>,
    /** List of files containing a certified English translation of the document */
    +translation?: $ReadOnlyArray<InputFile$Input>,
  |}

  declare export type passportElementPersonalDetails = {|
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementPersonalDetails',
    /** Personal details of the user */
    personal_details: personalDetails,
  |}

  declare export type passportElementPassport = {|
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementPassport',
    /** Passport */
    passport: identityDocument,
  |}

  declare export type passportElementDriverLicense = {|
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementDriverLicense',
    /** Driver license */
    driver_license: identityDocument,
  |}

  declare export type passportElementIdentityCard = {|
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementIdentityCard',
    /** Identity card */
    identity_card: identityDocument,
  |}

  declare export type passportElementInternalPassport = {|
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementInternalPassport',
    /** Internal passport */
    internal_passport: identityDocument,
  |}

  declare export type passportElementAddress = {|
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementAddress',
    /** Address */
    address: address,
  |}

  declare export type passportElementUtilityBill = {|
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementUtilityBill',
    /** Utility bill */
    utility_bill: personalDocument,
  |}

  declare export type passportElementBankStatement = {|
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementBankStatement',
    /** Bank statement */
    bank_statement: personalDocument,
  |}

  declare export type passportElementRentalAgreement = {|
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementRentalAgreement',
    /** Rental agreement */
    rental_agreement: personalDocument,
  |}

  declare export type passportElementPassportRegistration = {|
    /** A Telegram Passport element containing the user's passport registration pages */
    _: 'passportElementPassportRegistration',
    /** Passport registration pages */
    passport_registration: personalDocument,
  |}

  declare export type passportElementTemporaryRegistration = {|
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTemporaryRegistration',
    /** Temporary registration */
    temporary_registration: personalDocument,
  |}

  declare export type passportElementPhoneNumber = {|
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementPhoneNumber',
    /** Phone number */
    phone_number: string,
  |}

  declare export type passportElementEmailAddress = {|
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementEmailAddress',
    /** Email address */
    email_address: string,
  |}

  declare export type inputPassportElementPersonalDetails$Input = {|
    /** A Telegram Passport element to be saved containing the user's personal details */
    +_: 'inputPassportElementPersonalDetails',
    /** Personal details of the user */
    +personal_details?: personalDetails$Input,
  |}

  declare export type inputPassportElementPassport$Input = {|
    /** A Telegram Passport element to be saved containing the user's passport */
    +_: 'inputPassportElementPassport',
    /** The passport to be saved */
    +passport?: inputIdentityDocument$Input,
  |}

  declare export type inputPassportElementDriverLicense$Input = {|
    /** A Telegram Passport element to be saved containing the user's driver license */
    +_: 'inputPassportElementDriverLicense',
    /** The driver license to be saved */
    +driver_license?: inputIdentityDocument$Input,
  |}

  declare export type inputPassportElementIdentityCard$Input = {|
    /** A Telegram Passport element to be saved containing the user's identity card */
    +_: 'inputPassportElementIdentityCard',
    /** The identity card to be saved */
    +identity_card?: inputIdentityDocument$Input,
  |}

  declare export type inputPassportElementInternalPassport$Input = {|
    /** A Telegram Passport element to be saved containing the user's internal passport */
    +_: 'inputPassportElementInternalPassport',
    /** The internal passport to be saved */
    +internal_passport?: inputIdentityDocument$Input,
  |}

  declare export type inputPassportElementAddress$Input = {|
    /** A Telegram Passport element to be saved containing the user's address */
    +_: 'inputPassportElementAddress',
    /** The address to be saved */
    +address?: address$Input,
  |}

  declare export type inputPassportElementUtilityBill$Input = {|
    /** A Telegram Passport element to be saved containing the user's utility bill */
    +_: 'inputPassportElementUtilityBill',
    /** The utility bill to be saved */
    +utility_bill?: inputPersonalDocument$Input,
  |}

  declare export type inputPassportElementBankStatement$Input = {|
    /** A Telegram Passport element to be saved containing the user's bank statement */
    +_: 'inputPassportElementBankStatement',
    /** The bank statement to be saved */
    +bank_statement?: inputPersonalDocument$Input,
  |}

  declare export type inputPassportElementRentalAgreement$Input = {|
    /** A Telegram Passport element to be saved containing the user's rental agreement */
    +_: 'inputPassportElementRentalAgreement',
    /** The rental agreement to be saved */
    +rental_agreement?: inputPersonalDocument$Input,
  |}

  declare export type inputPassportElementPassportRegistration$Input = {|
    /** A Telegram Passport element to be saved containing the user's passport registration */
    +_: 'inputPassportElementPassportRegistration',
    /** The passport registration page to be saved */
    +passport_registration?: inputPersonalDocument$Input,
  |}

  declare export type inputPassportElementTemporaryRegistration$Input = {|
    /** A Telegram Passport element to be saved containing the user's temporary registration */
    +_: 'inputPassportElementTemporaryRegistration',
    /** The temporary registration document to be saved */
    +temporary_registration?: inputPersonalDocument$Input,
  |}

  declare export type inputPassportElementPhoneNumber$Input = {|
    /** A Telegram Passport element to be saved containing the user's phone number */
    +_: 'inputPassportElementPhoneNumber',
    /** The phone number to be saved */
    +phone_number?: string,
  |}

  declare export type inputPassportElementEmailAddress$Input = {|
    /** A Telegram Passport element to be saved containing the user's email address */
    +_: 'inputPassportElementEmailAddress',
    /** The email address to be saved */
    +email_address?: string,
  |}

  declare export type passportElements = {|
    /** Contains information about saved Telegram Passport elements */
    _: 'passportElements',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
  |}

  declare export type passportElementErrorSourceUnspecified = {|
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    _: 'passportElementErrorSourceUnspecified',
  |}

  declare export type passportElementErrorSourceDataField = {|
    /**
     * One of the data fields contains an error. The error will be considered resolved
     * when the value of the field changes
     */
    _: 'passportElementErrorSourceDataField',
    /** Field name */
    field_name: string,
  |}

  declare export type passportElementErrorSourceFrontSide = {|
    /**
     * The front side of the document contains an error. The error will be considered
     * resolved when the file with the front side changes
     */
    _: 'passportElementErrorSourceFrontSide',
  |}

  declare export type passportElementErrorSourceReverseSide = {|
    /**
     * The reverse side of the document contains an error. The error will be considered
     * resolved when the file with the reverse side changes
     */
    _: 'passportElementErrorSourceReverseSide',
  |}

  declare export type passportElementErrorSourceSelfie = {|
    /**
     * The selfie with the document contains an error. The error will be considered
     * resolved when the file with the selfie changes
     */
    _: 'passportElementErrorSourceSelfie',
  |}

  declare export type passportElementErrorSourceTranslationFile = {|
    /**
     * One of files with the translation of the document contains an error. The error
     * will be considered resolved when the file changes
     */
    _: 'passportElementErrorSourceTranslationFile',
    /** Index of a file with the error */
    file_index: number,
  |}

  declare export type passportElementErrorSourceTranslationFiles = {|
    /**
     * The translation of the document contains an error. The error will be considered
     * resolved when the list of translation files changes
     */
    _: 'passportElementErrorSourceTranslationFiles',
  |}

  declare export type passportElementErrorSourceFile = {|
    /**
     * The file contains an error. The error will be considered resolved when the file
     * changes
     */
    _: 'passportElementErrorSourceFile',
    /** Index of a file with the error */
    file_index: number,
  |}

  declare export type passportElementErrorSourceFiles = {|
    /**
     * The list of attached files contains an error. The error will be considered resolved
     * when the list of files changes
     */
    _: 'passportElementErrorSourceFiles',
  |}

  declare export type passportElementError = {|
    /** Contains the description of an error in a Telegram Passport element */
    _: 'passportElementError',
    /** Type of the Telegram Passport element which has the error */
    type: PassportElementType,
    /** Error message */
    message: string,
    /** Error source */
    source: PassportElementErrorSource,
  |}

  declare export type passportSuitableElement = {|
    /**
     * Contains information about a Telegram Passport element that was requested by
     * a service
     */
    _: 'passportSuitableElement',
    /** Type of the element */
    type: PassportElementType,
    /** True, if a selfie is required with the identity document */
    is_selfie_required: boolean,
    /** True, if a certified English translation is required with the document */
    is_translation_required: boolean,
    /**
     * True, if personal details must include the user's name in the language of their
     * country of residence
     */
    is_native_name_required: boolean,
  |}

  declare export type passportRequiredElement = {|
    /**
     * Contains a description of the required Telegram Passport element that was requested
     * by a service
     */
    _: 'passportRequiredElement',
    /** List of Telegram Passport elements any of which is enough to provide */
    suitable_elements: Array<passportSuitableElement>,
  |}

  declare export type passportAuthorizationForm = {|
    /** Contains information about a Telegram Passport authorization form that was requested */
    _: 'passportAuthorizationForm',
    /** Unique identifier of the authorization form */
    id: number,
    /** Telegram Passport elements that must be provided to complete the form */
    required_elements: Array<passportRequiredElement>,
    /** URL for the privacy policy of the service; may be empty */
    privacy_policy_url: string,
  |}

  declare export type passportElementsWithErrors = {|
    /** Contains information about a Telegram Passport elements and corresponding errors */
    _: 'passportElementsWithErrors',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
    /** Errors in the elements that are already available */
    errors: Array<passportElementError>,
  |}

  declare export type encryptedCredentials = {|
    /** Contains encrypted Telegram Passport data credentials */
    _: 'encryptedCredentials',
    /** The encrypted credentials */
    data: string /* base64 */,
    /** The decrypted data hash */
    hash: string /* base64 */,
    /** Secret for data decryption, encrypted with the service's public key */
    secret: string /* base64 */,
  |}

  declare export type encryptedPassportElement = {|
    /**
     * Contains information about an encrypted Telegram Passport element; for bots
     * only
     */
    _: 'encryptedPassportElement',
    /** Type of Telegram Passport element */
    type: PassportElementType,
    /** Encrypted JSON-encoded data about the user */
    data: string /* base64 */,
    /** The front side of an identity document */
    front_side: datedFile,
    /** The reverse side of an identity document; may be null */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
    /** List of attached files */
    files: Array<datedFile>,
    /** Unencrypted data, phone number or email address */
    value: string,
    /** Hash of the entire element */
    hash: string,
  |}

  declare export type inputPassportElementErrorSourceUnspecified$Input = {|
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    +_: 'inputPassportElementErrorSourceUnspecified',
    /** Current hash of the entire element */
    +element_hash?: string /* base64 */,
  |}

  declare export type inputPassportElementErrorSourceDataField$Input = {|
    /**
     * A data field contains an error. The error is considered resolved when the field's
     * value changes
     */
    +_: 'inputPassportElementErrorSourceDataField',
    /** Field name */
    +field_name?: string,
    /** Current data hash */
    +data_hash?: string /* base64 */,
  |}

  declare export type inputPassportElementErrorSourceFrontSide$Input = {|
    /**
     * The front side of the document contains an error. The error is considered resolved
     * when the file with the front side of the document changes
     */
    +_: 'inputPassportElementErrorSourceFrontSide',
    /** Current hash of the file containing the front side */
    +file_hash?: string /* base64 */,
  |}

  declare export type inputPassportElementErrorSourceReverseSide$Input = {|
    /**
     * The reverse side of the document contains an error. The error is considered
     * resolved when the file with the reverse side of the document changes
     */
    +_: 'inputPassportElementErrorSourceReverseSide',
    /** Current hash of the file containing the reverse side */
    +file_hash?: string /* base64 */,
  |}

  declare export type inputPassportElementErrorSourceSelfie$Input = {|
    /**
     * The selfie contains an error. The error is considered resolved when the file
     * with the selfie changes
     */
    +_: 'inputPassportElementErrorSourceSelfie',
    /** Current hash of the file containing the selfie */
    +file_hash?: string /* base64 */,
  |}

  declare export type inputPassportElementErrorSourceTranslationFile$Input = {|
    /**
     * One of the files containing the translation of the document contains an error.
     * The error is considered resolved when the file with the translation changes
     */
    +_: 'inputPassportElementErrorSourceTranslationFile',
    /** Current hash of the file containing the translation */
    +file_hash?: string /* base64 */,
  |}

  declare export type inputPassportElementErrorSourceTranslationFiles$Input = {|
    /**
     * The translation of the document contains an error. The error is considered resolved
     * when the list of files changes
     */
    +_: 'inputPassportElementErrorSourceTranslationFiles',
    /** Current hashes of all files with the translation */
    +file_hashes?: $ReadOnlyArray<string /* base64 */>,
  |}

  declare export type inputPassportElementErrorSourceFile$Input = {|
    /** The file contains an error. The error is considered resolved when the file changes */
    +_: 'inputPassportElementErrorSourceFile',
    /** Current hash of the file which has the error */
    +file_hash?: string /* base64 */,
  |}

  declare export type inputPassportElementErrorSourceFiles$Input = {|
    /**
     * The list of attached files contains an error. The error is considered resolved
     * when the file list changes
     */
    +_: 'inputPassportElementErrorSourceFiles',
    /** Current hashes of all attached files */
    +file_hashes?: $ReadOnlyArray<string /* base64 */>,
  |}

  declare export type inputPassportElementError$Input = {|
    /**
     * Contains the description of an error in a Telegram Passport element; for bots
     * only
     */
    +_: 'inputPassportElementError',
    /** Type of Telegram Passport element that has the error */
    +type?: PassportElementType$Input,
    /** Error message */
    +message?: string,
    /** Error source */
    +source?: InputPassportElementErrorSource$Input,
  |}

  declare export type messageText = {|
    /** A text message */
    _: 'messageText',
    /** Text of the message */
    text: formattedText,
    /** A link preview attached to the message; may be null */
    link_preview?: linkPreview,
    /**
     * Options which were used for generation of the link preview; may be null if default
     * options were used
     */
    link_preview_options?: linkPreviewOptions,
  |}

  declare export type messageAnimation = {|
    /** An animation message (GIF-style). */
    _: 'messageAnimation',
    /** The animation description */
    animation: animation,
    /** Animation caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the animation; otherwise, the caption
     * must be shown below the animation
     */
    show_caption_above_media: boolean,
    /** True, if the animation preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /**
     * True, if the animation thumbnail must be blurred and the animation must be shown
     * only while tapped
     */
    is_secret: boolean,
  |}

  declare export type messageAudio = {|
    /** An audio message */
    _: 'messageAudio',
    /** The audio description */
    audio: audio,
    /** Audio caption */
    caption: formattedText,
  |}

  declare export type messageDocument = {|
    /** A document message (general file) */
    _: 'messageDocument',
    /** The document description */
    document: document,
    /** Document caption */
    caption: formattedText,
  |}

  declare export type messagePaidMedia = {|
    /** A message with paid media */
    _: 'messagePaidMedia',
    /** Number of Telegram Stars needed to buy access to the media in the message */
    star_count: number,
    /** Information about the media */
    media: Array<PaidMedia>,
    /** Media caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the media; otherwise, the caption must
     * be shown below the media
     */
    show_caption_above_media: boolean,
  |}

  declare export type messagePhoto = {|
    /** A photo message */
    _: 'messagePhoto',
    /** The photo */
    photo: photo,
    /** Photo caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the photo; otherwise, the caption must
     * be shown below the photo
     */
    show_caption_above_media: boolean,
    /** True, if the photo preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /** True, if the photo must be blurred and must be shown only while tapped */
    is_secret: boolean,
  |}

  declare export type messageSticker = {|
    /** A sticker message */
    _: 'messageSticker',
    /** The sticker description */
    sticker: sticker,
    /** True, if premium animation of the sticker must be played */
    is_premium: boolean,
  |}

  declare export type messageVideo = {|
    /** A video message */
    _: 'messageVideo',
    /** The video description */
    video: video,
    /** Alternative qualities of the video */
    alternative_videos: Array<alternativeVideo>,
    /** Cover of the video; may be null if none */
    cover?: photo,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
    /** Video caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the video; otherwise, the caption must
     * be shown below the video
     */
    show_caption_above_media: boolean,
    /** True, if the video preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /**
     * True, if the video thumbnail must be blurred and the video must be shown only
     * while tapped
     */
    is_secret: boolean,
  |}

  declare export type messageVideoNote = {|
    /** A video note message */
    _: 'messageVideoNote',
    /** The video note description */
    video_note: videoNote,
    /** True, if at least one of the recipients has viewed the video note */
    is_viewed: boolean,
    /**
     * True, if the video note thumbnail must be blurred and the video note must be
     * shown only while tapped
     */
    is_secret: boolean,
  |}

  declare export type messageVoiceNote = {|
    /** A voice note message */
    _: 'messageVoiceNote',
    /** The voice note description */
    voice_note: voiceNote,
    /** Voice note caption */
    caption: formattedText,
    /** True, if at least one of the recipients has listened to the voice note */
    is_listened: boolean,
  |}

  declare export type messageExpiredPhoto = {|
    /** A self-destructed photo message */
    _: 'messageExpiredPhoto',
  |}

  declare export type messageExpiredVideo = {|
    /** A self-destructed video message */
    _: 'messageExpiredVideo',
  |}

  declare export type messageExpiredVideoNote = {|
    /** A self-destructed video note message */
    _: 'messageExpiredVideoNote',
  |}

  declare export type messageExpiredVoiceNote = {|
    /** A self-destructed voice note message */
    _: 'messageExpiredVoiceNote',
  |}

  declare export type messageLocation = {|
    /** A message with a location */
    _: 'messageLocation',
    /** The location description */
    location: location,
    /**
     * Time relative to the message send date, for which the location can be updated,
     * in seconds; if 0x7FFFFFFF, then location can be updated forever
     */
    live_period: number,
    /**
     * Left time for which the location can be updated, in seconds. If 0, then the
     * location can't be updated anymore. The update updateMessageContent is not sent
     * when this field changes
     */
    expires_in: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * If 0 the direction is unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). 0 if the notification is disabled. Available only
     * to the message sender
     */
    proximity_alert_radius: number,
  |}

  declare export type messageVenue = {|
    /** A message with information about a venue */
    _: 'messageVenue',
    /** The venue description */
    venue: venue,
  |}

  declare export type messageContact = {|
    /** A message with a user contact */
    _: 'messageContact',
    /** The contact description */
    contact: contact,
  |}

  declare export type messageAnimatedEmoji = {|
    /** A message with an animated emoji */
    _: 'messageAnimatedEmoji',
    /** The animated emoji */
    animated_emoji: animatedEmoji,
    /** The corresponding emoji */
    emoji: string,
  |}

  declare export type messageDice = {|
    /** A dice message. The dice value is randomly generated by the server */
    _: 'messageDice',
    /**
     * The animated stickers with the initial dice animation; may be null if unknown.
     * The update updateMessageContent will be sent when the sticker became known
     */
    initial_state?: DiceStickers,
    /**
     * The animated stickers with the final dice animation; may be null if unknown.
     * The update updateMessageContent will be sent when the sticker became known
     */
    final_state?: DiceStickers,
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** The dice value. If the value is 0, the dice don't have final state yet */
    value: number,
    /**
     * Number of frame after which a success animation like a shower of confetti needs
     * to be shown on updateMessageSendSucceeded
     */
    success_animation_frame_number: number,
  |}

  declare export type messageGame = {|
    /** A message with a game */
    _: 'messageGame',
    /** The game description */
    game: game,
  |}

  declare export type messagePoll = {|
    /** A message with a poll */
    _: 'messagePoll',
    /** The poll description */
    poll: poll,
  |}

  declare export type messageStory = {|
    /** A message with a forwarded story */
    _: 'messageStory',
    /** Identifier of the chat that posted the story */
    story_sender_chat_id: number,
    /** Story identifier */
    story_id: number,
    /** True, if the story was automatically forwarded because of a mention of the user */
    via_mention: boolean,
  |}

  declare export type messageInvoice = {|
    /**
     * A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart
     * to share the invoice
     */
    _: 'messageInvoice',
    /** Information about the product */
    product_info: productInfo,
    /** Currency for the product price */
    currency: string,
    /** Product total price in the smallest units of the currency */
    total_amount: number,
    /** Unique invoice bot start_parameter to be passed to getInternalLink */
    start_parameter: string,
    /** True, if the invoice is a test invoice */
    is_test: boolean,
    /** True, if the shipping address must be specified */
    need_shipping_address: boolean,
    /** The identifier of the message with the receipt, after the product has been purchased */
    receipt_message_id: number,
    /** Extended media attached to the invoice; may be null if none */
    paid_media?: PaidMedia,
    /** Extended media caption; may be null if none */
    paid_media_caption?: formattedText,
  |}

  declare export type messageCall = {|
    /** A message with information about an ended call */
    _: 'messageCall',
    /** True, if the call was a video call */
    is_video: boolean,
    /** Reason why the call was discarded */
    discard_reason: CallDiscardReason,
    /** Call duration, in seconds */
    duration: number,
  |}

  declare export type messageVideoChatScheduled = {|
    /** A new video chat was scheduled */
    _: 'messageVideoChatScheduled',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /**
     * Point in time (Unix timestamp) when the group call is expected to be started
     * by an administrator
     */
    start_date: number,
  |}

  declare export type messageVideoChatStarted = {|
    /** A newly created video chat */
    _: 'messageVideoChatStarted',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  |}

  declare export type messageVideoChatEnded = {|
    /** A message with information about an ended video chat */
    _: 'messageVideoChatEnded',
    /** Call duration, in seconds */
    duration: number,
  |}

  declare export type messageInviteVideoChatParticipants = {|
    /** A message with information about an invitation to a video chat */
    _: 'messageInviteVideoChatParticipants',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /** Invited user identifiers */
    user_ids: Array<number>,
  |}

  declare export type messageBasicGroupChatCreate = {|
    /** A newly created basic group */
    _: 'messageBasicGroupChatCreate',
    /** Title of the basic group */
    title: string,
    /** User identifiers of members in the basic group */
    member_user_ids: Array<number>,
  |}

  declare export type messageSupergroupChatCreate = {|
    /** A newly created supergroup or channel */
    _: 'messageSupergroupChatCreate',
    /** Title of the supergroup or channel */
    title: string,
  |}

  declare export type messageChatChangeTitle = {|
    /** An updated chat title */
    _: 'messageChatChangeTitle',
    /** New chat title */
    title: string,
  |}

  declare export type messageChatChangePhoto = {|
    /** An updated chat photo */
    _: 'messageChatChangePhoto',
    /** New chat photo */
    photo: chatPhoto,
  |}

  declare export type messageChatDeletePhoto = {|
    /** A deleted chat photo */
    _: 'messageChatDeletePhoto',
  |}

  declare export type messageChatAddMembers = {|
    /** New chat members were added */
    _: 'messageChatAddMembers',
    /** User identifiers of the new members */
    member_user_ids: Array<number>,
  |}

  declare export type messageChatJoinByLink = {|
    /** A new member joined the chat via an invite link */
    _: 'messageChatJoinByLink',
  |}

  declare export type messageChatJoinByRequest = {|
    /** A new member was accepted to the chat by an administrator */
    _: 'messageChatJoinByRequest',
  |}

  declare export type messageChatDeleteMember = {|
    /** A chat member was deleted */
    _: 'messageChatDeleteMember',
    /** User identifier of the deleted chat member */
    user_id: number,
  |}

  declare export type messageChatUpgradeTo = {|
    /** A basic group was upgraded to a supergroup and was deactivated as the result */
    _: 'messageChatUpgradeTo',
    /** Identifier of the supergroup to which the basic group was upgraded */
    supergroup_id: number,
  |}

  declare export type messageChatUpgradeFrom = {|
    /** A supergroup has been created from a basic group */
    _: 'messageChatUpgradeFrom',
    /** Title of the newly created supergroup */
    title: string,
    /** The identifier of the original basic group */
    basic_group_id: number,
  |}

  declare export type messagePinMessage = {|
    /** A message has been pinned */
    _: 'messagePinMessage',
    /**
     * Identifier of the pinned message, can be an identifier of a deleted message
     * or 0
     */
    message_id: number,
  |}

  declare export type messageScreenshotTaken = {|
    /** A screenshot of a message in the chat has been taken */
    _: 'messageScreenshotTaken',
  |}

  declare export type messageChatSetBackground = {|
    /** A new background was set in the chat */
    _: 'messageChatSetBackground',
    /**
     * Identifier of the message with a previously set same background; 0 if none.
     * Can be an identifier of a deleted message
     */
    old_background_message_id: number,
    /** The new background */
    background: chatBackground,
    /** True, if the background was set only for self */
    only_for_self: boolean,
  |}

  declare export type messageChatSetTheme = {|
    /** A theme in the chat has been changed */
    _: 'messageChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was
     * reset to the default one
     */
    theme_name: string,
  |}

  declare export type messageChatSetMessageAutoDeleteTime = {|
    /** The auto-delete or self-destruct timer for messages in the chat has been changed */
    _: 'messageChatSetMessageAutoDeleteTime',
    /** New value auto-delete or self-destruct time, in seconds; 0 if disabled */
    message_auto_delete_time: number,
    /** If not 0, a user identifier, which default setting was automatically applied */
    from_user_id: number,
  |}

  declare export type messageChatBoost = {|
    /** The chat was boosted by the sender of the message */
    _: 'messageChatBoost',
    /** Number of times the chat was boosted */
    boost_count: number,
  |}

  declare export type messageForumTopicCreated = {|
    /** A forum topic has been created */
    _: 'messageForumTopicCreated',
    /** Name of the topic */
    name: string,
    /** Icon of the topic */
    icon: forumTopicIcon,
  |}

  declare export type messageForumTopicEdited = {|
    /** A forum topic has been edited */
    _: 'messageForumTopicEdited',
    /** If non-empty, the new name of the topic */
    name: string,
    /** True, if icon's custom_emoji_id is changed */
    edit_icon_custom_emoji_id: boolean,
    /**
     * New unique identifier of the custom emoji shown on the topic icon; 0 if none.
     * Must be ignored if edit_icon_custom_emoji_id is false
     */
    icon_custom_emoji_id: string,
  |}

  declare export type messageForumTopicIsClosedToggled = {|
    /** A forum topic has been closed or opened */
    _: 'messageForumTopicIsClosedToggled',
    /** True, if the topic was closed; otherwise, the topic was reopened */
    is_closed: boolean,
  |}

  declare export type messageForumTopicIsHiddenToggled = {|
    /** A General forum topic has been hidden or unhidden */
    _: 'messageForumTopicIsHiddenToggled',
    /** True, if the topic was hidden; otherwise, the topic was unhidden */
    is_hidden: boolean,
  |}

  declare export type messageSuggestProfilePhoto = {|
    /** A profile photo was suggested to a user in a private chat */
    _: 'messageSuggestProfilePhoto',
    /**
     * The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious
     * to apply the photo
     */
    photo: chatPhoto,
  |}

  declare export type messageCustomServiceAction = {|
    /** A non-standard action has happened in the chat */
    _: 'messageCustomServiceAction',
    /** Message text to be shown in the chat */
    text: string,
  |}

  declare export type messageGameScore = {|
    /** A new high score was achieved in a game */
    _: 'messageGameScore',
    /** Identifier of the message with the game, can be an identifier of a deleted message */
    game_message_id: number,
    /**
     * Identifier of the game; may be different from the games presented in the message
     * with the game
     */
    game_id: string,
    /** New score */
    score: number,
  |}

  declare export type messagePaymentSuccessful = {|
    /** A payment has been sent to a bot or a business account */
    _: 'messagePaymentSuccessful',
    /** Identifier of the chat, containing the corresponding invoice message */
    invoice_chat_id: number,
    /**
     * Identifier of the message with the corresponding invoice; can be 0 or an identifier
     * of a deleted message
     */
    invoice_message_id: number,
    /** Currency for the price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /**
     * Point in time (Unix timestamp) when the subscription will expire; 0 if unknown
     * or the payment isn't recurring
     */
    subscription_until_date: number,
    /** True, if this is a recurring payment */
    is_recurring: boolean,
    /** True, if this is the first recurring payment */
    is_first_recurring: boolean,
    /** Name of the invoice; may be empty if unknown */
    invoice_name: string,
  |}

  declare export type messagePaymentSuccessfulBot = {|
    /** A payment has been received by the bot or the business account */
    _: 'messagePaymentSuccessfulBot',
    /** Currency for price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /**
     * Point in time (Unix timestamp) when the subscription will expire; 0 if unknown
     * or the payment isn't recurring
     */
    subscription_until_date: number,
    /** True, if this is a recurring payment */
    is_recurring: boolean,
    /** True, if this is the first recurring payment */
    is_first_recurring: boolean,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /**
     * Identifier of the shipping option chosen by the user; may be empty if not applicable;
     * for bots only
     */
    shipping_option_id: string,
    /** Information about the order; may be null; for bots only */
    order_info?: orderInfo,
    /** Telegram payment identifier */
    telegram_payment_charge_id: string,
    /** Provider payment identifier */
    provider_payment_charge_id: string,
  |}

  declare export type messagePaymentRefunded = {|
    /** A payment has been refunded */
    _: 'messagePaymentRefunded',
    /** Identifier of the previous owner of the Telegram Stars that refunds them */
    owner_id: MessageSender,
    /** Currency for the price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** Invoice payload; only for bots */
    invoice_payload: string /* base64 */,
    /** Telegram payment identifier */
    telegram_payment_charge_id: string,
    /** Provider payment identifier */
    provider_payment_charge_id: string,
  |}

  declare export type messageGiftedPremium = {|
    /** Telegram Premium was gifted to a user */
    _: 'messageGiftedPremium',
    /**
     * The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous
     * or is outgoing
     */
    gifter_user_id: number,
    /** The identifier of a user that received Telegram Premium; 0 if the gift is incoming */
    receiver_user_id: number,
    /** Message added to the gifted Telegram Premium by the sender */
    text: formattedText,
    /** Currency for the paid amount */
    currency: string,
    /** The paid amount, in the smallest units of the currency */
    amount: number,
    /** Cryptocurrency used to pay for the gift; may be empty if none */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency; 0 if none */
    cryptocurrency_amount: string,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  |}

  declare export type messagePremiumGiftCode = {|
    /** A Telegram Premium gift code was created for the user */
    _: 'messagePremiumGiftCode',
    /** Identifier of a chat or a user that created the gift code; may be null if unknown */
    creator_id?: MessageSender,
    /** Message added to the gift */
    text: formattedText,
    /** True, if the gift code was created for a giveaway */
    is_from_giveaway: boolean,
    /**
     * True, if the winner for the corresponding Telegram Premium subscription wasn't
     * chosen
     */
    is_unclaimed: boolean,
    /** Currency for the paid amount; empty if unknown */
    currency: string,
    /** The paid amount, in the smallest units of the currency; 0 if unknown */
    amount: number,
    /** Cryptocurrency used to pay for the gift; may be empty if none or unknown */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency; 0 if unknown */
    cryptocurrency_amount: string,
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
    /** The gift code */
    code: string,
  |}

  declare export type messageGiveawayCreated = {|
    /**
     * A giveaway was created for the chat. Use telegramPaymentPurposePremiumGiveaway,
     * storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway
     * to create a giveaway
     */
    _: 'messageGiveawayCreated',
    /**
     * Number of Telegram Stars that will be shared by winners of the giveaway; 0 for
     * Telegram Premium giveaways
     */
    star_count: number,
  |}

  declare export type messageGiveaway = {|
    /** A giveaway */
    _: 'messageGiveaway',
    /** Giveaway parameters */
    parameters: giveawayParameters,
    /** Number of users which will receive Telegram Premium subscription gift codes */
    winner_count: number,
    /** Prize of the giveaway */
    prize: GiveawayPrize,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  |}

  declare export type messageGiveawayCompleted = {|
    /** A giveaway without public winners has been completed for the chat */
    _: 'messageGiveawayCompleted',
    /** Identifier of the message with the giveaway; can be 0 if the message was deleted */
    giveaway_message_id: number,
    /** Number of winners in the giveaway */
    winner_count: number,
    /** True, if the giveaway is a Telegram Star giveaway */
    is_star_giveaway: boolean,
    /** Number of undistributed prizes; for Telegram Premium giveaways only */
    unclaimed_prize_count: number,
  |}

  declare export type messageGiveawayWinners = {|
    /** A giveaway with public winners has been completed for the chat */
    _: 'messageGiveawayWinners',
    /**
     * Identifier of the supergroup or channel chat, which was automatically boosted
     * by the winners of the giveaway
     */
    boosted_chat_id: number,
    /** Identifier of the message with the giveaway in the boosted chat */
    giveaway_message_id: number,
    /** Number of other chats that participated in the giveaway */
    additional_chat_count: number,
    /**
     * Point in time (Unix timestamp) when the winners were selected. May be bigger
     * than winners selection date specified in parameters of the giveaway
     */
    actual_winners_selection_date: number,
    /** True, if only new members of the chats were eligible for the giveaway */
    only_new_members: boolean,
    /** True, if the giveaway was canceled and was fully refunded */
    was_refunded: boolean,
    /** Prize of the giveaway */
    prize: GiveawayPrize,
    /** Additional description of the giveaway prize */
    prize_description: string,
    /** Total number of winners in the giveaway */
    winner_count: number,
    /** Up to 100 user identifiers of the winners of the giveaway */
    winner_user_ids: Array<number>,
    /** Number of undistributed prizes; for Telegram Premium giveaways only */
    unclaimed_prize_count: number,
  |}

  declare export type messageGiftedStars = {|
    /** Telegram Stars were gifted to a user */
    _: 'messageGiftedStars',
    /**
     * The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous
     * or is outgoing
     */
    gifter_user_id: number,
    /** The identifier of a user that received Telegram Stars; 0 if the gift is incoming */
    receiver_user_id: number,
    /** Currency for the paid amount */
    currency: string,
    /** The paid amount, in the smallest units of the currency */
    amount: number,
    /** Cryptocurrency used to pay for the gift; may be empty if none */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency; 0 if none */
    cryptocurrency_amount: string,
    /** Number of Telegram Stars that were gifted */
    star_count: number,
    /** Identifier of the transaction for Telegram Stars purchase; for receiver only */
    transaction_id: string,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  |}

  declare export type messageGiveawayPrizeStars = {|
    /** A Telegram Stars were received by the current user from a giveaway */
    _: 'messageGiveawayPrizeStars',
    /** Number of Telegram Stars that were received */
    star_count: number,
    /** Identifier of the transaction for Telegram Stars credit */
    transaction_id: string,
    /**
     * Identifier of the supergroup or channel chat, which was automatically boosted
     * by the winners of the giveaway
     */
    boosted_chat_id: number,
    /**
     * Identifier of the message with the giveaway in the boosted chat; can be 0 if
     * the message was deleted
     */
    giveaway_message_id: number,
    /**
     * True, if the corresponding winner wasn't chosen and the Telegram Stars were
     * received by the owner of the boosted chat
     */
    is_unclaimed: boolean,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  |}

  declare export type messageGift = {|
    /**
     * A regular gift was received or sent by the current user, or the current user
     * was notified about a channel gift
     */
    _: 'messageGift',
    /** The gift */
    gift: gift,
    /** Sender of the gift */
    sender_id: MessageSender,
    /**
     * Unique identifier of the received gift for the current user; only for the receiver
     * of the gift
     */
    received_gift_id: string,
    /** Message added to the gift */
    text: formattedText,
    /**
     * Number of Telegram Stars that can be claimed by the receiver instead of the
     * regular gift; 0 if the gift can't be sold by the receiver
     */
    sell_star_count: number,
    /**
     * Number of Telegram Stars that were paid by the sender for the ability to upgrade
     * the gift
     */
    prepaid_upgrade_star_count: number,
    /**
     * True, if the sender and gift text are shown only to the gift receiver; otherwise,
     * everyone will be able to see them
     */
    is_private: boolean,
    /**
     * True, if the gift is displayed on the user's or the channel's profile page;
     * only for the receiver of the gift
     */
    is_saved: boolean,
    /**
     * True, if the gift can be upgraded to a unique gift; only for the receiver of
     * the gift
     */
    can_be_upgraded: boolean,
    /**
     * True, if the gift was converted to Telegram Stars; only for the receiver of
     * the gift
     */
    was_converted: boolean,
    /** True, if the gift was upgraded to a unique gift */
    was_upgraded: boolean,
    /** True, if the gift was refunded and isn't available anymore */
    was_refunded: boolean,
    /**
     * Identifier of the corresponding upgraded gift; may be empty if unknown. Use
     * getReceivedGift to get information about the gift
     */
    upgraded_received_gift_id: string,
  |}

  declare export type messageUpgradedGift = {|
    /**
     * An upgraded gift was received or sent by the current user, or the current user
     * was notified about a channel gift
     */
    _: 'messageUpgradedGift',
    /** The gift */
    gift: upgradedGift,
    /** Sender of the gift; may be null for anonymous gifts */
    sender_id?: MessageSender,
    /**
     * Unique identifier of the received gift for the current user; only for the receiver
     * of the gift
     */
    received_gift_id: string,
    /**
     * True, if the gift was obtained by upgrading of a previously received gift; otherwise,
     * this is a transferred gift
     */
    is_upgrade: boolean,
    /**
     * True, if the gift is displayed on the user's or the channel's profile page;
     * only for the receiver of the gift
     */
    is_saved: boolean,
    /**
     * True, if the gift can be transferred to another owner; only for the receiver
     * of the gift
     */
    can_be_transferred: boolean,
    /**
     * True, if the gift was transferred to another owner; only for the receiver of
     * the gift
     */
    was_transferred: boolean,
    /**
     * Number of Telegram Stars that must be paid to transfer the upgraded gift; only
     * for the receiver of the gift
     */
    transfer_star_count: number,
    /**
     * Point in time (Unix timestamp) when the gift can be transferred to the TON blockchain
     * as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift
     */
    export_date: number,
  |}

  declare export type messageRefundedUpgradedGift = {|
    /** A gift which purchase, upgrade or transfer were refunded */
    _: 'messageRefundedUpgradedGift',
    /** The gift */
    gift: gift,
    /** Sender of the gift */
    sender_id: MessageSender,
    /** True, if the gift was obtained by upgrading of a previously received gift */
    is_upgrade: boolean,
  |}

  declare export type messageContactRegistered = {|
    /** A contact has registered with Telegram */
    _: 'messageContactRegistered',
  |}

  declare export type messageUsersShared = {|
    /** The current user shared users, which were requested by the bot */
    _: 'messageUsersShared',
    /** The shared users */
    users: Array<sharedUser>,
    /** Identifier of the keyboard button with the request */
    button_id: number,
  |}

  declare export type messageChatShared = {|
    /** The current user shared a chat, which was requested by the bot */
    _: 'messageChatShared',
    /** The shared chat */
    chat: sharedChat,
    /** Identifier of the keyboard button with the request */
    button_id: number,
  |}

  declare export type messageBotWriteAccessAllowed = {|
    /** The user allowed the bot to send messages */
    _: 'messageBotWriteAccessAllowed',
    /** The reason why the bot was allowed to write messages */
    reason: BotWriteAccessAllowReason,
  |}

  declare export type messageWebAppDataSent = {|
    /** Data from a Web App has been sent to a bot */
    _: 'messageWebAppDataSent',
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    button_text: string,
  |}

  declare export type messageWebAppDataReceived = {|
    /** Data from a Web App has been received; for bots only */
    _: 'messageWebAppDataReceived',
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    button_text: string,
    /** The data */
    data: string,
  |}

  declare export type messagePassportDataSent = {|
    /** Telegram Passport data has been sent to a bot */
    _: 'messagePassportDataSent',
    /** List of Telegram Passport element types sent */
    types: Array<PassportElementType>,
  |}

  declare export type messagePassportDataReceived = {|
    /** Telegram Passport data has been received; for bots only */
    _: 'messagePassportDataReceived',
    /** List of received Telegram Passport elements */
    elements: Array<encryptedPassportElement>,
    /** Encrypted data credentials */
    credentials: encryptedCredentials,
  |}

  declare export type messageProximityAlertTriggered = {|
    /** A user in the chat came within proximity alert range */
    _: 'messageProximityAlertTriggered',
    /** The identifier of a user or chat that triggered the proximity alert */
    traveler_id: MessageSender,
    /** The identifier of a user or chat that subscribed for the proximity alert */
    watcher_id: MessageSender,
    /** The distance between the users */
    distance: number,
  |}

  declare export type messageUnsupported = {|
    /** A message content that is not supported in the current TDLib version */
    _: 'messageUnsupported',
  |}

  declare export type textEntityTypeMention = {|
    /** A mention of a user, a supergroup, or a channel by their username */
    _: 'textEntityTypeMention',
  |}

  declare export type textEntityTypeMention$Input = {|
    /** A mention of a user, a supergroup, or a channel by their username */
    +_: 'textEntityTypeMention',
  |}

  declare export type textEntityTypeHashtag = {|
    /**
     * A hashtag text, beginning with "#" and optionally containing a chat username
     * at the end
     */
    _: 'textEntityTypeHashtag',
  |}

  declare export type textEntityTypeHashtag$Input = {|
    /**
     * A hashtag text, beginning with "#" and optionally containing a chat username
     * at the end
     */
    +_: 'textEntityTypeHashtag',
  |}

  declare export type textEntityTypeCashtag = {|
    /**
     * A cashtag text, beginning with "$", consisting of capital English letters (e.g.,
     * "$USD"), and optionally containing a chat username at the end
     */
    _: 'textEntityTypeCashtag',
  |}

  declare export type textEntityTypeCashtag$Input = {|
    /**
     * A cashtag text, beginning with "$", consisting of capital English letters (e.g.,
     * "$USD"), and optionally containing a chat username at the end
     */
    +_: 'textEntityTypeCashtag',
  |}

  declare export type textEntityTypeBotCommand = {|
    /** A bot command, beginning with "/" */
    _: 'textEntityTypeBotCommand',
  |}

  declare export type textEntityTypeBotCommand$Input = {|
    /** A bot command, beginning with "/" */
    +_: 'textEntityTypeBotCommand',
  |}

  declare export type textEntityTypeUrl = {|
    /** An HTTP URL */
    _: 'textEntityTypeUrl',
  |}

  declare export type textEntityTypeUrl$Input = {|
    /** An HTTP URL */
    +_: 'textEntityTypeUrl',
  |}

  declare export type textEntityTypeEmailAddress = {|
    /** An email address */
    _: 'textEntityTypeEmailAddress',
  |}

  declare export type textEntityTypeEmailAddress$Input = {|
    /** An email address */
    +_: 'textEntityTypeEmailAddress',
  |}

  declare export type textEntityTypePhoneNumber = {|
    /** A phone number */
    _: 'textEntityTypePhoneNumber',
  |}

  declare export type textEntityTypePhoneNumber$Input = {|
    /** A phone number */
    +_: 'textEntityTypePhoneNumber',
  |}

  declare export type textEntityTypeBankCardNumber = {|
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    _: 'textEntityTypeBankCardNumber',
  |}

  declare export type textEntityTypeBankCardNumber$Input = {|
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    +_: 'textEntityTypeBankCardNumber',
  |}

  declare export type textEntityTypeBold = {|
    /** A bold text */
    _: 'textEntityTypeBold',
  |}

  declare export type textEntityTypeBold$Input = {|
    /** A bold text */
    +_: 'textEntityTypeBold',
  |}

  declare export type textEntityTypeItalic = {|
    /** An italic text */
    _: 'textEntityTypeItalic',
  |}

  declare export type textEntityTypeItalic$Input = {|
    /** An italic text */
    +_: 'textEntityTypeItalic',
  |}

  declare export type textEntityTypeUnderline = {|
    /** An underlined text */
    _: 'textEntityTypeUnderline',
  |}

  declare export type textEntityTypeUnderline$Input = {|
    /** An underlined text */
    +_: 'textEntityTypeUnderline',
  |}

  declare export type textEntityTypeStrikethrough = {|
    /** A strikethrough text */
    _: 'textEntityTypeStrikethrough',
  |}

  declare export type textEntityTypeStrikethrough$Input = {|
    /** A strikethrough text */
    +_: 'textEntityTypeStrikethrough',
  |}

  declare export type textEntityTypeSpoiler = {|
    /** A spoiler text */
    _: 'textEntityTypeSpoiler',
  |}

  declare export type textEntityTypeSpoiler$Input = {|
    /** A spoiler text */
    +_: 'textEntityTypeSpoiler',
  |}

  declare export type textEntityTypeCode = {|
    /** Text that must be formatted as if inside a code HTML tag */
    _: 'textEntityTypeCode',
  |}

  declare export type textEntityTypeCode$Input = {|
    /** Text that must be formatted as if inside a code HTML tag */
    +_: 'textEntityTypeCode',
  |}

  declare export type textEntityTypePre = {|
    /** Text that must be formatted as if inside a pre HTML tag */
    _: 'textEntityTypePre',
  |}

  declare export type textEntityTypePre$Input = {|
    /** Text that must be formatted as if inside a pre HTML tag */
    +_: 'textEntityTypePre',
  |}

  declare export type textEntityTypePreCode = {|
    /** Text that must be formatted as if inside pre, and code HTML tags */
    _: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    language: string,
  |}

  declare export type textEntityTypePreCode$Input = {|
    /** Text that must be formatted as if inside pre, and code HTML tags */
    +_: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    +language?: string,
  |}

  declare export type textEntityTypeBlockQuote = {|
    /**
     * Text that must be formatted as if inside a blockquote HTML tag; not supported
     * in secret chats
     */
    _: 'textEntityTypeBlockQuote',
  |}

  declare export type textEntityTypeBlockQuote$Input = {|
    /**
     * Text that must be formatted as if inside a blockquote HTML tag; not supported
     * in secret chats
     */
    +_: 'textEntityTypeBlockQuote',
  |}

  declare export type textEntityTypeExpandableBlockQuote = {|
    /**
     * Text that must be formatted as if inside a blockquote HTML tag and collapsed
     * by default to 3 lines with the ability to show full text; not supported in secret
     * chats
     */
    _: 'textEntityTypeExpandableBlockQuote',
  |}

  declare export type textEntityTypeExpandableBlockQuote$Input = {|
    /**
     * Text that must be formatted as if inside a blockquote HTML tag and collapsed
     * by default to 3 lines with the ability to show full text; not supported in secret
     * chats
     */
    +_: 'textEntityTypeExpandableBlockQuote',
  |}

  declare export type textEntityTypeTextUrl = {|
    /** A text description shown instead of a raw URL */
    _: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    url: string,
  |}

  declare export type textEntityTypeTextUrl$Input = {|
    /** A text description shown instead of a raw URL */
    +_: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    +url?: string,
  |}

  declare export type textEntityTypeMentionName = {|
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    _: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    user_id: number,
  |}

  declare export type textEntityTypeMentionName$Input = {|
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    +_: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    +user_id?: number,
  |}

  declare export type textEntityTypeCustomEmoji = {|
    /**
     * A custom emoji. The text behind a custom emoji must be an emoji. Only premium
     * users can use premium custom emoji
     */
    _: 'textEntityTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    custom_emoji_id: string,
  |}

  declare export type textEntityTypeCustomEmoji$Input = {|
    /**
     * A custom emoji. The text behind a custom emoji must be an emoji. Only premium
     * users can use premium custom emoji
     */
    +_: 'textEntityTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    +custom_emoji_id?: number | string,
  |}

  declare export type textEntityTypeMediaTimestamp = {|
    /** A media timestamp */
    _: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note/story playing must
     * start, in seconds. The media can be in the content or the link preview of the
     * current message, or in the same places in the replied message
     */
    media_timestamp: number,
  |}

  declare export type textEntityTypeMediaTimestamp$Input = {|
    /** A media timestamp */
    +_: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note/story playing must
     * start, in seconds. The media can be in the content or the link preview of the
     * current message, or in the same places in the replied message
     */
    +media_timestamp?: number,
  |}

  declare export type inputThumbnail = {|
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    _: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    thumbnail: InputFile,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    width: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    height: number,
  |}

  declare export type inputThumbnail$Input = {|
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    +_: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    +thumbnail?: InputFile$Input,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    +width?: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    +height?: number,
  |}

  declare export type inputPaidMediaTypePhoto = {|
    /**
     * The media is a photo. The photo must be at most 10 MB in size. The photo's width
     * and height must not exceed 10000 in total. Width and height ratio must be at
     * most 20
     */
    _: 'inputPaidMediaTypePhoto',
  |}

  declare export type inputPaidMediaTypePhoto$Input = {|
    /**
     * The media is a photo. The photo must be at most 10 MB in size. The photo's width
     * and height must not exceed 10000 in total. Width and height ratio must be at
     * most 20
     */
    +_: 'inputPaidMediaTypePhoto',
  |}

  declare export type inputPaidMediaTypeVideo = {|
    /** The media is a video */
    _: 'inputPaidMediaTypeVideo',
    /** Cover of the video; pass null to skip cover uploading */
    cover: InputFile,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
    /** Duration of the video, in seconds */
    duration: number,
    /** True, if the video is expected to be streamed */
    supports_streaming: boolean,
  |}

  declare export type inputPaidMediaTypeVideo$Input = {|
    /** The media is a video */
    +_: 'inputPaidMediaTypeVideo',
    /** Cover of the video; pass null to skip cover uploading */
    +cover?: InputFile$Input,
    /** Timestamp from which the video playing must start, in seconds */
    +start_timestamp?: number,
    /** Duration of the video, in seconds */
    +duration?: number,
    /** True, if the video is expected to be streamed */
    +supports_streaming?: boolean,
  |}

  declare export type inputPaidMedia = {|
    /** Describes a paid media to be sent */
    _: 'inputPaidMedia',
    /** Type of the media */
    type: InputPaidMediaType,
    /** Photo or video to be sent */
    media: InputFile,
    /** Media thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the media, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Media width */
    width: number,
    /** Media height */
    height: number,
  |}

  declare export type inputPaidMedia$Input = {|
    /** Describes a paid media to be sent */
    +_: 'inputPaidMedia',
    /** Type of the media */
    +type?: InputPaidMediaType$Input,
    /** Photo or video to be sent */
    +media?: InputFile$Input,
    /** Media thumbnail; pass null to skip thumbnail uploading */
    +thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the media, if applicable */
    +added_sticker_file_ids?: $ReadOnlyArray<number>,
    /** Media width */
    +width?: number,
    /** Media height */
    +height?: number,
  |}

  declare export type messageSchedulingStateSendAtDate = {|
    /** The message will be sent at the specified date */
    _: 'messageSchedulingStateSendAtDate',
    /**
     * Point in time (Unix timestamp) when the message will be sent. The date must
     * be within 367 days in the future
     */
    send_date: number,
  |}

  declare export type messageSchedulingStateSendAtDate$Input = {|
    /** The message will be sent at the specified date */
    +_: 'messageSchedulingStateSendAtDate',
    /**
     * Point in time (Unix timestamp) when the message will be sent. The date must
     * be within 367 days in the future
     */
    +send_date?: number,
  |}

  declare export type messageSchedulingStateSendWhenOnline = {|
    /**
     * The message will be sent when the other user is online. Applicable to private
     * chats only and when the exact online status of the other user is known
     */
    _: 'messageSchedulingStateSendWhenOnline',
  |}

  declare export type messageSchedulingStateSendWhenOnline$Input = {|
    /**
     * The message will be sent when the other user is online. Applicable to private
     * chats only and when the exact online status of the other user is known
     */
    +_: 'messageSchedulingStateSendWhenOnline',
  |}

  declare export type messageSchedulingStateSendWhenVideoProcessed = {|
    /**
     * The message will be sent when the video in the message is converted and optimized;
     * can be used only by the server
     */
    _: 'messageSchedulingStateSendWhenVideoProcessed',
    /**
     * Approximate point in time (Unix timestamp) when the message is expected to be
     * sent
     */
    send_date: number,
  |}

  declare export type messageSchedulingStateSendWhenVideoProcessed$Input = {|
    /**
     * The message will be sent when the video in the message is converted and optimized;
     * can be used only by the server
     */
    +_: 'messageSchedulingStateSendWhenVideoProcessed',
    /**
     * Approximate point in time (Unix timestamp) when the message is expected to be
     * sent
     */
    +send_date?: number,
  |}

  declare export type messageSelfDestructTypeTimer = {|
    /**
     * The message will be self-destructed in the specified time after its content
     * was opened
     */
    _: 'messageSelfDestructTypeTimer',
    /**
     * The message's self-destruct time, in seconds; must be between 0 and 60 in private
     * chats
     */
    self_destruct_time: number,
  |}

  declare export type messageSelfDestructTypeTimer$Input = {|
    /**
     * The message will be self-destructed in the specified time after its content
     * was opened
     */
    +_: 'messageSelfDestructTypeTimer',
    /**
     * The message's self-destruct time, in seconds; must be between 0 and 60 in private
     * chats
     */
    +self_destruct_time?: number,
  |}

  declare export type messageSelfDestructTypeImmediately = {|
    /** The message can be opened only once and will be self-destructed once closed */
    _: 'messageSelfDestructTypeImmediately',
  |}

  declare export type messageSelfDestructTypeImmediately$Input = {|
    /** The message can be opened only once and will be self-destructed once closed */
    +_: 'messageSelfDestructTypeImmediately',
  |}

  declare export type messageSendOptions$Input = {|
    /** Options to be used when a message is sent */
    +_: 'messageSendOptions',
    /** Pass true to disable notification for the message */
    +disable_notification?: boolean,
    /** Pass true if the message is sent from the background */
    +from_background?: boolean,
    /**
     * Pass true if the content of the message must be protected from forwarding and
     * saving; for bots only
     */
    +protect_content?: boolean,
    /**
     * Pass true to allow the message to ignore regular broadcast limits for a small
     * fee; for bots only
     */
    +allow_paid_broadcast?: boolean,
    /** The number of Telegram Stars the user agreed to pay to send the messages */
    +paid_message_star_count?: number,
    /**
     * Pass true if the user explicitly chosen a sticker or a custom emoji from an
     * installed sticker set; applicable only to sendMessage and sendMessageAlbum
     */
    +update_order_of_installed_sticker_sets?: boolean,
    /**
     * Message scheduling state; pass null to send message immediately. Messages sent
     * to a secret chat, to a chat with paid messages, live location messages and self-destructing
     * messages can't be scheduled
     */
    +scheduling_state?: MessageSchedulingState$Input,
    /**
     * Identifier of the effect to apply to the message; pass 0 if none; applicable
     * only to sendMessage and sendMessageAlbum in private chats
     */
    +effect_id?: number | string,
    /**
     * Non-persistent identifier, which will be returned back in messageSendingStatePending
     * object and can be used to match sent messages and corresponding updateNewMessage
     * updates
     */
    +sending_id?: number,
    /** Pass true to get a fake message instead of actually sending them */
    +only_preview?: boolean,
  |}

  declare export type messageCopyOptions = {|
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages, messages with messageInvoice, messagePaidMedia,
     * messageGiveaway, or messageGiveawayWinners content can't be copied
     */
    _: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local. Use messageProperties.can_be_saved and messageProperties.can_be_copied_to_secret_chat
     * to check whether the message is suitable
     */
    send_copy: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    replace_caption: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    new_caption: formattedText,
    /**
     * True, if new caption must be shown above the media; otherwise, new caption must
     * be shown below the media; not supported in secret chats. Ignored if replace_caption
     * is false
     */
    new_show_caption_above_media: boolean,
  |}

  declare export type messageCopyOptions$Input = {|
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages, messages with messageInvoice, messagePaidMedia,
     * messageGiveaway, or messageGiveawayWinners content can't be copied
     */
    +_: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local. Use messageProperties.can_be_saved and messageProperties.can_be_copied_to_secret_chat
     * to check whether the message is suitable
     */
    +send_copy?: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    +replace_caption?: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    +new_caption?: formattedText$Input,
    /**
     * True, if new caption must be shown above the media; otherwise, new caption must
     * be shown below the media; not supported in secret chats. Ignored if replace_caption
     * is false
     */
    +new_show_caption_above_media?: boolean,
  |}

  declare export type inputMessageText = {|
    /** A text message */
    _: 'inputMessageText',
    /**
     * Formatted text to be sent; 0-getOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote,
     * ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are
     * allowed to be specified manually
     */
    text: formattedText,
    /**
     * Options to be used for generation of a link preview; may be null if none; pass
     * null to use default link preview options
     */
    link_preview_options?: linkPreviewOptions,
    /** True, if a chat message draft must be deleted */
    clear_draft: boolean,
  |}

  declare export type inputMessageText$Input = {|
    /** A text message */
    +_: 'inputMessageText',
    /**
     * Formatted text to be sent; 0-getOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote,
     * ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are
     * allowed to be specified manually
     */
    +text?: formattedText$Input,
    /**
     * Options to be used for generation of a link preview; may be null if none; pass
     * null to use default link preview options
     */
    +link_preview_options?: linkPreviewOptions$Input,
    /** True, if a chat message draft must be deleted */
    +clear_draft?: boolean,
  |}

  declare export type inputMessageAnimation = {|
    /** An animation message (GIF-style). */
    _: 'inputMessageAnimation',
    /** Animation file to be sent */
    animation: InputFile,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the animation, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the animation, in seconds */
    duration: number,
    /** Width of the animation; may be replaced by the server */
    width: number,
    /** Height of the animation; may be replaced by the server */
    height: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the animation; otherwise, the caption
     * must be shown below the animation; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /**
     * True, if the animation preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  |}

  declare export type inputMessageAnimation$Input = {|
    /** An animation message (GIF-style). */
    +_: 'inputMessageAnimation',
    /** Animation file to be sent */
    +animation?: InputFile$Input,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    +thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the animation, if applicable */
    +added_sticker_file_ids?: $ReadOnlyArray<number>,
    /** Duration of the animation, in seconds */
    +duration?: number,
    /** Width of the animation; may be replaced by the server */
    +width?: number,
    /** Height of the animation; may be replaced by the server */
    +height?: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the animation; otherwise, the caption
     * must be shown below the animation; not supported in secret chats
     */
    +show_caption_above_media?: boolean,
    /**
     * True, if the animation preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    +has_spoiler?: boolean,
  |}

  declare export type inputMessageAudio = {|
    /** An audio message */
    _: 'inputMessageAudio',
    /** Audio file to be sent */
    audio: InputFile,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    album_cover_thumbnail: inputThumbnail,
    /** Duration of the audio, in seconds; may be replaced by the server */
    duration: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    title: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    performer: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  |}

  declare export type inputMessageAudio$Input = {|
    /** An audio message */
    +_: 'inputMessageAudio',
    /** Audio file to be sent */
    +audio?: InputFile$Input,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    +album_cover_thumbnail?: inputThumbnail$Input,
    /** Duration of the audio, in seconds; may be replaced by the server */
    +duration?: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    +title?: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    +performer?: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
  |}

  declare export type inputMessageDocument = {|
    /** A document message (general file) */
    _: 'inputMessageDocument',
    /** Document to be sent */
    document: InputFile,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /**
     * Pass true to disable automatic file type detection and send the document as
     * a file. Always true for files sent to secret chats
     */
    disable_content_type_detection: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  |}

  declare export type inputMessageDocument$Input = {|
    /** A document message (general file) */
    +_: 'inputMessageDocument',
    /** Document to be sent */
    +document?: InputFile$Input,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    +thumbnail?: inputThumbnail$Input,
    /**
     * Pass true to disable automatic file type detection and send the document as
     * a file. Always true for files sent to secret chats
     */
    +disable_content_type_detection?: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
  |}

  declare export type inputMessagePaidMedia = {|
    /** A message with paid media; can be used only in channel chats with supergroupFullInfo.has_paid_media_allowed */
    _: 'inputMessagePaidMedia',
    /** The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max") */
    star_count: number,
    /** The content of the paid media */
    paid_media: Array<inputPaidMedia>,
    /**
     * Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the media; otherwise, the caption must
     * be shown below the media; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /** Bot-provided data for the paid media; bots only */
    payload: string,
  |}

  declare export type inputMessagePaidMedia$Input = {|
    /** A message with paid media; can be used only in channel chats with supergroupFullInfo.has_paid_media_allowed */
    +_: 'inputMessagePaidMedia',
    /** The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max") */
    +star_count?: number,
    /** The content of the paid media */
    +paid_media?: $ReadOnlyArray<inputPaidMedia$Input>,
    /**
     * Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the media; otherwise, the caption must
     * be shown below the media; not supported in secret chats
     */
    +show_caption_above_media?: boolean,
    /** Bot-provided data for the paid media; bots only */
    +payload?: string,
  |}

  declare export type inputMessagePhoto = {|
    /** A photo message */
    _: 'inputMessagePhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo's width and
     * height must not exceed 10000 in total. Width and height ratio must be at most
     * 20
     */
    photo: InputFile,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the photo, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Photo width */
    width: number,
    /** Photo height */
    height: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the photo; otherwise, the caption must
     * be shown below the photo; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /** Photo self-destruct type; pass null if none; private chats only */
    self_destruct_type: MessageSelfDestructType,
    /**
     * True, if the photo preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  |}

  declare export type inputMessagePhoto$Input = {|
    /** A photo message */
    +_: 'inputMessagePhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo's width and
     * height must not exceed 10000 in total. Width and height ratio must be at most
     * 20
     */
    +photo?: InputFile$Input,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    +thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the photo, if applicable */
    +added_sticker_file_ids?: $ReadOnlyArray<number>,
    /** Photo width */
    +width?: number,
    /** Photo height */
    +height?: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the photo; otherwise, the caption must
     * be shown below the photo; not supported in secret chats
     */
    +show_caption_above_media?: boolean,
    /** Photo self-destruct type; pass null if none; private chats only */
    +self_destruct_type?: MessageSelfDestructType$Input,
    /**
     * True, if the photo preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    +has_spoiler?: boolean,
  |}

  declare export type inputMessageSticker = {|
    /** A sticker message */
    _: 'inputMessageSticker',
    /** Sticker to be sent */
    sticker: InputFile,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** Sticker width */
    width: number,
    /** Sticker height */
    height: number,
    /** Emoji used to choose the sticker */
    emoji: string,
  |}

  declare export type inputMessageSticker$Input = {|
    /** A sticker message */
    +_: 'inputMessageSticker',
    /** Sticker to be sent */
    +sticker?: InputFile$Input,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    +thumbnail?: inputThumbnail$Input,
    /** Sticker width */
    +width?: number,
    /** Sticker height */
    +height?: number,
    /** Emoji used to choose the sticker */
    +emoji?: string,
  |}

  declare export type inputMessageVideo = {|
    /** A video message */
    _: 'inputMessageVideo',
    /**
     * Video to be sent. The video is expected to be re-encoded to MPEG4 format with
     * H.264 codec by the sender
     */
    video: InputFile,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /**
     * Cover of the video; pass null to skip cover uploading; not supported in secret
     * chats and for self-destructing messages
     */
    cover: InputFile,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
    /** File identifiers of the stickers added to the video, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /** True, if the video is expected to be streamed */
    supports_streaming: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the video; otherwise, the caption must
     * be shown below the video; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /** Video self-destruct type; pass null if none; private chats only */
    self_destruct_type: MessageSelfDestructType,
    /**
     * True, if the video preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  |}

  declare export type inputMessageVideo$Input = {|
    /** A video message */
    +_: 'inputMessageVideo',
    /**
     * Video to be sent. The video is expected to be re-encoded to MPEG4 format with
     * H.264 codec by the sender
     */
    +video?: InputFile$Input,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    +thumbnail?: inputThumbnail$Input,
    /**
     * Cover of the video; pass null to skip cover uploading; not supported in secret
     * chats and for self-destructing messages
     */
    +cover?: InputFile$Input,
    /** Timestamp from which the video playing must start, in seconds */
    +start_timestamp?: number,
    /** File identifiers of the stickers added to the video, if applicable */
    +added_sticker_file_ids?: $ReadOnlyArray<number>,
    /** Duration of the video, in seconds */
    +duration?: number,
    /** Video width */
    +width?: number,
    /** Video height */
    +height?: number,
    /** True, if the video is expected to be streamed */
    +supports_streaming?: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the video; otherwise, the caption must
     * be shown below the video; not supported in secret chats
     */
    +show_caption_above_media?: boolean,
    /** Video self-destruct type; pass null if none; private chats only */
    +self_destruct_type?: MessageSelfDestructType$Input,
    /**
     * True, if the video preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    +has_spoiler?: boolean,
  |}

  declare export type inputMessageVideoNote = {|
    /** A video note message */
    _: 'inputMessageVideoNote',
    /**
     * Video note to be sent. The video is expected to be encoded to MPEG4 format with
     * H.264 codec and have no data outside of the visible circle
     */
    video_note: InputFile,
    /** Video thumbnail; may be null if empty; pass null to skip thumbnail uploading */
    thumbnail?: inputThumbnail,
    /** Duration of the video, in seconds; 0-60 */
    duration: number,
    /** Video width and height; must be positive and not greater than 640 */
    length: number,
    /**
     * Video note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    self_destruct_type?: MessageSelfDestructType,
  |}

  declare export type inputMessageVideoNote$Input = {|
    /** A video note message */
    +_: 'inputMessageVideoNote',
    /**
     * Video note to be sent. The video is expected to be encoded to MPEG4 format with
     * H.264 codec and have no data outside of the visible circle
     */
    +video_note?: InputFile$Input,
    /** Video thumbnail; may be null if empty; pass null to skip thumbnail uploading */
    +thumbnail?: inputThumbnail$Input,
    /** Duration of the video, in seconds; 0-60 */
    +duration?: number,
    /** Video width and height; must be positive and not greater than 640 */
    +length?: number,
    /**
     * Video note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    +self_destruct_type?: MessageSelfDestructType$Input,
  |}

  declare export type inputMessageVoiceNote = {|
    /** A voice note message */
    _: 'inputMessageVoiceNote',
    /**
     * Voice note to be sent. The voice note must be encoded with the Opus codec and
     * stored inside an OGG container with a single audio channel, or be in MP3 or
     * M4A format as regular audio
     */
    voice_note: InputFile,
    /** Duration of the voice note, in seconds */
    duration: number,
    /** Waveform representation of the voice note in 5-bit format */
    waveform: string /* base64 */,
    /**
     * Voice note caption; may be null if empty; pass null to use an empty caption;
     * 0-getOption("message_caption_length_max") characters
     */
    caption?: formattedText,
    /**
     * Voice note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    self_destruct_type?: MessageSelfDestructType,
  |}

  declare export type inputMessageVoiceNote$Input = {|
    /** A voice note message */
    +_: 'inputMessageVoiceNote',
    /**
     * Voice note to be sent. The voice note must be encoded with the Opus codec and
     * stored inside an OGG container with a single audio channel, or be in MP3 or
     * M4A format as regular audio
     */
    +voice_note?: InputFile$Input,
    /** Duration of the voice note, in seconds */
    +duration?: number,
    /** Waveform representation of the voice note in 5-bit format */
    +waveform?: string /* base64 */,
    /**
     * Voice note caption; may be null if empty; pass null to use an empty caption;
     * 0-getOption("message_caption_length_max") characters
     */
    +caption?: formattedText$Input,
    /**
     * Voice note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    +self_destruct_type?: MessageSelfDestructType$Input,
  |}

  declare export type inputMessageLocation = {|
    /** A message with a location */
    _: 'inputMessageLocation',
    /** Location to be sent */
    location: location,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location,
     * and 0 otherwise
     */
    live_period: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    proximity_alert_radius: number,
  |}

  declare export type inputMessageLocation$Input = {|
    /** A message with a location */
    +_: 'inputMessageLocation',
    /** Location to be sent */
    +location?: location$Input,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location,
     * and 0 otherwise
     */
    +live_period?: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    +heading?: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    +proximity_alert_radius?: number,
  |}

  declare export type inputMessageVenue = {|
    /** A message with information about a venue */
    _: 'inputMessageVenue',
    /** Venue to send */
    venue: venue,
  |}

  declare export type inputMessageVenue$Input = {|
    /** A message with information about a venue */
    +_: 'inputMessageVenue',
    /** Venue to send */
    +venue?: venue$Input,
  |}

  declare export type inputMessageContact = {|
    /** A message containing a user contact */
    _: 'inputMessageContact',
    /** Contact to send */
    contact: contact,
  |}

  declare export type inputMessageContact$Input = {|
    /** A message containing a user contact */
    +_: 'inputMessageContact',
    /** Contact to send */
    +contact?: contact$Input,
  |}

  declare export type inputMessageDice = {|
    /** A dice message */
    _: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** True, if the chat message draft must be deleted */
    clear_draft: boolean,
  |}

  declare export type inputMessageDice$Input = {|
    /** A dice message */
    +_: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    +emoji?: string,
    /** True, if the chat message draft must be deleted */
    +clear_draft?: boolean,
  |}

  declare export type inputMessageGame = {|
    /** A message with a game; not supported for channels or secret chats */
    _: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    bot_user_id: number,
    /** Short name of the game */
    game_short_name: string,
  |}

  declare export type inputMessageGame$Input = {|
    /** A message with a game; not supported for channels or secret chats */
    +_: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    +bot_user_id?: number,
    /** Short name of the game */
    +game_short_name?: string,
  |}

  declare export type inputMessageInvoice = {|
    /** A message with an invoice; can be used only by bots */
    _: 'inputMessageInvoice',
    /** Invoice */
    invoice: invoice,
    /** Product title; 1-32 characters */
    title: string,
    /** Product description; 0-255 characters */
    description: string,
    /** Product photo URL; optional */
    photo_url: string,
    /** Product photo size */
    photo_size: number,
    /** Product photo width */
    photo_width: number,
    /** Product photo height */
    photo_height: number,
    /** The invoice payload */
    payload: string /* base64 */,
    /** Payment provider token; may be empty for payments in Telegram Stars */
    provider_token: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    provider_data: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    start_parameter: string,
    /** The content of paid media attached to the invoice; pass null if none */
    paid_media: inputPaidMedia,
    /**
     * Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    paid_media_caption: formattedText,
  |}

  declare export type inputMessageInvoice$Input = {|
    /** A message with an invoice; can be used only by bots */
    +_: 'inputMessageInvoice',
    /** Invoice */
    +invoice?: invoice$Input,
    /** Product title; 1-32 characters */
    +title?: string,
    /** Product description; 0-255 characters */
    +description?: string,
    /** Product photo URL; optional */
    +photo_url?: string,
    /** Product photo size */
    +photo_size?: number,
    /** Product photo width */
    +photo_width?: number,
    /** Product photo height */
    +photo_height?: number,
    /** The invoice payload */
    +payload?: string /* base64 */,
    /** Payment provider token; may be empty for payments in Telegram Stars */
    +provider_token?: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    +provider_data?: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    +start_parameter?: string,
    /** The content of paid media attached to the invoice; pass null if none */
    +paid_media?: inputPaidMedia$Input,
    /**
     * Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +paid_media_caption?: formattedText$Input,
  |}

  declare export type inputMessagePoll = {|
    /**
     * A message with a poll. Polls can't be sent to secret chats. Polls can be sent
     * only to a private chat with a bot
     */
    _: 'inputMessagePoll',
    /**
     * Poll question; 1-255 characters (up to 300 characters for bots). Only custom
     * emoji entities are allowed to be added and only by Premium users
     */
    question: formattedText,
    /**
     * List of poll answer options, 2-10 strings 1-100 characters each. Only custom
     * emoji entities are allowed to be added and only by Premium users
     */
    options: Array<formattedText>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    open_period: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    close_date: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    is_closed: boolean,
  |}

  declare export type inputMessagePoll$Input = {|
    /**
     * A message with a poll. Polls can't be sent to secret chats. Polls can be sent
     * only to a private chat with a bot
     */
    +_: 'inputMessagePoll',
    /**
     * Poll question; 1-255 characters (up to 300 characters for bots). Only custom
     * emoji entities are allowed to be added and only by Premium users
     */
    +question?: formattedText$Input,
    /**
     * List of poll answer options, 2-10 strings 1-100 characters each. Only custom
     * emoji entities are allowed to be added and only by Premium users
     */
    +options?: $ReadOnlyArray<formattedText$Input>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    +is_anonymous?: boolean,
    /** Type of the poll */
    +type?: PollType$Input,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    +open_period?: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    +close_date?: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    +is_closed?: boolean,
  |}

  declare export type inputMessageStory = {|
    /**
     * A message with a forwarded story. Stories can't be sent to secret chats. A story
     * can be forwarded only if story.can_be_forwarded
     */
    _: 'inputMessageStory',
    /** Identifier of the chat that posted the story */
    story_sender_chat_id: number,
    /** Story identifier */
    story_id: number,
  |}

  declare export type inputMessageStory$Input = {|
    /**
     * A message with a forwarded story. Stories can't be sent to secret chats. A story
     * can be forwarded only if story.can_be_forwarded
     */
    +_: 'inputMessageStory',
    /** Identifier of the chat that posted the story */
    +story_sender_chat_id?: number,
    /** Story identifier */
    +story_id?: number,
  |}

  declare export type inputMessageForwarded = {|
    /** A forwarded message */
    _: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    from_chat_id: number,
    /** Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded */
    message_id: number,
    /**
     * Pass true if a game message is being shared from a launched game; applies only
     * to game messages
     */
    in_game_share: boolean,
    /** Pass true to replace video start timestamp in the forwarded message */
    replace_video_start_timestamp: boolean,
    /** The new video start timestamp; ignored if replace_video_start_timestamp == false */
    new_video_start_timestamp: number,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    copy_options: messageCopyOptions,
  |}

  declare export type inputMessageForwarded$Input = {|
    /** A forwarded message */
    +_: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    +from_chat_id?: number,
    /** Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded */
    +message_id?: number,
    /**
     * Pass true if a game message is being shared from a launched game; applies only
     * to game messages
     */
    +in_game_share?: boolean,
    /** Pass true to replace video start timestamp in the forwarded message */
    +replace_video_start_timestamp?: boolean,
    /** The new video start timestamp; ignored if replace_video_start_timestamp == false */
    +new_video_start_timestamp?: number,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    +copy_options?: messageCopyOptions$Input,
  |}

  declare export type messageProperties = {|
    /**
     * Contains properties of a message and describes actions that can be done with
     * the message right now
     */
    _: 'messageProperties',
    /**
     * True, if content of the message can be copied to a secret chat using inputMessageForwarded
     * or forwardMessages with copy options
     */
    can_be_copied_to_secret_chat: boolean,
    /**
     * True, if the message can be deleted only for the current user while other users
     * will continue to see it using the method deleteMessages with revoke == false
     */
    can_be_deleted_only_for_self: boolean,
    /**
     * True, if the message can be deleted for all users using the method deleteMessages
     * with revoke == true
     */
    can_be_deleted_for_all_users: boolean,
    /**
     * True, if the message can be edited using the methods editMessageText, editMessageCaption,
     * or editMessageReplyMarkup. For live location and poll messages this fields shows
     * whether editMessageLiveLocation or stopPoll can be used with this message
     */
    can_be_edited: boolean,
    /** True, if the message can be forwarded using inputMessageForwarded or forwardMessages */
    can_be_forwarded: boolean,
    /** True, if the message can be paid using inputInvoiceMessage */
    can_be_paid: boolean,
    /**
     * True, if the message can be pinned or unpinned in the chat using pinChatMessage
     * or unpinChatMessage
     */
    can_be_pinned: boolean,
    /** True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage */
    can_be_replied: boolean,
    /** True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage */
    can_be_replied_in_another_chat: boolean,
    /**
     * True, if content of the message can be saved locally or copied using inputMessageForwarded
     * or forwardMessages with copy options
     */
    can_be_saved: boolean,
    /** True, if the message can be shared in a story using inputStoryAreaTypeMessage */
    can_be_shared_in_story: boolean,
    /** True, if the message can be edited using the method editMessageMedia */
    can_edit_media: boolean,
    /** True, if scheduling state of the message can be edited */
    can_edit_scheduling_state: boolean,
    /** True, if code for message embedding can be received using getMessageEmbeddingCode */
    can_get_embedding_code: boolean,
    /** True, if a link can be generated for the message using getMessageLink */
    can_get_link: boolean,
    /**
     * True, if media timestamp links can be generated for media timestamp entities
     * in the message text, caption or link preview description using getMessageLink
     */
    can_get_media_timestamp_links: boolean,
    /**
     * True, if information about the message thread is available through getMessageThread
     * and getMessageThreadHistory
     */
    can_get_message_thread: boolean,
    /** True, if read date of the message can be received through getMessageReadDate */
    can_get_read_date: boolean,
    /**
     * True, if message statistics are available through getMessageStatistics and message
     * forwards can be received using getMessagePublicForwards
     */
    can_get_statistics: boolean,
    /** True, if chat members already viewed the message can be received through getMessageViewers */
    can_get_viewers: boolean,
    /** True, if speech can be recognized for the message through recognizeSpeech */
    can_recognize_speech: boolean,
    /** True, if the message can be reported using reportChat */
    can_report_chat: boolean,
    /** True, if reactions on the message can be reported through reportMessageReactions */
    can_report_reactions: boolean,
    /** True, if the message can be reported using reportSupergroupSpam */
    can_report_supergroup_spam: boolean,
    /** True, if fact check for the message can be changed through setMessageFactCheck */
    can_set_fact_check: boolean,
    /** True, if message statistics must be available from context menu of the message */
    need_show_statistics: boolean,
  |}

  declare export type searchMessagesFilterEmpty$Input = {|
    /** Returns all found messages, no filter is applied */
    +_: 'searchMessagesFilterEmpty',
  |}

  declare export type searchMessagesFilterAnimation$Input = {|
    /** Returns only animation messages */
    +_: 'searchMessagesFilterAnimation',
  |}

  declare export type searchMessagesFilterAudio$Input = {|
    /** Returns only audio messages */
    +_: 'searchMessagesFilterAudio',
  |}

  declare export type searchMessagesFilterDocument$Input = {|
    /** Returns only document messages */
    +_: 'searchMessagesFilterDocument',
  |}

  declare export type searchMessagesFilterPhoto$Input = {|
    /** Returns only photo messages */
    +_: 'searchMessagesFilterPhoto',
  |}

  declare export type searchMessagesFilterVideo$Input = {|
    /** Returns only video messages */
    +_: 'searchMessagesFilterVideo',
  |}

  declare export type searchMessagesFilterVoiceNote$Input = {|
    /** Returns only voice note messages */
    +_: 'searchMessagesFilterVoiceNote',
  |}

  declare export type searchMessagesFilterPhotoAndVideo$Input = {|
    /** Returns only photo and video messages */
    +_: 'searchMessagesFilterPhotoAndVideo',
  |}

  declare export type searchMessagesFilterUrl$Input = {|
    /** Returns only messages containing URLs */
    +_: 'searchMessagesFilterUrl',
  |}

  declare export type searchMessagesFilterChatPhoto$Input = {|
    /** Returns only messages containing chat photos */
    +_: 'searchMessagesFilterChatPhoto',
  |}

  declare export type searchMessagesFilterVideoNote$Input = {|
    /** Returns only video note messages */
    +_: 'searchMessagesFilterVideoNote',
  |}

  declare export type searchMessagesFilterVoiceAndVideoNote$Input = {|
    /** Returns only voice and video note messages */
    +_: 'searchMessagesFilterVoiceAndVideoNote',
  |}

  declare export type searchMessagesFilterMention$Input = {|
    /**
     * Returns only messages with mentions of the current user, or messages that are
     * replies to their messages
     */
    +_: 'searchMessagesFilterMention',
  |}

  declare export type searchMessagesFilterUnreadMention$Input = {|
    /**
     * Returns only messages with unread mentions of the current user, or messages
     * that are replies to their messages. When using this filter the results can't
     * be additionally filtered by a query, a message thread or by the sending user
     */
    +_: 'searchMessagesFilterUnreadMention',
  |}

  declare export type searchMessagesFilterUnreadReaction$Input = {|
    /**
     * Returns only messages with unread reactions for the current user. When using
     * this filter the results can't be additionally filtered by a query, a message
     * thread or by the sending user
     */
    +_: 'searchMessagesFilterUnreadReaction',
  |}

  declare export type searchMessagesFilterFailedToSend$Input = {|
    /**
     * Returns only failed to send messages. This filter can be used only if the message
     * database is used
     */
    +_: 'searchMessagesFilterFailedToSend',
  |}

  declare export type searchMessagesFilterPinned$Input = {|
    /** Returns only pinned messages */
    +_: 'searchMessagesFilterPinned',
  |}

  declare export type searchMessagesChatTypeFilterPrivate$Input = {|
    /** Returns only messages in private chats */
    +_: 'searchMessagesChatTypeFilterPrivate',
  |}

  declare export type searchMessagesChatTypeFilterGroup$Input = {|
    /** Returns only messages in basic group and supergroup chats */
    +_: 'searchMessagesChatTypeFilterGroup',
  |}

  declare export type searchMessagesChatTypeFilterChannel$Input = {|
    /** Returns only messages in channel chats */
    +_: 'searchMessagesChatTypeFilterChannel',
  |}

  declare export type chatActionTyping = {|
    /** The user is typing a message */
    _: 'chatActionTyping',
  |}

  declare export type chatActionTyping$Input = {|
    /** The user is typing a message */
    +_: 'chatActionTyping',
  |}

  declare export type chatActionRecordingVideo = {|
    /** The user is recording a video */
    _: 'chatActionRecordingVideo',
  |}

  declare export type chatActionRecordingVideo$Input = {|
    /** The user is recording a video */
    +_: 'chatActionRecordingVideo',
  |}

  declare export type chatActionUploadingVideo = {|
    /** The user is uploading a video */
    _: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    progress: number,
  |}

  declare export type chatActionUploadingVideo$Input = {|
    /** The user is uploading a video */
    +_: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    +progress?: number,
  |}

  declare export type chatActionRecordingVoiceNote = {|
    /** The user is recording a voice note */
    _: 'chatActionRecordingVoiceNote',
  |}

  declare export type chatActionRecordingVoiceNote$Input = {|
    /** The user is recording a voice note */
    +_: 'chatActionRecordingVoiceNote',
  |}

  declare export type chatActionUploadingVoiceNote = {|
    /** The user is uploading a voice note */
    _: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    progress: number,
  |}

  declare export type chatActionUploadingVoiceNote$Input = {|
    /** The user is uploading a voice note */
    +_: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    +progress?: number,
  |}

  declare export type chatActionUploadingPhoto = {|
    /** The user is uploading a photo */
    _: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    progress: number,
  |}

  declare export type chatActionUploadingPhoto$Input = {|
    /** The user is uploading a photo */
    +_: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    +progress?: number,
  |}

  declare export type chatActionUploadingDocument = {|
    /** The user is uploading a document */
    _: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    progress: number,
  |}

  declare export type chatActionUploadingDocument$Input = {|
    /** The user is uploading a document */
    +_: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    +progress?: number,
  |}

  declare export type chatActionChoosingSticker = {|
    /** The user is picking a sticker to send */
    _: 'chatActionChoosingSticker',
  |}

  declare export type chatActionChoosingSticker$Input = {|
    /** The user is picking a sticker to send */
    +_: 'chatActionChoosingSticker',
  |}

  declare export type chatActionChoosingLocation = {|
    /** The user is picking a location or venue to send */
    _: 'chatActionChoosingLocation',
  |}

  declare export type chatActionChoosingLocation$Input = {|
    /** The user is picking a location or venue to send */
    +_: 'chatActionChoosingLocation',
  |}

  declare export type chatActionChoosingContact = {|
    /** The user is picking a contact to send */
    _: 'chatActionChoosingContact',
  |}

  declare export type chatActionChoosingContact$Input = {|
    /** The user is picking a contact to send */
    +_: 'chatActionChoosingContact',
  |}

  declare export type chatActionStartPlayingGame = {|
    /** The user has started to play a game */
    _: 'chatActionStartPlayingGame',
  |}

  declare export type chatActionStartPlayingGame$Input = {|
    /** The user has started to play a game */
    +_: 'chatActionStartPlayingGame',
  |}

  declare export type chatActionRecordingVideoNote = {|
    /** The user is recording a video note */
    _: 'chatActionRecordingVideoNote',
  |}

  declare export type chatActionRecordingVideoNote$Input = {|
    /** The user is recording a video note */
    +_: 'chatActionRecordingVideoNote',
  |}

  declare export type chatActionUploadingVideoNote = {|
    /** The user is uploading a video note */
    _: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    progress: number,
  |}

  declare export type chatActionUploadingVideoNote$Input = {|
    /** The user is uploading a video note */
    +_: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    +progress?: number,
  |}

  declare export type chatActionWatchingAnimations = {|
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    _: 'chatActionWatchingAnimations',
    /** The animated emoji */
    emoji: string,
  |}

  declare export type chatActionWatchingAnimations$Input = {|
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    +_: 'chatActionWatchingAnimations',
    /** The animated emoji */
    +emoji?: string,
  |}

  declare export type chatActionCancel = {|
    /** The user has canceled the previous action */
    _: 'chatActionCancel',
  |}

  declare export type chatActionCancel$Input = {|
    /** The user has canceled the previous action */
    +_: 'chatActionCancel',
  |}

  declare export type userStatusEmpty = {|
    /** The user's status has never been changed */
    _: 'userStatusEmpty',
  |}

  declare export type userStatusOnline = {|
    /** The user is online */
    _: 'userStatusOnline',
    /** Point in time (Unix timestamp) when the user's online status will expire */
    expires: number,
  |}

  declare export type userStatusOffline = {|
    /** The user is offline */
    _: 'userStatusOffline',
    /** Point in time (Unix timestamp) when the user was last online */
    was_online: number,
  |}

  declare export type userStatusRecently = {|
    /** The user was online recently */
    _: 'userStatusRecently',
    /**
     * Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus
     * privacy setting for the user and has no Telegram Premium
     */
    by_my_privacy_settings: boolean,
  |}

  declare export type userStatusLastWeek = {|
    /** The user is offline, but was online last week */
    _: 'userStatusLastWeek',
    /**
     * Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus
     * privacy setting for the user and has no Telegram Premium
     */
    by_my_privacy_settings: boolean,
  |}

  declare export type userStatusLastMonth = {|
    /** The user is offline, but was online last month */
    _: 'userStatusLastMonth',
    /**
     * Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus
     * privacy setting for the user and has no Telegram Premium
     */
    by_my_privacy_settings: boolean,
  |}

  declare export type emojiKeyword = {|
    /** Represents an emoji with its keyword */
    _: 'emojiKeyword',
    /** The emoji */
    emoji: string,
    /** The keyword */
    keyword: string,
  |}

  declare export type emojiKeywords = {|
    /** Represents a list of emojis with their keywords */
    _: 'emojiKeywords',
    /** List of emojis with their keywords */
    emoji_keywords: Array<emojiKeyword>,
  |}

  declare export type stickers = {|
    /** Represents a list of stickers */
    _: 'stickers',
    /** List of stickers */
    stickers: Array<sticker>,
  |}

  declare export type emojis = {|
    /** Represents a list of emojis */
    _: 'emojis',
    /** List of emojis */
    emojis: Array<string>,
  |}

  declare export type stickerSet = {|
    /** Represents a sticker set */
    _: 'stickerSet',
    /** Identifier of the sticker set */
    id: string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100;
     * may be null. The file can be downloaded only before the thumbnail is changed
     */
    thumbnail?: thumbnail,
    /** Sticker set thumbnail's outline; may be null if unknown */
    thumbnail_outline?: outline,
    /** True, if the sticker set is owned by the current user */
    is_owned: boolean,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** Type of the stickers in the set */
    sticker_type: StickerType,
    /**
     * True, if stickers in the sticker set are custom emoji that must be repainted;
     * for custom emoji sticker sets only
     */
    needs_repainting: boolean,
    /**
     * True, if stickers in the sticker set are custom emoji that can be used as chat
     * emoji status; for custom emoji sticker sets only
     */
    is_allowed_as_chat_emoji_status: boolean,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** List of stickers in this set */
    stickers: Array<sticker>,
    /**
     * A list of emojis corresponding to the stickers in the same order. The list is
     * only for informational purposes, because a sticker is always sent with a fixed
     * emoji from the corresponding Sticker object
     */
    emojis: Array<emojis>,
  |}

  declare export type stickerSetInfo = {|
    /** Represents short information about a sticker set */
    _: 'stickerSetInfo',
    /** Identifier of the sticker set */
    id: string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100;
     * may be null. The file can be downloaded only before the thumbnail is changed
     */
    thumbnail?: thumbnail,
    /** Sticker set thumbnail's outline; may be null if unknown */
    thumbnail_outline?: outline,
    /** True, if the sticker set is owned by the current user */
    is_owned: boolean,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** Type of the stickers in the set */
    sticker_type: StickerType,
    /**
     * True, if stickers in the sticker set are custom emoji that must be repainted;
     * for custom emoji sticker sets only
     */
    needs_repainting: boolean,
    /**
     * True, if stickers in the sticker set are custom emoji that can be used as chat
     * emoji status; for custom emoji sticker sets only
     */
    is_allowed_as_chat_emoji_status: boolean,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** Total number of stickers in the set */
    size: number,
    /**
     * Up to the first 5 stickers from the set, depending on the context. If the application
     * needs more stickers the full sticker set needs to be requested
     */
    covers: Array<sticker>,
  |}

  declare export type stickerSets = {|
    /** Represents a list of sticker sets */
    _: 'stickerSets',
    /** Approximate total number of sticker sets found */
    total_count: number,
    /** List of sticker sets */
    sets: Array<stickerSetInfo>,
  |}

  declare export type trendingStickerSets = {|
    /** Represents a list of trending sticker sets */
    _: 'trendingStickerSets',
    /** Approximate total number of trending sticker sets */
    total_count: number,
    /** List of trending sticker sets */
    sets: Array<stickerSetInfo>,
    /** True, if the list contains sticker sets with premium stickers */
    is_premium: boolean,
  |}

  declare export type emojiCategorySourceSearch = {|
    /**
     * The category contains a list of similar emoji to search for in getStickers and
     * searchStickers for stickers, or getInlineQueryResults with the bot getOption("animation_search_bot_username")
     * for animations
     */
    _: 'emojiCategorySourceSearch',
    /** List of emojis to search for */
    emojis: Array<string>,
  |}

  declare export type emojiCategorySourcePremium = {|
    /** The category contains premium stickers that must be found by getPremiumStickers */
    _: 'emojiCategorySourcePremium',
  |}

  declare export type emojiCategory = {|
    /** Describes an emoji category */
    _: 'emojiCategory',
    /** Name of the category */
    name: string,
    /** Custom emoji sticker, which represents icon of the category */
    icon: sticker,
    /** Source of stickers for the emoji category */
    source: EmojiCategorySource,
    /**
     * True, if the category must be shown first when choosing a sticker for the start
     * page
     */
    is_greeting: boolean,
  |}

  declare export type emojiCategories = {|
    /** Represents a list of emoji categories */
    _: 'emojiCategories',
    /** List of categories */
    categories: Array<emojiCategory>,
  |}

  declare export type emojiCategoryTypeDefault$Input = {|
    /** The category must be used by default (e.g., for custom emoji or animation search) */
    +_: 'emojiCategoryTypeDefault',
  |}

  declare export type emojiCategoryTypeRegularStickers$Input = {|
    /**
     * The category must be used by default for regular sticker selection. It may contain
     * greeting emoji category and premium stickers
     */
    +_: 'emojiCategoryTypeRegularStickers',
  |}

  declare export type emojiCategoryTypeEmojiStatus$Input = {|
    /** The category must be used for emoji status selection */
    +_: 'emojiCategoryTypeEmojiStatus',
  |}

  declare export type emojiCategoryTypeChatPhoto$Input = {|
    /** The category must be used for chat photo emoji selection */
    +_: 'emojiCategoryTypeChatPhoto',
  |}

  declare export type currentWeather = {|
    /** Describes the current weather */
    _: 'currentWeather',
    /** Temperature, in degree Celsius */
    temperature: number,
    /** Emoji representing the weather */
    emoji: string,
  |}

  declare export type storyAreaPosition = {|
    /** Describes position of a clickable rectangle area on a story media */
    _: 'storyAreaPosition',
    /** The abscissa of the rectangle's center, as a percentage of the media width */
    x_percentage: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    y_percentage: number,
    /** The width of the rectangle, as a percentage of the media width */
    width_percentage: number,
    /** The height of the rectangle, as a percentage of the media height */
    height_percentage: number,
    /** Clockwise rotation angle of the rectangle, in degrees; 0-360 */
    rotation_angle: number,
    /** The radius of the rectangle corner rounding, as a percentage of the media width */
    corner_radius_percentage: number,
  |}

  declare export type storyAreaPosition$Input = {|
    /** Describes position of a clickable rectangle area on a story media */
    +_: 'storyAreaPosition',
    /** The abscissa of the rectangle's center, as a percentage of the media width */
    +x_percentage?: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    +y_percentage?: number,
    /** The width of the rectangle, as a percentage of the media width */
    +width_percentage?: number,
    /** The height of the rectangle, as a percentage of the media height */
    +height_percentage?: number,
    /** Clockwise rotation angle of the rectangle, in degrees; 0-360 */
    +rotation_angle?: number,
    /** The radius of the rectangle corner rounding, as a percentage of the media width */
    +corner_radius_percentage?: number,
  |}

  declare export type storyAreaTypeLocation = {|
    /** An area pointing to a location */
    _: 'storyAreaTypeLocation',
    /** The location */
    location: location,
    /** Address of the location; may be null if unknown */
    address?: locationAddress,
  |}

  declare export type storyAreaTypeVenue = {|
    /** An area pointing to a venue */
    _: 'storyAreaTypeVenue',
    /** Information about the venue */
    venue: venue,
  |}

  declare export type storyAreaTypeSuggestedReaction = {|
    /**
     * An area pointing to a suggested reaction. App needs to show a clickable reaction
     * on the area and call setStoryReaction when the are is clicked
     */
    _: 'storyAreaTypeSuggestedReaction',
    /** Type of the reaction */
    reaction_type: ReactionType,
    /** Number of times the reaction was added */
    total_count: number,
    /** True, if reaction has a dark background */
    is_dark: boolean,
    /** True, if reaction corner is flipped */
    is_flipped: boolean,
  |}

  declare export type storyAreaTypeMessage = {|
    /** An area pointing to a message */
    _: 'storyAreaTypeMessage',
    /** Identifier of the chat with the message */
    chat_id: number,
    /** Identifier of the message */
    message_id: number,
  |}

  declare export type storyAreaTypeLink = {|
    /** An area pointing to a HTTP or tg:// link */
    _: 'storyAreaTypeLink',
    /** HTTP or tg:// URL to be opened when the area is clicked */
    url: string,
  |}

  declare export type storyAreaTypeWeather = {|
    /** An area with information about weather */
    _: 'storyAreaTypeWeather',
    /** Temperature, in degree Celsius */
    temperature: number,
    /** Emoji representing the weather */
    emoji: string,
    /** A color of the area background in the ARGB format */
    background_color: number,
  |}

  declare export type storyAreaTypeUpgradedGift = {|
    /** An area with an upgraded gift */
    _: 'storyAreaTypeUpgradedGift',
    /** Unique name of the upgraded gift */
    gift_name: string,
  |}

  declare export type storyArea = {|
    /** Describes a clickable rectangle area on a story media */
    _: 'storyArea',
    /** Position of the area */
    position: storyAreaPosition,
    /** Type of the area */
    type: StoryAreaType,
  |}

  declare export type inputStoryAreaTypeLocation$Input = {|
    /** An area pointing to a location */
    +_: 'inputStoryAreaTypeLocation',
    /** The location */
    +location?: location$Input,
    /** Address of the location; pass null if unknown */
    +address?: locationAddress$Input,
  |}

  declare export type inputStoryAreaTypeFoundVenue$Input = {|
    /** An area pointing to a venue found by the bot getOption("venue_search_bot_username") */
    +_: 'inputStoryAreaTypeFoundVenue',
    /** Identifier of the inline query, used to found the venue */
    +query_id?: number | string,
    /** Identifier of the inline query result */
    +result_id?: string,
  |}

  declare export type inputStoryAreaTypePreviousVenue$Input = {|
    /** An area pointing to a venue already added to the story */
    +_: 'inputStoryAreaTypePreviousVenue',
    /** Provider of the venue */
    +venue_provider?: string,
    /** Identifier of the venue in the provider database */
    +venue_id?: string,
  |}

  declare export type inputStoryAreaTypeSuggestedReaction$Input = {|
    /** An area pointing to a suggested reaction */
    +_: 'inputStoryAreaTypeSuggestedReaction',
    /** Type of the reaction */
    +reaction_type?: ReactionType$Input,
    /** True, if reaction has a dark background */
    +is_dark?: boolean,
    /** True, if reaction corner is flipped */
    +is_flipped?: boolean,
  |}

  declare export type inputStoryAreaTypeMessage$Input = {|
    /** An area pointing to a message */
    +_: 'inputStoryAreaTypeMessage',
    /**
     * Identifier of the chat with the message. Currently, the chat must be a supergroup
     * or a channel chat
     */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_shared_in_story to check
     * whether the message is suitable
     */
    +message_id?: number,
  |}

  declare export type inputStoryAreaTypeLink$Input = {|
    /** An area pointing to a HTTP or tg:// link */
    +_: 'inputStoryAreaTypeLink',
    /** HTTP or tg:// URL to be opened when the area is clicked */
    +url?: string,
  |}

  declare export type inputStoryAreaTypeWeather$Input = {|
    /** An area with information about weather */
    +_: 'inputStoryAreaTypeWeather',
    /** Temperature, in degree Celsius */
    +temperature?: number,
    /** Emoji representing the weather */
    +emoji?: string,
    /** A color of the area background in the ARGB format */
    +background_color?: number,
  |}

  declare export type inputStoryAreaTypeUpgradedGift$Input = {|
    /** An area with an upgraded gift */
    +_: 'inputStoryAreaTypeUpgradedGift',
    /** Unique name of the upgraded gift */
    +gift_name?: string,
  |}

  declare export type inputStoryArea$Input = {|
    /** Describes a clickable rectangle area on a story media to be added */
    +_: 'inputStoryArea',
    /** Position of the area */
    +position?: storyAreaPosition$Input,
    /** Type of the area */
    +type?: InputStoryAreaType$Input,
  |}

  declare export type inputStoryAreas$Input = {|
    /** Contains a list of story areas to be added */
    +_: 'inputStoryAreas',
    /**
     * List of input story areas. Currently, a story can have up to 10 inputStoryAreaTypeLocation,
     * inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up
     * to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction
     * areas, up to 1 inputStoryAreaTypeMessage area, up to getOption("story_link_area_count_max")
     * inputStoryAreaTypeLink areas if the current user is a Telegram Premium user,
     * up to 3 inputStoryAreaTypeWeather areas, and up to 1 inputStoryAreaTypeUpgradedGift
     * area
     */
    +areas?: $ReadOnlyArray<inputStoryArea$Input>,
  |}

  declare export type storyVideo = {|
    /** Describes a video file sent in a story */
    _: 'storyVideo',
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /**
     * True, if stickers were added to the video. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** True, if the video has no sound */
    is_animation: boolean,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG or MPEG4 format; may be null */
    thumbnail?: thumbnail,
    /** Size of file prefix, which is expected to be preloaded, in bytes */
    preload_prefix_size: number,
    /** Timestamp of the frame used as video thumbnail */
    cover_frame_timestamp: number,
    /** File containing the video */
    video: file,
  |}

  declare export type storyContentPhoto = {|
    /** A photo story */
    _: 'storyContentPhoto',
    /** The photo */
    photo: photo,
  |}

  declare export type storyContentVideo = {|
    /** A video story */
    _: 'storyContentVideo',
    /** The video in MPEG4 format */
    video: storyVideo,
    /**
     * Alternative version of the video in MPEG4 format, encoded with H.264 codec;
     * may be null
     */
    alternative_video?: storyVideo,
  |}

  declare export type storyContentUnsupported = {|
    /** A story content that is not supported in the current TDLib version */
    _: 'storyContentUnsupported',
  |}

  declare export type inputStoryContentPhoto$Input = {|
    /** A photo story */
    +_: 'inputStoryContentPhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo size must
     * be 1080x1920
     */
    +photo?: InputFile$Input,
    /** File identifiers of the stickers added to the photo, if applicable */
    +added_sticker_file_ids?: $ReadOnlyArray<number>,
  |}

  declare export type inputStoryContentVideo$Input = {|
    /** A video story */
    +_: 'inputStoryContentVideo',
    /**
     * Video to be sent. The video size must be 720x1280. The video must be streamable
     * and stored in MPEG4 format, after encoding with H.265 codec and key frames added
     * each second
     */
    +video?: InputFile$Input,
    /** File identifiers of the stickers added to the video, if applicable */
    +added_sticker_file_ids?: $ReadOnlyArray<number>,
    /** Precise duration of the video, in seconds; 0-60 */
    +duration?: number,
    /** Timestamp of the frame, which will be used as video thumbnail */
    +cover_frame_timestamp?: number,
    /** True, if the video has no sound */
    +is_animation?: boolean,
  |}

  declare export type storyListMain = {|
    /** The list of stories, shown in the main chat list and folder chat lists */
    _: 'storyListMain',
  |}

  declare export type storyListMain$Input = {|
    /** The list of stories, shown in the main chat list and folder chat lists */
    +_: 'storyListMain',
  |}

  declare export type storyListArchive = {|
    /** The list of stories, shown in the Arvhive chat list */
    _: 'storyListArchive',
  |}

  declare export type storyListArchive$Input = {|
    /** The list of stories, shown in the Arvhive chat list */
    +_: 'storyListArchive',
  |}

  declare export type storyOriginPublicStory = {|
    /** The original story was a public story with known sender */
    _: 'storyOriginPublicStory',
    /** Identifier of the chat that posted original story */
    chat_id: number,
    /** Story identifier of the original story */
    story_id: number,
  |}

  declare export type storyOriginHiddenUser = {|
    /** The original story was sent by an unknown user */
    _: 'storyOriginHiddenUser',
    /** Name of the story sender */
    sender_name: string,
  |}

  declare export type storyRepostInfo = {|
    /** Contains information about original story that was reposted */
    _: 'storyRepostInfo',
    /** Origin of the story that was reposted */
    origin: StoryOrigin,
    /**
     * True, if story content was modified during reposting; otherwise, story wasn't
     * modified
     */
    is_content_modified: boolean,
  |}

  declare export type storyInteractionInfo = {|
    /** Contains information about interactions with a story */
    _: 'storyInteractionInfo',
    /** Number of times the story was viewed */
    view_count: number,
    /** Number of times the story was forwarded; 0 if none or unknown */
    forward_count: number,
    /** Number of reactions added to the story; 0 if none or unknown */
    reaction_count: number,
    /** Identifiers of at most 3 recent viewers of the story */
    recent_viewer_user_ids: Array<number>,
  |}

  declare export type story = {|
    /** Represents a story */
    _: 'story',
    /** Unique story identifier among stories of the given sender */
    id: number,
    /** Identifier of the chat that posted the story */
    sender_chat_id: number,
    /**
     * Identifier of the sender of the story; may be null if the story is posted on
     * behalf of the sender_chat_id
     */
    sender_id?: MessageSender,
    /** Point in time (Unix timestamp) when the story was published */
    date: number,
    /** True, if the story is being sent by the current user */
    is_being_sent: boolean,
    /** True, if the story is being edited by the current user */
    is_being_edited: boolean,
    /** True, if the story was edited */
    is_edited: boolean,
    /**
     * True, if the story is saved in the sender's profile and will be available there
     * after expiration
     */
    is_posted_to_chat_page: boolean,
    /** True, if the story is visible only for the current user */
    is_visible_only_for_self: boolean,
    /** True, if the story can be deleted */
    can_be_deleted: boolean,
    /** True, if the story can be edited */
    can_be_edited: boolean,
    /**
     * True, if the story can be forwarded as a message. Otherwise, screenshots and
     * saving of the story content must be also forbidden
     */
    can_be_forwarded: boolean,
    /** True, if the story can be replied in the chat with the story sender */
    can_be_replied: boolean,
    /** True, if the story's is_posted_to_chat_page value can be changed */
    can_toggle_is_posted_to_chat_page: boolean,
    /** True, if the story statistics are available through getStoryStatistics */
    can_get_statistics: boolean,
    /** True, if interactions with the story can be received through getStoryInteractions */
    can_get_interactions: boolean,
    /**
     * True, if users viewed the story can't be received, because the story has expired
     * more than getOption("story_viewers_expiration_delay") seconds ago
     */
    has_expired_viewers: boolean,
    /** Information about the original story; may be null if the story wasn't reposted */
    repost_info?: storyRepostInfo,
    /**
     * Information about interactions with the story; may be null if the story isn't
     * owned or there were no interactions
     */
    interaction_info?: storyInteractionInfo,
    /** Type of the chosen reaction; may be null if none */
    chosen_reaction_type?: ReactionType,
    /** Privacy rules affecting story visibility; may be approximate for non-owned stories */
    privacy_settings: StoryPrivacySettings,
    /** Content of the story */
    content: StoryContent,
    /** Clickable areas to be shown on the story content */
    areas: Array<storyArea>,
    /** Caption of the story */
    caption: formattedText,
  |}

  declare export type stories = {|
    /** Represents a list of stories */
    _: 'stories',
    /** Approximate total number of stories found */
    total_count: number,
    /** The list of stories */
    stories: Array<story>,
    /**
     * Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories
     * with from_story_id == 0
     */
    pinned_story_ids: Array<number>,
  |}

  declare export type foundStories = {|
    /** Contains a list of stories found by a search */
    _: 'foundStories',
    /** Approximate total number of stories found */
    total_count: number,
    /** List of stories */
    stories: Array<story>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type storyFullId$Input = {|
    /** Contains identifier of a story along with identifier of its sender */
    +_: 'storyFullId',
    /** Identifier of the chat that posted the story */
    +sender_chat_id?: number,
    /** Unique story identifier among stories of the given sender */
    +story_id?: number,
  |}

  declare export type storyInfo = {|
    /** Contains basic information about a story */
    _: 'storyInfo',
    /** Unique story identifier among stories of the given sender */
    story_id: number,
    /** Point in time (Unix timestamp) when the story was published */
    date: number,
    /** True, if the story is available only to close friends */
    is_for_close_friends: boolean,
  |}

  declare export type chatActiveStories = {|
    /** Describes active stories posted by a chat */
    _: 'chatActiveStories',
    /** Identifier of the chat that posted the stories */
    chat_id: number,
    /**
     * Identifier of the story list in which the stories are shown; may be null if
     * the stories aren't shown in a story list
     */
    list?: StoryList,
    /**
     * A parameter used to determine order of the stories in the story list; 0 if the
     * stories doesn't need to be shown in the story list. Stories must be sorted by
     * the pair (order, story_sender_chat_id) in descending order
     */
    order: number,
    /** Identifier of the last read active story */
    max_read_story_id: number,
    /**
     * Basic information about the stories; use getStory to get full information about
     * the stories. The stories are in chronological order (i.e., in order of increasing
     * story identifiers)
     */
    stories: Array<storyInfo>,
  |}

  declare export type storyInteractionTypeView = {|
    /** A view of the story */
    _: 'storyInteractionTypeView',
    /** Type of the reaction that was chosen by the viewer; may be null if none */
    chosen_reaction_type?: ReactionType,
  |}

  declare export type storyInteractionTypeForward = {|
    /** A forward of the story as a message */
    _: 'storyInteractionTypeForward',
    /** The message with story forward */
    message: message,
  |}

  declare export type storyInteractionTypeRepost = {|
    /** A repost of the story as a story */
    _: 'storyInteractionTypeRepost',
    /** The reposted story */
    story: story,
  |}

  declare export type storyInteraction = {|
    /** Represents interaction with a story */
    _: 'storyInteraction',
    /** Identifier of the user or chat that made the interaction */
    actor_id: MessageSender,
    /** Approximate point in time (Unix timestamp) when the interaction happened */
    interaction_date: number,
    /** Block list to which the actor is added; may be null if none or for chat stories */
    block_list?: BlockList,
    /** Type of the interaction */
    type: StoryInteractionType,
  |}

  declare export type storyInteractions = {|
    /** Represents a list of interactions with a story */
    _: 'storyInteractions',
    /** Approximate total number of interactions found */
    total_count: number,
    /** Approximate total number of found forwards and reposts; always 0 for chat stories */
    total_forward_count: number,
    /** Approximate total number of found reactions; always 0 for chat stories */
    total_reaction_count: number,
    /** List of story interactions */
    interactions: Array<storyInteraction>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type quickReplyMessage = {|
    /** Describes a message that can be used for quick reply */
    _: 'quickReplyMessage',
    /** Unique message identifier among all quick replies */
    id: number,
    /**
     * The sending state of the message; may be null if the message isn't being sent
     * and didn't fail to be sent
     */
    sending_state?: MessageSendingState,
    /** True, if the message can be edited */
    can_be_edited: boolean,
    /**
     * The identifier of the quick reply message to which the message replies; 0 if
     * none
     */
    reply_to_message_id: number,
    /** If non-zero, the user identifier of the bot through which this message was sent */
    via_bot_user_id: number,
    /**
     * Unique identifier of an album this message belongs to; 0 if none. Only audios,
     * documents, photos and videos can be grouped together in albums
     */
    media_album_id: string,
    /** Content of the message */
    content: MessageContent,
    /** Inline keyboard reply markup for the message; may be null if none */
    reply_markup?: ReplyMarkup,
  |}

  declare export type quickReplyMessages = {|
    /** Contains a list of quick reply messages */
    _: 'quickReplyMessages',
    /** List of quick reply messages; messages may be null */
    messages: Array<quickReplyMessage | null>,
  |}

  declare export type quickReplyShortcut = {|
    /** Describes a shortcut that can be used for a quick reply */
    _: 'quickReplyShortcut',
    /** Unique shortcut identifier */
    id: number,
    /** The name of the shortcut that can be used to use the shortcut */
    name: string,
    /** The first shortcut message */
    first_message: quickReplyMessage,
    /** The total number of messages in the shortcut */
    message_count: number,
  |}

  declare export type publicForwardMessage = {|
    /** Contains a public forward as a message */
    _: 'publicForwardMessage',
    /** Information about the message */
    message: message,
  |}

  declare export type publicForwardStory = {|
    /** Contains a public repost to a story */
    _: 'publicForwardStory',
    /** Information about the story */
    story: story,
  |}

  declare export type publicForwards = {|
    /**
     * Represents a list of public forwards and reposts as a story of a message or
     * a story
     */
    _: 'publicForwards',
    /** Approximate total number of messages and stories found */
    total_count: number,
    /** List of found public forwards and reposts */
    forwards: Array<PublicForward>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type botMediaPreview = {|
    /** Describes media previews of a bot */
    _: 'botMediaPreview',
    /** Point in time (Unix timestamp) when the preview was added or changed last time */
    date: number,
    /** Content of the preview */
    content: StoryContent,
  |}

  declare export type botMediaPreviews = {|
    /** Contains a list of media previews of a bot */
    _: 'botMediaPreviews',
    /** List of media previews */
    previews: Array<botMediaPreview>,
  |}

  declare export type botMediaPreviewInfo = {|
    /**
     * Contains a list of media previews of a bot for the given language and the list
     * of languages for which the bot has dedicated previews
     */
    _: 'botMediaPreviewInfo',
    /** List of media previews */
    previews: Array<botMediaPreview>,
    /** List of language codes for which the bot has dedicated previews */
    language_codes: Array<string>,
  |}

  declare export type chatBoostLevelFeatures = {|
    /** Contains a list of features available on a specific chat boost level */
    _: 'chatBoostLevelFeatures',
    /** Target chat boost level */
    level: number,
    /** Number of stories that the chat can publish daily */
    story_per_day_count: number,
    /**
     * Number of custom emoji reactions that can be added to the list of available
     * reactions
     */
    custom_emoji_reaction_count: number,
    /** Number of custom colors for chat title */
    title_color_count: number,
    /** Number of custom colors for profile photo background */
    profile_accent_color_count: number,
    /** True, if custom emoji for profile background can be set */
    can_set_profile_background_custom_emoji: boolean,
    /**
     * Number of custom colors for background of empty chat photo, replies to messages
     * and link previews
     */
    accent_color_count: number,
    /** True, if custom emoji for reply header and link preview background can be set */
    can_set_background_custom_emoji: boolean,
    /** True, if emoji status can be set */
    can_set_emoji_status: boolean,
    /** Number of chat theme backgrounds that can be set as chat background */
    chat_theme_background_count: number,
    /** True, if custom background can be set in the chat for all users */
    can_set_custom_background: boolean,
    /** True, if custom emoji sticker set can be set for the chat */
    can_set_custom_emoji_sticker_set: boolean,
    /**
     * True, if speech recognition can be used for video note and voice note messages
     * by all users
     */
    can_recognize_speech: boolean,
    /** True, if sponsored messages can be disabled in the chat */
    can_disable_sponsored_messages: boolean,
  |}

  declare export type chatBoostFeatures = {|
    /** Contains a list of features available on the first chat boost levels */
    _: 'chatBoostFeatures',
    /** The list of features */
    features: Array<chatBoostLevelFeatures>,
    /** The minimum boost level required to set custom emoji for profile background */
    min_profile_background_custom_emoji_boost_level: number,
    /**
     * The minimum boost level required to set custom emoji for reply header and link
     * preview background; for channel chats only
     */
    min_background_custom_emoji_boost_level: number,
    /** The minimum boost level required to set emoji status */
    min_emoji_status_boost_level: number,
    /** The minimum boost level required to set a chat theme background as chat background */
    min_chat_theme_background_boost_level: number,
    /** The minimum boost level required to set custom chat background */
    min_custom_background_boost_level: number,
    /**
     * The minimum boost level required to set custom emoji sticker set for the chat;
     * for supergroup chats only
     */
    min_custom_emoji_sticker_set_boost_level: number,
    /**
     * The minimum boost level allowing to recognize speech in video note and voice
     * note messages for non-Premium users; for supergroup chats only
     */
    min_speech_recognition_boost_level: number,
    /**
     * The minimum boost level allowing to disable sponsored messages in the chat;
     * for channel chats only
     */
    min_sponsored_message_disable_boost_level: number,
  |}

  declare export type chatBoostSourceGiftCode = {|
    /** The chat created a Telegram Premium gift code for a user */
    _: 'chatBoostSourceGiftCode',
    /** Identifier of a user, for which the gift code was created */
    user_id: number,
    /**
     * The created Telegram Premium gift code, which is known only if this is a gift
     * code for the current user, or it has already been claimed
     */
    gift_code: string,
  |}

  declare export type chatBoostSourceGiveaway = {|
    /** The chat created a giveaway */
    _: 'chatBoostSourceGiveaway',
    /** Identifier of a user that won in the giveaway; 0 if none */
    user_id: number,
    /**
     * The created Telegram Premium gift code if it was used by the user or can be
     * claimed by the current user; an empty string otherwise; for Telegram Premium
     * giveways only
     */
    gift_code: string,
    /** Number of Telegram Stars distributed among winners of the giveaway */
    star_count: number,
    /**
     * Identifier of the corresponding giveaway message; can be an identifier of a
     * deleted message
     */
    giveaway_message_id: number,
    /**
     * True, if the winner for the corresponding giveaway prize wasn't chosen, because
     * there were not enough participants
     */
    is_unclaimed: boolean,
  |}

  declare export type chatBoostSourcePremium = {|
    /**
     * A user with Telegram Premium subscription or gifted Telegram Premium boosted
     * the chat
     */
    _: 'chatBoostSourcePremium',
    /** Identifier of the user */
    user_id: number,
  |}

  declare export type prepaidGiveaway = {|
    /** Describes a prepaid giveaway */
    _: 'prepaidGiveaway',
    /** Unique identifier of the prepaid giveaway */
    id: string,
    /** Number of users which will receive giveaway prize */
    winner_count: number,
    /** Prize of the giveaway */
    prize: GiveawayPrize,
    /**
     * The number of boosts received by the chat from the giveaway; for Telegram Star
     * giveaways only
     */
    boost_count: number,
    /** Point in time (Unix timestamp) when the giveaway was paid */
    payment_date: number,
  |}

  declare export type chatBoostStatus = {|
    /** Describes current boost status of a chat */
    _: 'chatBoostStatus',
    /** An HTTP URL, which can be used to boost the chat */
    boost_url: string,
    /** Identifiers of boost slots of the current user applied to the chat */
    applied_slot_ids: Array<number>,
    /** Current boost level of the chat */
    level: number,
    /**
     * The number of boosts received by the chat from created Telegram Premium gift
     * codes and giveaways; always 0 if the current user isn't an administrator in
     * the chat
     */
    gift_code_boost_count: number,
    /** The number of boosts received by the chat */
    boost_count: number,
    /** The number of boosts added to reach the current level */
    current_level_boost_count: number,
    /**
     * The number of boosts needed to reach the next level; 0 if the next level isn't
     * available
     */
    next_level_boost_count: number,
    /**
     * Approximate number of Telegram Premium subscribers joined the chat; always 0
     * if the current user isn't an administrator in the chat
     */
    premium_member_count: number,
    /**
     * A percentage of Telegram Premium subscribers joined the chat; always 0 if the
     * current user isn't an administrator in the chat
     */
    premium_member_percentage: number,
    /** The list of prepaid giveaways available for the chat; only for chat administrators */
    prepaid_giveaways: Array<prepaidGiveaway>,
  |}

  declare export type chatBoost = {|
    /** Describes a boost applied to a chat */
    _: 'chatBoost',
    /** Unique identifier of the boost */
    id: string,
    /** The number of identical boosts applied */
    count: number,
    /** Source of the boost */
    source: ChatBoostSource,
    /** Point in time (Unix timestamp) when the chat was boosted */
    start_date: number,
    /** Point in time (Unix timestamp) when the boost will expire */
    expiration_date: number,
  |}

  declare export type foundChatBoosts = {|
    /** Contains a list of boosts applied to a chat */
    _: 'foundChatBoosts',
    /** Total number of boosts applied to the chat */
    total_count: number,
    /** List of boosts */
    boosts: Array<chatBoost>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type chatBoostSlot = {|
    /** Describes a slot for chat boost */
    _: 'chatBoostSlot',
    /** Unique identifier of the slot */
    slot_id: number,
    /** Identifier of the currently boosted chat; 0 if none */
    currently_boosted_chat_id: number,
    /** Point in time (Unix timestamp) when the chat was boosted; 0 if none */
    start_date: number,
    /** Point in time (Unix timestamp) when the boost will expire */
    expiration_date: number,
    /**
     * Point in time (Unix timestamp) after which the boost can be used for another
     * chat
     */
    cooldown_until_date: number,
  |}

  declare export type chatBoostSlots = {|
    /** Contains a list of chat boost slots */
    _: 'chatBoostSlots',
    /** List of boost slots */
    slots: Array<chatBoostSlot>,
  |}

  declare export type resendCodeReasonUserRequest$Input = {|
    /** The user requested to resend the code */
    +_: 'resendCodeReasonUserRequest',
  |}

  declare export type resendCodeReasonVerificationFailed$Input = {|
    /** The code is re-sent, because device verification has failed */
    +_: 'resendCodeReasonVerificationFailed',
    /**
     * Cause of the verification failure, for example, PLAY_SERVICES_NOT_AVAILABLE,
     * APNS_RECEIVE_TIMEOUT, or APNS_INIT_FAILED
     */
    +error_message?: string,
  |}

  declare export type callDiscardReasonEmpty = {|
    /** The call wasn't discarded, or the reason is unknown */
    _: 'callDiscardReasonEmpty',
  |}

  declare export type callDiscardReasonMissed = {|
    /**
     * The call was ended before the conversation started. It was canceled by the caller
     * or missed by the other party
     */
    _: 'callDiscardReasonMissed',
  |}

  declare export type callDiscardReasonDeclined = {|
    /**
     * The call was ended before the conversation started. It was declined by the other
     * party
     */
    _: 'callDiscardReasonDeclined',
  |}

  declare export type callDiscardReasonDisconnected = {|
    /** The call was ended during the conversation because the users were disconnected */
    _: 'callDiscardReasonDisconnected',
  |}

  declare export type callDiscardReasonHungUp = {|
    /** The call was ended because one of the parties hung up */
    _: 'callDiscardReasonHungUp',
  |}

  declare export type callDiscardReasonAllowGroupCall = {|
    /**
     * The call was ended because it has been used successfully to transfer private
     * encryption key for the associated group call
     */
    _: 'callDiscardReasonAllowGroupCall',
    /**
     * Encrypted using the call private key encryption key for the associated group
     * call
     */
    encrypted_group_call_key: string /* base64 */,
  |}

  declare export type callProtocol = {|
    /** Specifies the supported call protocols */
    _: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    udp_p2p: boolean,
    /** True, if connection through UDP reflectors is supported */
    udp_reflector: boolean,
    /** The minimum supported API layer; use 65 */
    min_layer: number,
    /** The maximum supported API layer; use 92 */
    max_layer: number,
    /** List of supported tgcalls versions */
    library_versions: Array<string>,
  |}

  declare export type callProtocol$Input = {|
    /** Specifies the supported call protocols */
    +_: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    +udp_p2p?: boolean,
    /** True, if connection through UDP reflectors is supported */
    +udp_reflector?: boolean,
    /** The minimum supported API layer; use 65 */
    +min_layer?: number,
    /** The maximum supported API layer; use 92 */
    +max_layer?: number,
    /** List of supported tgcalls versions */
    +library_versions?: $ReadOnlyArray<string>,
  |}

  declare export type callServerTypeTelegramReflector = {|
    /** A Telegram call reflector */
    _: 'callServerTypeTelegramReflector',
    /** A peer tag to be used with the reflector */
    peer_tag: string /* base64 */,
    /** True, if the server uses TCP instead of UDP */
    is_tcp: boolean,
  |}

  declare export type callServerTypeWebrtc = {|
    /** A WebRTC server */
    _: 'callServerTypeWebrtc',
    /** Username to be used for authentication */
    username: string,
    /** Authentication password */
    password: string,
    /** True, if the server supports TURN */
    supports_turn: boolean,
    /** True, if the server supports STUN */
    supports_stun: boolean,
  |}

  declare export type callServer = {|
    /** Describes a server for relaying call data */
    _: 'callServer',
    /** Server identifier */
    id: string,
    /** Server IPv4 address */
    ip_address: string,
    /** Server IPv6 address */
    ipv6_address: string,
    /** Server port number */
    port: number,
    /** Server type */
    type: CallServerType,
  |}

  declare export type callId = {|
    /** Contains the call identifier */
    _: 'callId',
    /** Call identifier */
    id: number,
  |}

  declare export type groupCallId = {|
    /** Contains the group call identifier */
    _: 'groupCallId',
    /** Group call identifier */
    id: number,
  |}

  declare export type callStatePending = {|
    /** The call is pending, waiting to be accepted by a user */
    _: 'callStatePending',
    /** True, if the call has already been created by the server */
    is_created: boolean,
    /** True, if the call has already been received by the other party */
    is_received: boolean,
  |}

  declare export type callStateExchangingKeys = {|
    /** The call has been answered and encryption keys are being exchanged */
    _: 'callStateExchangingKeys',
  |}

  declare export type callStateReady = {|
    /** The call is ready to use */
    _: 'callStateReady',
    /** Call protocols supported by the other call participant */
    protocol: callProtocol,
    /** List of available call servers */
    servers: Array<callServer>,
    /** A JSON-encoded call config */
    config: string,
    /** Call encryption key */
    encryption_key: string /* base64 */,
    /** Encryption key fingerprint represented as 4 emoji */
    emojis: Array<string>,
    /** True, if peer-to-peer connection is allowed by users privacy settings */
    allow_p2p: boolean,
    /** Custom JSON-encoded call parameters to be passed to tgcalls */
    custom_parameters: string,
  |}

  declare export type callStateHangingUp = {|
    /** The call is hanging up after discardCall has been called */
    _: 'callStateHangingUp',
  |}

  declare export type callStateDiscarded = {|
    /** The call has ended successfully */
    _: 'callStateDiscarded',
    /** The reason why the call has ended */
    reason: CallDiscardReason,
    /** True, if the call rating must be sent to the server */
    need_rating: boolean,
    /** True, if the call debug information must be sent to the server */
    need_debug_information: boolean,
    /** True, if the call log must be sent to the server */
    need_log: boolean,
  |}

  declare export type callStateError = {|
    /** The call has ended with an error */
    _: 'callStateError',
    /**
     * Error. An error with the code 4005000 will be returned if an outgoing call is
     * missed because of an expired timeout
     */
    error: error,
  |}

  declare export type groupCallVideoQualityThumbnail$Input = {|
    /** The worst available video quality */
    +_: 'groupCallVideoQualityThumbnail',
  |}

  declare export type groupCallVideoQualityMedium$Input = {|
    /** The medium video quality */
    +_: 'groupCallVideoQualityMedium',
  |}

  declare export type groupCallVideoQualityFull$Input = {|
    /** The best available video quality */
    +_: 'groupCallVideoQualityFull',
  |}

  declare export type groupCallStream = {|
    /** Describes an available stream in a group call */
    _: 'groupCallStream',
    /** Identifier of an audio/video channel */
    channel_id: number,
    /** Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds */
    scale: number,
    /** Point in time when the stream currently ends; Unix timestamp in milliseconds */
    time_offset: number,
  |}

  declare export type groupCallStreams = {|
    /** Represents a list of group call streams */
    _: 'groupCallStreams',
    /** A list of group call streams */
    streams: Array<groupCallStream>,
  |}

  declare export type rtmpUrl = {|
    /** Represents an RTMP URL */
    _: 'rtmpUrl',
    /** The URL */
    url: string,
    /** Stream key */
    stream_key: string,
  |}

  declare export type groupCallRecentSpeaker = {|
    /** Describes a recently speaking participant in a group call */
    _: 'groupCallRecentSpeaker',
    /** Group call participant identifier */
    participant_id: MessageSender,
    /** True, is the user has spoken recently */
    is_speaking: boolean,
  |}

  declare export type groupCall = {|
    /** Describes a group call */
    _: 'groupCall',
    /** Group call identifier */
    id: number,
    /** Identifier of one-to-one call from which the group call was created; 0 if unknown */
    from_call_id: number,
    /** Group call title */
    title: string,
    /**
     * Point in time (Unix timestamp) when the group call is expected to be started
     * by an administrator; 0 if it is already active or was ended
     */
    scheduled_start_date: number,
    /**
     * True, if the group call is scheduled and the current user will receive a notification
     * when the group call starts
     */
    enabled_start_notification: boolean,
    /** True, if the call is active */
    is_active: boolean,
    /** True, if the chat is an RTMP stream instead of an ordinary video chat */
    is_rtmp_stream: boolean,
    /** True, if the call is joined */
    is_joined: boolean,
    /**
     * True, if user was kicked from the call because of network loss and the call
     * needs to be rejoined
     */
    need_rejoin: boolean,
    /** True, if the current user can manage the group call */
    can_be_managed: boolean,
    /** Number of participants in the group call */
    participant_count: number,
    /**
     * True, if group call participants, which are muted, aren't returned in participant
     * list
     */
    has_hidden_listeners: boolean,
    /** True, if all group call participants are loaded */
    loaded_all_participants: boolean,
    /** At most 3 recently speaking users in the group call */
    recent_speakers: Array<groupCallRecentSpeaker>,
    /** True, if the current user's video is enabled */
    is_my_video_enabled: boolean,
    /** True, if the current user's video is paused */
    is_my_video_paused: boolean,
    /** True, if the current user can broadcast video or share screen */
    can_enable_video: boolean,
    /** True, if only group call administrators can unmute new participants */
    mute_new_participants: boolean,
    /** True, if the current user can enable or disable mute_new_participants setting */
    can_toggle_mute_new_participants: boolean,
    /**
     * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall
     * update is not triggered when value of this field changes, but the same recording
     * goes on
     */
    record_duration: number,
    /** True, if a video file is being recorded for the call */
    is_video_recorded: boolean,
    /** Call duration, in seconds; for ended calls only */
    duration: number,
  |}

  declare export type groupCallVideoSourceGroup = {|
    /** Describes a group of video synchronization source identifiers */
    _: 'groupCallVideoSourceGroup',
    /** The semantics of sources, one of "SIM" or "FID" */
    semantics: string,
    /** The list of synchronization source identifiers */
    source_ids: Array<number>,
  |}

  declare export type groupCallParticipantVideoInfo = {|
    /** Contains information about a group call participant's video channel */
    _: 'groupCallParticipantVideoInfo',
    /** List of synchronization source groups of the video */
    source_groups: Array<groupCallVideoSourceGroup>,
    /** Video channel endpoint identifier */
    endpoint_id: string,
    /**
     * True, if the video is paused. This flag needs to be ignored, if new video frames
     * are received
     */
    is_paused: boolean,
  |}

  declare export type groupCallParticipant = {|
    /** Represents a group call participant */
    _: 'groupCallParticipant',
    /** Identifier of the group call participant */
    participant_id: MessageSender,
    /** User's audio channel synchronization source identifier */
    audio_source_id: number,
    /** User's screen sharing audio channel synchronization source identifier */
    screen_sharing_audio_source_id: number,
    /** Information about user's video channel; may be null if there is no active video */
    video_info?: groupCallParticipantVideoInfo,
    /**
     * Information about user's screen sharing video channel; may be null if there
     * is no active screen sharing video
     */
    screen_sharing_video_info?: groupCallParticipantVideoInfo,
    /** The participant user's bio or the participant chat's description */
    bio: string,
    /** True, if the participant is the current user */
    is_current_user: boolean,
    /** True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking */
    is_speaking: boolean,
    /** True, if the participant hand is raised */
    is_hand_raised: boolean,
    /**
     * True, if the current user can mute the participant for all other group call
     * participants
     */
    can_be_muted_for_all_users: boolean,
    /**
     * True, if the current user can allow the participant to unmute themselves or
     * unmute the participant (if the participant is the current user)
     */
    can_be_unmuted_for_all_users: boolean,
    /** True, if the current user can mute the participant only for self */
    can_be_muted_for_current_user: boolean,
    /** True, if the current user can unmute the participant for self */
    can_be_unmuted_for_current_user: boolean,
    /** True, if the participant is muted for all users */
    is_muted_for_all_users: boolean,
    /** True, if the participant is muted for the current user */
    is_muted_for_current_user: boolean,
    /** True, if the participant is muted for all users, but can unmute themselves */
    can_unmute_self: boolean,
    /** Participant's volume level; 1-20000 in hundreds of percents */
    volume_level: number,
    /**
     * User's order in the group call participant list. Orders must be compared lexicographically.
     * The bigger is order, the higher is user in the list. If order is empty, the
     * user must be removed from the participant list
     */
    order: string,
  |}

  declare export type callProblemEcho$Input = {|
    /** The user heard their own voice */
    +_: 'callProblemEcho',
  |}

  declare export type callProblemNoise$Input = {|
    /** The user heard background noise */
    +_: 'callProblemNoise',
  |}

  declare export type callProblemInterruptions$Input = {|
    /** The other side kept disappearing */
    +_: 'callProblemInterruptions',
  |}

  declare export type callProblemDistortedSpeech$Input = {|
    /** The speech was distorted */
    +_: 'callProblemDistortedSpeech',
  |}

  declare export type callProblemSilentLocal$Input = {|
    /** The user couldn't hear the other side */
    +_: 'callProblemSilentLocal',
  |}

  declare export type callProblemSilentRemote$Input = {|
    /** The other side couldn't hear the user */
    +_: 'callProblemSilentRemote',
  |}

  declare export type callProblemDropped$Input = {|
    /** The call ended unexpectedly */
    +_: 'callProblemDropped',
  |}

  declare export type callProblemDistortedVideo$Input = {|
    /** The video was distorted */
    +_: 'callProblemDistortedVideo',
  |}

  declare export type callProblemPixelatedVideo$Input = {|
    /** The video was pixelated */
    +_: 'callProblemPixelatedVideo',
  |}

  declare export type call = {|
    /** Describes a call */
    _: 'call',
    /** Call identifier, not persistent */
    id: number,
    /** User identifier of the other call participant */
    user_id: number,
    /** True, if the call is outgoing */
    is_outgoing: boolean,
    /** True, if the call is a video call */
    is_video: boolean,
    /** Call state */
    state: CallState,
    /**
     * Identifier of the group call associated with the call; 0 if the group call isn't
     * created yet. The group call can be received through the method getGroupCall
     */
    group_call_id: number,
  |}

  declare export type firebaseAuthenticationSettingsAndroid$Input = {|
    /** Settings for Firebase Authentication in the official Android application */
    +_: 'firebaseAuthenticationSettingsAndroid',
  |}

  declare export type firebaseAuthenticationSettingsIos$Input = {|
    /** Settings for Firebase Authentication in the official iOS application */
    +_: 'firebaseAuthenticationSettingsIos',
    /** Device token from Apple Push Notification service */
    +device_token?: string,
    /** True, if App Sandbox is enabled */
    +is_app_sandbox?: boolean,
  |}

  declare export type phoneNumberAuthenticationSettings$Input = {|
    /** Contains settings for the authentication of the user's phone number */
    +_: 'phoneNumberAuthenticationSettings',
    /**
     * Pass true if the authentication code may be sent via a flash call to the specified
     * phone number
     */
    +allow_flash_call?: boolean,
    /**
     * Pass true if the authentication code may be sent via a missed call to the specified
     * phone number
     */
    +allow_missed_call?: boolean,
    /** Pass true if the authenticated phone number is used on the current device */
    +is_current_phone_number?: boolean,
    /**
     * Pass true if there is a SIM card in the current device, but it is not possible
     * to check whether phone number matches
     */
    +has_unknown_phone_number?: boolean,
    /**
     * For official applications only. True, if the application can use Android SMS
     * Retriever API (requires Google Play Services >= 10.2) to automatically receive
     * the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/
     * for more details
     */
    +allow_sms_retriever_api?: boolean,
    /**
     * For official Android and iOS applications only; pass null otherwise. Settings
     * for Firebase Authentication
     */
    +firebase_authentication_settings?: FirebaseAuthenticationSettings$Input,
    /**
     * List of up to 20 authentication tokens, recently received in updateOption("authentication_token")
     * in previously logged out sessions
     */
    +authentication_tokens?: $ReadOnlyArray<string>,
  |}

  declare export type addedReaction = {|
    /** Represents a reaction applied to a message */
    _: 'addedReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Identifier of the chat member, applied the reaction */
    sender_id: MessageSender,
    /** True, if the reaction was added by the current user */
    is_outgoing: boolean,
    /** Point in time (Unix timestamp) when the reaction was added */
    date: number,
  |}

  declare export type addedReactions = {|
    /** Represents a list of reactions added to a message */
    _: 'addedReactions',
    /** The total number of found reactions */
    total_count: number,
    /** The list of added reactions */
    reactions: Array<addedReaction>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type availableReaction = {|
    /** Represents an available reaction */
    _: 'availableReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** True, if Telegram Premium is needed to send the reaction */
    needs_premium: boolean,
  |}

  declare export type availableReactions = {|
    /** Represents a list of reactions that can be added to a message */
    _: 'availableReactions',
    /** List of reactions to be shown at the top */
    top_reactions: Array<availableReaction>,
    /** List of recently used reactions */
    recent_reactions: Array<availableReaction>,
    /** List of popular reactions */
    popular_reactions: Array<availableReaction>,
    /** True, if any custom emoji reaction can be added by Telegram Premium subscribers */
    allow_custom_emoji: boolean,
    /** True, if the reactions will be tags and the message can be found by them */
    are_tags: boolean,
    /**
     * The reason why the current user can't add reactions to the message, despite
     * some other users can; may be null if none
     */
    unavailability_reason?: ReactionUnavailabilityReason,
  |}

  declare export type emojiReaction = {|
    /** Contains information about an emoji reaction */
    _: 'emojiReaction',
    /** Text representation of the reaction */
    emoji: string,
    /** Reaction title */
    title: string,
    /** True, if the reaction can be added to new messages and enabled in chats */
    is_active: boolean,
    /** Static icon for the reaction */
    static_icon: sticker,
    /** Appear animation for the reaction */
    appear_animation: sticker,
    /** Select animation for the reaction */
    select_animation: sticker,
    /** Activate animation for the reaction */
    activate_animation: sticker,
    /** Effect animation for the reaction */
    effect_animation: sticker,
    /** Around animation for the reaction; may be null */
    around_animation?: sticker,
    /** Center animation for the reaction; may be null */
    center_animation?: sticker,
  |}

  declare export type reactionUnavailabilityReasonAnonymousAdministrator = {|
    /**
     * The user is an anonymous administrator in the supergroup, but isn't a creator
     * of it, so they can't vote on behalf of the supergroup
     */
    _: 'reactionUnavailabilityReasonAnonymousAdministrator',
  |}

  declare export type reactionUnavailabilityReasonGuest = {|
    /**
     * The user isn't a member of the supergroup and can't send messages and reactions
     * there without joining
     */
    _: 'reactionUnavailabilityReasonGuest',
  |}

  declare export type animations = {|
    /** Represents a list of animations */
    _: 'animations',
    /** List of animations */
    animations: Array<animation>,
  |}

  declare export type diceStickersRegular = {|
    /** A regular animated sticker */
    _: 'diceStickersRegular',
    /** The animated sticker with the dice animation */
    sticker: sticker,
  |}

  declare export type diceStickersSlotMachine = {|
    /** Animated stickers to be combined into a slot machine */
    _: 'diceStickersSlotMachine',
    /**
     * The animated sticker with the slot machine background. The background animation
     * must start playing after all reel animations finish
     */
    background: sticker,
    /**
     * The animated sticker with the lever animation. The lever animation must play
     * once in the initial dice state
     */
    lever: sticker,
    /** The animated sticker with the left reel */
    left_reel: sticker,
    /** The animated sticker with the center reel */
    center_reel: sticker,
    /** The animated sticker with the right reel */
    right_reel: sticker,
  |}

  declare export type importedContacts = {|
    /** Represents the result of an importContacts request */
    _: 'importedContacts',
    /**
     * User identifiers of the imported contacts in the same order as they were specified
     * in the request; 0 if the contact is not yet a registered user
     */
    user_ids: Array<number>,
    /**
     * The number of users that imported the corresponding contact; 0 for already registered
     * users or if unavailable
     */
    importer_count: Array<number>,
  |}

  declare export type speechRecognitionResultPending = {|
    /** The speech recognition is ongoing */
    _: 'speechRecognitionResultPending',
    /** Partially recognized text */
    partial_text: string,
  |}

  declare export type speechRecognitionResultText = {|
    /** The speech recognition successfully finished */
    _: 'speechRecognitionResultText',
    /** Recognized text */
    text: string,
  |}

  declare export type speechRecognitionResultError = {|
    /** The speech recognition failed */
    _: 'speechRecognitionResultError',
    /**
     * Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned
     * when media duration is too big to be recognized
     */
    error: error,
  |}

  declare export type businessConnection = {|
    /** Describes a connection of the bot with a business account */
    _: 'businessConnection',
    /** Unique identifier of the connection */
    id: string,
    /** Identifier of the business user that created the connection */
    user_id: number,
    /** Chat identifier of the private chat with the user */
    user_chat_id: number,
    /** Point in time (Unix timestamp) when the connection was established */
    date: number,
    /** True, if the bot can send messages to the connected user; false otherwise */
    can_reply: boolean,
    /** True, if the connection is enabled; false otherwise */
    is_enabled: boolean,
  |}

  declare export type attachmentMenuBotColor = {|
    /** Describes a color to highlight a bot added to attachment menu */
    _: 'attachmentMenuBotColor',
    /** Color in the RGB format for light themes */
    light_color: number,
    /** Color in the RGB format for dark themes */
    dark_color: number,
  |}

  declare export type attachmentMenuBot = {|
    /** Represents a bot, which can be added to attachment or side menu */
    _: 'attachmentMenuBot',
    /** User identifier of the bot */
    bot_user_id: number,
    /**
     * True, if the bot supports opening from attachment menu in the chat with the
     * bot
     */
    supports_self_chat: boolean,
    /**
     * True, if the bot supports opening from attachment menu in private chats with
     * ordinary users
     */
    supports_user_chats: boolean,
    /**
     * True, if the bot supports opening from attachment menu in private chats with
     * other bots
     */
    supports_bot_chats: boolean,
    /**
     * True, if the bot supports opening from attachment menu in basic group and supergroup
     * chats
     */
    supports_group_chats: boolean,
    /** True, if the bot supports opening from attachment menu in channel chats */
    supports_channel_chats: boolean,
    /** True, if the user must be asked for the permission to send messages to the bot */
    request_write_access: boolean,
    /**
     * True, if the bot was explicitly added by the user. If the bot isn't added, then
     * on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and
     * the bot must be added or removed
     */
    is_added: boolean,
    /** True, if the bot must be shown in the attachment menu */
    show_in_attachment_menu: boolean,
    /** True, if the bot must be shown in the side menu */
    show_in_side_menu: boolean,
    /** True, if a disclaimer, why the bot is shown in the side menu, is needed */
    show_disclaimer_in_side_menu: boolean,
    /** Name for the bot in attachment menu */
    name: string,
    /** Color to highlight selected name of the bot if appropriate; may be null */
    name_color?: attachmentMenuBotColor,
    /** Default icon for the bot in SVG format; may be null */
    default_icon?: file,
    /** Icon for the bot in SVG format for the official iOS app; may be null */
    ios_static_icon?: file,
    /** Icon for the bot in TGS format for the official iOS app; may be null */
    ios_animated_icon?: file,
    /** Icon for the bot in PNG format for the official iOS app side menu; may be null */
    ios_side_menu_icon?: file,
    /** Icon for the bot in TGS format for the official Android app; may be null */
    android_icon?: file,
    /**
     * Icon for the bot in SVG format for the official Android app side menu; may be
     * null
     */
    android_side_menu_icon?: file,
    /** Icon for the bot in TGS format for the official native macOS app; may be null */
    macos_icon?: file,
    /**
     * Icon for the bot in PNG format for the official macOS app side menu; may be
     * null
     */
    macos_side_menu_icon?: file,
    /** Color to highlight selected icon of the bot if appropriate; may be null */
    icon_color?: attachmentMenuBotColor,
    /** Default placeholder for opened Web Apps in SVG format; may be null */
    web_app_placeholder?: file,
  |}

  declare export type sentWebAppMessage = {|
    /** Information about the message sent by answerWebAppQuery */
    _: 'sentWebAppMessage',
    /** Identifier of the sent inline message, if known */
    inline_message_id: string,
  |}

  declare export type botWriteAccessAllowReasonConnectedWebsite = {|
    /** The user connected a website by logging in using Telegram Login Widget on it */
    _: 'botWriteAccessAllowReasonConnectedWebsite',
    /** Domain name of the connected website */
    domain_name: string,
  |}

  declare export type botWriteAccessAllowReasonAddedToAttachmentMenu = {|
    /** The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu */
    _: 'botWriteAccessAllowReasonAddedToAttachmentMenu',
  |}

  declare export type botWriteAccessAllowReasonLaunchedWebApp = {|
    /** The user launched a Web App using getWebAppLinkUrl */
    _: 'botWriteAccessAllowReasonLaunchedWebApp',
    /** Information about the Web App */
    web_app: webApp,
  |}

  declare export type botWriteAccessAllowReasonAcceptedRequest = {|
    /** The user accepted bot's request to send messages with allowBotToSendMessages */
    _: 'botWriteAccessAllowReasonAcceptedRequest',
  |}

  declare export type httpUrl = {|
    /** Contains an HTTP URL */
    _: 'httpUrl',
    /** The URL */
    url: string,
  |}

  declare export type userLink = {|
    /** Contains an HTTPS URL, which can be used to get information about a user */
    _: 'userLink',
    /** The URL */
    url: string,
    /**
     * Left time for which the link is valid, in seconds; 0 if the link is a public
     * username link
     */
    expires_in: number,
  |}

  declare export type targetChatTypes = {|
    /** Describes allowed types for the target chat */
    _: 'targetChatTypes',
    /** True, if private chats with ordinary users are allowed */
    allow_user_chats: boolean,
    /** True, if private chats with other bots are allowed */
    allow_bot_chats: boolean,
    /** True, if basic group and supergroup chats are allowed */
    allow_group_chats: boolean,
    /** True, if channel chats are allowed */
    allow_channel_chats: boolean,
  |}

  declare export type targetChatTypes$Input = {|
    /** Describes allowed types for the target chat */
    +_: 'targetChatTypes',
    /** True, if private chats with ordinary users are allowed */
    +allow_user_chats?: boolean,
    /** True, if private chats with other bots are allowed */
    +allow_bot_chats?: boolean,
    /** True, if basic group and supergroup chats are allowed */
    +allow_group_chats?: boolean,
    /** True, if channel chats are allowed */
    +allow_channel_chats?: boolean,
  |}

  declare export type targetChatCurrent = {|
    /** The currently opened chat and forum topic must be kept */
    _: 'targetChatCurrent',
  |}

  declare export type targetChatCurrent$Input = {|
    /** The currently opened chat and forum topic must be kept */
    +_: 'targetChatCurrent',
  |}

  declare export type targetChatChosen = {|
    /** The chat needs to be chosen by the user among chats of the specified types */
    _: 'targetChatChosen',
    /** Allowed types for the chat */
    types: targetChatTypes,
  |}

  declare export type targetChatChosen$Input = {|
    /** The chat needs to be chosen by the user among chats of the specified types */
    +_: 'targetChatChosen',
    /** Allowed types for the chat */
    +types?: targetChatTypes$Input,
  |}

  declare export type targetChatInternalLink = {|
    /** The chat needs to be open with the provided internal link */
    _: 'targetChatInternalLink',
    /** An internal link pointing to the chat */
    link: InternalLinkType,
  |}

  declare export type targetChatInternalLink$Input = {|
    /** The chat needs to be open with the provided internal link */
    +_: 'targetChatInternalLink',
    /** An internal link pointing to the chat */
    +link?: InternalLinkType$Input,
  |}

  declare export type inputInlineQueryResultAnimation$Input = {|
    /**
     * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4
     * AVC video
     */
    +_: 'inputInlineQueryResultAnimation',
    /** Unique identifier of the query result */
    +id?: string,
    /** Title of the query result */
    +title?: string,
    /** URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists */
    +thumbnail_url?: string,
    /**
     * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg",
     * "image/gif" and "video/mp4"
     */
    +thumbnail_mime_type?: string,
    /** The URL of the video file (file size must not exceed 1MB) */
    +video_url?: string,
    /** MIME type of the video file. Must be one of "image/gif" and "video/mp4" */
    +video_mime_type?: string,
    /** Duration of the video, in seconds */
    +video_duration?: number,
    /** Width of the video */
    +video_width?: number,
    /** Height of the video */
    +video_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultArticle$Input = {|
    /** Represents a link to an article or web page */
    +_: 'inputInlineQueryResultArticle',
    /** Unique identifier of the query result */
    +id?: string,
    /** URL of the result, if it exists */
    +url?: string,
    /** Title of the result */
    +title?: string,
    /** A short description of the result */
    +description?: string,
    /** URL of the result thumbnail, if it exists */
    +thumbnail_url?: string,
    /** Thumbnail width, if known */
    +thumbnail_width?: number,
    /** Thumbnail height, if known */
    +thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultAudio$Input = {|
    /** Represents a link to an MP3 audio file */
    +_: 'inputInlineQueryResultAudio',
    /** Unique identifier of the query result */
    +id?: string,
    /** Title of the audio file */
    +title?: string,
    /** Performer of the audio file */
    +performer?: string,
    /** The URL of the audio file */
    +audio_url?: string,
    /** Audio file duration, in seconds */
    +audio_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultContact$Input = {|
    /** Represents a user contact */
    +_: 'inputInlineQueryResultContact',
    /** Unique identifier of the query result */
    +id?: string,
    /** User contact */
    +contact?: contact$Input,
    /** URL of the result thumbnail, if it exists */
    +thumbnail_url?: string,
    /** Thumbnail width, if known */
    +thumbnail_width?: number,
    /** Thumbnail height, if known */
    +thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultDocument$Input = {|
    /** Represents a link to a file */
    +_: 'inputInlineQueryResultDocument',
    /** Unique identifier of the query result */
    +id?: string,
    /** Title of the resulting file */
    +title?: string,
    /** Short description of the result, if known */
    +description?: string,
    /** URL of the file */
    +document_url?: string,
    /**
     * MIME type of the file content; only "application/pdf" and "application/zip"
     * are currently allowed
     */
    +mime_type?: string,
    /** The URL of the file thumbnail, if it exists */
    +thumbnail_url?: string,
    /** Width of the thumbnail */
    +thumbnail_width?: number,
    /** Height of the thumbnail */
    +thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultGame$Input = {|
    /** Represents a game */
    +_: 'inputInlineQueryResultGame',
    /** Unique identifier of the query result */
    +id?: string,
    /** Short name of the game */
    +game_short_name?: string,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
  |}

  declare export type inputInlineQueryResultLocation$Input = {|
    /** Represents a point on the map */
    +_: 'inputInlineQueryResultLocation',
    /** Unique identifier of the query result */
    +id?: string,
    /** Location result */
    +location?: location$Input,
    /**
     * Amount of time relative to the message sent time until the location can be updated,
     * in seconds
     */
    +live_period?: number,
    /** Title of the result */
    +title?: string,
    /** URL of the result thumbnail, if it exists */
    +thumbnail_url?: string,
    /** Thumbnail width, if known */
    +thumbnail_width?: number,
    /** Thumbnail height, if known */
    +thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultPhoto$Input = {|
    /** Represents link to a JPEG image */
    +_: 'inputInlineQueryResultPhoto',
    /** Unique identifier of the query result */
    +id?: string,
    /** Title of the result, if known */
    +title?: string,
    /** A short description of the result, if known */
    +description?: string,
    /** URL of the photo thumbnail, if it exists */
    +thumbnail_url?: string,
    /** The URL of the JPEG photo (photo size must not exceed 5MB) */
    +photo_url?: string,
    /** Width of the photo */
    +photo_width?: number,
    /** Height of the photo */
    +photo_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultSticker$Input = {|
    /** Represents a link to a WEBP, TGS, or WEBM sticker */
    +_: 'inputInlineQueryResultSticker',
    /** Unique identifier of the query result */
    +id?: string,
    /** URL of the sticker thumbnail, if it exists */
    +thumbnail_url?: string,
    /**
     * The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed
     * 5MB)
     */
    +sticker_url?: string,
    /** Width of the sticker */
    +sticker_width?: number,
    /** Height of the sticker */
    +sticker_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultVenue$Input = {|
    /** Represents information about a venue */
    +_: 'inputInlineQueryResultVenue',
    /** Unique identifier of the query result */
    +id?: string,
    /** Venue result */
    +venue?: venue$Input,
    /** URL of the result thumbnail, if it exists */
    +thumbnail_url?: string,
    /** Thumbnail width, if known */
    +thumbnail_width?: number,
    /** Thumbnail height, if known */
    +thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultVideo$Input = {|
    /** Represents a link to a page containing an embedded video player or a video file */
    +_: 'inputInlineQueryResultVideo',
    /** Unique identifier of the query result */
    +id?: string,
    /** Title of the result */
    +title?: string,
    /** A short description of the result, if known */
    +description?: string,
    /** The URL of the video thumbnail (JPEG), if it exists */
    +thumbnail_url?: string,
    /** URL of the embedded video player or video file */
    +video_url?: string,
    /**
     * MIME type of the content of the video URL, only "text/html" or "video/mp4" are
     * currently supported
     */
    +mime_type?: string,
    /** Width of the video */
    +video_width?: number,
    /** Height of the video */
    +video_height?: number,
    /** Video duration, in seconds */
    +video_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inputInlineQueryResultVoiceNote$Input = {|
    /**
     * Represents a link to an opus-encoded audio file within an OGG container, single
     * channel audio
     */
    +_: 'inputInlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    +id?: string,
    /** Title of the voice note */
    +title?: string,
    /** The URL of the voice note file */
    +voice_note_url?: string,
    /** Duration of the voice note, in seconds */
    +voice_note_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type inlineQueryResultArticle = {|
    /** Represents a link to an article or web page */
    _: 'inlineQueryResultArticle',
    /** Unique identifier of the query result */
    id: string,
    /** URL of the result, if it exists */
    url: string,
    /** Title of the result */
    title: string,
    /** A short description of the result */
    description: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  |}

  declare export type inlineQueryResultContact = {|
    /** Represents a user contact */
    _: 'inlineQueryResultContact',
    /** Unique identifier of the query result */
    id: string,
    /** A user contact */
    contact: contact,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  |}

  declare export type inlineQueryResultLocation = {|
    /** Represents a point on the map */
    _: 'inlineQueryResultLocation',
    /** Unique identifier of the query result */
    id: string,
    /** Location result */
    location: location,
    /** Title of the result */
    title: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  |}

  declare export type inlineQueryResultVenue = {|
    /** Represents information about a venue */
    _: 'inlineQueryResultVenue',
    /** Unique identifier of the query result */
    id: string,
    /** Venue result */
    venue: venue,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  |}

  declare export type inlineQueryResultGame = {|
    /** Represents information about a game */
    _: 'inlineQueryResultGame',
    /** Unique identifier of the query result */
    id: string,
    /** Game result */
    game: game,
  |}

  declare export type inlineQueryResultAnimation = {|
    /** Represents an animation file */
    _: 'inlineQueryResultAnimation',
    /** Unique identifier of the query result */
    id: string,
    /** Animation file */
    animation: animation,
    /** Animation title */
    title: string,
  |}

  declare export type inlineQueryResultAudio = {|
    /** Represents an audio file */
    _: 'inlineQueryResultAudio',
    /** Unique identifier of the query result */
    id: string,
    /** Audio file */
    audio: audio,
  |}

  declare export type inlineQueryResultDocument = {|
    /** Represents a document */
    _: 'inlineQueryResultDocument',
    /** Unique identifier of the query result */
    id: string,
    /** Document */
    document: document,
    /** Document title */
    title: string,
    /** Document description */
    description: string,
  |}

  declare export type inlineQueryResultPhoto = {|
    /** Represents a photo */
    _: 'inlineQueryResultPhoto',
    /** Unique identifier of the query result */
    id: string,
    /** Photo */
    photo: photo,
    /** Title of the result, if known */
    title: string,
    /** A short description of the result, if known */
    description: string,
  |}

  declare export type inlineQueryResultSticker = {|
    /** Represents a sticker */
    _: 'inlineQueryResultSticker',
    /** Unique identifier of the query result */
    id: string,
    /** Sticker */
    sticker: sticker,
  |}

  declare export type inlineQueryResultVideo = {|
    /** Represents a video */
    _: 'inlineQueryResultVideo',
    /** Unique identifier of the query result */
    id: string,
    /** Video */
    video: video,
    /** Title of the video */
    title: string,
    /** Description of the video */
    description: string,
  |}

  declare export type inlineQueryResultVoiceNote = {|
    /** Represents a voice note */
    _: 'inlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    id: string,
    /** Voice note */
    voice_note: voiceNote,
    /** Title of the voice note */
    title: string,
  |}

  declare export type inlineQueryResultsButtonTypeStartBot = {|
    /**
     * Describes the button that opens a private chat with the bot and sends a start
     * message to the bot with the given parameter
     */
    _: 'inlineQueryResultsButtonTypeStartBot',
    /** The parameter for the bot start message */
    parameter: string,
  |}

  declare export type inlineQueryResultsButtonTypeStartBot$Input = {|
    /**
     * Describes the button that opens a private chat with the bot and sends a start
     * message to the bot with the given parameter
     */
    +_: 'inlineQueryResultsButtonTypeStartBot',
    /** The parameter for the bot start message */
    +parameter?: string,
  |}

  declare export type inlineQueryResultsButtonTypeWebApp = {|
    /** Describes the button that opens a Web App by calling getWebAppUrl */
    _: 'inlineQueryResultsButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    url: string,
  |}

  declare export type inlineQueryResultsButtonTypeWebApp$Input = {|
    /** Describes the button that opens a Web App by calling getWebAppUrl */
    +_: 'inlineQueryResultsButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    +url?: string,
  |}

  declare export type inlineQueryResultsButton = {|
    /** Represents a button to be shown above inline query results */
    _: 'inlineQueryResultsButton',
    /** The text of the button */
    text: string,
    /** Type of the button */
    type: InlineQueryResultsButtonType,
  |}

  declare export type inlineQueryResultsButton$Input = {|
    /** Represents a button to be shown above inline query results */
    +_: 'inlineQueryResultsButton',
    /** The text of the button */
    +text?: string,
    /** Type of the button */
    +type?: InlineQueryResultsButtonType$Input,
  |}

  declare export type inlineQueryResults = {|
    /**
     * Represents the results of the inline query. Use sendInlineQueryResultMessage
     * to send the result of the query
     */
    _: 'inlineQueryResults',
    /** Unique identifier of the inline query */
    inline_query_id: string,
    /** Button to be shown above inline query results; may be null */
    button?: inlineQueryResultsButton,
    /** Results of the query */
    results: Array<InlineQueryResult>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  |}

  declare export type preparedInlineMessageId = {|
    /** Represents an inline message that can be sent via the bot */
    _: 'preparedInlineMessageId',
    /** Unique identifier for the message */
    id: string,
    /** Point in time (Unix timestamp) when the message can't be used anymore */
    expiration_date: number,
  |}

  declare export type preparedInlineMessage = {|
    /**
     * Represents a ready to send inline message. Use sendInlineQueryResultMessage
     * to send the message
     */
    _: 'preparedInlineMessage',
    /** Unique identifier of the inline query to pass to sendInlineQueryResultMessage */
    inline_query_id: string,
    /** Resulted inline message of the query */
    result: InlineQueryResult,
    /** Types of the chats to which the message can be sent */
    chat_types: targetChatTypes,
  |}

  declare export type callbackQueryPayloadData = {|
    /** The payload for a general callback button */
    _: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    data: string /* base64 */,
  |}

  declare export type callbackQueryPayloadData$Input = {|
    /** The payload for a general callback button */
    +_: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    +data?: string /* base64 */,
  |}

  declare export type callbackQueryPayloadDataWithPassword = {|
    /** The payload for a callback button requiring password */
    _: 'callbackQueryPayloadDataWithPassword',
    /** The 2-step verification password for the current user */
    password: string,
    /** Data that was attached to the callback button */
    data: string /* base64 */,
  |}

  declare export type callbackQueryPayloadDataWithPassword$Input = {|
    /** The payload for a callback button requiring password */
    +_: 'callbackQueryPayloadDataWithPassword',
    /** The 2-step verification password for the current user */
    +password?: string,
    /** Data that was attached to the callback button */
    +data?: string /* base64 */,
  |}

  declare export type callbackQueryPayloadGame = {|
    /** The payload for a game callback button */
    _: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    game_short_name: string,
  |}

  declare export type callbackQueryPayloadGame$Input = {|
    /** The payload for a game callback button */
    +_: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    +game_short_name?: string,
  |}

  declare export type callbackQueryAnswer = {|
    /** Contains a bot's answer to a callback query */
    _: 'callbackQueryAnswer',
    /** Text of the answer */
    text: string,
    /** True, if an alert must be shown to the user instead of a toast notification */
    show_alert: boolean,
    /** URL to be opened */
    url: string,
  |}

  declare export type customRequestResult = {|
    /** Contains the result of a custom request */
    _: 'customRequestResult',
    /** A JSON-serialized result */
    result: string,
  |}

  declare export type gameHighScore = {|
    /** Contains one row of the game high score table */
    _: 'gameHighScore',
    /** Position in the high score table */
    position: number,
    /** User identifier */
    user_id: number,
    /** User score */
    score: number,
  |}

  declare export type gameHighScores = {|
    /** Contains a list of game high scores */
    _: 'gameHighScores',
    /** A list of game high scores */
    scores: Array<gameHighScore>,
  |}

  declare export type chatEventMessageEdited = {|
    /** A message was edited */
    _: 'chatEventMessageEdited',
    /** The original message before the edit */
    old_message: message,
    /** The message after it was edited */
    new_message: message,
  |}

  declare export type chatEventMessageDeleted = {|
    /** A message was deleted */
    _: 'chatEventMessageDeleted',
    /** Deleted message */
    message: message,
    /** True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive */
    can_report_anti_spam_false_positive: boolean,
  |}

  declare export type chatEventMessagePinned = {|
    /** A message was pinned */
    _: 'chatEventMessagePinned',
    /** Pinned message */
    message: message,
  |}

  declare export type chatEventMessageUnpinned = {|
    /** A message was unpinned */
    _: 'chatEventMessageUnpinned',
    /** Unpinned message */
    message: message,
  |}

  declare export type chatEventPollStopped = {|
    /** A poll in a message was stopped */
    _: 'chatEventPollStopped',
    /** The message with the poll */
    message: message,
  |}

  declare export type chatEventMemberJoined = {|
    /** A new member joined the chat */
    _: 'chatEventMemberJoined',
  |}

  declare export type chatEventMemberJoinedByInviteLink = {|
    /** A new member joined the chat via an invite link */
    _: 'chatEventMemberJoinedByInviteLink',
    /** Invite link used to join the chat */
    invite_link: chatInviteLink,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
  |}

  declare export type chatEventMemberJoinedByRequest = {|
    /** A new member was accepted to the chat by an administrator */
    _: 'chatEventMemberJoinedByRequest',
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
    /** Invite link used to join the chat; may be null */
    invite_link?: chatInviteLink,
  |}

  declare export type chatEventMemberInvited = {|
    /** A new chat member was invited */
    _: 'chatEventMemberInvited',
    /** New member user identifier */
    user_id: number,
    /** New member status */
    status: ChatMemberStatus,
  |}

  declare export type chatEventMemberLeft = {|
    /** A member left the chat */
    _: 'chatEventMemberLeft',
  |}

  declare export type chatEventMemberPromoted = {|
    /**
     * A chat member has gained/lost administrator status, or the list of their administrator
     * privileges has changed
     */
    _: 'chatEventMemberPromoted',
    /** Affected chat member user identifier */
    user_id: number,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  |}

  declare export type chatEventMemberRestricted = {|
    /**
     * A chat member was restricted/unrestricted or banned/unbanned, or the list of
     * their restrictions has changed
     */
    _: 'chatEventMemberRestricted',
    /** Affected chat member identifier */
    member_id: MessageSender,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  |}

  declare export type chatEventMemberSubscriptionExtended = {|
    /** A chat member extended their subscription to the chat */
    _: 'chatEventMemberSubscriptionExtended',
    /** Affected chat member user identifier */
    user_id: number,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  |}

  declare export type chatEventAvailableReactionsChanged = {|
    /** The chat available reactions were changed */
    _: 'chatEventAvailableReactionsChanged',
    /** Previous chat available reactions */
    old_available_reactions: ChatAvailableReactions,
    /** New chat available reactions */
    new_available_reactions: ChatAvailableReactions,
  |}

  declare export type chatEventBackgroundChanged = {|
    /** The chat background was changed */
    _: 'chatEventBackgroundChanged',
    /** Previous background; may be null if none */
    old_background?: chatBackground,
    /** New background; may be null if none */
    new_background?: chatBackground,
  |}

  declare export type chatEventDescriptionChanged = {|
    /** The chat description was changed */
    _: 'chatEventDescriptionChanged',
    /** Previous chat description */
    old_description: string,
    /** New chat description */
    new_description: string,
  |}

  declare export type chatEventEmojiStatusChanged = {|
    /** The chat emoji status was changed */
    _: 'chatEventEmojiStatusChanged',
    /** Previous emoji status; may be null if none */
    old_emoji_status?: emojiStatus,
    /** New emoji status; may be null if none */
    new_emoji_status?: emojiStatus,
  |}

  declare export type chatEventLinkedChatChanged = {|
    /** The linked chat of a supergroup was changed */
    _: 'chatEventLinkedChatChanged',
    /** Previous supergroup linked chat identifier */
    old_linked_chat_id: number,
    /** New supergroup linked chat identifier */
    new_linked_chat_id: number,
  |}

  declare export type chatEventLocationChanged = {|
    /** The supergroup location was changed */
    _: 'chatEventLocationChanged',
    /** Previous location; may be null */
    old_location?: chatLocation,
    /** New location; may be null */
    new_location?: chatLocation,
  |}

  declare export type chatEventMessageAutoDeleteTimeChanged = {|
    /** The message auto-delete timer was changed */
    _: 'chatEventMessageAutoDeleteTimeChanged',
    /** Previous value of message_auto_delete_time */
    old_message_auto_delete_time: number,
    /** New value of message_auto_delete_time */
    new_message_auto_delete_time: number,
  |}

  declare export type chatEventPermissionsChanged = {|
    /** The chat permissions were changed */
    _: 'chatEventPermissionsChanged',
    /** Previous chat permissions */
    old_permissions: chatPermissions,
    /** New chat permissions */
    new_permissions: chatPermissions,
  |}

  declare export type chatEventPhotoChanged = {|
    /** The chat photo was changed */
    _: 'chatEventPhotoChanged',
    /** Previous chat photo value; may be null */
    old_photo?: chatPhoto,
    /** New chat photo value; may be null */
    new_photo?: chatPhoto,
  |}

  declare export type chatEventSlowModeDelayChanged = {|
    /** The slow_mode_delay setting of a supergroup was changed */
    _: 'chatEventSlowModeDelayChanged',
    /** Previous value of slow_mode_delay, in seconds */
    old_slow_mode_delay: number,
    /** New value of slow_mode_delay, in seconds */
    new_slow_mode_delay: number,
  |}

  declare export type chatEventStickerSetChanged = {|
    /** The supergroup sticker set was changed */
    _: 'chatEventStickerSetChanged',
    /** Previous identifier of the chat sticker set; 0 if none */
    old_sticker_set_id: string,
    /** New identifier of the chat sticker set; 0 if none */
    new_sticker_set_id: string,
  |}

  declare export type chatEventCustomEmojiStickerSetChanged = {|
    /** The supergroup sticker set with allowed custom emoji was changed */
    _: 'chatEventCustomEmojiStickerSetChanged',
    /** Previous identifier of the chat sticker set; 0 if none */
    old_sticker_set_id: string,
    /** New identifier of the chat sticker set; 0 if none */
    new_sticker_set_id: string,
  |}

  declare export type chatEventTitleChanged = {|
    /** The chat title was changed */
    _: 'chatEventTitleChanged',
    /** Previous chat title */
    old_title: string,
    /** New chat title */
    new_title: string,
  |}

  declare export type chatEventUsernameChanged = {|
    /** The chat editable username was changed */
    _: 'chatEventUsernameChanged',
    /** Previous chat username */
    old_username: string,
    /** New chat username */
    new_username: string,
  |}

  declare export type chatEventActiveUsernamesChanged = {|
    /** The chat active usernames were changed */
    _: 'chatEventActiveUsernamesChanged',
    /** Previous list of active usernames */
    old_usernames: Array<string>,
    /** New list of active usernames */
    new_usernames: Array<string>,
  |}

  declare export type chatEventAccentColorChanged = {|
    /** The chat accent color or background custom emoji were changed */
    _: 'chatEventAccentColorChanged',
    /** Previous identifier of chat accent color */
    old_accent_color_id: number,
    /** Previous identifier of the custom emoji; 0 if none */
    old_background_custom_emoji_id: string,
    /** New identifier of chat accent color */
    new_accent_color_id: number,
    /** New identifier of the custom emoji; 0 if none */
    new_background_custom_emoji_id: string,
  |}

  declare export type chatEventProfileAccentColorChanged = {|
    /** The chat's profile accent color or profile background custom emoji were changed */
    _: 'chatEventProfileAccentColorChanged',
    /** Previous identifier of chat's profile accent color; -1 if none */
    old_profile_accent_color_id: number,
    /** Previous identifier of the custom emoji; 0 if none */
    old_profile_background_custom_emoji_id: string,
    /** New identifier of chat's profile accent color; -1 if none */
    new_profile_accent_color_id: number,
    /** New identifier of the custom emoji; 0 if none */
    new_profile_background_custom_emoji_id: string,
  |}

  declare export type chatEventHasProtectedContentToggled = {|
    /** The has_protected_content setting of a channel was toggled */
    _: 'chatEventHasProtectedContentToggled',
    /** New value of has_protected_content */
    has_protected_content: boolean,
  |}

  declare export type chatEventInvitesToggled = {|
    /** The can_invite_users permission of a supergroup chat was toggled */
    _: 'chatEventInvitesToggled',
    /** New value of can_invite_users permission */
    can_invite_users: boolean,
  |}

  declare export type chatEventIsAllHistoryAvailableToggled = {|
    /** The is_all_history_available setting of a supergroup was toggled */
    _: 'chatEventIsAllHistoryAvailableToggled',
    /** New value of is_all_history_available */
    is_all_history_available: boolean,
  |}

  declare export type chatEventHasAggressiveAntiSpamEnabledToggled = {|
    /** The has_aggressive_anti_spam_enabled setting of a supergroup was toggled */
    _: 'chatEventHasAggressiveAntiSpamEnabledToggled',
    /** New value of has_aggressive_anti_spam_enabled */
    has_aggressive_anti_spam_enabled: boolean,
  |}

  declare export type chatEventSignMessagesToggled = {|
    /** The sign_messages setting of a channel was toggled */
    _: 'chatEventSignMessagesToggled',
    /** New value of sign_messages */
    sign_messages: boolean,
  |}

  declare export type chatEventShowMessageSenderToggled = {|
    /** The show_message_sender setting of a channel was toggled */
    _: 'chatEventShowMessageSenderToggled',
    /** New value of show_message_sender */
    show_message_sender: boolean,
  |}

  declare export type chatEventInviteLinkEdited = {|
    /** A chat invite link was edited */
    _: 'chatEventInviteLinkEdited',
    /** Previous information about the invite link */
    old_invite_link: chatInviteLink,
    /** New information about the invite link */
    new_invite_link: chatInviteLink,
  |}

  declare export type chatEventInviteLinkRevoked = {|
    /** A chat invite link was revoked */
    _: 'chatEventInviteLinkRevoked',
    /** The invite link */
    invite_link: chatInviteLink,
  |}

  declare export type chatEventInviteLinkDeleted = {|
    /** A revoked chat invite link was deleted */
    _: 'chatEventInviteLinkDeleted',
    /** The invite link */
    invite_link: chatInviteLink,
  |}

  declare export type chatEventVideoChatCreated = {|
    /** A video chat was created */
    _: 'chatEventVideoChatCreated',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  |}

  declare export type chatEventVideoChatEnded = {|
    /** A video chat was ended */
    _: 'chatEventVideoChatEnded',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  |}

  declare export type chatEventVideoChatMuteNewParticipantsToggled = {|
    /** The mute_new_participants setting of a video chat was toggled */
    _: 'chatEventVideoChatMuteNewParticipantsToggled',
    /** New value of the mute_new_participants setting */
    mute_new_participants: boolean,
  |}

  declare export type chatEventVideoChatParticipantIsMutedToggled = {|
    /** A video chat participant was muted or unmuted */
    _: 'chatEventVideoChatParticipantIsMutedToggled',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of is_muted */
    is_muted: boolean,
  |}

  declare export type chatEventVideoChatParticipantVolumeLevelChanged = {|
    /** A video chat participant volume level was changed */
    _: 'chatEventVideoChatParticipantVolumeLevelChanged',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of volume_level; 1-20000 in hundreds of percents */
    volume_level: number,
  |}

  declare export type chatEventIsForumToggled = {|
    /** The is_forum setting of a channel was toggled */
    _: 'chatEventIsForumToggled',
    /** New value of is_forum */
    is_forum: boolean,
  |}

  declare export type chatEventForumTopicCreated = {|
    /** A new forum topic was created */
    _: 'chatEventForumTopicCreated',
    /** Information about the topic */
    topic_info: forumTopicInfo,
  |}

  declare export type chatEventForumTopicEdited = {|
    /** A forum topic was edited */
    _: 'chatEventForumTopicEdited',
    /** Old information about the topic */
    old_topic_info: forumTopicInfo,
    /** New information about the topic */
    new_topic_info: forumTopicInfo,
  |}

  declare export type chatEventForumTopicToggleIsClosed = {|
    /** A forum topic was closed or reopened */
    _: 'chatEventForumTopicToggleIsClosed',
    /** New information about the topic */
    topic_info: forumTopicInfo,
  |}

  declare export type chatEventForumTopicToggleIsHidden = {|
    /** The General forum topic was hidden or unhidden */
    _: 'chatEventForumTopicToggleIsHidden',
    /** New information about the topic */
    topic_info: forumTopicInfo,
  |}

  declare export type chatEventForumTopicDeleted = {|
    /** A forum topic was deleted */
    _: 'chatEventForumTopicDeleted',
    /** Information about the topic */
    topic_info: forumTopicInfo,
  |}

  declare export type chatEventForumTopicPinned = {|
    /** A pinned forum topic was changed */
    _: 'chatEventForumTopicPinned',
    /** Information about the old pinned topic; may be null */
    old_topic_info?: forumTopicInfo,
    /** Information about the new pinned topic; may be null */
    new_topic_info?: forumTopicInfo,
  |}

  declare export type chatEvent = {|
    /** Represents a chat event */
    _: 'chatEvent',
    /** Chat event identifier */
    id: string,
    /** Point in time (Unix timestamp) when the event happened */
    date: number,
    /** Identifier of the user or chat who performed the action */
    member_id: MessageSender,
    /** The action */
    action: ChatEventAction,
  |}

  declare export type chatEvents = {|
    /** Contains a list of chat events */
    _: 'chatEvents',
    /** List of events */
    events: Array<chatEvent>,
  |}

  declare export type chatEventLogFilters$Input = {|
    /** Represents a set of filters used to obtain a chat event log */
    +_: 'chatEventLogFilters',
    /** True, if message edits need to be returned */
    +message_edits?: boolean,
    /** True, if message deletions need to be returned */
    +message_deletions?: boolean,
    /** True, if pin/unpin events need to be returned */
    +message_pins?: boolean,
    /** True, if members joining events need to be returned */
    +member_joins?: boolean,
    /** True, if members leaving events need to be returned */
    +member_leaves?: boolean,
    /** True, if invited member events need to be returned */
    +member_invites?: boolean,
    /** True, if member promotion/demotion events need to be returned */
    +member_promotions?: boolean,
    /** True, if member restricted/unrestricted/banned/unbanned events need to be returned */
    +member_restrictions?: boolean,
    /** True, if changes in chat information need to be returned */
    +info_changes?: boolean,
    /** True, if changes in chat settings need to be returned */
    +setting_changes?: boolean,
    /** True, if changes to invite links need to be returned */
    +invite_link_changes?: boolean,
    /** True, if video chat actions need to be returned */
    +video_chat_changes?: boolean,
    /** True, if forum-related actions need to be returned */
    +forum_changes?: boolean,
    /** True, if subscription extensions need to be returned */
    +subscription_extensions?: boolean,
  |}

  declare export type languagePackStringValueOrdinary = {|
    /** An ordinary language pack string */
    _: 'languagePackStringValueOrdinary',
    /** String value */
    value: string,
  |}

  declare export type languagePackStringValueOrdinary$Input = {|
    /** An ordinary language pack string */
    +_: 'languagePackStringValueOrdinary',
    /** String value */
    +value?: string,
  |}

  declare export type languagePackStringValuePluralized = {|
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    _: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    zero_value: string,
    /** Value for one object */
    one_value: string,
    /** Value for two objects */
    two_value: string,
    /** Value for few objects */
    few_value: string,
    /** Value for many objects */
    many_value: string,
    /** Default value */
    other_value: string,
  |}

  declare export type languagePackStringValuePluralized$Input = {|
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    +_: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    +zero_value?: string,
    /** Value for one object */
    +one_value?: string,
    /** Value for two objects */
    +two_value?: string,
    /** Value for few objects */
    +few_value?: string,
    /** Value for many objects */
    +many_value?: string,
    /** Default value */
    +other_value?: string,
  |}

  declare export type languagePackStringValueDeleted = {|
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    _: 'languagePackStringValueDeleted',
  |}

  declare export type languagePackStringValueDeleted$Input = {|
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    +_: 'languagePackStringValueDeleted',
  |}

  declare export type languagePackString = {|
    /** Represents one language pack string */
    _: 'languagePackString',
    /** String key */
    key: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    value: LanguagePackStringValue,
  |}

  declare export type languagePackString$Input = {|
    /** Represents one language pack string */
    +_: 'languagePackString',
    /** String key */
    +key?: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    +value?: LanguagePackStringValue$Input,
  |}

  declare export type languagePackStrings = {|
    /** Contains a list of language pack strings */
    _: 'languagePackStrings',
    /** A list of language pack strings */
    strings: Array<languagePackString>,
  |}

  declare export type languagePackInfo = {|
    /** Contains information about a language pack */
    _: 'languagePackInfo',
    /** Unique language pack identifier */
    id: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    base_language_pack_id: string,
    /** Language name */
    name: string,
    /** Name of the language in that language */
    native_name: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    plural_code: string,
    /** True, if the language pack is official */
    is_official: boolean,
    /** True, if the language pack strings are RTL */
    is_rtl: boolean,
    /** True, if the language pack is a beta language pack */
    is_beta: boolean,
    /** True, if the language pack is installed by the current user */
    is_installed: boolean,
    /** Total number of non-deleted strings from the language pack */
    total_string_count: number,
    /** Total number of translated strings from the language pack */
    translated_string_count: number,
    /** Total number of non-deleted strings from the language pack available locally */
    local_string_count: number,
    /** Link to language translation interface; empty for custom local language packs */
    translation_url: string,
  |}

  declare export type languagePackInfo$Input = {|
    /** Contains information about a language pack */
    +_: 'languagePackInfo',
    /** Unique language pack identifier */
    +id?: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    +base_language_pack_id?: string,
    /** Language name */
    +name?: string,
    /** Name of the language in that language */
    +native_name?: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    +plural_code?: string,
    /** True, if the language pack is official */
    +is_official?: boolean,
    /** True, if the language pack strings are RTL */
    +is_rtl?: boolean,
    /** True, if the language pack is a beta language pack */
    +is_beta?: boolean,
    /** True, if the language pack is installed by the current user */
    +is_installed?: boolean,
    /** Total number of non-deleted strings from the language pack */
    +total_string_count?: number,
    /** Total number of translated strings from the language pack */
    +translated_string_count?: number,
    /** Total number of non-deleted strings from the language pack available locally */
    +local_string_count?: number,
    /** Link to language translation interface; empty for custom local language packs */
    +translation_url?: string,
  |}

  declare export type localizationTargetInfo = {|
    /** Contains information about the current localization target */
    _: 'localizationTargetInfo',
    /** List of available language packs for this application */
    language_packs: Array<languagePackInfo>,
  |}

  declare export type premiumLimitTypeSupergroupCount = {|
    /** The maximum number of joined supergroups and channels */
    _: 'premiumLimitTypeSupergroupCount',
  |}

  declare export type premiumLimitTypeSupergroupCount$Input = {|
    /** The maximum number of joined supergroups and channels */
    +_: 'premiumLimitTypeSupergroupCount',
  |}

  declare export type premiumLimitTypePinnedChatCount = {|
    /** The maximum number of pinned chats in the main chat list */
    _: 'premiumLimitTypePinnedChatCount',
  |}

  declare export type premiumLimitTypePinnedChatCount$Input = {|
    /** The maximum number of pinned chats in the main chat list */
    +_: 'premiumLimitTypePinnedChatCount',
  |}

  declare export type premiumLimitTypeCreatedPublicChatCount = {|
    /** The maximum number of created public chats */
    _: 'premiumLimitTypeCreatedPublicChatCount',
  |}

  declare export type premiumLimitTypeCreatedPublicChatCount$Input = {|
    /** The maximum number of created public chats */
    +_: 'premiumLimitTypeCreatedPublicChatCount',
  |}

  declare export type premiumLimitTypeSavedAnimationCount = {|
    /** The maximum number of saved animations */
    _: 'premiumLimitTypeSavedAnimationCount',
  |}

  declare export type premiumLimitTypeSavedAnimationCount$Input = {|
    /** The maximum number of saved animations */
    +_: 'premiumLimitTypeSavedAnimationCount',
  |}

  declare export type premiumLimitTypeFavoriteStickerCount = {|
    /** The maximum number of favorite stickers */
    _: 'premiumLimitTypeFavoriteStickerCount',
  |}

  declare export type premiumLimitTypeFavoriteStickerCount$Input = {|
    /** The maximum number of favorite stickers */
    +_: 'premiumLimitTypeFavoriteStickerCount',
  |}

  declare export type premiumLimitTypeChatFolderCount = {|
    /** The maximum number of chat folders */
    _: 'premiumLimitTypeChatFolderCount',
  |}

  declare export type premiumLimitTypeChatFolderCount$Input = {|
    /** The maximum number of chat folders */
    +_: 'premiumLimitTypeChatFolderCount',
  |}

  declare export type premiumLimitTypeChatFolderChosenChatCount = {|
    /**
     * The maximum number of pinned and always included, or always excluded chats in
     * a chat folder
     */
    _: 'premiumLimitTypeChatFolderChosenChatCount',
  |}

  declare export type premiumLimitTypeChatFolderChosenChatCount$Input = {|
    /**
     * The maximum number of pinned and always included, or always excluded chats in
     * a chat folder
     */
    +_: 'premiumLimitTypeChatFolderChosenChatCount',
  |}

  declare export type premiumLimitTypePinnedArchivedChatCount = {|
    /** The maximum number of pinned chats in the archive chat list */
    _: 'premiumLimitTypePinnedArchivedChatCount',
  |}

  declare export type premiumLimitTypePinnedArchivedChatCount$Input = {|
    /** The maximum number of pinned chats in the archive chat list */
    +_: 'premiumLimitTypePinnedArchivedChatCount',
  |}

  declare export type premiumLimitTypePinnedSavedMessagesTopicCount = {|
    /** The maximum number of pinned Saved Messages topics */
    _: 'premiumLimitTypePinnedSavedMessagesTopicCount',
  |}

  declare export type premiumLimitTypePinnedSavedMessagesTopicCount$Input = {|
    /** The maximum number of pinned Saved Messages topics */
    +_: 'premiumLimitTypePinnedSavedMessagesTopicCount',
  |}

  declare export type premiumLimitTypeCaptionLength = {|
    /** The maximum length of sent media caption */
    _: 'premiumLimitTypeCaptionLength',
  |}

  declare export type premiumLimitTypeCaptionLength$Input = {|
    /** The maximum length of sent media caption */
    +_: 'premiumLimitTypeCaptionLength',
  |}

  declare export type premiumLimitTypeBioLength = {|
    /** The maximum length of the user's bio */
    _: 'premiumLimitTypeBioLength',
  |}

  declare export type premiumLimitTypeBioLength$Input = {|
    /** The maximum length of the user's bio */
    +_: 'premiumLimitTypeBioLength',
  |}

  declare export type premiumLimitTypeChatFolderInviteLinkCount = {|
    /** The maximum number of invite links for a chat folder */
    _: 'premiumLimitTypeChatFolderInviteLinkCount',
  |}

  declare export type premiumLimitTypeChatFolderInviteLinkCount$Input = {|
    /** The maximum number of invite links for a chat folder */
    +_: 'premiumLimitTypeChatFolderInviteLinkCount',
  |}

  declare export type premiumLimitTypeShareableChatFolderCount = {|
    /** The maximum number of added shareable chat folders */
    _: 'premiumLimitTypeShareableChatFolderCount',
  |}

  declare export type premiumLimitTypeShareableChatFolderCount$Input = {|
    /** The maximum number of added shareable chat folders */
    +_: 'premiumLimitTypeShareableChatFolderCount',
  |}

  declare export type premiumLimitTypeActiveStoryCount = {|
    /** The maximum number of active stories */
    _: 'premiumLimitTypeActiveStoryCount',
  |}

  declare export type premiumLimitTypeActiveStoryCount$Input = {|
    /** The maximum number of active stories */
    +_: 'premiumLimitTypeActiveStoryCount',
  |}

  declare export type premiumLimitTypeWeeklySentStoryCount = {|
    /** The maximum number of stories sent per week */
    _: 'premiumLimitTypeWeeklySentStoryCount',
  |}

  declare export type premiumLimitTypeWeeklySentStoryCount$Input = {|
    /** The maximum number of stories sent per week */
    +_: 'premiumLimitTypeWeeklySentStoryCount',
  |}

  declare export type premiumLimitTypeMonthlySentStoryCount = {|
    /** The maximum number of stories sent per month */
    _: 'premiumLimitTypeMonthlySentStoryCount',
  |}

  declare export type premiumLimitTypeMonthlySentStoryCount$Input = {|
    /** The maximum number of stories sent per month */
    +_: 'premiumLimitTypeMonthlySentStoryCount',
  |}

  declare export type premiumLimitTypeStoryCaptionLength = {|
    /** The maximum length of captions of sent stories */
    _: 'premiumLimitTypeStoryCaptionLength',
  |}

  declare export type premiumLimitTypeStoryCaptionLength$Input = {|
    /** The maximum length of captions of sent stories */
    +_: 'premiumLimitTypeStoryCaptionLength',
  |}

  declare export type premiumLimitTypeStorySuggestedReactionAreaCount = {|
    /** The maximum number of suggested reaction areas on a story */
    _: 'premiumLimitTypeStorySuggestedReactionAreaCount',
  |}

  declare export type premiumLimitTypeStorySuggestedReactionAreaCount$Input = {|
    /** The maximum number of suggested reaction areas on a story */
    +_: 'premiumLimitTypeStorySuggestedReactionAreaCount',
  |}

  declare export type premiumLimitTypeSimilarChatCount = {|
    /** The maximum number of received similar chats */
    _: 'premiumLimitTypeSimilarChatCount',
  |}

  declare export type premiumLimitTypeSimilarChatCount$Input = {|
    /** The maximum number of received similar chats */
    +_: 'premiumLimitTypeSimilarChatCount',
  |}

  declare export type premiumFeatureIncreasedLimits = {|
    /** Increased limits */
    _: 'premiumFeatureIncreasedLimits',
  |}

  declare export type premiumFeatureIncreasedLimits$Input = {|
    /** Increased limits */
    +_: 'premiumFeatureIncreasedLimits',
  |}

  declare export type premiumFeatureIncreasedUploadFileSize = {|
    /** Increased maximum upload file size */
    _: 'premiumFeatureIncreasedUploadFileSize',
  |}

  declare export type premiumFeatureIncreasedUploadFileSize$Input = {|
    /** Increased maximum upload file size */
    +_: 'premiumFeatureIncreasedUploadFileSize',
  |}

  declare export type premiumFeatureImprovedDownloadSpeed = {|
    /** Improved download speed */
    _: 'premiumFeatureImprovedDownloadSpeed',
  |}

  declare export type premiumFeatureImprovedDownloadSpeed$Input = {|
    /** Improved download speed */
    +_: 'premiumFeatureImprovedDownloadSpeed',
  |}

  declare export type premiumFeatureVoiceRecognition = {|
    /** The ability to convert voice notes to text */
    _: 'premiumFeatureVoiceRecognition',
  |}

  declare export type premiumFeatureVoiceRecognition$Input = {|
    /** The ability to convert voice notes to text */
    +_: 'premiumFeatureVoiceRecognition',
  |}

  declare export type premiumFeatureDisabledAds = {|
    /** Disabled ads */
    _: 'premiumFeatureDisabledAds',
  |}

  declare export type premiumFeatureDisabledAds$Input = {|
    /** Disabled ads */
    +_: 'premiumFeatureDisabledAds',
  |}

  declare export type premiumFeatureUniqueReactions = {|
    /** Allowed to use more reactions */
    _: 'premiumFeatureUniqueReactions',
  |}

  declare export type premiumFeatureUniqueReactions$Input = {|
    /** Allowed to use more reactions */
    +_: 'premiumFeatureUniqueReactions',
  |}

  declare export type premiumFeatureUniqueStickers = {|
    /** Allowed to use premium stickers with unique effects */
    _: 'premiumFeatureUniqueStickers',
  |}

  declare export type premiumFeatureUniqueStickers$Input = {|
    /** Allowed to use premium stickers with unique effects */
    +_: 'premiumFeatureUniqueStickers',
  |}

  declare export type premiumFeatureCustomEmoji = {|
    /** Allowed to use custom emoji stickers in message texts and captions */
    _: 'premiumFeatureCustomEmoji',
  |}

  declare export type premiumFeatureCustomEmoji$Input = {|
    /** Allowed to use custom emoji stickers in message texts and captions */
    +_: 'premiumFeatureCustomEmoji',
  |}

  declare export type premiumFeatureAdvancedChatManagement = {|
    /**
     * Ability to change position of the main chat list, archive and mute all new chats
     * from non-contacts, and completely disable notifications about the user's contacts
     * joined Telegram
     */
    _: 'premiumFeatureAdvancedChatManagement',
  |}

  declare export type premiumFeatureAdvancedChatManagement$Input = {|
    /**
     * Ability to change position of the main chat list, archive and mute all new chats
     * from non-contacts, and completely disable notifications about the user's contacts
     * joined Telegram
     */
    +_: 'premiumFeatureAdvancedChatManagement',
  |}

  declare export type premiumFeatureProfileBadge = {|
    /** A badge in the user's profile */
    _: 'premiumFeatureProfileBadge',
  |}

  declare export type premiumFeatureProfileBadge$Input = {|
    /** A badge in the user's profile */
    +_: 'premiumFeatureProfileBadge',
  |}

  declare export type premiumFeatureEmojiStatus = {|
    /** The ability to show an emoji status along with the user's name */
    _: 'premiumFeatureEmojiStatus',
  |}

  declare export type premiumFeatureEmojiStatus$Input = {|
    /** The ability to show an emoji status along with the user's name */
    +_: 'premiumFeatureEmojiStatus',
  |}

  declare export type premiumFeatureAnimatedProfilePhoto = {|
    /** Profile photo animation on message and chat screens */
    _: 'premiumFeatureAnimatedProfilePhoto',
  |}

  declare export type premiumFeatureAnimatedProfilePhoto$Input = {|
    /** Profile photo animation on message and chat screens */
    +_: 'premiumFeatureAnimatedProfilePhoto',
  |}

  declare export type premiumFeatureForumTopicIcon = {|
    /** The ability to set a custom emoji as a forum topic icon */
    _: 'premiumFeatureForumTopicIcon',
  |}

  declare export type premiumFeatureForumTopicIcon$Input = {|
    /** The ability to set a custom emoji as a forum topic icon */
    +_: 'premiumFeatureForumTopicIcon',
  |}

  declare export type premiumFeatureAppIcons = {|
    /** Allowed to set a premium application icons */
    _: 'premiumFeatureAppIcons',
  |}

  declare export type premiumFeatureAppIcons$Input = {|
    /** Allowed to set a premium application icons */
    +_: 'premiumFeatureAppIcons',
  |}

  declare export type premiumFeatureRealTimeChatTranslation = {|
    /** Allowed to translate chat messages real-time */
    _: 'premiumFeatureRealTimeChatTranslation',
  |}

  declare export type premiumFeatureRealTimeChatTranslation$Input = {|
    /** Allowed to translate chat messages real-time */
    +_: 'premiumFeatureRealTimeChatTranslation',
  |}

  declare export type premiumFeatureUpgradedStories = {|
    /** Allowed to use many additional features for stories */
    _: 'premiumFeatureUpgradedStories',
  |}

  declare export type premiumFeatureUpgradedStories$Input = {|
    /** Allowed to use many additional features for stories */
    +_: 'premiumFeatureUpgradedStories',
  |}

  declare export type premiumFeatureChatBoost = {|
    /** The ability to boost chats */
    _: 'premiumFeatureChatBoost',
  |}

  declare export type premiumFeatureChatBoost$Input = {|
    /** The ability to boost chats */
    +_: 'premiumFeatureChatBoost',
  |}

  declare export type premiumFeatureAccentColor = {|
    /** The ability to choose accent color for replies and user profile */
    _: 'premiumFeatureAccentColor',
  |}

  declare export type premiumFeatureAccentColor$Input = {|
    /** The ability to choose accent color for replies and user profile */
    +_: 'premiumFeatureAccentColor',
  |}

  declare export type premiumFeatureBackgroundForBoth = {|
    /** The ability to set private chat background for both users */
    _: 'premiumFeatureBackgroundForBoth',
  |}

  declare export type premiumFeatureBackgroundForBoth$Input = {|
    /** The ability to set private chat background for both users */
    +_: 'premiumFeatureBackgroundForBoth',
  |}

  declare export type premiumFeatureSavedMessagesTags = {|
    /** The ability to use tags in Saved Messages */
    _: 'premiumFeatureSavedMessagesTags',
  |}

  declare export type premiumFeatureSavedMessagesTags$Input = {|
    /** The ability to use tags in Saved Messages */
    +_: 'premiumFeatureSavedMessagesTags',
  |}

  declare export type premiumFeatureMessagePrivacy = {|
    /**
     * The ability to disallow incoming voice and video note messages in private chats
     * using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
     * and to restrict incoming messages from non-contacts using setNewChatPrivacySettings
     */
    _: 'premiumFeatureMessagePrivacy',
  |}

  declare export type premiumFeatureMessagePrivacy$Input = {|
    /**
     * The ability to disallow incoming voice and video note messages in private chats
     * using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
     * and to restrict incoming messages from non-contacts using setNewChatPrivacySettings
     */
    +_: 'premiumFeatureMessagePrivacy',
  |}

  declare export type premiumFeatureLastSeenTimes = {|
    /**
     * The ability to view last seen and read times of other users even they can't
     * view last seen or read time for the current user
     */
    _: 'premiumFeatureLastSeenTimes',
  |}

  declare export type premiumFeatureLastSeenTimes$Input = {|
    /**
     * The ability to view last seen and read times of other users even they can't
     * view last seen or read time for the current user
     */
    +_: 'premiumFeatureLastSeenTimes',
  |}

  declare export type premiumFeatureBusiness = {|
    /** The ability to use Business features */
    _: 'premiumFeatureBusiness',
  |}

  declare export type premiumFeatureBusiness$Input = {|
    /** The ability to use Business features */
    +_: 'premiumFeatureBusiness',
  |}

  declare export type premiumFeatureMessageEffects = {|
    /** The ability to use all available message effects */
    _: 'premiumFeatureMessageEffects',
  |}

  declare export type premiumFeatureMessageEffects$Input = {|
    /** The ability to use all available message effects */
    +_: 'premiumFeatureMessageEffects',
  |}

  declare export type businessFeatureLocation = {|
    /** The ability to set location */
    _: 'businessFeatureLocation',
  |}

  declare export type businessFeatureLocation$Input = {|
    /** The ability to set location */
    +_: 'businessFeatureLocation',
  |}

  declare export type businessFeatureOpeningHours = {|
    /** The ability to set opening hours */
    _: 'businessFeatureOpeningHours',
  |}

  declare export type businessFeatureOpeningHours$Input = {|
    /** The ability to set opening hours */
    +_: 'businessFeatureOpeningHours',
  |}

  declare export type businessFeatureQuickReplies = {|
    /** The ability to use quick replies */
    _: 'businessFeatureQuickReplies',
  |}

  declare export type businessFeatureQuickReplies$Input = {|
    /** The ability to use quick replies */
    +_: 'businessFeatureQuickReplies',
  |}

  declare export type businessFeatureGreetingMessage = {|
    /** The ability to set up a greeting message */
    _: 'businessFeatureGreetingMessage',
  |}

  declare export type businessFeatureGreetingMessage$Input = {|
    /** The ability to set up a greeting message */
    +_: 'businessFeatureGreetingMessage',
  |}

  declare export type businessFeatureAwayMessage = {|
    /** The ability to set up an away message */
    _: 'businessFeatureAwayMessage',
  |}

  declare export type businessFeatureAwayMessage$Input = {|
    /** The ability to set up an away message */
    +_: 'businessFeatureAwayMessage',
  |}

  declare export type businessFeatureAccountLinks = {|
    /**
     * The ability to create links to the business account with predefined message
     * text
     */
    _: 'businessFeatureAccountLinks',
  |}

  declare export type businessFeatureAccountLinks$Input = {|
    /**
     * The ability to create links to the business account with predefined message
     * text
     */
    +_: 'businessFeatureAccountLinks',
  |}

  declare export type businessFeatureStartPage = {|
    /** The ability to customize start page */
    _: 'businessFeatureStartPage',
  |}

  declare export type businessFeatureStartPage$Input = {|
    /** The ability to customize start page */
    +_: 'businessFeatureStartPage',
  |}

  declare export type businessFeatureBots = {|
    /** The ability to connect a bot to the account */
    _: 'businessFeatureBots',
  |}

  declare export type businessFeatureBots$Input = {|
    /** The ability to connect a bot to the account */
    +_: 'businessFeatureBots',
  |}

  declare export type businessFeatureEmojiStatus = {|
    /** The ability to show an emoji status along with the business name */
    _: 'businessFeatureEmojiStatus',
  |}

  declare export type businessFeatureEmojiStatus$Input = {|
    /** The ability to show an emoji status along with the business name */
    +_: 'businessFeatureEmojiStatus',
  |}

  declare export type businessFeatureChatFolderTags = {|
    /** The ability to display folder names for each chat in the chat list */
    _: 'businessFeatureChatFolderTags',
  |}

  declare export type businessFeatureChatFolderTags$Input = {|
    /** The ability to display folder names for each chat in the chat list */
    +_: 'businessFeatureChatFolderTags',
  |}

  declare export type businessFeatureUpgradedStories = {|
    /** Allowed to use many additional features for stories */
    _: 'businessFeatureUpgradedStories',
  |}

  declare export type businessFeatureUpgradedStories$Input = {|
    /** Allowed to use many additional features for stories */
    +_: 'businessFeatureUpgradedStories',
  |}

  declare export type premiumStoryFeaturePriorityOrder$Input = {|
    /**
     * Stories of the current user are displayed before stories of non-Premium contacts,
     * supergroups, and channels
     */
    +_: 'premiumStoryFeaturePriorityOrder',
  |}

  declare export type premiumStoryFeatureStealthMode$Input = {|
    /** The ability to hide the fact that the user viewed other's stories */
    +_: 'premiumStoryFeatureStealthMode',
  |}

  declare export type premiumStoryFeaturePermanentViewsHistory$Input = {|
    /** The ability to check who opened the current user's stories after they expire */
    +_: 'premiumStoryFeaturePermanentViewsHistory',
  |}

  declare export type premiumStoryFeatureCustomExpirationDuration$Input = {|
    /** The ability to set custom expiration duration for stories */
    +_: 'premiumStoryFeatureCustomExpirationDuration',
  |}

  declare export type premiumStoryFeatureSaveStories$Input = {|
    /** The ability to save other's unprotected stories */
    +_: 'premiumStoryFeatureSaveStories',
  |}

  declare export type premiumStoryFeatureLinksAndFormatting$Input = {|
    /**
     * The ability to use links and formatting in story caption, and use inputStoryAreaTypeLink
     * areas
     */
    +_: 'premiumStoryFeatureLinksAndFormatting',
  |}

  declare export type premiumStoryFeatureVideoQuality$Input = {|
    /** The ability to choose better quality for viewed stories */
    +_: 'premiumStoryFeatureVideoQuality',
  |}

  declare export type premiumLimit = {|
    /** Contains information about a limit, increased for Premium users */
    _: 'premiumLimit',
    /** The type of the limit */
    type: PremiumLimitType,
    /** Default value of the limit */
    default_value: number,
    /** Value of the limit for Premium users */
    premium_value: number,
  |}

  declare export type premiumFeatures = {|
    /** Contains information about features, available to Premium users */
    _: 'premiumFeatures',
    /** The list of available features */
    features: Array<PremiumFeature>,
    /** The list of limits, increased for Premium users */
    limits: Array<premiumLimit>,
    /**
     * An internal link to be opened to pay for Telegram Premium if store payment isn't
     * possible; may be null if direct payment isn't available
     */
    payment_link?: InternalLinkType,
  |}

  declare export type businessFeatures = {|
    /** Contains information about features, available to Business user accounts */
    _: 'businessFeatures',
    /** The list of available business features */
    features: Array<BusinessFeature>,
  |}

  declare export type premiumSourceLimitExceeded$Input = {|
    /** A limit was exceeded */
    +_: 'premiumSourceLimitExceeded',
    /** Type of the exceeded limit */
    +limit_type?: PremiumLimitType$Input,
  |}

  declare export type premiumSourceFeature$Input = {|
    /** A user tried to use a Premium feature */
    +_: 'premiumSourceFeature',
    /** The used feature */
    +feature?: PremiumFeature$Input,
  |}

  declare export type premiumSourceBusinessFeature$Input = {|
    /** A user tried to use a Business feature */
    +_: 'premiumSourceBusinessFeature',
    /** The used feature; pass null if none specific feature was used */
    +feature?: BusinessFeature$Input,
  |}

  declare export type premiumSourceStoryFeature$Input = {|
    /** A user tried to use a Premium story feature */
    +_: 'premiumSourceStoryFeature',
    /** The used feature */
    +feature?: PremiumStoryFeature$Input,
  |}

  declare export type premiumSourceLink$Input = {|
    /** A user opened an internal link of the type internalLinkTypePremiumFeatures */
    +_: 'premiumSourceLink',
    /** The referrer from the link */
    +referrer?: string,
  |}

  declare export type premiumSourceSettings$Input = {|
    /** A user opened the Premium features screen from settings */
    +_: 'premiumSourceSettings',
  |}

  declare export type premiumFeaturePromotionAnimation = {|
    /** Describes a promotion animation for a Premium feature */
    _: 'premiumFeaturePromotionAnimation',
    /** Premium feature */
    feature: PremiumFeature,
    /** Promotion animation for the feature */
    animation: animation,
  |}

  declare export type businessFeaturePromotionAnimation = {|
    /** Describes a promotion animation for a Business feature */
    _: 'businessFeaturePromotionAnimation',
    /** Business feature */
    feature: BusinessFeature,
    /** Promotion animation for the feature */
    animation: animation,
  |}

  declare export type premiumState = {|
    /**
     * Contains state of Telegram Premium subscription and promotion videos for Premium
     * features
     */
    _: 'premiumState',
    /**
     * Text description of the state of the current Premium subscription; may be empty
     * if the current user has no Telegram Premium subscription
     */
    state: formattedText,
    /** The list of available options for buying Telegram Premium */
    payment_options: Array<premiumStatePaymentOption>,
    /** The list of available promotion animations for Premium features */
    animations: Array<premiumFeaturePromotionAnimation>,
    /** The list of available promotion animations for Business features */
    business_animations: Array<businessFeaturePromotionAnimation>,
  |}

  declare export type storePaymentPurposePremiumSubscription$Input = {|
    /** The user subscribing to Telegram Premium */
    +_: 'storePaymentPurposePremiumSubscription',
    /**
     * Pass true if this is a restore of a Telegram Premium purchase; only for App
     * Store
     */
    +is_restore?: boolean,
    /**
     * Pass true if this is an upgrade from a monthly subscription to early subscription;
     * only for App Store
     */
    +is_upgrade?: boolean,
  |}

  declare export type storePaymentPurposePremiumGift$Input = {|
    /** The user gifting Telegram Premium to another user */
    +_: 'storePaymentPurposePremiumGift',
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Identifiers of the user which will receive Telegram Premium */
    +user_id?: number,
    /**
     * Text to show along with the gift codes; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    +text?: formattedText$Input,
  |}

  declare export type storePaymentPurposePremiumGiftCodes$Input = {|
    /** The user boosting a chat by creating Telegram Premium gift codes for other users */
    +_: 'storePaymentPurposePremiumGiftCodes',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the users for duration of the Premium subscription and which is administered
     * by the user
     */
    +boosted_chat_id?: number,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Identifiers of the users which can activate the gift codes */
    +user_ids?: $ReadOnlyArray<number>,
    /**
     * Text to show along with the gift codes; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    +text?: formattedText$Input,
  |}

  declare export type storePaymentPurposePremiumGiveaway$Input = {|
    /** The user creating a Telegram Premium giveaway */
    +_: 'storePaymentPurposePremiumGiveaway',
    /** Giveaway parameters */
    +parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
  |}

  declare export type storePaymentPurposeStarGiveaway$Input = {|
    /** The user creating a Telegram Star giveaway */
    +_: 'storePaymentPurposeStarGiveaway',
    /** Giveaway parameters */
    +parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** The number of users to receive Telegram Stars */
    +winner_count?: number,
    /** The number of Telegram Stars to be distributed through the giveaway */
    +star_count?: number,
  |}

  declare export type storePaymentPurposeStars$Input = {|
    /** The user buying Telegram Stars */
    +_: 'storePaymentPurposeStars',
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Number of bought Telegram Stars */
    +star_count?: number,
  |}

  declare export type storePaymentPurposeGiftedStars$Input = {|
    /** The user buying Telegram Stars for other users */
    +_: 'storePaymentPurposeGiftedStars',
    /** Identifier of the user to which Telegram Stars are gifted */
    +user_id?: number,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Number of bought Telegram Stars */
    +star_count?: number,
  |}

  declare export type telegramPaymentPurposePremiumGift$Input = {|
    /** The user gifting Telegram Premium to another user */
    +_: 'telegramPaymentPurposePremiumGift',
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Identifier of the user which will receive Telegram Premium */
    +user_id?: number,
    /** Number of months the Telegram Premium subscription will be active for the user */
    +month_count?: number,
    /**
     * Text to show to the user receiving Telegram Premium; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    +text?: formattedText$Input,
  |}

  declare export type telegramPaymentPurposePremiumGiftCodes$Input = {|
    /** The user boosting a chat by creating Telegram Premium gift codes for other users */
    +_: 'telegramPaymentPurposePremiumGiftCodes',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the users for duration of the Premium subscription and which is administered
     * by the user
     */
    +boosted_chat_id?: number,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Identifiers of the users which can activate the gift codes */
    +user_ids?: $ReadOnlyArray<number>,
    /** Number of months the Telegram Premium subscription will be active for the users */
    +month_count?: number,
    /**
     * Text to show along with the gift codes; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    +text?: formattedText$Input,
  |}

  declare export type telegramPaymentPurposePremiumGiveaway$Input = {|
    /** The user creating a Telegram Premium giveaway */
    +_: 'telegramPaymentPurposePremiumGiveaway',
    /** Giveaway parameters */
    +parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Number of users which will be able to activate the gift codes */
    +winner_count?: number,
    /** Number of months the Telegram Premium subscription will be active for the users */
    +month_count?: number,
  |}

  declare export type telegramPaymentPurposeStars$Input = {|
    /** The user buying Telegram Stars */
    +_: 'telegramPaymentPurposeStars',
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Number of bought Telegram Stars */
    +star_count?: number,
  |}

  declare export type telegramPaymentPurposeGiftedStars$Input = {|
    /** The user buying Telegram Stars for other users */
    +_: 'telegramPaymentPurposeGiftedStars',
    /** Identifier of the user to which Telegram Stars are gifted */
    +user_id?: number,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** Number of bought Telegram Stars */
    +star_count?: number,
  |}

  declare export type telegramPaymentPurposeStarGiveaway$Input = {|
    /** The user creating a Telegram Star giveaway */
    +_: 'telegramPaymentPurposeStarGiveaway',
    /** Giveaway parameters */
    +parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    +currency?: string,
    /** Paid amount, in the smallest units of the currency */
    +amount?: number,
    /** The number of users to receive Telegram Stars */
    +winner_count?: number,
    /** The number of Telegram Stars to be distributed through the giveaway */
    +star_count?: number,
  |}

  declare export type telegramPaymentPurposeJoinChat$Input = {|
    /** The user joins a chat and subscribes to regular payments in Telegram Stars */
    +_: 'telegramPaymentPurposeJoinChat',
    /** Invite link to use */
    +invite_link?: string,
  |}

  declare export type deviceTokenFirebaseCloudMessaging$Input = {|
    /** A token for Firebase Cloud Messaging */
    +_: 'deviceTokenFirebaseCloudMessaging',
    /** Device registration token; may be empty to deregister a device */
    +token?: string,
    /** True, if push notifications must be additionally encrypted */
    +encrypt?: boolean,
  |}

  declare export type deviceTokenApplePush$Input = {|
    /** A token for Apple Push Notification service */
    +_: 'deviceTokenApplePush',
    /** Device token; may be empty to deregister a device */
    +device_token?: string,
    /** True, if App Sandbox is enabled */
    +is_app_sandbox?: boolean,
  |}

  declare export type deviceTokenApplePushVoIP$Input = {|
    /** A token for Apple Push Notification service VoIP notifications */
    +_: 'deviceTokenApplePushVoIP',
    /** Device token; may be empty to deregister a device */
    +device_token?: string,
    /** True, if App Sandbox is enabled */
    +is_app_sandbox?: boolean,
    /** True, if push notifications must be additionally encrypted */
    +encrypt?: boolean,
  |}

  declare export type deviceTokenWindowsPush$Input = {|
    /** A token for Windows Push Notification Services */
    +_: 'deviceTokenWindowsPush',
    /**
     * The access token that will be used to send notifications; may be empty to deregister
     * a device
     */
    +access_token?: string,
  |}

  declare export type deviceTokenMicrosoftPush$Input = {|
    /** A token for Microsoft Push Notification Service */
    +_: 'deviceTokenMicrosoftPush',
    /** Push notification channel URI; may be empty to deregister a device */
    +channel_uri?: string,
  |}

  declare export type deviceTokenMicrosoftPushVoIP$Input = {|
    /** A token for Microsoft Push Notification Service VoIP channel */
    +_: 'deviceTokenMicrosoftPushVoIP',
    /** Push notification channel URI; may be empty to deregister a device */
    +channel_uri?: string,
  |}

  declare export type deviceTokenWebPush$Input = {|
    /** A token for web Push API */
    +_: 'deviceTokenWebPush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    +endpoint?: string,
    /** Base64url-encoded P-256 elliptic curve Diffie-Hellman public key */
    +p256dh_base64url?: string,
    /** Base64url-encoded authentication secret */
    +auth_base64url?: string,
  |}

  declare export type deviceTokenSimplePush$Input = {|
    /** A token for Simple Push API for Firefox OS */
    +_: 'deviceTokenSimplePush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    +endpoint?: string,
  |}

  declare export type deviceTokenUbuntuPush$Input = {|
    /** A token for Ubuntu Push Client service */
    +_: 'deviceTokenUbuntuPush',
    /** Token; may be empty to deregister a device */
    +token?: string,
  |}

  declare export type deviceTokenBlackBerryPush$Input = {|
    /** A token for BlackBerry Push Service */
    +_: 'deviceTokenBlackBerryPush',
    /** Token; may be empty to deregister a device */
    +token?: string,
  |}

  declare export type deviceTokenTizenPush$Input = {|
    /** A token for Tizen Push Service */
    +_: 'deviceTokenTizenPush',
    /** Push service registration identifier; may be empty to deregister a device */
    +reg_id?: string,
  |}

  declare export type deviceTokenHuaweiPush$Input = {|
    /** A token for HUAWEI Push Service */
    +_: 'deviceTokenHuaweiPush',
    /** Device registration token; may be empty to deregister a device */
    +token?: string,
    /** True, if push notifications must be additionally encrypted */
    +encrypt?: boolean,
  |}

  declare export type pushReceiverId = {|
    /**
     * Contains a globally unique push receiver identifier, which can be used to identify
     * which account has received a push notification
     */
    _: 'pushReceiverId',
    /** The globally unique identifier of push notification subscription */
    id: string,
  |}

  declare export type backgroundFillSolid = {|
    /** Describes a solid fill of a background */
    _: 'backgroundFillSolid',
    /** A color of the background in the RGB format */
    color: number,
  |}

  declare export type backgroundFillSolid$Input = {|
    /** Describes a solid fill of a background */
    +_: 'backgroundFillSolid',
    /** A color of the background in the RGB format */
    +color?: number,
  |}

  declare export type backgroundFillGradient = {|
    /** Describes a gradient fill of a background */
    _: 'backgroundFillGradient',
    /** A top color of the background in the RGB format */
    top_color: number,
    /** A bottom color of the background in the RGB format */
    bottom_color: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be
     * divisible by 45
     */
    rotation_angle: number,
  |}

  declare export type backgroundFillGradient$Input = {|
    /** Describes a gradient fill of a background */
    +_: 'backgroundFillGradient',
    /** A top color of the background in the RGB format */
    +top_color?: number,
    /** A bottom color of the background in the RGB format */
    +bottom_color?: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be
     * divisible by 45
     */
    +rotation_angle?: number,
  |}

  declare export type backgroundFillFreeformGradient = {|
    /** Describes a freeform gradient fill of a background */
    _: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradient in the RGB format */
    colors: Array<number>,
  |}

  declare export type backgroundFillFreeformGradient$Input = {|
    /** Describes a freeform gradient fill of a background */
    +_: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradient in the RGB format */
    +colors?: $ReadOnlyArray<number>,
  |}

  declare export type backgroundTypeWallpaper = {|
    /** A wallpaper in JPEG format */
    _: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    is_blurred: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  |}

  declare export type backgroundTypeWallpaper$Input = {|
    /** A wallpaper in JPEG format */
    +_: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    +is_blurred?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    +is_moving?: boolean,
  |}

  declare export type backgroundTypePattern = {|
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    _: 'backgroundTypePattern',
    /** Fill of the background */
    fill: BackgroundFill,
    /** Intensity of the pattern when it is shown above the filled background; 0-100 */
    intensity: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    is_inverted: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  |}

  declare export type backgroundTypePattern$Input = {|
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    +_: 'backgroundTypePattern',
    /** Fill of the background */
    +fill?: BackgroundFill$Input,
    /** Intensity of the pattern when it is shown above the filled background; 0-100 */
    +intensity?: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    +is_inverted?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    +is_moving?: boolean,
  |}

  declare export type backgroundTypeFill = {|
    /** A filled background */
    _: 'backgroundTypeFill',
    /** The background fill */
    fill: BackgroundFill,
  |}

  declare export type backgroundTypeFill$Input = {|
    /** A filled background */
    +_: 'backgroundTypeFill',
    /** The background fill */
    +fill?: BackgroundFill$Input,
  |}

  declare export type backgroundTypeChatTheme = {|
    /** A background from a chat theme; can be used only as a chat background in channels */
    _: 'backgroundTypeChatTheme',
    /** Name of the chat theme */
    theme_name: string,
  |}

  declare export type backgroundTypeChatTheme$Input = {|
    /** A background from a chat theme; can be used only as a chat background in channels */
    +_: 'backgroundTypeChatTheme',
    /** Name of the chat theme */
    +theme_name?: string,
  |}

  declare export type inputBackgroundLocal$Input = {|
    /** A background from a local file */
    +_: 'inputBackgroundLocal',
    /**
     * Background file to use. Only inputFileLocal and inputFileGenerated are supported.
     * The file must be in JPEG format for wallpapers and in PNG format for patterns
     */
    +background?: InputFile$Input,
  |}

  declare export type inputBackgroundRemote$Input = {|
    /** A background from the server */
    +_: 'inputBackgroundRemote',
    /** The background identifier */
    +background_id?: number | string,
  |}

  declare export type inputBackgroundPrevious$Input = {|
    /** A background previously set in the chat; for chat backgrounds only */
    +_: 'inputBackgroundPrevious',
    /** Identifier of the message with the background */
    +message_id?: number,
  |}

  declare export type chatTheme = {|
    /** Describes a chat theme */
    _: 'chatTheme',
    /** Theme name */
    name: string,
    /** Theme settings for a light chat theme */
    light_settings: themeSettings,
    /** Theme settings for a dark chat theme */
    dark_settings: themeSettings,
  |}

  declare export type timeZone = {|
    /** Describes a time zone */
    _: 'timeZone',
    /** Unique time zone identifier */
    id: string,
    /** Time zone name */
    name: string,
    /** Current UTC time offset for the time zone */
    utc_time_offset: number,
  |}

  declare export type timeZones = {|
    /** Contains a list of time zones */
    _: 'timeZones',
    /** A list of time zones */
    time_zones: Array<timeZone>,
  |}

  declare export type hashtags = {|
    /** Contains a list of hashtags */
    _: 'hashtags',
    /** A list of hashtags */
    hashtags: Array<string>,
  |}

  declare export type canSendStoryResultOk = {|
    /** A story can be sent */
    _: 'canSendStoryResultOk',
  |}

  declare export type canSendStoryResultPremiumNeeded = {|
    /** The user must subscribe to Telegram Premium to be able to post stories */
    _: 'canSendStoryResultPremiumNeeded',
  |}

  declare export type canSendStoryResultBoostNeeded = {|
    /**
     * The chat must be boosted first by Telegram Premium subscribers to post more
     * stories. Call getChatBoostStatus to get current boost status of the chat
     */
    _: 'canSendStoryResultBoostNeeded',
  |}

  declare export type canSendStoryResultActiveStoryLimitExceeded = {|
    /**
     * The limit for the number of active stories exceeded. The user can buy Telegram
     * Premium, delete an active story, or wait for the oldest story to expire
     */
    _: 'canSendStoryResultActiveStoryLimitExceeded',
  |}

  declare export type canSendStoryResultWeeklyLimitExceeded = {|
    /**
     * The weekly limit for the number of posted stories exceeded. The user needs to
     * buy Telegram Premium or wait specified time
     */
    _: 'canSendStoryResultWeeklyLimitExceeded',
    /** Time left before the user can send the next story */
    retry_after: number,
  |}

  declare export type canSendStoryResultMonthlyLimitExceeded = {|
    /**
     * The monthly limit for the number of posted stories exceeded. The user needs
     * to buy Telegram Premium or wait specified time
     */
    _: 'canSendStoryResultMonthlyLimitExceeded',
    /** Time left before the user can send the next story */
    retry_after: number,
  |}

  declare export type canTransferOwnershipResultOk = {|
    /** The session can be used */
    _: 'canTransferOwnershipResultOk',
  |}

  declare export type canTransferOwnershipResultPasswordNeeded = {|
    /** The 2-step verification needs to be enabled first */
    _: 'canTransferOwnershipResultPasswordNeeded',
  |}

  declare export type canTransferOwnershipResultPasswordTooFresh = {|
    /** The 2-step verification was enabled recently, user needs to wait */
    _: 'canTransferOwnershipResultPasswordTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  |}

  declare export type canTransferOwnershipResultSessionTooFresh = {|
    /** The session was created recently, user needs to wait */
    _: 'canTransferOwnershipResultSessionTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  |}

  declare export type checkChatUsernameResultOk = {|
    /** The username can be set */
    _: 'checkChatUsernameResultOk',
  |}

  declare export type checkChatUsernameResultUsernameInvalid = {|
    /** The username is invalid */
    _: 'checkChatUsernameResultUsernameInvalid',
  |}

  declare export type checkChatUsernameResultUsernameOccupied = {|
    /** The username is occupied */
    _: 'checkChatUsernameResultUsernameOccupied',
  |}

  declare export type checkChatUsernameResultUsernamePurchasable = {|
    /**
     * The username can be purchased at https://fragment.com. Information about the
     * username can be received using getCollectibleItemInfo
     */
    _: 'checkChatUsernameResultUsernamePurchasable',
  |}

  declare export type checkChatUsernameResultPublicChatsTooMany = {|
    /**
     * The user has too many chats with username, one of them must be made private
     * first
     */
    _: 'checkChatUsernameResultPublicChatsTooMany',
  |}

  declare export type checkChatUsernameResultPublicGroupsUnavailable = {|
    /** The user can't be a member of a public supergroup */
    _: 'checkChatUsernameResultPublicGroupsUnavailable',
  |}

  declare export type checkStickerSetNameResultOk = {|
    /** The name can be set */
    _: 'checkStickerSetNameResultOk',
  |}

  declare export type checkStickerSetNameResultNameInvalid = {|
    /** The name is invalid */
    _: 'checkStickerSetNameResultNameInvalid',
  |}

  declare export type checkStickerSetNameResultNameOccupied = {|
    /** The name is occupied */
    _: 'checkStickerSetNameResultNameOccupied',
  |}

  declare export type resetPasswordResultOk = {|
    /** The password was reset */
    _: 'resetPasswordResultOk',
  |}

  declare export type resetPasswordResultPending = {|
    /** The password reset request is pending */
    _: 'resetPasswordResultPending',
    /**
     * Point in time (Unix timestamp) after which the password can be reset immediately
     * using resetPassword
     */
    pending_reset_date: number,
  |}

  declare export type resetPasswordResultDeclined = {|
    /** The password reset request was declined */
    _: 'resetPasswordResultDeclined',
    /** Point in time (Unix timestamp) when the password reset can be retried */
    retry_date: number,
  |}

  declare export type messageFileTypePrivate = {|
    /** The messages were exported from a private chat */
    _: 'messageFileTypePrivate',
    /** Name of the other party; may be empty if unrecognized */
    name: string,
  |}

  declare export type messageFileTypeGroup = {|
    /** The messages were exported from a group chat */
    _: 'messageFileTypeGroup',
    /** Title of the group chat; may be empty if unrecognized */
    title: string,
  |}

  declare export type messageFileTypeUnknown = {|
    /** The messages were exported from a chat of unknown type */
    _: 'messageFileTypeUnknown',
  |}

  declare export type pushMessageContentHidden = {|
    /** A general message with hidden content */
    _: 'pushMessageContentHidden',
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentAnimation = {|
    /** An animation message (GIF-style). */
    _: 'pushMessageContentAnimation',
    /** Message content; may be null */
    animation?: animation,
    /** Animation caption */
    caption: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentAudio = {|
    /** An audio message */
    _: 'pushMessageContentAudio',
    /** Message content; may be null */
    audio?: audio,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentContact = {|
    /** A message with a user contact */
    _: 'pushMessageContentContact',
    /** Contact's name */
    name: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentContactRegistered = {|
    /** A contact has registered with Telegram */
    _: 'pushMessageContentContactRegistered',
  |}

  declare export type pushMessageContentDocument = {|
    /** A document message (a general file) */
    _: 'pushMessageContentDocument',
    /** Message content; may be null */
    document?: document,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentGame = {|
    /** A message with a game */
    _: 'pushMessageContentGame',
    /** Game title, empty for pinned game message */
    title: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentGameScore = {|
    /** A new high score was achieved in a game */
    _: 'pushMessageContentGameScore',
    /** Game title, empty for pinned message */
    title: string,
    /** New score, 0 for pinned message */
    score: number,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentInvoice = {|
    /** A message with an invoice from a bot */
    _: 'pushMessageContentInvoice',
    /** Product price */
    price: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentLocation = {|
    /** A message with a location */
    _: 'pushMessageContentLocation',
    /** True, if the location is live */
    is_live: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentPaidMedia = {|
    /** A message with paid media */
    _: 'pushMessageContentPaidMedia',
    /**
     * Number of Telegram Stars needed to buy access to the media in the message; 0
     * for pinned message
     */
    star_count: number,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentPhoto = {|
    /** A photo message */
    _: 'pushMessageContentPhoto',
    /** Message content; may be null */
    photo?: photo,
    /** Photo caption */
    caption: string,
    /** True, if the photo is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentPoll = {|
    /** A message with a poll */
    _: 'pushMessageContentPoll',
    /** Poll question */
    question: string,
    /** True, if the poll is regular and not in quiz mode */
    is_regular: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentPremiumGiftCode = {|
    /** A message with a Telegram Premium gift code created for the user */
    _: 'pushMessageContentPremiumGiftCode',
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
  |}

  declare export type pushMessageContentGiveaway = {|
    /** A message with a giveaway */
    _: 'pushMessageContentGiveaway',
    /** Number of users which will receive giveaway prizes; 0 for pinned message */
    winner_count: number,
    /** Prize of the giveaway; may be null for pinned message */
    prize?: GiveawayPrize,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentGift = {|
    /** A message with a gift */
    _: 'pushMessageContentGift',
    /** Number of Telegram Stars that sender paid for the gift */
    star_count: number,
  |}

  declare export type pushMessageContentUpgradedGift = {|
    /** A message with an upgraded gift */
    _: 'pushMessageContentUpgradedGift',
    /**
     * True, if the gift was obtained by upgrading of a previously received gift; otherwise,
     * this is a transferred gift
     */
    is_upgrade: boolean,
  |}

  declare export type pushMessageContentScreenshotTaken = {|
    /** A screenshot of a message in the chat has been taken */
    _: 'pushMessageContentScreenshotTaken',
  |}

  declare export type pushMessageContentSticker = {|
    /** A message with a sticker */
    _: 'pushMessageContentSticker',
    /** Message content; may be null */
    sticker?: sticker,
    /** Emoji corresponding to the sticker; may be empty */
    emoji: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentStory = {|
    /** A message with a story */
    _: 'pushMessageContentStory',
    /** True, if the user was mentioned in the story */
    is_mention: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentText = {|
    /** A text message */
    _: 'pushMessageContentText',
    /** Message text */
    text: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentVideo = {|
    /** A video message */
    _: 'pushMessageContentVideo',
    /** Message content; may be null */
    video?: video,
    /** Video caption */
    caption: string,
    /** True, if the video is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentVideoNote = {|
    /** A video note message */
    _: 'pushMessageContentVideoNote',
    /** Message content; may be null */
    video_note?: videoNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentVoiceNote = {|
    /** A voice note message */
    _: 'pushMessageContentVoiceNote',
    /** Message content; may be null */
    voice_note?: voiceNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  |}

  declare export type pushMessageContentBasicGroupChatCreate = {|
    /** A newly created basic group */
    _: 'pushMessageContentBasicGroupChatCreate',
  |}

  declare export type pushMessageContentVideoChatStarted = {|
    /** A video chat or live stream was started */
    _: 'pushMessageContentVideoChatStarted',
  |}

  declare export type pushMessageContentVideoChatEnded = {|
    /** A video chat or live stream has ended */
    _: 'pushMessageContentVideoChatEnded',
  |}

  declare export type pushMessageContentInviteVideoChatParticipants = {|
    /** An invitation of participants to a video chat or live stream */
    _: 'pushMessageContentInviteVideoChatParticipants',
    /** True, if the current user was invited to the video chat or the live stream */
    is_current_user: boolean,
  |}

  declare export type pushMessageContentChatAddMembers = {|
    /** New chat members were invited to a group */
    _: 'pushMessageContentChatAddMembers',
    /** Name of the added member */
    member_name: string,
    /** True, if the current user was added to the group */
    is_current_user: boolean,
    /** True, if the user has returned to the group themselves */
    is_returned: boolean,
  |}

  declare export type pushMessageContentChatChangePhoto = {|
    /** A chat photo was edited */
    _: 'pushMessageContentChatChangePhoto',
  |}

  declare export type pushMessageContentChatChangeTitle = {|
    /** A chat title was edited */
    _: 'pushMessageContentChatChangeTitle',
    /** New chat title */
    title: string,
  |}

  declare export type pushMessageContentChatSetBackground = {|
    /** A chat background was edited */
    _: 'pushMessageContentChatSetBackground',
    /** True, if the set background is the same as the background of the current user */
    is_same: boolean,
  |}

  declare export type pushMessageContentChatSetTheme = {|
    /** A chat theme was edited */
    _: 'pushMessageContentChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme
     * was reset to the default one
     */
    theme_name: string,
  |}

  declare export type pushMessageContentChatDeleteMember = {|
    /** A chat member was deleted */
    _: 'pushMessageContentChatDeleteMember',
    /** Name of the deleted member */
    member_name: string,
    /** True, if the current user was deleted from the group */
    is_current_user: boolean,
    /** True, if the user has left the group themselves */
    is_left: boolean,
  |}

  declare export type pushMessageContentChatJoinByLink = {|
    /** A new member joined the chat via an invite link */
    _: 'pushMessageContentChatJoinByLink',
  |}

  declare export type pushMessageContentChatJoinByRequest = {|
    /** A new member was accepted to the chat by an administrator */
    _: 'pushMessageContentChatJoinByRequest',
  |}

  declare export type pushMessageContentRecurringPayment = {|
    /** A new recurring payment was made by the current user */
    _: 'pushMessageContentRecurringPayment',
    /** The paid amount */
    amount: string,
  |}

  declare export type pushMessageContentSuggestProfilePhoto = {|
    /** A profile photo was suggested to the user */
    _: 'pushMessageContentSuggestProfilePhoto',
  |}

  declare export type pushMessageContentProximityAlertTriggered = {|
    /** A user in the chat came within proximity alert range from the current user */
    _: 'pushMessageContentProximityAlertTriggered',
    /** The distance to the user */
    distance: number,
  |}

  declare export type pushMessageContentMessageForwards = {|
    /** A forwarded messages */
    _: 'pushMessageContentMessageForwards',
    /** Number of forwarded messages */
    total_count: number,
  |}

  declare export type pushMessageContentMediaAlbum = {|
    /** A media album */
    _: 'pushMessageContentMediaAlbum',
    /** Number of messages in the album */
    total_count: number,
    /** True, if the album has at least one photo */
    has_photos: boolean,
    /** True, if the album has at least one video file */
    has_videos: boolean,
    /** True, if the album has at least one audio file */
    has_audios: boolean,
    /** True, if the album has at least one document */
    has_documents: boolean,
  |}

  declare export type notificationTypeNewMessage = {|
    /** New message was received */
    _: 'notificationTypeNewMessage',
    /** The message */
    message: message,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
  |}

  declare export type notificationTypeNewSecretChat = {|
    /** New secret chat was created */
    _: 'notificationTypeNewSecretChat',
  |}

  declare export type notificationTypeNewCall = {|
    /** New call was received */
    _: 'notificationTypeNewCall',
    /** Call identifier */
    call_id: number,
  |}

  declare export type notificationTypeNewPushMessage = {|
    /** New message was received through a push notification */
    _: 'notificationTypeNewPushMessage',
    /**
     * The message identifier. The message will not be available in the chat history,
     * but the identifier can be used in viewMessages, or as a message to be replied
     * in the same chat
     */
    message_id: number,
    /** Identifier of the sender of the message. Corresponding user or chat may be inaccessible */
    sender_id: MessageSender,
    /** Name of the sender */
    sender_name: string,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** Push message content */
    content: PushMessageContent,
  |}

  declare export type notificationGroupTypeMessages = {|
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with ordinary unread messages
     */
    _: 'notificationGroupTypeMessages',
  |}

  declare export type notificationGroupTypeMentions = {|
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with unread mentions of the current user, replies to their messages, or a pinned
     * message
     */
    _: 'notificationGroupTypeMentions',
  |}

  declare export type notificationGroupTypeSecretChat = {|
    /** A group containing a notification of type notificationTypeNewSecretChat */
    _: 'notificationGroupTypeSecretChat',
  |}

  declare export type notificationGroupTypeCalls = {|
    /** A group containing notifications of type notificationTypeNewCall */
    _: 'notificationGroupTypeCalls',
  |}

  declare export type notificationSound = {|
    /** Describes a notification sound in MP3 format */
    _: 'notificationSound',
    /** Unique identifier of the notification sound */
    id: string,
    /** Duration of the sound, in seconds */
    duration: number,
    /** Point in time (Unix timestamp) when the sound was created */
    date: number,
    /** Title of the notification sound */
    title: string,
    /** Arbitrary data, defined while the sound was uploaded */
    data: string,
    /** File containing the sound */
    sound: file,
  |}

  declare export type notificationSounds = {|
    /** Contains a list of notification sounds */
    _: 'notificationSounds',
    /** A list of notification sounds */
    notification_sounds: Array<notificationSound>,
  |}

  declare export type notification = {|
    /** Contains information about a notification */
    _: 'notification',
    /** Unique persistent identifier of this notification */
    id: number,
    /** Notification date */
    date: number,
    /** True, if the notification was explicitly sent without sound */
    is_silent: boolean,
    /** Notification type */
    type: NotificationType,
  |}

  declare export type notificationGroup = {|
    /** Describes a group of notifications */
    _: 'notificationGroup',
    /** Unique persistent auto-incremented from 1 identifier of the notification group */
    id: number,
    /** Type of the group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Total number of active notifications in the group */
    total_count: number,
    /** The list of active notifications */
    notifications: Array<notification>,
  |}

  declare export type optionValueBoolean = {|
    /** Represents a boolean option */
    _: 'optionValueBoolean',
    /** The value of the option */
    value: boolean,
  |}

  declare export type optionValueBoolean$Input = {|
    /** Represents a boolean option */
    +_: 'optionValueBoolean',
    /** The value of the option */
    +value?: boolean,
  |}

  declare export type optionValueEmpty = {|
    /** Represents an unknown option or an option which has a default value */
    _: 'optionValueEmpty',
  |}

  declare export type optionValueEmpty$Input = {|
    /** Represents an unknown option or an option which has a default value */
    +_: 'optionValueEmpty',
  |}

  declare export type optionValueInteger = {|
    /** Represents an integer option */
    _: 'optionValueInteger',
    /** The value of the option */
    value: string,
  |}

  declare export type optionValueInteger$Input = {|
    /** Represents an integer option */
    +_: 'optionValueInteger',
    /** The value of the option */
    +value?: number | string,
  |}

  declare export type optionValueString = {|
    /** Represents a string option */
    _: 'optionValueString',
    /** The value of the option */
    value: string,
  |}

  declare export type optionValueString$Input = {|
    /** Represents a string option */
    +_: 'optionValueString',
    /** The value of the option */
    +value?: string,
  |}

  declare export type jsonObjectMember = {|
    /** Represents one member of a JSON object */
    _: 'jsonObjectMember',
    /** Member's key */
    key: string,
    /** Member's value */
    value: JsonValue,
  |}

  declare export type jsonObjectMember$Input = {|
    /** Represents one member of a JSON object */
    +_: 'jsonObjectMember',
    /** Member's key */
    +key?: string,
    /** Member's value */
    +value?: JsonValue$Input,
  |}

  declare export type jsonValueNull = {|
    /** Represents a null JSON value */
    _: 'jsonValueNull',
  |}

  declare export type jsonValueNull$Input = {|
    /** Represents a null JSON value */
    +_: 'jsonValueNull',
  |}

  declare export type jsonValueBoolean = {|
    /** Represents a boolean JSON value */
    _: 'jsonValueBoolean',
    /** The value */
    value: boolean,
  |}

  declare export type jsonValueBoolean$Input = {|
    /** Represents a boolean JSON value */
    +_: 'jsonValueBoolean',
    /** The value */
    +value?: boolean,
  |}

  declare export type jsonValueNumber = {|
    /** Represents a numeric JSON value */
    _: 'jsonValueNumber',
    /** The value */
    value: number,
  |}

  declare export type jsonValueNumber$Input = {|
    /** Represents a numeric JSON value */
    +_: 'jsonValueNumber',
    /** The value */
    +value?: number,
  |}

  declare export type jsonValueString = {|
    /** Represents a string JSON value */
    _: 'jsonValueString',
    /** The value */
    value: string,
  |}

  declare export type jsonValueString$Input = {|
    /** Represents a string JSON value */
    +_: 'jsonValueString',
    /** The value */
    +value?: string,
  |}

  declare export type jsonValueArray = {|
    /** Represents a JSON array */
    _: 'jsonValueArray',
    /** The list of array elements */
    values: Array<JsonValue>,
  |}

  declare export type jsonValueArray$Input = {|
    /** Represents a JSON array */
    +_: 'jsonValueArray',
    /** The list of array elements */
    +values?: $ReadOnlyArray<JsonValue$Input>,
  |}

  declare export type jsonValueObject = {|
    /** Represents a JSON object */
    _: 'jsonValueObject',
    /** The list of object members */
    members: Array<jsonObjectMember>,
  |}

  declare export type jsonValueObject$Input = {|
    /** Represents a JSON object */
    +_: 'jsonValueObject',
    /** The list of object members */
    +members?: $ReadOnlyArray<jsonObjectMember$Input>,
  |}

  declare export type storyPrivacySettingsEveryone = {|
    /** The story can be viewed by everyone */
    _: 'storyPrivacySettingsEveryone',
    /**
     * Identifiers of the users that can't see the story; always unknown and empty
     * for non-owned stories
     */
    except_user_ids: Array<number>,
  |}

  declare export type storyPrivacySettingsEveryone$Input = {|
    /** The story can be viewed by everyone */
    +_: 'storyPrivacySettingsEveryone',
    /**
     * Identifiers of the users that can't see the story; always unknown and empty
     * for non-owned stories
     */
    +except_user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type storyPrivacySettingsContacts = {|
    /** The story can be viewed by all contacts except chosen users */
    _: 'storyPrivacySettingsContacts',
    /**
     * User identifiers of the contacts that can't see the story; always unknown and
     * empty for non-owned stories
     */
    except_user_ids: Array<number>,
  |}

  declare export type storyPrivacySettingsContacts$Input = {|
    /** The story can be viewed by all contacts except chosen users */
    +_: 'storyPrivacySettingsContacts',
    /**
     * User identifiers of the contacts that can't see the story; always unknown and
     * empty for non-owned stories
     */
    +except_user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type storyPrivacySettingsCloseFriends = {|
    /** The story can be viewed by all close friends */
    _: 'storyPrivacySettingsCloseFriends',
  |}

  declare export type storyPrivacySettingsCloseFriends$Input = {|
    /** The story can be viewed by all close friends */
    +_: 'storyPrivacySettingsCloseFriends',
  |}

  declare export type storyPrivacySettingsSelectedUsers = {|
    /** The story can be viewed by certain specified users */
    _: 'storyPrivacySettingsSelectedUsers',
    /** Identifiers of the users; always unknown and empty for non-owned stories */
    user_ids: Array<number>,
  |}

  declare export type storyPrivacySettingsSelectedUsers$Input = {|
    /** The story can be viewed by certain specified users */
    +_: 'storyPrivacySettingsSelectedUsers',
    /** Identifiers of the users; always unknown and empty for non-owned stories */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type userPrivacySettingRuleAllowAll = {|
    /** A rule to allow all users to do something */
    _: 'userPrivacySettingRuleAllowAll',
  |}

  declare export type userPrivacySettingRuleAllowAll$Input = {|
    /** A rule to allow all users to do something */
    +_: 'userPrivacySettingRuleAllowAll',
  |}

  declare export type userPrivacySettingRuleAllowContacts = {|
    /** A rule to allow all contacts of the user to do something */
    _: 'userPrivacySettingRuleAllowContacts',
  |}

  declare export type userPrivacySettingRuleAllowContacts$Input = {|
    /** A rule to allow all contacts of the user to do something */
    +_: 'userPrivacySettingRuleAllowContacts',
  |}

  declare export type userPrivacySettingRuleAllowBots = {|
    /** A rule to allow all bots to do something */
    _: 'userPrivacySettingRuleAllowBots',
  |}

  declare export type userPrivacySettingRuleAllowBots$Input = {|
    /** A rule to allow all bots to do something */
    +_: 'userPrivacySettingRuleAllowBots',
  |}

  declare export type userPrivacySettingRuleAllowPremiumUsers = {|
    /**
     * A rule to allow all Premium Users to do something; currently, allowed only for
     * userPrivacySettingAllowChatInvites
     */
    _: 'userPrivacySettingRuleAllowPremiumUsers',
  |}

  declare export type userPrivacySettingRuleAllowPremiumUsers$Input = {|
    /**
     * A rule to allow all Premium Users to do something; currently, allowed only for
     * userPrivacySettingAllowChatInvites
     */
    +_: 'userPrivacySettingRuleAllowPremiumUsers',
  |}

  declare export type userPrivacySettingRuleAllowUsers = {|
    /** A rule to allow certain specified users to do something */
    _: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  |}

  declare export type userPrivacySettingRuleAllowUsers$Input = {|
    /** A rule to allow certain specified users to do something */
    +_: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type userPrivacySettingRuleAllowChatMembers = {|
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    _: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  |}

  declare export type userPrivacySettingRuleAllowChatMembers$Input = {|
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    +_: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    +chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type userPrivacySettingRuleRestrictAll = {|
    /** A rule to restrict all users from doing something */
    _: 'userPrivacySettingRuleRestrictAll',
  |}

  declare export type userPrivacySettingRuleRestrictAll$Input = {|
    /** A rule to restrict all users from doing something */
    +_: 'userPrivacySettingRuleRestrictAll',
  |}

  declare export type userPrivacySettingRuleRestrictContacts = {|
    /** A rule to restrict all contacts of the user from doing something */
    _: 'userPrivacySettingRuleRestrictContacts',
  |}

  declare export type userPrivacySettingRuleRestrictContacts$Input = {|
    /** A rule to restrict all contacts of the user from doing something */
    +_: 'userPrivacySettingRuleRestrictContacts',
  |}

  declare export type userPrivacySettingRuleRestrictBots = {|
    /** A rule to restrict all bots from doing something */
    _: 'userPrivacySettingRuleRestrictBots',
  |}

  declare export type userPrivacySettingRuleRestrictBots$Input = {|
    /** A rule to restrict all bots from doing something */
    +_: 'userPrivacySettingRuleRestrictBots',
  |}

  declare export type userPrivacySettingRuleRestrictUsers = {|
    /** A rule to restrict all specified users from doing something */
    _: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  |}

  declare export type userPrivacySettingRuleRestrictUsers$Input = {|
    /** A rule to restrict all specified users from doing something */
    +_: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type userPrivacySettingRuleRestrictChatMembers = {|
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    _: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  |}

  declare export type userPrivacySettingRuleRestrictChatMembers$Input = {|
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    +_: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    +chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type userPrivacySettingRules = {|
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    _: 'userPrivacySettingRules',
    /** A list of rules */
    rules: Array<UserPrivacySettingRule>,
  |}

  declare export type userPrivacySettingRules$Input = {|
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    +_: 'userPrivacySettingRules',
    /** A list of rules */
    +rules?: $ReadOnlyArray<UserPrivacySettingRule$Input>,
  |}

  declare export type userPrivacySettingShowStatus = {|
    /** A privacy setting for managing whether the user's online status is visible */
    _: 'userPrivacySettingShowStatus',
  |}

  declare export type userPrivacySettingShowStatus$Input = {|
    /** A privacy setting for managing whether the user's online status is visible */
    +_: 'userPrivacySettingShowStatus',
  |}

  declare export type userPrivacySettingShowProfilePhoto = {|
    /** A privacy setting for managing whether the user's profile photo is visible */
    _: 'userPrivacySettingShowProfilePhoto',
  |}

  declare export type userPrivacySettingShowProfilePhoto$Input = {|
    /** A privacy setting for managing whether the user's profile photo is visible */
    +_: 'userPrivacySettingShowProfilePhoto',
  |}

  declare export type userPrivacySettingShowLinkInForwardedMessages = {|
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    _: 'userPrivacySettingShowLinkInForwardedMessages',
  |}

  declare export type userPrivacySettingShowLinkInForwardedMessages$Input = {|
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    +_: 'userPrivacySettingShowLinkInForwardedMessages',
  |}

  declare export type userPrivacySettingShowPhoneNumber = {|
    /** A privacy setting for managing whether the user's phone number is visible */
    _: 'userPrivacySettingShowPhoneNumber',
  |}

  declare export type userPrivacySettingShowPhoneNumber$Input = {|
    /** A privacy setting for managing whether the user's phone number is visible */
    +_: 'userPrivacySettingShowPhoneNumber',
  |}

  declare export type userPrivacySettingShowBio = {|
    /** A privacy setting for managing whether the user's bio is visible */
    _: 'userPrivacySettingShowBio',
  |}

  declare export type userPrivacySettingShowBio$Input = {|
    /** A privacy setting for managing whether the user's bio is visible */
    +_: 'userPrivacySettingShowBio',
  |}

  declare export type userPrivacySettingShowBirthdate = {|
    /** A privacy setting for managing whether the user's birthdate is visible */
    _: 'userPrivacySettingShowBirthdate',
  |}

  declare export type userPrivacySettingShowBirthdate$Input = {|
    /** A privacy setting for managing whether the user's birthdate is visible */
    +_: 'userPrivacySettingShowBirthdate',
  |}

  declare export type userPrivacySettingAllowChatInvites = {|
    /** A privacy setting for managing whether the user can be invited to chats */
    _: 'userPrivacySettingAllowChatInvites',
  |}

  declare export type userPrivacySettingAllowChatInvites$Input = {|
    /** A privacy setting for managing whether the user can be invited to chats */
    +_: 'userPrivacySettingAllowChatInvites',
  |}

  declare export type userPrivacySettingAllowCalls = {|
    /** A privacy setting for managing whether the user can be called */
    _: 'userPrivacySettingAllowCalls',
  |}

  declare export type userPrivacySettingAllowCalls$Input = {|
    /** A privacy setting for managing whether the user can be called */
    +_: 'userPrivacySettingAllowCalls',
  |}

  declare export type userPrivacySettingAllowPeerToPeerCalls = {|
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    _: 'userPrivacySettingAllowPeerToPeerCalls',
  |}

  declare export type userPrivacySettingAllowPeerToPeerCalls$Input = {|
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    +_: 'userPrivacySettingAllowPeerToPeerCalls',
  |}

  declare export type userPrivacySettingAllowFindingByPhoneNumber = {|
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    _: 'userPrivacySettingAllowFindingByPhoneNumber',
  |}

  declare export type userPrivacySettingAllowFindingByPhoneNumber$Input = {|
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    +_: 'userPrivacySettingAllowFindingByPhoneNumber',
  |}

  declare export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages = {|
    /**
     * A privacy setting for managing whether the user can receive voice and video
     * messages in private chats; for Telegram Premium users only
     */
    _: 'userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages',
  |}

  declare export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input = {|
    /**
     * A privacy setting for managing whether the user can receive voice and video
     * messages in private chats; for Telegram Premium users only
     */
    +_: 'userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages',
  |}

  declare export type userPrivacySettingAutosaveGifts = {|
    /**
     * A privacy setting for managing whether received gifts are automatically shown
     * on the user's profile page
     */
    _: 'userPrivacySettingAutosaveGifts',
  |}

  declare export type userPrivacySettingAutosaveGifts$Input = {|
    /**
     * A privacy setting for managing whether received gifts are automatically shown
     * on the user's profile page
     */
    +_: 'userPrivacySettingAutosaveGifts',
  |}

  declare export type userPrivacySettingAllowUnpaidMessages = {|
    /**
     * A privacy setting for managing whether the user can receive messages without
     * additional payment
     */
    _: 'userPrivacySettingAllowUnpaidMessages',
  |}

  declare export type userPrivacySettingAllowUnpaidMessages$Input = {|
    /**
     * A privacy setting for managing whether the user can receive messages without
     * additional payment
     */
    +_: 'userPrivacySettingAllowUnpaidMessages',
  |}

  declare export type readDatePrivacySettings = {|
    /**
     * Contains privacy settings for message read date in private chats. Read dates
     * are always shown to the users that can see online status of the current user
     * regardless of this setting
     */
    _: 'readDatePrivacySettings',
    /**
     * True, if message read date is shown to other users in private chats. If false
     * and the current user isn't a Telegram Premium user, then they will not be able
     * to see other's message read date
     */
    show_read_date: boolean,
  |}

  declare export type readDatePrivacySettings$Input = {|
    /**
     * Contains privacy settings for message read date in private chats. Read dates
     * are always shown to the users that can see online status of the current user
     * regardless of this setting
     */
    +_: 'readDatePrivacySettings',
    /**
     * True, if message read date is shown to other users in private chats. If false
     * and the current user isn't a Telegram Premium user, then they will not be able
     * to see other's message read date
     */
    +show_read_date?: boolean,
  |}

  declare export type newChatPrivacySettings = {|
    /** Contains privacy settings for chats with non-contacts */
    _: 'newChatPrivacySettings',
    /**
     * True, if non-contacts users are able to write first to the current user. Telegram
     * Premium subscribers are able to write first regardless of this setting
     */
    allow_new_chats_from_unknown_users: boolean,
    /**
     * Number of Telegram Stars that must be paid for every incoming private message
     * by non-contacts; 0-getOption("paid_message_star_count_max"). If positive, then
     * allow_new_chats_from_unknown_users must be true. The current user will receive
     * getOption("paid_message_earnings_per_mille") Telegram Stars for each 1000 Telegram
     * Stars paid for message sending
     */
    incoming_paid_message_star_count: number,
  |}

  declare export type newChatPrivacySettings$Input = {|
    /** Contains privacy settings for chats with non-contacts */
    +_: 'newChatPrivacySettings',
    /**
     * True, if non-contacts users are able to write first to the current user. Telegram
     * Premium subscribers are able to write first regardless of this setting
     */
    +allow_new_chats_from_unknown_users?: boolean,
    /**
     * Number of Telegram Stars that must be paid for every incoming private message
     * by non-contacts; 0-getOption("paid_message_star_count_max"). If positive, then
     * allow_new_chats_from_unknown_users must be true. The current user will receive
     * getOption("paid_message_earnings_per_mille") Telegram Stars for each 1000 Telegram
     * Stars paid for message sending
     */
    +incoming_paid_message_star_count?: number,
  |}

  declare export type canSendMessageToUserResultOk = {|
    /** The user can be messaged */
    _: 'canSendMessageToUserResultOk',
  |}

  declare export type canSendMessageToUserResultUserHasPaidMessages = {|
    /** The user can be messaged, but the messages are paid */
    _: 'canSendMessageToUserResultUserHasPaidMessages',
    /**
     * Number of Telegram Stars that must be paid by the current user for each sent
     * message to the user
     */
    outgoing_paid_message_star_count: number,
  |}

  declare export type canSendMessageToUserResultUserIsDeleted = {|
    /** The user can't be messaged, because they are deleted or unknown */
    _: 'canSendMessageToUserResultUserIsDeleted',
  |}

  declare export type canSendMessageToUserResultUserRestrictsNewChats = {|
    /** The user can't be messaged, because they restrict new chats with non-contacts */
    _: 'canSendMessageToUserResultUserRestrictsNewChats',
  |}

  declare export type accountTtl = {|
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    _: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-730 days
     */
    days: number,
  |}

  declare export type accountTtl$Input = {|
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    +_: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-730 days
     */
    +days?: number,
  |}

  declare export type messageAutoDeleteTime = {|
    /** Contains default auto-delete timer setting for new chats */
    _: 'messageAutoDeleteTime',
    /** Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically */
    time: number,
  |}

  declare export type messageAutoDeleteTime$Input = {|
    /** Contains default auto-delete timer setting for new chats */
    +_: 'messageAutoDeleteTime',
    /** Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically */
    +time?: number,
  |}

  declare export type sessionTypeAndroid = {|
    /** The session is running on an Android device */
    _: 'sessionTypeAndroid',
  |}

  declare export type sessionTypeApple = {|
    /** The session is running on a generic Apple device */
    _: 'sessionTypeApple',
  |}

  declare export type sessionTypeBrave = {|
    /** The session is running on the Brave browser */
    _: 'sessionTypeBrave',
  |}

  declare export type sessionTypeChrome = {|
    /** The session is running on the Chrome browser */
    _: 'sessionTypeChrome',
  |}

  declare export type sessionTypeEdge = {|
    /** The session is running on the Edge browser */
    _: 'sessionTypeEdge',
  |}

  declare export type sessionTypeFirefox = {|
    /** The session is running on the Firefox browser */
    _: 'sessionTypeFirefox',
  |}

  declare export type sessionTypeIpad = {|
    /** The session is running on an iPad device */
    _: 'sessionTypeIpad',
  |}

  declare export type sessionTypeIphone = {|
    /** The session is running on an iPhone device */
    _: 'sessionTypeIphone',
  |}

  declare export type sessionTypeLinux = {|
    /** The session is running on a Linux device */
    _: 'sessionTypeLinux',
  |}

  declare export type sessionTypeMac = {|
    /** The session is running on a Mac device */
    _: 'sessionTypeMac',
  |}

  declare export type sessionTypeOpera = {|
    /** The session is running on the Opera browser */
    _: 'sessionTypeOpera',
  |}

  declare export type sessionTypeSafari = {|
    /** The session is running on the Safari browser */
    _: 'sessionTypeSafari',
  |}

  declare export type sessionTypeUbuntu = {|
    /** The session is running on an Ubuntu device */
    _: 'sessionTypeUbuntu',
  |}

  declare export type sessionTypeUnknown = {|
    /** The session is running on an unknown type of device */
    _: 'sessionTypeUnknown',
  |}

  declare export type sessionTypeVivaldi = {|
    /** The session is running on the Vivaldi browser */
    _: 'sessionTypeVivaldi',
  |}

  declare export type sessionTypeWindows = {|
    /** The session is running on a Windows device */
    _: 'sessionTypeWindows',
  |}

  declare export type sessionTypeXbox = {|
    /** The session is running on an Xbox console */
    _: 'sessionTypeXbox',
  |}

  declare export type session = {|
    /**
     * Contains information about one session in a Telegram application used by the
     * current user. Sessions must be shown to the user in the returned order
     */
    _: 'session',
    /** Session identifier */
    id: string,
    /** True, if this session is the current session */
    is_current: boolean,
    /**
     * True, if a 2-step verification password is needed to complete authorization
     * of the session
     */
    is_password_pending: boolean,
    /** True, if the session wasn't confirmed from another session */
    is_unconfirmed: boolean,
    /** True, if incoming secret chats can be accepted by the session */
    can_accept_secret_chats: boolean,
    /** True, if incoming calls can be accepted by the session */
    can_accept_calls: boolean,
    /**
     * Session type based on the system and application version, which can be used
     * to display a corresponding icon
     */
    type: SessionType,
    /** Telegram API identifier, as provided by the application */
    api_id: number,
    /** Name of the application, as provided by the application */
    application_name: string,
    /** The version of the application, as provided by the application */
    application_version: string,
    /**
     * True, if the application is an official application or uses the api_id of an
     * official application
     */
    is_official_application: boolean,
    /**
     * Model of the device the application has been run or is running on, as provided
     * by the application
     */
    device_model: string,
    /**
     * Operating system the application has been run or is running on, as provided
     * by the application
     */
    platform: string,
    /**
     * Version of the operating system the application has been run or is running on,
     * as provided by the application
     */
    system_version: string,
    /** Point in time (Unix timestamp) when the user has logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when the session was last used */
    last_active_date: number,
    /** IP address from which the session was created, in human-readable format */
    ip_address: string,
    /**
     * A human-readable description of the location from which the session was created,
     * based on the IP address
     */
    location: string,
  |}

  declare export type sessions = {|
    /** Contains a list of sessions */
    _: 'sessions',
    /** List of sessions */
    sessions: Array<session>,
    /**
     * Number of days of inactivity before sessions will automatically be terminated;
     * 1-366 days
     */
    inactive_session_ttl_days: number,
  |}

  declare export type unconfirmedSession = {|
    /** Contains information about an unconfirmed session */
    _: 'unconfirmedSession',
    /** Session identifier */
    id: string,
    /** Point in time (Unix timestamp) when the user has logged in */
    log_in_date: number,
    /**
     * Model of the device that was used for the session creation, as provided by the
     * application
     */
    device_model: string,
    /**
     * A human-readable description of the location from which the session was created,
     * based on the IP address
     */
    location: string,
  |}

  declare export type connectedWebsite = {|
    /** Contains information about one website the current user is logged in with Telegram */
    _: 'connectedWebsite',
    /** Website identifier */
    id: string,
    /** The domain name of the website */
    domain_name: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /** The version of a browser used to log in */
    browser: string,
    /** Operating system the browser is running on */
    platform: string,
    /** Point in time (Unix timestamp) when the user was logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when obtained authorization was last used */
    last_active_date: number,
    /** IP address from which the user was logged in, in human-readable format */
    ip_address: string,
    /**
     * Human-readable description of a country and a region from which the user was
     * logged in, based on the IP address
     */
    location: string,
  |}

  declare export type connectedWebsites = {|
    /** Contains a list of websites the current user is logged in with Telegram */
    _: 'connectedWebsites',
    /** List of connected websites */
    websites: Array<connectedWebsite>,
  |}

  declare export type reportReasonSpam$Input = {|
    /** The chat contains spam messages */
    +_: 'reportReasonSpam',
  |}

  declare export type reportReasonViolence$Input = {|
    /** The chat promotes violence */
    +_: 'reportReasonViolence',
  |}

  declare export type reportReasonPornography$Input = {|
    /** The chat contains pornographic messages */
    +_: 'reportReasonPornography',
  |}

  declare export type reportReasonChildAbuse$Input = {|
    /** The chat has child abuse related content */
    +_: 'reportReasonChildAbuse',
  |}

  declare export type reportReasonCopyright$Input = {|
    /** The chat contains copyrighted content */
    +_: 'reportReasonCopyright',
  |}

  declare export type reportReasonUnrelatedLocation$Input = {|
    /** The location-based chat is unrelated to its stated location */
    +_: 'reportReasonUnrelatedLocation',
  |}

  declare export type reportReasonFake$Input = {|
    /** The chat represents a fake account */
    +_: 'reportReasonFake',
  |}

  declare export type reportReasonIllegalDrugs$Input = {|
    /** The chat has illegal drugs related content */
    +_: 'reportReasonIllegalDrugs',
  |}

  declare export type reportReasonPersonalDetails$Input = {|
    /** The chat contains messages with personal details */
    +_: 'reportReasonPersonalDetails',
  |}

  declare export type reportReasonCustom$Input = {|
    /** A custom reason provided by the user */
    +_: 'reportReasonCustom',
  |}

  declare export type reportChatResultOk = {|
    /** The chat was reported successfully */
    _: 'reportChatResultOk',
  |}

  declare export type reportChatResultOptionRequired = {|
    /**
     * The user must choose an option to report the chat and repeat request with the
     * chosen option
     */
    _: 'reportChatResultOptionRequired',
    /** Title for the option choice */
    title: string,
    /** List of available options */
    options: Array<reportOption>,
  |}

  declare export type reportChatResultTextRequired = {|
    /** The user must add additional text details to the report */
    _: 'reportChatResultTextRequired',
    /** Option identifier for the next reportChat request */
    option_id: string /* base64 */,
    /** True, if the user can skip text adding */
    is_optional: boolean,
  |}

  declare export type reportChatResultMessagesRequired = {|
    /**
     * The user must choose messages to report and repeat the reportChat request with
     * the chosen messages
     */
    _: 'reportChatResultMessagesRequired',
  |}

  declare export type reportStoryResultOk = {|
    /** The story was reported successfully */
    _: 'reportStoryResultOk',
  |}

  declare export type reportStoryResultOptionRequired = {|
    /**
     * The user must choose an option to report the story and repeat request with the
     * chosen option
     */
    _: 'reportStoryResultOptionRequired',
    /** Title for the option choice */
    title: string,
    /** List of available options */
    options: Array<reportOption>,
  |}

  declare export type reportStoryResultTextRequired = {|
    /** The user must add additional text details to the report */
    _: 'reportStoryResultTextRequired',
    /** Option identifier for the next reportStory request */
    option_id: string /* base64 */,
    /** True, if the user can skip text adding */
    is_optional: boolean,
  |}

  declare export type internalLinkTypeActiveSessions = {|
    /**
     * The link is a link to the Devices section of the application. Use getActiveSessions
     * to get the list of active sessions and show them to the user
     */
    _: 'internalLinkTypeActiveSessions',
  |}

  declare export type internalLinkTypeActiveSessions$Input = {|
    /**
     * The link is a link to the Devices section of the application. Use getActiveSessions
     * to get the list of active sessions and show them to the user
     */
    +_: 'internalLinkTypeActiveSessions',
  |}

  declare export type internalLinkTypeAttachmentMenuBot = {|
    /**
     * The link is a link to an attachment menu bot to be opened in the specified or
     * a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to attachment menu, then show a disclaimer about
     * Mini Apps being third-party applications, ask the user to accept their Terms
     * of service and confirm adding the bot to side and attachment menu. If the user
     * accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. If the attachment menu bot can't be used in the opened chat,
     * show an error to the user. If the bot is added to attachment menu and can be
     * used in the chat, then use openWebApp with the given URL
     */
    _: 'internalLinkTypeAttachmentMenuBot',
    /** Target chat to be opened */
    target_chat: TargetChat,
    /** Username of the bot */
    bot_username: string,
    /** URL to be passed to openWebApp */
    url: string,
  |}

  declare export type internalLinkTypeAttachmentMenuBot$Input = {|
    /**
     * The link is a link to an attachment menu bot to be opened in the specified or
     * a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to attachment menu, then show a disclaimer about
     * Mini Apps being third-party applications, ask the user to accept their Terms
     * of service and confirm adding the bot to side and attachment menu. If the user
     * accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. If the attachment menu bot can't be used in the opened chat,
     * show an error to the user. If the bot is added to attachment menu and can be
     * used in the chat, then use openWebApp with the given URL
     */
    +_: 'internalLinkTypeAttachmentMenuBot',
    /** Target chat to be opened */
    +target_chat?: TargetChat$Input,
    /** Username of the bot */
    +bot_username?: string,
    /** URL to be passed to openWebApp */
    +url?: string,
  |}

  declare export type internalLinkTypeAuthenticationCode = {|
    /**
     * The link contains an authentication code. Call checkAuthenticationCode with
     * the code if the current authorization state is authorizationStateWaitCode
     */
    _: 'internalLinkTypeAuthenticationCode',
    /** The authentication code */
    code: string,
  |}

  declare export type internalLinkTypeAuthenticationCode$Input = {|
    /**
     * The link contains an authentication code. Call checkAuthenticationCode with
     * the code if the current authorization state is authorizationStateWaitCode
     */
    +_: 'internalLinkTypeAuthenticationCode',
    /** The authentication code */
    +code?: string,
  |}

  declare export type internalLinkTypeBackground = {|
    /**
     * The link is a link to a background. Call searchBackground with the given background
     * name to process the link. If background is found and the user wants to apply
     * it, then call setDefaultBackground
     */
    _: 'internalLinkTypeBackground',
    /** Name of the background */
    background_name: string,
  |}

  declare export type internalLinkTypeBackground$Input = {|
    /**
     * The link is a link to a background. Call searchBackground with the given background
     * name to process the link. If background is found and the user wants to apply
     * it, then call setDefaultBackground
     */
    +_: 'internalLinkTypeBackground',
    /** Name of the background */
    +background_name?: string,
  |}

  declare export type internalLinkTypeBotAddToChannel = {|
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a channel
     * chat as an administrator. Call searchPublicChat with the given bot username
     * and check that the user is a bot, ask the current user to select a channel chat
     * to add the bot to as an administrator. Then, call getChatMember to receive the
     * current bot rights in the chat and if the bot already is an administrator, check
     * that the current user can edit its administrator rights and combine received
     * rights with the requested administrator rights. Then, show confirmation box
     * to the user, and call setChatMemberStatus with the chosen chat and confirmed
     * rights
     */
    _: 'internalLinkTypeBotAddToChannel',
    /** Username of the bot */
    bot_username: string,
    /** Expected administrator rights for the bot */
    administrator_rights: chatAdministratorRights,
  |}

  declare export type internalLinkTypeBotAddToChannel$Input = {|
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a channel
     * chat as an administrator. Call searchPublicChat with the given bot username
     * and check that the user is a bot, ask the current user to select a channel chat
     * to add the bot to as an administrator. Then, call getChatMember to receive the
     * current bot rights in the chat and if the bot already is an administrator, check
     * that the current user can edit its administrator rights and combine received
     * rights with the requested administrator rights. Then, show confirmation box
     * to the user, and call setChatMemberStatus with the chosen chat and confirmed
     * rights
     */
    +_: 'internalLinkTypeBotAddToChannel',
    /** Username of the bot */
    +bot_username?: string,
    /** Expected administrator rights for the bot */
    +administrator_rights?: chatAdministratorRights$Input,
  |}

  declare export type internalLinkTypeBotStart = {|
    /**
     * The link is a link to a chat with a Telegram bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot, show START button in the
     * chat with the bot, and then call sendBotStartMessage with the given start parameter
     * after the button is pressed
     */
    _: 'internalLinkTypeBotStart',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
    /**
     * True, if sendBotStartMessage must be called automatically without showing the
     * START button
     */
    autostart: boolean,
  |}

  declare export type internalLinkTypeBotStart$Input = {|
    /**
     * The link is a link to a chat with a Telegram bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot, show START button in the
     * chat with the bot, and then call sendBotStartMessage with the given start parameter
     * after the button is pressed
     */
    +_: 'internalLinkTypeBotStart',
    /** Username of the bot */
    +bot_username?: string,
    /** The parameter to be passed to sendBotStartMessage */
    +start_parameter?: string,
    /**
     * True, if sendBotStartMessage must be called automatically without showing the
     * START button
     */
    +autostart?: boolean,
  |}

  declare export type internalLinkTypeBotStartInGroup = {|
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a group
     * chat. Call searchPublicChat with the given bot username, check that the user
     * is a bot and can be added to groups, ask the current user to select a basic
     * group or a supergroup chat to add the bot to, taking into account that bots
     * can be added to a public supergroup only by administrators of the supergroup.
     * If administrator rights are provided by the link, call getChatMember to receive
     * the current bot rights in the chat and if the bot already is an administrator,
     * check that the current user can edit its administrator rights, combine received
     * rights with the requested administrator rights, show confirmation box to the
     * user, and call setChatMemberStatus with the chosen chat and confirmed administrator
     * rights. Before call to setChatMemberStatus it may be required to upgrade the
     * chosen basic group chat to a supergroup chat. Then, if start_parameter isn't
     * empty, call sendBotStartMessage with the given start parameter and the chosen
     * chat; otherwise, just send /start message with bot's username added to the chat
     */
    _: 'internalLinkTypeBotStartInGroup',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
    /** Expected administrator rights for the bot; may be null */
    administrator_rights?: chatAdministratorRights,
  |}

  declare export type internalLinkTypeBotStartInGroup$Input = {|
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a group
     * chat. Call searchPublicChat with the given bot username, check that the user
     * is a bot and can be added to groups, ask the current user to select a basic
     * group or a supergroup chat to add the bot to, taking into account that bots
     * can be added to a public supergroup only by administrators of the supergroup.
     * If administrator rights are provided by the link, call getChatMember to receive
     * the current bot rights in the chat and if the bot already is an administrator,
     * check that the current user can edit its administrator rights, combine received
     * rights with the requested administrator rights, show confirmation box to the
     * user, and call setChatMemberStatus with the chosen chat and confirmed administrator
     * rights. Before call to setChatMemberStatus it may be required to upgrade the
     * chosen basic group chat to a supergroup chat. Then, if start_parameter isn't
     * empty, call sendBotStartMessage with the given start parameter and the chosen
     * chat; otherwise, just send /start message with bot's username added to the chat
     */
    +_: 'internalLinkTypeBotStartInGroup',
    /** Username of the bot */
    +bot_username?: string,
    /** The parameter to be passed to sendBotStartMessage */
    +start_parameter?: string,
    /** Expected administrator rights for the bot; may be null */
    +administrator_rights?: chatAdministratorRights$Input,
  |}

  declare export type internalLinkTypeBusinessChat = {|
    /**
     * The link is a link to a business chat. Use getBusinessChatLinkInfo with the
     * provided link name to get information about the link, then open received private
     * chat and replace chat draft with the provided text
     */
    _: 'internalLinkTypeBusinessChat',
    /** Name of the link */
    link_name: string,
  |}

  declare export type internalLinkTypeBusinessChat$Input = {|
    /**
     * The link is a link to a business chat. Use getBusinessChatLinkInfo with the
     * provided link name to get information about the link, then open received private
     * chat and replace chat draft with the provided text
     */
    +_: 'internalLinkTypeBusinessChat',
    /** Name of the link */
    +link_name?: string,
  |}

  declare export type internalLinkTypeBuyStars = {|
    /** The link is a link to the Telegram Star purchase section of the application */
    _: 'internalLinkTypeBuyStars',
    /** The number of Telegram Stars that must be owned by the user */
    star_count: number,
    /**
     * Purpose of Telegram Star purchase. Arbitrary string specified by the server,
     * for example, "subs" if the Telegram Stars are required to extend channel subscriptions
     */
    purpose: string,
  |}

  declare export type internalLinkTypeBuyStars$Input = {|
    /** The link is a link to the Telegram Star purchase section of the application */
    +_: 'internalLinkTypeBuyStars',
    /** The number of Telegram Stars that must be owned by the user */
    +star_count?: number,
    /**
     * Purpose of Telegram Star purchase. Arbitrary string specified by the server,
     * for example, "subs" if the Telegram Stars are required to extend channel subscriptions
     */
    +purpose?: string,
  |}

  declare export type internalLinkTypeChangePhoneNumber = {|
    /** The link is a link to the change phone number section of the application */
    _: 'internalLinkTypeChangePhoneNumber',
  |}

  declare export type internalLinkTypeChangePhoneNumber$Input = {|
    /** The link is a link to the change phone number section of the application */
    +_: 'internalLinkTypeChangePhoneNumber',
  |}

  declare export type internalLinkTypeChatAffiliateProgram = {|
    /**
     * The link is an affiliate program link. Call searchChatAffiliateProgram with
     * the given username and referrer to process the link
     */
    _: 'internalLinkTypeChatAffiliateProgram',
    /** Username to be passed to searchChatAffiliateProgram */
    username: string,
    /** Referrer to be passed to searchChatAffiliateProgram */
    referrer: string,
  |}

  declare export type internalLinkTypeChatAffiliateProgram$Input = {|
    /**
     * The link is an affiliate program link. Call searchChatAffiliateProgram with
     * the given username and referrer to process the link
     */
    +_: 'internalLinkTypeChatAffiliateProgram',
    /** Username to be passed to searchChatAffiliateProgram */
    +username?: string,
    /** Referrer to be passed to searchChatAffiliateProgram */
    +referrer?: string,
  |}

  declare export type internalLinkTypeChatBoost = {|
    /**
     * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with
     * the given URL to process the link. If the chat is found, then call getChatBoostStatus
     * and getAvailableChatBoostSlots to get the current boost status and check whether
     * the chat can be boosted. If the user wants to boost the chat and the chat can
     * be boosted, then call boostChat
     */
    _: 'internalLinkTypeChatBoost',
    /** URL to be passed to getChatBoostLinkInfo */
    url: string,
  |}

  declare export type internalLinkTypeChatBoost$Input = {|
    /**
     * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with
     * the given URL to process the link. If the chat is found, then call getChatBoostStatus
     * and getAvailableChatBoostSlots to get the current boost status and check whether
     * the chat can be boosted. If the user wants to boost the chat and the chat can
     * be boosted, then call boostChat
     */
    +_: 'internalLinkTypeChatBoost',
    /** URL to be passed to getChatBoostLinkInfo */
    +url?: string,
  |}

  declare export type internalLinkTypeChatFolderInvite = {|
    /**
     * The link is an invite link to a chat folder. Call checkChatFolderInviteLink
     * with the given invite link to process the link. If the link is valid and the
     * user wants to join the chat folder, then call addChatFolderByInviteLink
     */
    _: 'internalLinkTypeChatFolderInvite',
    /** Internal representation of the invite link */
    invite_link: string,
  |}

  declare export type internalLinkTypeChatFolderInvite$Input = {|
    /**
     * The link is an invite link to a chat folder. Call checkChatFolderInviteLink
     * with the given invite link to process the link. If the link is valid and the
     * user wants to join the chat folder, then call addChatFolderByInviteLink
     */
    +_: 'internalLinkTypeChatFolderInvite',
    /** Internal representation of the invite link */
    +invite_link?: string,
  |}

  declare export type internalLinkTypeChatFolderSettings = {|
    /** The link is a link to the folder section of the application settings */
    _: 'internalLinkTypeChatFolderSettings',
  |}

  declare export type internalLinkTypeChatFolderSettings$Input = {|
    /** The link is a link to the folder section of the application settings */
    +_: 'internalLinkTypeChatFolderSettings',
  |}

  declare export type internalLinkTypeChatInvite = {|
    /**
     * The link is a chat invite link. Call checkChatInviteLink with the given invite
     * link to process the link. If the link is valid and the user wants to join the
     * chat, then call joinChatByInviteLink
     */
    _: 'internalLinkTypeChatInvite',
    /** Internal representation of the invite link */
    invite_link: string,
  |}

  declare export type internalLinkTypeChatInvite$Input = {|
    /**
     * The link is a chat invite link. Call checkChatInviteLink with the given invite
     * link to process the link. If the link is valid and the user wants to join the
     * chat, then call joinChatByInviteLink
     */
    +_: 'internalLinkTypeChatInvite',
    /** Internal representation of the invite link */
    +invite_link?: string,
  |}

  declare export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings = {|
    /**
     * The link is a link to the default message auto-delete timer settings section
     * of the application settings
     */
    _: 'internalLinkTypeDefaultMessageAutoDeleteTimerSettings',
  |}

  declare export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input = {|
    /**
     * The link is a link to the default message auto-delete timer settings section
     * of the application settings
     */
    +_: 'internalLinkTypeDefaultMessageAutoDeleteTimerSettings',
  |}

  declare export type internalLinkTypeEditProfileSettings = {|
    /** The link is a link to the edit profile section of the application settings */
    _: 'internalLinkTypeEditProfileSettings',
  |}

  declare export type internalLinkTypeEditProfileSettings$Input = {|
    /** The link is a link to the edit profile section of the application settings */
    +_: 'internalLinkTypeEditProfileSettings',
  |}

  declare export type internalLinkTypeGame = {|
    /**
     * The link is a link to a game. Call searchPublicChat with the given bot username,
     * check that the user is a bot, ask the current user to select a chat to send
     * the game, and then call sendMessage with inputMessageGame
     */
    _: 'internalLinkTypeGame',
    /** Username of the bot that owns the game */
    bot_username: string,
    /** Short name of the game */
    game_short_name: string,
  |}

  declare export type internalLinkTypeGame$Input = {|
    /**
     * The link is a link to a game. Call searchPublicChat with the given bot username,
     * check that the user is a bot, ask the current user to select a chat to send
     * the game, and then call sendMessage with inputMessageGame
     */
    +_: 'internalLinkTypeGame',
    /** Username of the bot that owns the game */
    +bot_username?: string,
    /** Short name of the game */
    +game_short_name?: string,
  |}

  declare export type internalLinkTypeInstantView = {|
    /**
     * The link must be opened in an Instant View. Call getWebPageInstantView with
     * the given URL to process the link. If Instant View is found, then show it, otherwise,
     * open the fallback URL in an external browser
     */
    _: 'internalLinkTypeInstantView',
    /** URL to be passed to getWebPageInstantView */
    url: string,
    /** An URL to open if getWebPageInstantView fails */
    fallback_url: string,
  |}

  declare export type internalLinkTypeInstantView$Input = {|
    /**
     * The link must be opened in an Instant View. Call getWebPageInstantView with
     * the given URL to process the link. If Instant View is found, then show it, otherwise,
     * open the fallback URL in an external browser
     */
    +_: 'internalLinkTypeInstantView',
    /** URL to be passed to getWebPageInstantView */
    +url?: string,
    /** An URL to open if getWebPageInstantView fails */
    +fallback_url?: string,
  |}

  declare export type internalLinkTypeInvoice = {|
    /**
     * The link is a link to an invoice. Call getPaymentForm with the given invoice
     * name to process the link
     */
    _: 'internalLinkTypeInvoice',
    /** Name of the invoice */
    invoice_name: string,
  |}

  declare export type internalLinkTypeInvoice$Input = {|
    /**
     * The link is a link to an invoice. Call getPaymentForm with the given invoice
     * name to process the link
     */
    +_: 'internalLinkTypeInvoice',
    /** Name of the invoice */
    +invoice_name?: string,
  |}

  declare export type internalLinkTypeLanguagePack = {|
    /**
     * The link is a link to a language pack. Call getLanguagePackInfo with the given
     * language pack identifier to process the link. If the language pack is found
     * and the user wants to apply it, then call setOption for the option "language_pack_id"
     */
    _: 'internalLinkTypeLanguagePack',
    /** Language pack identifier */
    language_pack_id: string,
  |}

  declare export type internalLinkTypeLanguagePack$Input = {|
    /**
     * The link is a link to a language pack. Call getLanguagePackInfo with the given
     * language pack identifier to process the link. If the language pack is found
     * and the user wants to apply it, then call setOption for the option "language_pack_id"
     */
    +_: 'internalLinkTypeLanguagePack',
    /** Language pack identifier */
    +language_pack_id?: string,
  |}

  declare export type internalLinkTypeLanguageSettings = {|
    /** The link is a link to the language section of the application settings */
    _: 'internalLinkTypeLanguageSettings',
  |}

  declare export type internalLinkTypeLanguageSettings$Input = {|
    /** The link is a link to the language section of the application settings */
    +_: 'internalLinkTypeLanguageSettings',
  |}

  declare export type internalLinkTypeMainWebApp = {|
    /**
     * The link is a link to the main Web App of a bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot and has the main Web App.
     * If the bot can be added to attachment menu, then use getAttachmentMenuBot to
     * receive information about the bot, then if the bot isn't added to side menu,
     * show a disclaimer about Mini Apps being third-party applications, ask the user
     * to accept their Terms of service and confirm adding the bot to side and attachment
     * menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, use getMainWebApp with the given start parameter and mode
     * and open the returned URL as a Web App
     */
    _: 'internalLinkTypeMainWebApp',
    /** Username of the bot */
    bot_username: string,
    /** Start parameter to be passed to getMainWebApp */
    start_parameter: string,
    /** The mode to be passed to getMainWebApp */
    mode: WebAppOpenMode,
  |}

  declare export type internalLinkTypeMainWebApp$Input = {|
    /**
     * The link is a link to the main Web App of a bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot and has the main Web App.
     * If the bot can be added to attachment menu, then use getAttachmentMenuBot to
     * receive information about the bot, then if the bot isn't added to side menu,
     * show a disclaimer about Mini Apps being third-party applications, ask the user
     * to accept their Terms of service and confirm adding the bot to side and attachment
     * menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, use getMainWebApp with the given start parameter and mode
     * and open the returned URL as a Web App
     */
    +_: 'internalLinkTypeMainWebApp',
    /** Username of the bot */
    +bot_username?: string,
    /** Start parameter to be passed to getMainWebApp */
    +start_parameter?: string,
    /** The mode to be passed to getMainWebApp */
    +mode?: WebAppOpenMode$Input,
  |}

  declare export type internalLinkTypeMessage = {|
    /**
     * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo
     * with the given URL to process the link, and then open received forum topic or
     * chat and show the message there
     */
    _: 'internalLinkTypeMessage',
    /** URL to be passed to getMessageLinkInfo */
    url: string,
  |}

  declare export type internalLinkTypeMessage$Input = {|
    /**
     * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo
     * with the given URL to process the link, and then open received forum topic or
     * chat and show the message there
     */
    +_: 'internalLinkTypeMessage',
    /** URL to be passed to getMessageLinkInfo */
    +url?: string,
  |}

  declare export type internalLinkTypeMessageDraft = {|
    /**
     * The link contains a message draft text. A share screen needs to be shown to
     * the user, then the chosen chat must be opened and the text is added to the input
     * field
     */
    _: 'internalLinkTypeMessageDraft',
    /** Message draft text */
    text: formattedText,
    /**
     * True, if the first line of the text contains a link. If true, the input field
     * needs to be focused and the text after the link must be selected
     */
    contains_link: boolean,
  |}

  declare export type internalLinkTypeMessageDraft$Input = {|
    /**
     * The link contains a message draft text. A share screen needs to be shown to
     * the user, then the chosen chat must be opened and the text is added to the input
     * field
     */
    +_: 'internalLinkTypeMessageDraft',
    /** Message draft text */
    +text?: formattedText$Input,
    /**
     * True, if the first line of the text contains a link. If true, the input field
     * needs to be focused and the text after the link must be selected
     */
    +contains_link?: boolean,
  |}

  declare export type internalLinkTypePassportDataRequest = {|
    /**
     * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
     * with the given parameters to process the link if the link was received from
     * outside of the application; otherwise, ignore it
     */
    _: 'internalLinkTypePassportDataRequest',
    /**
     * User identifier of the service's bot; the corresponding user may be unknown
     * yet
     */
    bot_user_id: number,
    /** Telegram Passport element types requested by the service */
    scope: string,
    /** Service's public key */
    public_key: string,
    /** Unique request identifier provided by the service */
    nonce: string,
    /**
     * An HTTP URL to open once the request is finished, canceled, or failed with the
     * parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=...
     * respectively. If empty, then onActivityResult method must be used to return
     * response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel
     * must be opened otherwise
     */
    callback_url: string,
  |}

  declare export type internalLinkTypePassportDataRequest$Input = {|
    /**
     * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
     * with the given parameters to process the link if the link was received from
     * outside of the application; otherwise, ignore it
     */
    +_: 'internalLinkTypePassportDataRequest',
    /**
     * User identifier of the service's bot; the corresponding user may be unknown
     * yet
     */
    +bot_user_id?: number,
    /** Telegram Passport element types requested by the service */
    +scope?: string,
    /** Service's public key */
    +public_key?: string,
    /** Unique request identifier provided by the service */
    +nonce?: string,
    /**
     * An HTTP URL to open once the request is finished, canceled, or failed with the
     * parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=...
     * respectively. If empty, then onActivityResult method must be used to return
     * response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel
     * must be opened otherwise
     */
    +callback_url?: string,
  |}

  declare export type internalLinkTypePhoneNumberConfirmation = {|
    /**
     * The link can be used to confirm ownership of a phone number to prevent account
     * deletion. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership
     * with the given hash to process the link. If succeeded, call checkPhoneNumberCode
     * to check entered by the user code, or resendPhoneNumberCode to resend it
     */
    _: 'internalLinkTypePhoneNumberConfirmation',
    /** Hash value from the link */
    hash: string,
    /** Phone number value from the link */
    phone_number: string,
  |}

  declare export type internalLinkTypePhoneNumberConfirmation$Input = {|
    /**
     * The link can be used to confirm ownership of a phone number to prevent account
     * deletion. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership
     * with the given hash to process the link. If succeeded, call checkPhoneNumberCode
     * to check entered by the user code, or resendPhoneNumberCode to resend it
     */
    +_: 'internalLinkTypePhoneNumberConfirmation',
    /** Hash value from the link */
    +hash?: string,
    /** Phone number value from the link */
    +phone_number?: string,
  |}

  declare export type internalLinkTypePremiumFeatures = {|
    /**
     * The link is a link to the Premium features screen of the application from which
     * the user can subscribe to Telegram Premium. Call getPremiumFeatures with the
     * given referrer to process the link
     */
    _: 'internalLinkTypePremiumFeatures',
    /** Referrer specified in the link */
    referrer: string,
  |}

  declare export type internalLinkTypePremiumFeatures$Input = {|
    /**
     * The link is a link to the Premium features screen of the application from which
     * the user can subscribe to Telegram Premium. Call getPremiumFeatures with the
     * given referrer to process the link
     */
    +_: 'internalLinkTypePremiumFeatures',
    /** Referrer specified in the link */
    +referrer?: string,
  |}

  declare export type internalLinkTypePremiumGift = {|
    /**
     * The link is a link to the screen for gifting Telegram Premium subscriptions
     * to friends via inputInvoiceTelegram with telegramPaymentPurposePremiumGift payments
     * or in-store purchases
     */
    _: 'internalLinkTypePremiumGift',
    /** Referrer specified in the link */
    referrer: string,
  |}

  declare export type internalLinkTypePremiumGift$Input = {|
    /**
     * The link is a link to the screen for gifting Telegram Premium subscriptions
     * to friends via inputInvoiceTelegram with telegramPaymentPurposePremiumGift payments
     * or in-store purchases
     */
    +_: 'internalLinkTypePremiumGift',
    /** Referrer specified in the link */
    +referrer?: string,
  |}

  declare export type internalLinkTypePremiumGiftCode = {|
    /**
     * The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode
     * with the given code to process the link. If the code is valid and the user wants
     * to apply it, then call applyPremiumGiftCode
     */
    _: 'internalLinkTypePremiumGiftCode',
    /** The Telegram Premium gift code */
    code: string,
  |}

  declare export type internalLinkTypePremiumGiftCode$Input = {|
    /**
     * The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode
     * with the given code to process the link. If the code is valid and the user wants
     * to apply it, then call applyPremiumGiftCode
     */
    +_: 'internalLinkTypePremiumGiftCode',
    /** The Telegram Premium gift code */
    +code?: string,
  |}

  declare export type internalLinkTypePrivacyAndSecuritySettings = {|
    /** The link is a link to the privacy and security section of the application settings */
    _: 'internalLinkTypePrivacyAndSecuritySettings',
  |}

  declare export type internalLinkTypePrivacyAndSecuritySettings$Input = {|
    /** The link is a link to the privacy and security section of the application settings */
    +_: 'internalLinkTypePrivacyAndSecuritySettings',
  |}

  declare export type internalLinkTypeProxy = {|
    /**
     * The link is a link to a proxy. Call addProxy with the given parameters to process
     * the link and add the proxy
     */
    _: 'internalLinkTypeProxy',
    /** Proxy server domain or IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Type of the proxy */
    type: ProxyType,
  |}

  declare export type internalLinkTypeProxy$Input = {|
    /**
     * The link is a link to a proxy. Call addProxy with the given parameters to process
     * the link and add the proxy
     */
    +_: 'internalLinkTypeProxy',
    /** Proxy server domain or IP address */
    +server?: string,
    /** Proxy server port */
    +port?: number,
    /** Type of the proxy */
    +type?: ProxyType$Input,
  |}

  declare export type internalLinkTypePublicChat = {|
    /**
     * The link is a link to a chat by its username. Call searchPublicChat with the
     * given chat username to process the link. If the chat is found, open its profile
     * information screen or the chat itself. If draft text isn't empty and the chat
     * is a private chat with a regular user, then put the draft text in the input
     * field
     */
    _: 'internalLinkTypePublicChat',
    /** Username of the chat */
    chat_username: string,
    /** Draft text for message to send in the chat */
    draft_text: string,
    /**
     * True, if chat profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    open_profile: boolean,
  |}

  declare export type internalLinkTypePublicChat$Input = {|
    /**
     * The link is a link to a chat by its username. Call searchPublicChat with the
     * given chat username to process the link. If the chat is found, open its profile
     * information screen or the chat itself. If draft text isn't empty and the chat
     * is a private chat with a regular user, then put the draft text in the input
     * field
     */
    +_: 'internalLinkTypePublicChat',
    /** Username of the chat */
    +chat_username?: string,
    /** Draft text for message to send in the chat */
    +draft_text?: string,
    /**
     * True, if chat profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    +open_profile?: boolean,
  |}

  declare export type internalLinkTypeQrCodeAuthentication = {|
    /**
     * The link can be used to login the current user on another device, but it must
     * be scanned from QR-code using in-app camera. An alert similar to "This code
     * can be used to allow someone to log in to your Telegram account. To confirm
     * Telegram login, please go to Settings > Devices > Scan QR and scan the code"
     * needs to be shown
     */
    _: 'internalLinkTypeQrCodeAuthentication',
  |}

  declare export type internalLinkTypeQrCodeAuthentication$Input = {|
    /**
     * The link can be used to login the current user on another device, but it must
     * be scanned from QR-code using in-app camera. An alert similar to "This code
     * can be used to allow someone to log in to your Telegram account. To confirm
     * Telegram login, please go to Settings > Devices > Scan QR and scan the code"
     * needs to be shown
     */
    +_: 'internalLinkTypeQrCodeAuthentication',
  |}

  declare export type internalLinkTypeRestorePurchases = {|
    /**
     * The link forces restore of App Store purchases when opened. For official iOS
     * application only
     */
    _: 'internalLinkTypeRestorePurchases',
  |}

  declare export type internalLinkTypeRestorePurchases$Input = {|
    /**
     * The link forces restore of App Store purchases when opened. For official iOS
     * application only
     */
    +_: 'internalLinkTypeRestorePurchases',
  |}

  declare export type internalLinkTypeSettings = {|
    /** The link is a link to application settings */
    _: 'internalLinkTypeSettings',
  |}

  declare export type internalLinkTypeSettings$Input = {|
    /** The link is a link to application settings */
    +_: 'internalLinkTypeSettings',
  |}

  declare export type internalLinkTypeStickerSet = {|
    /**
     * The link is a link to a sticker set. Call searchStickerSet with the given sticker
     * set name to process the link and show the sticker set. If the sticker set is
     * found and the user wants to add it, then call changeStickerSet
     */
    _: 'internalLinkTypeStickerSet',
    /** Name of the sticker set */
    sticker_set_name: string,
    /** True, if the sticker set is expected to contain custom emoji */
    expect_custom_emoji: boolean,
  |}

  declare export type internalLinkTypeStickerSet$Input = {|
    /**
     * The link is a link to a sticker set. Call searchStickerSet with the given sticker
     * set name to process the link and show the sticker set. If the sticker set is
     * found and the user wants to add it, then call changeStickerSet
     */
    +_: 'internalLinkTypeStickerSet',
    /** Name of the sticker set */
    +sticker_set_name?: string,
    /** True, if the sticker set is expected to contain custom emoji */
    +expect_custom_emoji?: boolean,
  |}

  declare export type internalLinkTypeStory = {|
    /**
     * The link is a link to a story. Call searchPublicChat with the given sender username,
     * then call getStory with the received chat identifier and the given story identifier,
     * then show the story if received
     */
    _: 'internalLinkTypeStory',
    /** Username of the sender of the story */
    story_sender_username: string,
    /** Story identifier */
    story_id: number,
  |}

  declare export type internalLinkTypeStory$Input = {|
    /**
     * The link is a link to a story. Call searchPublicChat with the given sender username,
     * then call getStory with the received chat identifier and the given story identifier,
     * then show the story if received
     */
    +_: 'internalLinkTypeStory',
    /** Username of the sender of the story */
    +story_sender_username?: string,
    /** Story identifier */
    +story_id?: number,
  |}

  declare export type internalLinkTypeTheme = {|
    /** The link is a link to a cloud theme. TDLib has no theme support yet */
    _: 'internalLinkTypeTheme',
    /** Name of the theme */
    theme_name: string,
  |}

  declare export type internalLinkTypeTheme$Input = {|
    /** The link is a link to a cloud theme. TDLib has no theme support yet */
    +_: 'internalLinkTypeTheme',
    /** Name of the theme */
    +theme_name?: string,
  |}

  declare export type internalLinkTypeThemeSettings = {|
    /** The link is a link to the theme section of the application settings */
    _: 'internalLinkTypeThemeSettings',
  |}

  declare export type internalLinkTypeThemeSettings$Input = {|
    /** The link is a link to the theme section of the application settings */
    +_: 'internalLinkTypeThemeSettings',
  |}

  declare export type internalLinkTypeUnknownDeepLink = {|
    /** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
    _: 'internalLinkTypeUnknownDeepLink',
    /** Link to be passed to getDeepLinkInfo */
    link: string,
  |}

  declare export type internalLinkTypeUnknownDeepLink$Input = {|
    /** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
    +_: 'internalLinkTypeUnknownDeepLink',
    /** Link to be passed to getDeepLinkInfo */
    +link?: string,
  |}

  declare export type internalLinkTypeUnsupportedProxy = {|
    /** The link is a link to an unsupported proxy. An alert can be shown to the user */
    _: 'internalLinkTypeUnsupportedProxy',
  |}

  declare export type internalLinkTypeUnsupportedProxy$Input = {|
    /** The link is a link to an unsupported proxy. An alert can be shown to the user */
    +_: 'internalLinkTypeUnsupportedProxy',
  |}

  declare export type internalLinkTypeUpgradedGift = {|
    /**
     * The link is a link to an upgraded gift. Call getUpgradedGift with the given
     * name to process the link
     */
    _: 'internalLinkTypeUpgradedGift',
    /** Name of the unique gift */
    name: string,
  |}

  declare export type internalLinkTypeUpgradedGift$Input = {|
    /**
     * The link is a link to an upgraded gift. Call getUpgradedGift with the given
     * name to process the link
     */
    +_: 'internalLinkTypeUpgradedGift',
    /** Name of the unique gift */
    +name?: string,
  |}

  declare export type internalLinkTypeUserPhoneNumber = {|
    /**
     * The link is a link to a user by its phone number. Call searchUserByPhoneNumber
     * with the given phone number to process the link. If the user is found, then
     * call createPrivateChat and open user's profile information screen or the chat
     * itself. If draft text isn't empty, then put the draft text in the input field
     */
    _: 'internalLinkTypeUserPhoneNumber',
    /** Phone number of the user */
    phone_number: string,
    /** Draft text for message to send in the chat */
    draft_text: string,
    /**
     * True, if user's profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    open_profile: boolean,
  |}

  declare export type internalLinkTypeUserPhoneNumber$Input = {|
    /**
     * The link is a link to a user by its phone number. Call searchUserByPhoneNumber
     * with the given phone number to process the link. If the user is found, then
     * call createPrivateChat and open user's profile information screen or the chat
     * itself. If draft text isn't empty, then put the draft text in the input field
     */
    +_: 'internalLinkTypeUserPhoneNumber',
    /** Phone number of the user */
    +phone_number?: string,
    /** Draft text for message to send in the chat */
    +draft_text?: string,
    /**
     * True, if user's profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    +open_profile?: boolean,
  |}

  declare export type internalLinkTypeUserToken = {|
    /**
     * The link is a link to a user by a temporary token. Call searchUserByToken with
     * the given token to process the link. If the user is found, then call createPrivateChat
     * and open the chat
     */
    _: 'internalLinkTypeUserToken',
    /** The token */
    token: string,
  |}

  declare export type internalLinkTypeUserToken$Input = {|
    /**
     * The link is a link to a user by a temporary token. Call searchUserByToken with
     * the given token to process the link. If the user is found, then call createPrivateChat
     * and open the chat
     */
    +_: 'internalLinkTypeUserToken',
    /** The token */
    +token?: string,
  |}

  declare export type internalLinkTypeVideoChat = {|
    /**
     * The link is a link to a video chat. Call searchPublicChat with the given chat
     * username, and then joinGroupCall with the given invite hash to process the link
     */
    _: 'internalLinkTypeVideoChat',
    /** Username of the chat with the video chat */
    chat_username: string,
    /**
     * If non-empty, invite hash to be used to join the video chat without being muted
     * by administrators
     */
    invite_hash: string,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    is_live_stream: boolean,
  |}

  declare export type internalLinkTypeVideoChat$Input = {|
    /**
     * The link is a link to a video chat. Call searchPublicChat with the given chat
     * username, and then joinGroupCall with the given invite hash to process the link
     */
    +_: 'internalLinkTypeVideoChat',
    /** Username of the chat with the video chat */
    +chat_username?: string,
    /**
     * If non-empty, invite hash to be used to join the video chat without being muted
     * by administrators
     */
    +invite_hash?: string,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    +is_live_stream?: boolean,
  |}

  declare export type internalLinkTypeWebApp = {|
    /**
     * The link is a link to a Web App. Call searchPublicChat with the given bot username,
     * check that the user is a bot. If the bot is restricted for the current user,
     * then show an error message. Otherwise, call searchWebApp with the received bot
     * and the given web_app_short_name. Process received foundWebApp by showing a
     * confirmation dialog if needed. If the bot can be added to attachment or side
     * menu, but isn't added yet, then show a disclaimer about Mini Apps being third-party
     * applications instead of the dialog and ask the user to accept their Terms of
     * service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web
     * App
     */
    _: 'internalLinkTypeWebApp',
    /** Username of the bot that owns the Web App */
    bot_username: string,
    /** Short name of the Web App */
    web_app_short_name: string,
    /** Start parameter to be passed to getWebAppLinkUrl */
    start_parameter: string,
    /** The mode in which the Web App must be opened */
    mode: WebAppOpenMode,
  |}

  declare export type internalLinkTypeWebApp$Input = {|
    /**
     * The link is a link to a Web App. Call searchPublicChat with the given bot username,
     * check that the user is a bot. If the bot is restricted for the current user,
     * then show an error message. Otherwise, call searchWebApp with the received bot
     * and the given web_app_short_name. Process received foundWebApp by showing a
     * confirmation dialog if needed. If the bot can be added to attachment or side
     * menu, but isn't added yet, then show a disclaimer about Mini Apps being third-party
     * applications instead of the dialog and ask the user to accept their Terms of
     * service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web
     * App
     */
    +_: 'internalLinkTypeWebApp',
    /** Username of the bot that owns the Web App */
    +bot_username?: string,
    /** Short name of the Web App */
    +web_app_short_name?: string,
    /** Start parameter to be passed to getWebAppLinkUrl */
    +start_parameter?: string,
    /** The mode in which the Web App must be opened */
    +mode?: WebAppOpenMode$Input,
  |}

  declare export type messageLink = {|
    /** Contains an HTTPS link to a message in a supergroup or channel, or a forum topic */
    _: 'messageLink',
    /** The link */
    link: string,
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
  |}

  declare export type messageLinkInfo = {|
    /** Contains information about a link to a message or a forum topic in a chat */
    _: 'messageLinkInfo',
    /** True, if the link is a public link for a message or a forum topic in a chat */
    is_public: boolean,
    /** If found, identifier of the chat to which the link points, 0 otherwise */
    chat_id: number,
    /**
     * If found, identifier of the message thread in which to open the message, or
     * a forum topic to open if the message is missing
     */
    message_thread_id: number,
    /** If found, the linked message; may be null */
    message?: message,
    /**
     * Timestamp from which the video/audio/video note/voice note/story playing must
     * start, in seconds; 0 if not specified. The media can be in the message content
     * or in its link preview
     */
    media_timestamp: number,
    /** True, if the whole media album to which the message belongs is linked */
    for_album: boolean,
  |}

  declare export type chatBoostLink = {|
    /** Contains an HTTPS link to boost a chat */
    _: 'chatBoostLink',
    /** The link */
    link: string,
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
  |}

  declare export type chatBoostLinkInfo = {|
    /** Contains information about a link to boost a chat */
    _: 'chatBoostLinkInfo',
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
    /** Identifier of the chat to which the link points; 0 if the chat isn't found */
    chat_id: number,
  |}

  declare export type blockListMain = {|
    /**
     * The main block list that disallows writing messages to the current user, receiving
     * their status and photo, viewing of stories, and some other actions
     */
    _: 'blockListMain',
  |}

  declare export type blockListMain$Input = {|
    /**
     * The main block list that disallows writing messages to the current user, receiving
     * their status and photo, viewing of stories, and some other actions
     */
    +_: 'blockListMain',
  |}

  declare export type blockListStories = {|
    /** The block list that disallows viewing of stories of the current user */
    _: 'blockListStories',
  |}

  declare export type blockListStories$Input = {|
    /** The block list that disallows viewing of stories of the current user */
    +_: 'blockListStories',
  |}

  declare export type filePart = {|
    /** Contains a part of a file */
    _: 'filePart',
    /** File bytes */
    data: string /* base64 */,
  |}

  declare export type fileTypeNone = {|
    /** The data is not a file */
    _: 'fileTypeNone',
  |}

  declare export type fileTypeNone$Input = {|
    /** The data is not a file */
    +_: 'fileTypeNone',
  |}

  declare export type fileTypeAnimation = {|
    /** The file is an animation */
    _: 'fileTypeAnimation',
  |}

  declare export type fileTypeAnimation$Input = {|
    /** The file is an animation */
    +_: 'fileTypeAnimation',
  |}

  declare export type fileTypeAudio = {|
    /** The file is an audio file */
    _: 'fileTypeAudio',
  |}

  declare export type fileTypeAudio$Input = {|
    /** The file is an audio file */
    +_: 'fileTypeAudio',
  |}

  declare export type fileTypeDocument = {|
    /** The file is a document */
    _: 'fileTypeDocument',
  |}

  declare export type fileTypeDocument$Input = {|
    /** The file is a document */
    +_: 'fileTypeDocument',
  |}

  declare export type fileTypeNotificationSound = {|
    /** The file is a notification sound */
    _: 'fileTypeNotificationSound',
  |}

  declare export type fileTypeNotificationSound$Input = {|
    /** The file is a notification sound */
    +_: 'fileTypeNotificationSound',
  |}

  declare export type fileTypePhoto = {|
    /** The file is a photo */
    _: 'fileTypePhoto',
  |}

  declare export type fileTypePhoto$Input = {|
    /** The file is a photo */
    +_: 'fileTypePhoto',
  |}

  declare export type fileTypePhotoStory = {|
    /** The file is a photo published as a story */
    _: 'fileTypePhotoStory',
  |}

  declare export type fileTypePhotoStory$Input = {|
    /** The file is a photo published as a story */
    +_: 'fileTypePhotoStory',
  |}

  declare export type fileTypeProfilePhoto = {|
    /** The file is a profile photo */
    _: 'fileTypeProfilePhoto',
  |}

  declare export type fileTypeProfilePhoto$Input = {|
    /** The file is a profile photo */
    +_: 'fileTypeProfilePhoto',
  |}

  declare export type fileTypeSecret = {|
    /** The file was sent to a secret chat (the file type is not known to the server) */
    _: 'fileTypeSecret',
  |}

  declare export type fileTypeSecret$Input = {|
    /** The file was sent to a secret chat (the file type is not known to the server) */
    +_: 'fileTypeSecret',
  |}

  declare export type fileTypeSecretThumbnail = {|
    /** The file is a thumbnail of a file from a secret chat */
    _: 'fileTypeSecretThumbnail',
  |}

  declare export type fileTypeSecretThumbnail$Input = {|
    /** The file is a thumbnail of a file from a secret chat */
    +_: 'fileTypeSecretThumbnail',
  |}

  declare export type fileTypeSecure = {|
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    _: 'fileTypeSecure',
  |}

  declare export type fileTypeSecure$Input = {|
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    +_: 'fileTypeSecure',
  |}

  declare export type fileTypeSelfDestructingPhoto = {|
    /** The file is a self-destructing photo in a private chat */
    _: 'fileTypeSelfDestructingPhoto',
  |}

  declare export type fileTypeSelfDestructingPhoto$Input = {|
    /** The file is a self-destructing photo in a private chat */
    +_: 'fileTypeSelfDestructingPhoto',
  |}

  declare export type fileTypeSelfDestructingVideo = {|
    /** The file is a self-destructing video in a private chat */
    _: 'fileTypeSelfDestructingVideo',
  |}

  declare export type fileTypeSelfDestructingVideo$Input = {|
    /** The file is a self-destructing video in a private chat */
    +_: 'fileTypeSelfDestructingVideo',
  |}

  declare export type fileTypeSelfDestructingVideoNote = {|
    /** The file is a self-destructing video note in a private chat */
    _: 'fileTypeSelfDestructingVideoNote',
  |}

  declare export type fileTypeSelfDestructingVideoNote$Input = {|
    /** The file is a self-destructing video note in a private chat */
    +_: 'fileTypeSelfDestructingVideoNote',
  |}

  declare export type fileTypeSelfDestructingVoiceNote = {|
    /** The file is a self-destructing voice note in a private chat */
    _: 'fileTypeSelfDestructingVoiceNote',
  |}

  declare export type fileTypeSelfDestructingVoiceNote$Input = {|
    /** The file is a self-destructing voice note in a private chat */
    +_: 'fileTypeSelfDestructingVoiceNote',
  |}

  declare export type fileTypeSticker = {|
    /** The file is a sticker */
    _: 'fileTypeSticker',
  |}

  declare export type fileTypeSticker$Input = {|
    /** The file is a sticker */
    +_: 'fileTypeSticker',
  |}

  declare export type fileTypeThumbnail = {|
    /** The file is a thumbnail of another file */
    _: 'fileTypeThumbnail',
  |}

  declare export type fileTypeThumbnail$Input = {|
    /** The file is a thumbnail of another file */
    +_: 'fileTypeThumbnail',
  |}

  declare export type fileTypeUnknown = {|
    /** The file type is not yet known */
    _: 'fileTypeUnknown',
  |}

  declare export type fileTypeUnknown$Input = {|
    /** The file type is not yet known */
    +_: 'fileTypeUnknown',
  |}

  declare export type fileTypeVideo = {|
    /** The file is a video */
    _: 'fileTypeVideo',
  |}

  declare export type fileTypeVideo$Input = {|
    /** The file is a video */
    +_: 'fileTypeVideo',
  |}

  declare export type fileTypeVideoNote = {|
    /** The file is a video note */
    _: 'fileTypeVideoNote',
  |}

  declare export type fileTypeVideoNote$Input = {|
    /** The file is a video note */
    +_: 'fileTypeVideoNote',
  |}

  declare export type fileTypeVideoStory = {|
    /** The file is a video published as a story */
    _: 'fileTypeVideoStory',
  |}

  declare export type fileTypeVideoStory$Input = {|
    /** The file is a video published as a story */
    +_: 'fileTypeVideoStory',
  |}

  declare export type fileTypeVoiceNote = {|
    /** The file is a voice note */
    _: 'fileTypeVoiceNote',
  |}

  declare export type fileTypeVoiceNote$Input = {|
    /** The file is a voice note */
    +_: 'fileTypeVoiceNote',
  |}

  declare export type fileTypeWallpaper = {|
    /** The file is a wallpaper or a background pattern */
    _: 'fileTypeWallpaper',
  |}

  declare export type fileTypeWallpaper$Input = {|
    /** The file is a wallpaper or a background pattern */
    +_: 'fileTypeWallpaper',
  |}

  declare export type storageStatisticsByFileType = {|
    /** Contains the storage usage statistics for a specific file type */
    _: 'storageStatisticsByFileType',
    /** File type */
    file_type: FileType,
    /** Total size of the files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
  |}

  declare export type storageStatisticsByChat = {|
    /** Contains the storage usage statistics for a specific chat */
    _: 'storageStatisticsByChat',
    /** Chat identifier; 0 if none */
    chat_id: number,
    /** Total size of the files in the chat, in bytes */
    size: number,
    /** Total number of files in the chat */
    count: number,
    /** Statistics split by file types */
    by_file_type: Array<storageStatisticsByFileType>,
  |}

  declare export type storageStatistics = {|
    /** Contains the exact storage usage statistics split by chats and file type */
    _: 'storageStatistics',
    /** Total size of files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
    /** Statistics split by chats */
    by_chat: Array<storageStatisticsByChat>,
  |}

  declare export type storageStatisticsFast = {|
    /**
     * Contains approximate storage usage statistics, excluding files of unknown file
     * type
     */
    _: 'storageStatisticsFast',
    /** Approximate total size of files, in bytes */
    files_size: number,
    /** Approximate number of files */
    file_count: number,
    /** Size of the database */
    database_size: number,
    /** Size of the language pack database */
    language_pack_database_size: number,
    /** Size of the TDLib internal log */
    log_size: number,
  |}

  declare export type databaseStatistics = {|
    /** Contains database statistics */
    _: 'databaseStatistics',
    /** Database statistics in an unspecified human-readable format */
    statistics: string,
  |}

  declare export type networkTypeNone = {|
    /** The network is not available */
    _: 'networkTypeNone',
  |}

  declare export type networkTypeNone$Input = {|
    /** The network is not available */
    +_: 'networkTypeNone',
  |}

  declare export type networkTypeMobile = {|
    /** A mobile network */
    _: 'networkTypeMobile',
  |}

  declare export type networkTypeMobile$Input = {|
    /** A mobile network */
    +_: 'networkTypeMobile',
  |}

  declare export type networkTypeMobileRoaming = {|
    /** A mobile roaming network */
    _: 'networkTypeMobileRoaming',
  |}

  declare export type networkTypeMobileRoaming$Input = {|
    /** A mobile roaming network */
    +_: 'networkTypeMobileRoaming',
  |}

  declare export type networkTypeWiFi = {|
    /** A Wi-Fi network */
    _: 'networkTypeWiFi',
  |}

  declare export type networkTypeWiFi$Input = {|
    /** A Wi-Fi network */
    +_: 'networkTypeWiFi',
  |}

  declare export type networkTypeOther = {|
    /** A different network type (e.g., Ethernet network) */
    _: 'networkTypeOther',
  |}

  declare export type networkTypeOther$Input = {|
    /** A different network type (e.g., Ethernet network) */
    +_: 'networkTypeOther',
  |}

  declare export type networkStatisticsEntryFile = {|
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    _: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    file_type: FileType,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
  |}

  declare export type networkStatisticsEntryFile$Input = {|
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    +_: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    +file_type?: FileType$Input,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    +network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    +sent_bytes?: number,
    /** Total number of bytes received */
    +received_bytes?: number,
  |}

  declare export type networkStatisticsEntryCall = {|
    /** Contains information about the total amount of data that was used for calls */
    _: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
    /** Total call duration, in seconds */
    duration: number,
  |}

  declare export type networkStatisticsEntryCall$Input = {|
    /** Contains information about the total amount of data that was used for calls */
    +_: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    +network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    +sent_bytes?: number,
    /** Total number of bytes received */
    +received_bytes?: number,
    /** Total call duration, in seconds */
    +duration?: number,
  |}

  declare export type networkStatistics = {|
    /** A full list of available network statistic entries */
    _: 'networkStatistics',
    /** Point in time (Unix timestamp) from which the statistics are collected */
    since_date: number,
    /** Network statistics entries */
    entries: Array<NetworkStatisticsEntry>,
  |}

  declare export type autoDownloadSettings = {|
    /** Contains auto-download settings */
    _: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    is_auto_download_enabled: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    max_photo_file_size: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    max_video_file_size: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    max_other_file_size: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    video_upload_bitrate: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    preload_large_videos: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    preload_next_audio: boolean,
    /** True, if stories needs to be preloaded */
    preload_stories: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    use_less_data_for_calls: boolean,
  |}

  declare export type autoDownloadSettings$Input = {|
    /** Contains auto-download settings */
    +_: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    +is_auto_download_enabled?: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    +max_photo_file_size?: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    +max_video_file_size?: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    +max_other_file_size?: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    +video_upload_bitrate?: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    +preload_large_videos?: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    +preload_next_audio?: boolean,
    /** True, if stories needs to be preloaded */
    +preload_stories?: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    +use_less_data_for_calls?: boolean,
  |}

  declare export type autoDownloadSettingsPresets = {|
    /** Contains auto-download settings presets for the current user */
    _: 'autoDownloadSettingsPresets',
    /** Preset with lowest settings; expected to be used by default when roaming */
    low: autoDownloadSettings,
    /**
     * Preset with medium settings; expected to be used by default when using mobile
     * data
     */
    medium: autoDownloadSettings,
    /**
     * Preset with highest settings; expected to be used by default when connected
     * on Wi-Fi
     */
    high: autoDownloadSettings,
  |}

  declare export type autosaveSettingsScopePrivateChats = {|
    /** Autosave settings applied to all private chats without chat-specific settings */
    _: 'autosaveSettingsScopePrivateChats',
  |}

  declare export type autosaveSettingsScopePrivateChats$Input = {|
    /** Autosave settings applied to all private chats without chat-specific settings */
    +_: 'autosaveSettingsScopePrivateChats',
  |}

  declare export type autosaveSettingsScopeGroupChats = {|
    /**
     * Autosave settings applied to all basic group and supergroup chats without chat-specific
     * settings
     */
    _: 'autosaveSettingsScopeGroupChats',
  |}

  declare export type autosaveSettingsScopeGroupChats$Input = {|
    /**
     * Autosave settings applied to all basic group and supergroup chats without chat-specific
     * settings
     */
    +_: 'autosaveSettingsScopeGroupChats',
  |}

  declare export type autosaveSettingsScopeChannelChats = {|
    /** Autosave settings applied to all channel chats without chat-specific settings */
    _: 'autosaveSettingsScopeChannelChats',
  |}

  declare export type autosaveSettingsScopeChannelChats$Input = {|
    /** Autosave settings applied to all channel chats without chat-specific settings */
    +_: 'autosaveSettingsScopeChannelChats',
  |}

  declare export type autosaveSettingsScopeChat = {|
    /** Autosave settings applied to a chat */
    _: 'autosaveSettingsScopeChat',
    /** Chat identifier */
    chat_id: number,
  |}

  declare export type autosaveSettingsScopeChat$Input = {|
    /** Autosave settings applied to a chat */
    +_: 'autosaveSettingsScopeChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type scopeAutosaveSettings = {|
    /** Contains autosave settings for an autosave settings scope */
    _: 'scopeAutosaveSettings',
    /** True, if photo autosave is enabled */
    autosave_photos: boolean,
    /** True, if video autosave is enabled */
    autosave_videos: boolean,
    /** The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB */
    max_video_file_size: number,
  |}

  declare export type scopeAutosaveSettings$Input = {|
    /** Contains autosave settings for an autosave settings scope */
    +_: 'scopeAutosaveSettings',
    /** True, if photo autosave is enabled */
    +autosave_photos?: boolean,
    /** True, if video autosave is enabled */
    +autosave_videos?: boolean,
    /** The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB */
    +max_video_file_size?: number,
  |}

  declare export type autosaveSettingsException = {|
    /**
     * Contains autosave settings for a chat, which overrides default settings for
     * the corresponding scope
     */
    _: 'autosaveSettingsException',
    /** Chat identifier */
    chat_id: number,
    /** Autosave settings for the chat */
    settings: scopeAutosaveSettings,
  |}

  declare export type autosaveSettings = {|
    /** Describes autosave settings */
    _: 'autosaveSettings',
    /** Default autosave settings for private chats */
    private_chat_settings: scopeAutosaveSettings,
    /** Default autosave settings for basic group and supergroup chats */
    group_settings: scopeAutosaveSettings,
    /** Default autosave settings for channel chats */
    channel_settings: scopeAutosaveSettings,
    /** Autosave settings for specific chats */
    exceptions: Array<autosaveSettingsException>,
  |}

  declare export type connectionStateWaitingForNetwork = {|
    /**
     * Waiting for the network to become available. Use setNetworkType to change the
     * available network type
     */
    _: 'connectionStateWaitingForNetwork',
  |}

  declare export type connectionStateConnectingToProxy = {|
    /** Establishing a connection with a proxy server */
    _: 'connectionStateConnectingToProxy',
  |}

  declare export type connectionStateConnecting = {|
    /** Establishing a connection to the Telegram servers */
    _: 'connectionStateConnecting',
  |}

  declare export type connectionStateUpdating = {|
    /** Downloading data expected to be received while the application was offline */
    _: 'connectionStateUpdating',
  |}

  declare export type connectionStateReady = {|
    /** There is a working connection to the Telegram servers */
    _: 'connectionStateReady',
  |}

  declare export type topChatCategoryUsers$Input = {|
    /** A category containing frequently used private chats with non-bot users */
    +_: 'topChatCategoryUsers',
  |}

  declare export type topChatCategoryBots$Input = {|
    /** A category containing frequently used private chats with bot users */
    +_: 'topChatCategoryBots',
  |}

  declare export type topChatCategoryGroups$Input = {|
    /** A category containing frequently used basic groups and supergroups */
    +_: 'topChatCategoryGroups',
  |}

  declare export type topChatCategoryChannels$Input = {|
    /** A category containing frequently used channels */
    +_: 'topChatCategoryChannels',
  |}

  declare export type topChatCategoryInlineBots$Input = {|
    /**
     * A category containing frequently used chats with inline bots sorted by their
     * usage in inline mode
     */
    +_: 'topChatCategoryInlineBots',
  |}

  declare export type topChatCategoryWebAppBots$Input = {|
    /** A category containing frequently used chats with bots, which Web Apps were opened */
    +_: 'topChatCategoryWebAppBots',
  |}

  declare export type topChatCategoryCalls$Input = {|
    /** A category containing frequently used chats used for calls */
    +_: 'topChatCategoryCalls',
  |}

  declare export type topChatCategoryForwardChats$Input = {|
    /** A category containing frequently used chats used to forward messages */
    +_: 'topChatCategoryForwardChats',
  |}

  declare export type foundPosition = {|
    /** Contains 0-based match position */
    _: 'foundPosition',
    /** The position of the match */
    position: number,
  |}

  declare export type foundPositions = {|
    /** Contains 0-based positions of matched objects */
    _: 'foundPositions',
    /** Total number of matched objects */
    total_count: number,
    /** The positions of the matched objects */
    positions: Array<number>,
  |}

  declare export type tMeUrlTypeUser = {|
    /** A URL linking to a user */
    _: 'tMeUrlTypeUser',
    /** Identifier of the user */
    user_id: number,
  |}

  declare export type tMeUrlTypeSupergroup = {|
    /** A URL linking to a public supergroup or channel */
    _: 'tMeUrlTypeSupergroup',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
  |}

  declare export type tMeUrlTypeChatInvite = {|
    /** A chat invite link */
    _: 'tMeUrlTypeChatInvite',
    /** Information about the chat invite link */
    info: chatInviteLinkInfo,
  |}

  declare export type tMeUrlTypeStickerSet = {|
    /** A URL linking to a sticker set */
    _: 'tMeUrlTypeStickerSet',
    /** Identifier of the sticker set */
    sticker_set_id: string,
  |}

  declare export type tMeUrl = {|
    /** Represents a URL linking to an internal Telegram entity */
    _: 'tMeUrl',
    /** URL */
    url: string,
    /** Type of the URL */
    type: TMeUrlType,
  |}

  declare export type tMeUrls = {|
    /** Contains a list of t.me URLs */
    _: 'tMeUrls',
    /** List of URLs */
    urls: Array<tMeUrl>,
  |}

  declare export type suggestedActionEnableArchiveAndMuteNewChats = {|
    /**
     * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting
     * in archiveChatListSettings
     */
    _: 'suggestedActionEnableArchiveAndMuteNewChats',
  |}

  declare export type suggestedActionEnableArchiveAndMuteNewChats$Input = {|
    /**
     * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting
     * in archiveChatListSettings
     */
    +_: 'suggestedActionEnableArchiveAndMuteNewChats',
  |}

  declare export type suggestedActionCheckPassword = {|
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    _: 'suggestedActionCheckPassword',
  |}

  declare export type suggestedActionCheckPassword$Input = {|
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    +_: 'suggestedActionCheckPassword',
  |}

  declare export type suggestedActionCheckPhoneNumber = {|
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    _: 'suggestedActionCheckPhoneNumber',
  |}

  declare export type suggestedActionCheckPhoneNumber$Input = {|
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    +_: 'suggestedActionCheckPhoneNumber',
  |}

  declare export type suggestedActionViewChecksHint = {|
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    _: 'suggestedActionViewChecksHint',
  |}

  declare export type suggestedActionViewChecksHint$Input = {|
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    +_: 'suggestedActionViewChecksHint',
  |}

  declare export type suggestedActionConvertToBroadcastGroup = {|
    /** Suggests the user to convert specified supergroup to a broadcast group */
    _: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    supergroup_id: number,
  |}

  declare export type suggestedActionConvertToBroadcastGroup$Input = {|
    /** Suggests the user to convert specified supergroup to a broadcast group */
    +_: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    +supergroup_id?: number,
  |}

  declare export type suggestedActionSetPassword = {|
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    _: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password; if 0, then the user is advised to set the password for security
     * reasons
     */
    authorization_delay: number,
  |}

  declare export type suggestedActionSetPassword$Input = {|
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    +_: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password; if 0, then the user is advised to set the password for security
     * reasons
     */
    +authorization_delay?: number,
  |}

  declare export type suggestedActionUpgradePremium = {|
    /**
     * Suggests the user to upgrade the Premium subscription from monthly payments
     * to annual payments
     */
    _: 'suggestedActionUpgradePremium',
  |}

  declare export type suggestedActionUpgradePremium$Input = {|
    /**
     * Suggests the user to upgrade the Premium subscription from monthly payments
     * to annual payments
     */
    +_: 'suggestedActionUpgradePremium',
  |}

  declare export type suggestedActionRestorePremium = {|
    /** Suggests the user to restore a recently expired Premium subscription */
    _: 'suggestedActionRestorePremium',
  |}

  declare export type suggestedActionRestorePremium$Input = {|
    /** Suggests the user to restore a recently expired Premium subscription */
    +_: 'suggestedActionRestorePremium',
  |}

  declare export type suggestedActionSubscribeToAnnualPremium = {|
    /** Suggests the user to subscribe to the Premium subscription with annual payments */
    _: 'suggestedActionSubscribeToAnnualPremium',
  |}

  declare export type suggestedActionSubscribeToAnnualPremium$Input = {|
    /** Suggests the user to subscribe to the Premium subscription with annual payments */
    +_: 'suggestedActionSubscribeToAnnualPremium',
  |}

  declare export type suggestedActionGiftPremiumForChristmas = {|
    /** Suggests the user to gift Telegram Premium to friends for Christmas */
    _: 'suggestedActionGiftPremiumForChristmas',
  |}

  declare export type suggestedActionGiftPremiumForChristmas$Input = {|
    /** Suggests the user to gift Telegram Premium to friends for Christmas */
    +_: 'suggestedActionGiftPremiumForChristmas',
  |}

  declare export type suggestedActionSetBirthdate = {|
    /** Suggests the user to set birthdate */
    _: 'suggestedActionSetBirthdate',
  |}

  declare export type suggestedActionSetBirthdate$Input = {|
    /** Suggests the user to set birthdate */
    +_: 'suggestedActionSetBirthdate',
  |}

  declare export type suggestedActionSetProfilePhoto = {|
    /** Suggests the user to set profile photo */
    _: 'suggestedActionSetProfilePhoto',
  |}

  declare export type suggestedActionSetProfilePhoto$Input = {|
    /** Suggests the user to set profile photo */
    +_: 'suggestedActionSetProfilePhoto',
  |}

  declare export type suggestedActionExtendPremium = {|
    /** Suggests the user to extend their expiring Telegram Premium subscription */
    _: 'suggestedActionExtendPremium',
    /** A URL for managing Telegram Premium subscription */
    manage_premium_subscription_url: string,
  |}

  declare export type suggestedActionExtendPremium$Input = {|
    /** Suggests the user to extend their expiring Telegram Premium subscription */
    +_: 'suggestedActionExtendPremium',
    /** A URL for managing Telegram Premium subscription */
    +manage_premium_subscription_url?: string,
  |}

  declare export type suggestedActionExtendStarSubscriptions = {|
    /**
     * Suggests the user to extend their expiring Telegram Star subscriptions. Call
     * getStarSubscriptions with only_expiring == true to get the number of expiring
     * subscriptions and the number of required to buy Telegram Stars
     */
    _: 'suggestedActionExtendStarSubscriptions',
  |}

  declare export type suggestedActionExtendStarSubscriptions$Input = {|
    /**
     * Suggests the user to extend their expiring Telegram Star subscriptions. Call
     * getStarSubscriptions with only_expiring == true to get the number of expiring
     * subscriptions and the number of required to buy Telegram Stars
     */
    +_: 'suggestedActionExtendStarSubscriptions',
  |}

  declare export type count = {|
    /** Contains a counter */
    _: 'count',
    /** Count */
    count: number,
  |}

  declare export type text = {|
    /** Contains some text */
    _: 'text',
    /** Text */
    text: string,
  |}

  declare export type seconds = {|
    /** Contains a value representing a number of seconds */
    _: 'seconds',
    /** Number of seconds */
    seconds: number,
  |}

  declare export type fileDownloadedPrefixSize = {|
    /** Contains size of downloaded prefix of a file */
    _: 'fileDownloadedPrefixSize',
    /** The prefix size, in bytes */
    size: number,
  |}

  declare export type starCount = {|
    /** Contains a number of Telegram Stars */
    _: 'starCount',
    /** Number of Telegram Stars */
    star_count: number,
  |}

  declare export type deepLinkInfo = {|
    /** Contains information about a tg: deep link */
    _: 'deepLinkInfo',
    /** Text to be shown to the user */
    text: formattedText,
    /** True, if the user must be asked to update the application */
    need_update_application: boolean,
  |}

  declare export type textParseModeMarkdown$Input = {|
    /** The text uses Markdown-style formatting */
    +_: 'textParseModeMarkdown',
    /**
     * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 -
     * Telegram Bot API "MarkdownV2" parse mode
     */
    +version?: number,
  |}

  declare export type textParseModeHTML$Input = {|
    /**
     * The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse
     * mode
     */
    +_: 'textParseModeHTML',
  |}

  declare export type proxyTypeSocks5 = {|
    /** A SOCKS5 proxy server */
    _: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
  |}

  declare export type proxyTypeSocks5$Input = {|
    /** A SOCKS5 proxy server */
    +_: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    +username?: string,
    /** Password for logging in; may be empty */
    +password?: string,
  |}

  declare export type proxyTypeHttp = {|
    /** A HTTP transparent proxy server */
    _: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    http_only: boolean,
  |}

  declare export type proxyTypeHttp$Input = {|
    /** A HTTP transparent proxy server */
    +_: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    +username?: string,
    /** Password for logging in; may be empty */
    +password?: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    +http_only?: boolean,
  |}

  declare export type proxyTypeMtproto = {|
    /** An MTProto proxy server */
    _: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    secret: string,
  |}

  declare export type proxyTypeMtproto$Input = {|
    /** An MTProto proxy server */
    +_: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    +secret?: string,
  |}

  declare export type proxy = {|
    /** Contains information about a proxy server */
    _: 'proxy',
    /** Unique identifier of the proxy */
    id: number,
    /** Proxy server domain or IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Point in time (Unix timestamp) when the proxy was last used; 0 if never */
    last_used_date: number,
    /** True, if the proxy is enabled now */
    is_enabled: boolean,
    /** Type of the proxy */
    type: ProxyType,
  |}

  declare export type proxies = {|
    /** Represents a list of proxy servers */
    _: 'proxies',
    /** List of proxy servers */
    proxies: Array<proxy>,
  |}

  declare export type inputSticker$Input = {|
    /** A sticker to be added to a sticker set */
    +_: 'inputSticker',
    /**
     * File with the sticker; must fit in a 512x512 square. For WEBP stickers the file
     * must be in WEBP or PNG format, which will be converted to WEBP server-side.
     * See https://core.telegram.org/animated_stickers#technical-requirements for technical
     * requirements
     */
    +sticker?: InputFile$Input,
    /** Format of the sticker */
    +format?: StickerFormat$Input,
    /** String with 1-20 emoji corresponding to the sticker */
    +emojis?: string,
    /** Position where the mask is placed; pass null if not specified */
    +mask_position?: maskPosition$Input,
    /**
     * List of up to 20 keywords with total length up to 64 characters, which can be
     * used to find the sticker
     */
    +keywords?: $ReadOnlyArray<string>,
  |}

  declare export type dateRange = {|
    /** Represents a date range */
    _: 'dateRange',
    /** Point in time (Unix timestamp) at which the date range begins */
    start_date: number,
    /** Point in time (Unix timestamp) at which the date range ends */
    end_date: number,
  |}

  declare export type statisticalValue = {|
    /** A value with information about its recent changes */
    _: 'statisticalValue',
    /** The current value */
    value: number,
    /** The value for the previous day */
    previous_value: number,
    /** The growth rate of the value, as a percentage */
    growth_rate_percentage: number,
  |}

  declare export type statisticalGraphData = {|
    /** A graph data */
    _: 'statisticalGraphData',
    /** Graph data in JSON format */
    json_data: string,
    /** If non-empty, a token which can be used to receive a zoomed in graph */
    zoom_token: string,
  |}

  declare export type statisticalGraphAsync = {|
    /** The graph data to be asynchronously loaded through getStatisticalGraph */
    _: 'statisticalGraphAsync',
    /** The token to use for data loading */
    token: string,
  |}

  declare export type statisticalGraphError = {|
    /** An error message to be shown to the user instead of the graph */
    _: 'statisticalGraphError',
    /** The error message */
    error_message: string,
  |}

  declare export type chatStatisticsObjectTypeMessage = {|
    /** Describes a message sent in the chat */
    _: 'chatStatisticsObjectTypeMessage',
    /** Message identifier */
    message_id: number,
  |}

  declare export type chatStatisticsObjectTypeStory = {|
    /** Describes a story sent by the chat */
    _: 'chatStatisticsObjectTypeStory',
    /** Story identifier */
    story_id: number,
  |}

  declare export type chatStatisticsInteractionInfo = {|
    /**
     * Contains statistics about interactions with a message sent in the chat or a
     * story sent by the chat
     */
    _: 'chatStatisticsInteractionInfo',
    /** Type of the object */
    object_type: ChatStatisticsObjectType,
    /** Number of times the object was viewed */
    view_count: number,
    /** Number of times the object was forwarded */
    forward_count: number,
    /** Number of times reactions were added to the object */
    reaction_count: number,
  |}

  declare export type chatStatisticsMessageSenderInfo = {|
    /** Contains statistics about messages sent by a user */
    _: 'chatStatisticsMessageSenderInfo',
    /** User identifier */
    user_id: number,
    /** Number of sent messages */
    sent_message_count: number,
    /** Average number of characters in sent messages; 0 if unknown */
    average_character_count: number,
  |}

  declare export type chatStatisticsAdministratorActionsInfo = {|
    /** Contains statistics about administrator actions done by a user */
    _: 'chatStatisticsAdministratorActionsInfo',
    /** Administrator user identifier */
    user_id: number,
    /** Number of messages deleted by the administrator */
    deleted_message_count: number,
    /** Number of users banned by the administrator */
    banned_user_count: number,
    /** Number of users restricted by the administrator */
    restricted_user_count: number,
  |}

  declare export type chatStatisticsInviterInfo = {|
    /** Contains statistics about number of new members invited by a user */
    _: 'chatStatisticsInviterInfo',
    /** User identifier */
    user_id: number,
    /** Number of new members invited by the user */
    added_member_count: number,
  |}

  declare export type chatStatisticsSupergroup = {|
    /** A detailed statistics about a supergroup chat */
    _: 'chatStatisticsSupergroup',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Number of messages sent to the chat */
    message_count: statisticalValue,
    /** Number of users who viewed messages in the chat */
    viewer_count: statisticalValue,
    /** Number of users who sent messages to the chat */
    sender_count: statisticalValue,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing distribution of active users per language */
    language_graph: StatisticalGraph,
    /** A graph containing distribution of sent messages by content type */
    message_content_graph: StatisticalGraph,
    /** A graph containing number of different actions in the chat */
    action_graph: StatisticalGraph,
    /** A graph containing distribution of message views per hour */
    day_graph: StatisticalGraph,
    /** A graph containing distribution of message views per day of week */
    week_graph: StatisticalGraph,
    /** List of users sent most messages in the last week */
    top_senders: Array<chatStatisticsMessageSenderInfo>,
    /** List of most active administrators in the last week */
    top_administrators: Array<chatStatisticsAdministratorActionsInfo>,
    /** List of most active inviters of new members in the last week */
    top_inviters: Array<chatStatisticsInviterInfo>,
  |}

  declare export type chatStatisticsChannel = {|
    /** A detailed statistics about a channel chat */
    _: 'chatStatisticsChannel',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Mean number of times the recently sent messages were viewed */
    mean_message_view_count: statisticalValue,
    /** Mean number of times the recently sent messages were shared */
    mean_message_share_count: statisticalValue,
    /** Mean number of times reactions were added to the recently sent messages */
    mean_message_reaction_count: statisticalValue,
    /** Mean number of times the recently sent stories were viewed */
    mean_story_view_count: statisticalValue,
    /** Mean number of times the recently sent stories were shared */
    mean_story_share_count: statisticalValue,
    /** Mean number of times reactions were added to the recently sent stories */
    mean_story_reaction_count: statisticalValue,
    /** A percentage of users with enabled notifications for the chat; 0-100 */
    enabled_notifications_percentage: number,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of members muted and unmuted the chat */
    mute_graph: StatisticalGraph,
    /** A graph containing number of message views in a given hour in the last two weeks */
    view_count_by_hour_graph: StatisticalGraph,
    /** A graph containing number of message views per source */
    view_count_by_source_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing number of users viewed chat messages per language */
    language_graph: StatisticalGraph,
    /** A graph containing number of chat message views and shares */
    message_interaction_graph: StatisticalGraph,
    /** A graph containing number of reactions on messages */
    message_reaction_graph: StatisticalGraph,
    /** A graph containing number of story views and shares */
    story_interaction_graph: StatisticalGraph,
    /** A graph containing number of reactions on stories */
    story_reaction_graph: StatisticalGraph,
    /** A graph containing number of views of associated with the chat instant views */
    instant_view_interaction_graph: StatisticalGraph,
    /**
     * Detailed statistics about number of views and shares of recently sent messages
     * and stories
     */
    recent_interactions: Array<chatStatisticsInteractionInfo>,
  |}

  declare export type chatRevenueAmount = {|
    /** Contains information about revenue earned from sponsored messages in a chat */
    _: 'chatRevenueAmount',
    /** Cryptocurrency in which revenue is calculated */
    cryptocurrency: string,
    /** Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency */
    total_amount: string,
    /**
     * Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units
     * of the cryptocurrency
     */
    balance_amount: string,
    /**
     * Amount of the cryptocurrency available for withdrawal, in the smallest units
     * of the cryptocurrency
     */
    available_amount: string,
    /** True, if Telegram Stars can be withdrawn now or later */
    withdrawal_enabled: boolean,
  |}

  declare export type chatRevenueStatistics = {|
    /** A detailed statistics about revenue earned from sponsored messages in a chat */
    _: 'chatRevenueStatistics',
    /** A graph containing amount of revenue in a given hour */
    revenue_by_hour_graph: StatisticalGraph,
    /** A graph containing amount of revenue */
    revenue_graph: StatisticalGraph,
    /** Amount of earned revenue */
    revenue_amount: chatRevenueAmount,
    /**
     * Current conversion rate of the cryptocurrency in which revenue is calculated
     * to USD
     */
    usd_rate: number,
  |}

  declare export type messageStatistics = {|
    /** A detailed statistics about a message */
    _: 'messageStatistics',
    /** A graph containing number of message views and shares */
    message_interaction_graph: StatisticalGraph,
    /** A graph containing number of message reactions */
    message_reaction_graph: StatisticalGraph,
  |}

  declare export type storyStatistics = {|
    /** A detailed statistics about a story */
    _: 'storyStatistics',
    /** A graph containing number of story views and shares */
    story_interaction_graph: StatisticalGraph,
    /** A graph containing number of story reactions */
    story_reaction_graph: StatisticalGraph,
  |}

  declare export type revenueWithdrawalStatePending = {|
    /** Withdrawal is pending */
    _: 'revenueWithdrawalStatePending',
  |}

  declare export type revenueWithdrawalStateSucceeded = {|
    /** Withdrawal succeeded */
    _: 'revenueWithdrawalStateSucceeded',
    /** Point in time (Unix timestamp) when the withdrawal was completed */
    date: number,
    /** The URL where the withdrawal transaction can be viewed */
    url: string,
  |}

  declare export type revenueWithdrawalStateFailed = {|
    /** Withdrawal failed */
    _: 'revenueWithdrawalStateFailed',
  |}

  declare export type chatRevenueTransactionTypeEarnings = {|
    /** Describes earnings from sponsored messages in a chat in some time frame */
    _: 'chatRevenueTransactionTypeEarnings',
    /** Point in time (Unix timestamp) when the earnings started */
    start_date: number,
    /** Point in time (Unix timestamp) when the earnings ended */
    end_date: number,
  |}

  declare export type chatRevenueTransactionTypeWithdrawal = {|
    /** Describes a withdrawal of earnings */
    _: 'chatRevenueTransactionTypeWithdrawal',
    /** Point in time (Unix timestamp) when the earnings withdrawal started */
    withdrawal_date: number,
    /** Name of the payment provider */
    provider: string,
    /** State of the withdrawal */
    state: RevenueWithdrawalState,
  |}

  declare export type chatRevenueTransactionTypeRefund = {|
    /** Describes a refund for failed withdrawal of earnings */
    _: 'chatRevenueTransactionTypeRefund',
    /** Point in time (Unix timestamp) when the transaction was refunded */
    refund_date: number,
    /** Name of the payment provider */
    provider: string,
  |}

  declare export type chatRevenueTransaction = {|
    /** Contains a chat revenue transactions */
    _: 'chatRevenueTransaction',
    /** Cryptocurrency in which revenue is calculated */
    cryptocurrency: string,
    /** The withdrawn amount, in the smallest units of the cryptocurrency */
    cryptocurrency_amount: string,
    /** Type of the transaction */
    type: ChatRevenueTransactionType,
  |}

  declare export type chatRevenueTransactions = {|
    /** Contains a list of chat revenue transactions */
    _: 'chatRevenueTransactions',
    /** Total number of transactions */
    total_count: number,
    /** List of transactions */
    transactions: Array<chatRevenueTransaction>,
  |}

  declare export type starRevenueStatus = {|
    /** Contains information about Telegram Stars earned by a bot or a chat */
    _: 'starRevenueStatus',
    /** Total amount of Telegram Stars earned */
    total_amount: starAmount,
    /** The amount of Telegram Stars that aren't withdrawn yet */
    current_amount: starAmount,
    /** The amount of Telegram Stars that are available for withdrawal */
    available_amount: starAmount,
    /** True, if Telegram Stars can be withdrawn now or later */
    withdrawal_enabled: boolean,
    /**
     * Time left before the next withdrawal can be started, in seconds; 0 if withdrawal
     * can be started now
     */
    next_withdrawal_in: number,
  |}

  declare export type starRevenueStatistics = {|
    /** A detailed statistics about Telegram Stars earned by a bot or a chat */
    _: 'starRevenueStatistics',
    /** A graph containing amount of revenue in a given day */
    revenue_by_day_graph: StatisticalGraph,
    /** Telegram Star revenue status */
    status: starRevenueStatus,
    /** Current conversion rate of a Telegram Star to USD */
    usd_rate: number,
  |}

  declare export type point = {|
    /** A point on a Cartesian plane */
    _: 'point',
    /** The point's first coordinate */
    x: number,
    /** The point's second coordinate */
    y: number,
  |}

  declare export type vectorPathCommandLine = {|
    /** A straight line to a given point */
    _: 'vectorPathCommandLine',
    /** The end point of the straight line */
    end_point: point,
  |}

  declare export type vectorPathCommandCubicBezierCurve = {|
    /** A cubic Bézier curve to a given point */
    _: 'vectorPathCommandCubicBezierCurve',
    /** The start control point of the curve */
    start_control_point: point,
    /** The end control point of the curve */
    end_control_point: point,
    /** The end point of the curve */
    end_point: point,
  |}

  declare export type botCommandScopeDefault$Input = {|
    /** A scope covering all users */
    +_: 'botCommandScopeDefault',
  |}

  declare export type botCommandScopeAllPrivateChats$Input = {|
    /** A scope covering all private chats */
    +_: 'botCommandScopeAllPrivateChats',
  |}

  declare export type botCommandScopeAllGroupChats$Input = {|
    /** A scope covering all group and supergroup chats */
    +_: 'botCommandScopeAllGroupChats',
  |}

  declare export type botCommandScopeAllChatAdministrators$Input = {|
    /** A scope covering all group and supergroup chat administrators */
    +_: 'botCommandScopeAllChatAdministrators',
  |}

  declare export type botCommandScopeChat$Input = {|
    /** A scope covering all members of a chat */
    +_: 'botCommandScopeChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type botCommandScopeChatAdministrators$Input = {|
    /** A scope covering all administrators of a chat */
    +_: 'botCommandScopeChatAdministrators',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type botCommandScopeChatMember$Input = {|
    /** A scope covering a member of a chat */
    +_: 'botCommandScopeChatMember',
    /** Chat identifier */
    +chat_id?: number,
    /** User identifier */
    +user_id?: number,
  |}

  declare export type phoneNumberCodeTypeChange$Input = {|
    /**
     * Checks ownership of a new phone number to change the user's authentication phone
     * number; for official Android and iOS applications only
     */
    +_: 'phoneNumberCodeTypeChange',
  |}

  declare export type phoneNumberCodeTypeVerify$Input = {|
    /** Verifies ownership of a phone number to be added to the user's Telegram Passport */
    +_: 'phoneNumberCodeTypeVerify',
  |}

  declare export type phoneNumberCodeTypeConfirmOwnership$Input = {|
    /**
     * Confirms ownership of a phone number to prevent account deletion while handling
     * links of the type internalLinkTypePhoneNumberConfirmation
     */
    +_: 'phoneNumberCodeTypeConfirmOwnership',
    /** Hash value from the link */
    +hash?: string,
  |}

  declare export type updateAuthorizationState = {|
    /** The user authorization state has changed */
    _: 'updateAuthorizationState',
    /** New authorization state */
    authorization_state: AuthorizationState,
  |}

  declare export type updateNewMessage = {|
    /** A new message was received; can also be an outgoing message */
    _: 'updateNewMessage',
    /** The new message */
    message: message,
  |}

  declare export type updateMessageSendAcknowledged = {|
    /**
     * A request to send a message has reached the Telegram server. This doesn't mean
     * that the message will be sent successfully. This update is sent only if the
     * option "use_quick_ack" is set to true. This update may be sent multiple times
     * for the same message
     */
    _: 'updateMessageSendAcknowledged',
    /** The chat identifier of the sent message */
    chat_id: number,
    /** A temporary message identifier */
    message_id: number,
  |}

  declare export type updateMessageSendSucceeded = {|
    /** A message has been successfully sent */
    _: 'updateMessageSendSucceeded',
    /**
     * The sent message. Almost any field of the new message can be different from
     * the corresponding field of the original message. For example, the field scheduling_state
     * may change, making the message scheduled, or non-scheduled
     */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
  |}

  declare export type updateMessageSendFailed = {|
    /**
     * A message failed to send. Be aware that some messages being sent can be irrecoverably
     * deleted, in which case updateDeleteMessages will be received instead of this
     * update
     */
    _: 'updateMessageSendFailed',
    /** The failed to send message */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
    /** The cause of the message sending failure */
    error: error,
  |}

  declare export type updateMessageContent = {|
    /** The message content has changed */
    _: 'updateMessageContent',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New message content */
    new_content: MessageContent,
  |}

  declare export type updateMessageEdited = {|
    /**
     * A message was edited. Changes in the message content will come in a separate
     * updateMessageContent
     */
    _: 'updateMessageEdited',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was edited */
    edit_date: number,
    /** New message reply markup; may be null */
    reply_markup?: ReplyMarkup,
  |}

  declare export type updateMessageIsPinned = {|
    /** The message pinned state was changed */
    _: 'updateMessageIsPinned',
    /** Chat identifier */
    chat_id: number,
    /** The message identifier */
    message_id: number,
    /** True, if the message is pinned */
    is_pinned: boolean,
  |}

  declare export type updateMessageInteractionInfo = {|
    /** The information about interactions with a message has changed */
    _: 'updateMessageInteractionInfo',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New information about interactions with the message; may be null */
    interaction_info?: messageInteractionInfo,
  |}

  declare export type updateMessageContentOpened = {|
    /**
     * The message content was opened. Updates voice note messages to "listened", video
     * note messages to "viewed" and starts the self-destruct timer
     */
    _: 'updateMessageContentOpened',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
  |}

  declare export type updateMessageMentionRead = {|
    /** A message with an unread mention was read */
    _: 'updateMessageMentionRead',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new number of unread mention messages left in the chat */
    unread_mention_count: number,
  |}

  declare export type updateMessageUnreadReactions = {|
    /** The list of unread reactions added to a message was changed */
    _: 'updateMessageUnreadReactions',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new list of unread reactions */
    unread_reactions: Array<unreadReaction>,
    /** The new number of messages with unread reactions left in the chat */
    unread_reaction_count: number,
  |}

  declare export type updateMessageFactCheck = {|
    /** A fact-check added to a message was changed */
    _: 'updateMessageFactCheck',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new fact-check */
    fact_check: factCheck,
  |}

  declare export type updateMessageLiveLocationViewed = {|
    /**
     * A message with a live location was viewed. When the update is received, the
     * application is expected to update the live location
     */
    _: 'updateMessageLiveLocationViewed',
    /** Identifier of the chat with the live location message */
    chat_id: number,
    /** Identifier of the message with live location */
    message_id: number,
  |}

  declare export type updateVideoPublished = {|
    /**
     * An automatically scheduled message with video has been successfully sent after
     * conversion
     */
    _: 'updateVideoPublished',
    /** Identifier of the chat with the message */
    chat_id: number,
    /** Identifier of the sent message */
    message_id: number,
  |}

  declare export type updateNewChat = {|
    /**
     * A new chat has been loaded/created. This update is guaranteed to come before
     * the chat identifier is returned to the application. The chat field changes will
     * be reported through separate updates
     */
    _: 'updateNewChat',
    /** The chat */
    chat: chat,
  |}

  declare export type updateChatTitle = {|
    /** The title of a chat was changed */
    _: 'updateChatTitle',
    /** Chat identifier */
    chat_id: number,
    /** The new chat title */
    title: string,
  |}

  declare export type updateChatPhoto = {|
    /** A chat photo was changed */
    _: 'updateChatPhoto',
    /** Chat identifier */
    chat_id: number,
    /** The new chat photo; may be null */
    photo?: chatPhotoInfo,
  |}

  declare export type updateChatAccentColors = {|
    /** Chat accent colors have changed */
    _: 'updateChatAccentColors',
    /** Chat identifier */
    chat_id: number,
    /** The new chat accent color identifier */
    accent_color_id: number,
    /**
     * The new identifier of a custom emoji to be shown on the reply header and link
     * preview background; 0 if none
     */
    background_custom_emoji_id: string,
    /** The new chat profile accent color identifier; -1 if none */
    profile_accent_color_id: number,
    /**
     * The new identifier of a custom emoji to be shown on the profile background;
     * 0 if none
     */
    profile_background_custom_emoji_id: string,
  |}

  declare export type updateChatPermissions = {|
    /** Chat permissions were changed */
    _: 'updateChatPermissions',
    /** Chat identifier */
    chat_id: number,
    /** The new chat permissions */
    permissions: chatPermissions,
  |}

  declare export type updateChatLastMessage = {|
    /** The last message of a chat was changed */
    _: 'updateChatLastMessage',
    /** Chat identifier */
    chat_id: number,
    /**
     * The new last message in the chat; may be null if the last message became unknown.
     * While the last message is unknown, new messages can be added to the chat without
     * corresponding updateNewMessage update
     */
    last_message?: message,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  |}

  declare export type updateChatPosition = {|
    /**
     * The position of a chat in a chat list has changed. An updateChatLastMessage
     * or updateChatDraftMessage update might be sent instead of the update
     */
    _: 'updateChatPosition',
    /** Chat identifier */
    chat_id: number,
    /**
     * New chat position. If new order is 0, then the chat needs to be removed from
     * the list
     */
    position: chatPosition,
  |}

  declare export type updateChatAddedToList = {|
    /** A chat was added to a chat list */
    _: 'updateChatAddedToList',
    /** Chat identifier */
    chat_id: number,
    /** The chat list to which the chat was added */
    chat_list: ChatList,
  |}

  declare export type updateChatRemovedFromList = {|
    /** A chat was removed from a chat list */
    _: 'updateChatRemovedFromList',
    /** Chat identifier */
    chat_id: number,
    /** The chat list from which the chat was removed */
    chat_list: ChatList,
  |}

  declare export type updateChatReadInbox = {|
    /** Incoming messages were read or the number of unread messages has been changed */
    _: 'updateChatReadInbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** The number of unread messages left in the chat */
    unread_count: number,
  |}

  declare export type updateChatReadOutbox = {|
    /** Outgoing messages were read */
    _: 'updateChatReadOutbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of last read outgoing message */
    last_read_outbox_message_id: number,
  |}

  declare export type updateChatActionBar = {|
    /** The chat action bar was changed */
    _: 'updateChatActionBar',
    /** Chat identifier */
    chat_id: number,
    /** The new value of the action bar; may be null */
    action_bar?: ChatActionBar,
  |}

  declare export type updateChatBusinessBotManageBar = {|
    /** The bar for managing business bot was changed in a chat */
    _: 'updateChatBusinessBotManageBar',
    /** Chat identifier */
    chat_id: number,
    /** The new value of the business bot manage bar; may be null */
    business_bot_manage_bar?: businessBotManageBar,
  |}

  declare export type updateChatAvailableReactions = {|
    /** The chat available reactions were changed */
    _: 'updateChatAvailableReactions',
    /** Chat identifier */
    chat_id: number,
    /** The new reactions, available in the chat */
    available_reactions: ChatAvailableReactions,
  |}

  declare export type updateChatDraftMessage = {|
    /**
     * A chat draft has changed. Be aware that the update may come in the currently
     * opened chat but with old content of the draft. If the user has changed the content
     * of the draft, this update mustn't be applied
     */
    _: 'updateChatDraftMessage',
    /** Chat identifier */
    chat_id: number,
    /** The new draft message; may be null if none */
    draft_message?: draftMessage,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  |}

  declare export type updateChatEmojiStatus = {|
    /** Chat emoji status has changed */
    _: 'updateChatEmojiStatus',
    /** Chat identifier */
    chat_id: number,
    /** The new chat emoji status; may be null */
    emoji_status?: emojiStatus,
  |}

  declare export type updateChatMessageSender = {|
    /** The message sender that is selected to send messages in a chat has changed */
    _: 'updateChatMessageSender',
    /** Chat identifier */
    chat_id: number,
    /**
     * New value of message_sender_id; may be null if the user can't change message
     * sender
     */
    message_sender_id?: MessageSender,
  |}

  declare export type updateChatMessageAutoDeleteTime = {|
    /** The message auto-delete or self-destruct timer setting for a chat was changed */
    _: 'updateChatMessageAutoDeleteTime',
    /** Chat identifier */
    chat_id: number,
    /** New value of message_auto_delete_time */
    message_auto_delete_time: number,
  |}

  declare export type updateChatNotificationSettings = {|
    /** Notification settings for a chat were changed */
    _: 'updateChatNotificationSettings',
    /** Chat identifier */
    chat_id: number,
    /** The new notification settings */
    notification_settings: chatNotificationSettings,
  |}

  declare export type updateChatPendingJoinRequests = {|
    /** The chat pending join requests were changed */
    _: 'updateChatPendingJoinRequests',
    /** Chat identifier */
    chat_id: number,
    /** The new data about pending join requests; may be null */
    pending_join_requests?: chatJoinRequestsInfo,
  |}

  declare export type updateChatReplyMarkup = {|
    /**
     * The default chat reply markup was changed. Can occur because new messages with
     * reply markup were received or because an old reply markup was hidden by the
     * user
     */
    _: 'updateChatReplyMarkup',
    /** Chat identifier */
    chat_id: number,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
  |}

  declare export type updateChatBackground = {|
    /** The chat background was changed */
    _: 'updateChatBackground',
    /** Chat identifier */
    chat_id: number,
    /** The new chat background; may be null if background was reset to default */
    background?: chatBackground,
  |}

  declare export type updateChatTheme = {|
    /** The chat theme was changed */
    _: 'updateChatTheme',
    /** Chat identifier */
    chat_id: number,
    /** The new name of the chat theme; may be empty if theme was reset to default */
    theme_name: string,
  |}

  declare export type updateChatUnreadMentionCount = {|
    /** The chat unread_mention_count has changed */
    _: 'updateChatUnreadMentionCount',
    /** Chat identifier */
    chat_id: number,
    /** The number of unread mention messages left in the chat */
    unread_mention_count: number,
  |}

  declare export type updateChatUnreadReactionCount = {|
    /** The chat unread_reaction_count has changed */
    _: 'updateChatUnreadReactionCount',
    /** Chat identifier */
    chat_id: number,
    /** The number of messages with unread reactions left in the chat */
    unread_reaction_count: number,
  |}

  declare export type updateChatVideoChat = {|
    /** A chat video chat state has changed */
    _: 'updateChatVideoChat',
    /** Chat identifier */
    chat_id: number,
    /** New value of video_chat */
    video_chat: videoChat,
  |}

  declare export type updateChatDefaultDisableNotification = {|
    /**
     * The value of the default disable_notification parameter, used when a message
     * is sent to the chat, was changed
     */
    _: 'updateChatDefaultDisableNotification',
    /** Chat identifier */
    chat_id: number,
    /** The new default_disable_notification value */
    default_disable_notification: boolean,
  |}

  declare export type updateChatHasProtectedContent = {|
    /** A chat content was allowed or restricted for saving */
    _: 'updateChatHasProtectedContent',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_protected_content */
    has_protected_content: boolean,
  |}

  declare export type updateChatIsTranslatable = {|
    /** Translation of chat messages was enabled or disabled */
    _: 'updateChatIsTranslatable',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_translatable */
    is_translatable: boolean,
  |}

  declare export type updateChatIsMarkedAsUnread = {|
    /** A chat was marked as unread or was read */
    _: 'updateChatIsMarkedAsUnread',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_marked_as_unread */
    is_marked_as_unread: boolean,
  |}

  declare export type updateChatViewAsTopics = {|
    /** A chat default appearance has changed */
    _: 'updateChatViewAsTopics',
    /** Chat identifier */
    chat_id: number,
    /** New value of view_as_topics */
    view_as_topics: boolean,
  |}

  declare export type updateChatBlockList = {|
    /** A chat was blocked or unblocked */
    _: 'updateChatBlockList',
    /** Chat identifier */
    chat_id: number,
    /** Block list to which the chat is added; may be null if none */
    block_list?: BlockList,
  |}

  declare export type updateChatHasScheduledMessages = {|
    /** A chat's has_scheduled_messages field has changed */
    _: 'updateChatHasScheduledMessages',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_scheduled_messages */
    has_scheduled_messages: boolean,
  |}

  declare export type updateChatFolders = {|
    /** The list of chat folders or a chat folder has changed */
    _: 'updateChatFolders',
    /** The new list of chat folders */
    chat_folders: Array<chatFolderInfo>,
    /** Position of the main chat list among chat folders, 0-based */
    main_chat_list_position: number,
    /** True, if folder tags are enabled */
    are_tags_enabled: boolean,
  |}

  declare export type updateChatOnlineMemberCount = {|
    /**
     * The number of online group members has changed. This update with non-zero number
     * of online group members is sent only for currently opened chats. There is no
     * guarantee that it is sent just after the number of online users has changed
     */
    _: 'updateChatOnlineMemberCount',
    /** Identifier of the chat */
    chat_id: number,
    /** New number of online members in the chat, or 0 if unknown */
    online_member_count: number,
  |}

  declare export type updateSavedMessagesTopic = {|
    /**
     * Basic information about a Saved Messages topic has changed. This update is guaranteed
     * to come before the topic identifier is returned to the application
     */
    _: 'updateSavedMessagesTopic',
    /** New data about the topic */
    topic: savedMessagesTopic,
  |}

  declare export type updateSavedMessagesTopicCount = {|
    /** Number of Saved Messages topics has changed */
    _: 'updateSavedMessagesTopicCount',
    /** Approximate total number of Saved Messages topics */
    topic_count: number,
  |}

  declare export type updateQuickReplyShortcut = {|
    /**
     * Basic information about a quick reply shortcut has changed. This update is guaranteed
     * to come before the quick shortcut name is returned to the application
     */
    _: 'updateQuickReplyShortcut',
    /** New data about the shortcut */
    shortcut: quickReplyShortcut,
  |}

  declare export type updateQuickReplyShortcutDeleted = {|
    /** A quick reply shortcut and all its messages were deleted */
    _: 'updateQuickReplyShortcutDeleted',
    /** The identifier of the deleted shortcut */
    shortcut_id: number,
  |}

  declare export type updateQuickReplyShortcuts = {|
    /** The list of quick reply shortcuts has changed */
    _: 'updateQuickReplyShortcuts',
    /** The new list of identifiers of quick reply shortcuts */
    shortcut_ids: Array<number>,
  |}

  declare export type updateQuickReplyShortcutMessages = {|
    /** The list of quick reply shortcut messages has changed */
    _: 'updateQuickReplyShortcutMessages',
    /** The identifier of the shortcut */
    shortcut_id: number,
    /**
     * The new list of quick reply messages for the shortcut in order from the first
     * to the last sent
     */
    messages: Array<quickReplyMessage>,
  |}

  declare export type updateForumTopicInfo = {|
    /** Basic information about a topic in a forum chat was changed */
    _: 'updateForumTopicInfo',
    /** Chat identifier */
    chat_id: number,
    /** New information about the topic */
    info: forumTopicInfo,
  |}

  declare export type updateScopeNotificationSettings = {|
    /** Notification settings for some type of chats were updated */
    _: 'updateScopeNotificationSettings',
    /** Types of chats for which notification settings were updated */
    scope: NotificationSettingsScope,
    /** The new notification settings */
    notification_settings: scopeNotificationSettings,
  |}

  declare export type updateReactionNotificationSettings = {|
    /** Notification settings for reactions were updated */
    _: 'updateReactionNotificationSettings',
    /** The new notification settings */
    notification_settings: reactionNotificationSettings,
  |}

  declare export type updateNotification = {|
    /** A notification was changed */
    _: 'updateNotification',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** Changed notification */
    notification: notification,
  |}

  declare export type updateNotificationGroup = {|
    /** A list of active notifications in a notification group has changed */
    _: 'updateNotificationGroup',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** New type of the notification group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Chat identifier, which notification settings must be applied to the added notifications */
    notification_settings_chat_id: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    notification_sound_id: string,
    /**
     * Total number of unread notifications in the group, can be bigger than number
     * of active notifications
     */
    total_count: number,
    /** List of added group notifications, sorted by notification identifier */
    added_notifications: Array<notification>,
    /** Identifiers of removed group notifications, sorted by notification identifier */
    removed_notification_ids: Array<number>,
  |}

  declare export type updateActiveNotifications = {|
    /**
     * Contains active notifications that were shown on previous application launches.
     * This update is sent only if the message database is used. In that case it comes
     * once before any updateNotification and updateNotificationGroup update
     */
    _: 'updateActiveNotifications',
    /** Lists of active notification groups */
    groups: Array<notificationGroup>,
  |}

  declare export type updateHavePendingNotifications = {|
    /**
     * Describes whether there are some pending notification updates. Can be used to
     * prevent application from killing, while there are some pending notifications
     */
    _: 'updateHavePendingNotifications',
    /** True, if there are some delayed notification updates, which will be sent soon */
    have_delayed_notifications: boolean,
    /**
     * True, if there can be some yet unreceived notifications, which are being fetched
     * from the server
     */
    have_unreceived_notifications: boolean,
  |}

  declare export type updateDeleteMessages = {|
    /** Some messages were deleted */
    _: 'updateDeleteMessages',
    /** Chat identifier */
    chat_id: number,
    /** Identifiers of the deleted messages */
    message_ids: Array<number>,
    /**
     * True, if the messages are permanently deleted by a user (as opposed to just
     * becoming inaccessible)
     */
    is_permanent: boolean,
    /**
     * True, if the messages are deleted only from the cache and can possibly be retrieved
     * again in the future
     */
    from_cache: boolean,
  |}

  declare export type updateChatAction = {|
    /** A message sender activity in the chat has changed */
    _: 'updateChatAction',
    /** Chat identifier */
    chat_id: number,
    /** If not 0, the message thread identifier in which the action was performed */
    message_thread_id: number,
    /** Identifier of a message sender performing the action */
    sender_id: MessageSender,
    /** The action */
    action: ChatAction,
  |}

  declare export type updateUserStatus = {|
    /** The user went online or offline */
    _: 'updateUserStatus',
    /** User identifier */
    user_id: number,
    /** New status of the user */
    status: UserStatus,
  |}

  declare export type updateUser = {|
    /**
     * Some data of a user has changed. This update is guaranteed to come before the
     * user identifier is returned to the application
     */
    _: 'updateUser',
    /** New data about the user */
    user: user,
  |}

  declare export type updateBasicGroup = {|
    /**
     * Some data of a basic group has changed. This update is guaranteed to come before
     * the basic group identifier is returned to the application
     */
    _: 'updateBasicGroup',
    /** New data about the group */
    basic_group: basicGroup,
  |}

  declare export type updateSupergroup = {|
    /**
     * Some data of a supergroup or a channel has changed. This update is guaranteed
     * to come before the supergroup identifier is returned to the application
     */
    _: 'updateSupergroup',
    /** New data about the supergroup */
    supergroup: supergroup,
  |}

  declare export type updateSecretChat = {|
    /**
     * Some data of a secret chat has changed. This update is guaranteed to come before
     * the secret chat identifier is returned to the application
     */
    _: 'updateSecretChat',
    /** New data about the secret chat */
    secret_chat: secretChat,
  |}

  declare export type updateUserFullInfo = {|
    /** Some data in userFullInfo has been changed */
    _: 'updateUserFullInfo',
    /** User identifier */
    user_id: number,
    /** New full information about the user */
    user_full_info: userFullInfo,
  |}

  declare export type updateBasicGroupFullInfo = {|
    /** Some data in basicGroupFullInfo has been changed */
    _: 'updateBasicGroupFullInfo',
    /** Identifier of a basic group */
    basic_group_id: number,
    /** New full information about the group */
    basic_group_full_info: basicGroupFullInfo,
  |}

  declare export type updateSupergroupFullInfo = {|
    /** Some data in supergroupFullInfo has been changed */
    _: 'updateSupergroupFullInfo',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
    /** New full information about the supergroup */
    supergroup_full_info: supergroupFullInfo,
  |}

  declare export type updateServiceNotification = {|
    /**
     * A service notification from the server was received. Upon receiving this the
     * application must show a popup with the content of the notification
     */
    _: 'updateServiceNotification',
    /**
     * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel"
     * and "Log out" must be shown under notification; if user presses the second,
     * all local data must be destroyed using Destroy method
     */
    type: string,
    /** Notification content */
    content: MessageContent,
  |}

  declare export type updateFile = {|
    /** Information about a file was updated */
    _: 'updateFile',
    /** New data about the file */
    file: file,
  |}

  declare export type updateFileGenerationStart = {|
    /**
     * The file generation process needs to be started by the application. Use setFileGenerationProgress
     * and finishFileGeneration to generate the file
     */
    _: 'updateFileGenerationStart',
    /** Unique identifier for the generation process */
    generation_id: string,
    /** The original path specified by the application in inputFileGenerated */
    original_path: string,
    /**
     * The path to a file that must be created and where the new file must be generated
     * by the application. If the application has no access to the path, it can use
     * writeGeneratedFilePart to generate the file
     */
    destination_path: string,
    /**
     * If the conversion is "#url#" than original_path contains an HTTP/HTTPS URL of
     * a file that must be downloaded by the application. Otherwise, this is the conversion
     * specified by the application in inputFileGenerated
     */
    conversion: string,
  |}

  declare export type updateFileGenerationStop = {|
    /** File generation is no longer needed */
    _: 'updateFileGenerationStop',
    /** Unique identifier for the generation process */
    generation_id: string,
  |}

  declare export type updateFileDownloads = {|
    /** The state of the file download list has changed */
    _: 'updateFileDownloads',
    /** Total size of files in the file download list, in bytes */
    total_size: number,
    /** Total number of files in the file download list */
    total_count: number,
    /** Total downloaded size of files in the file download list, in bytes */
    downloaded_size: number,
  |}

  declare export type updateFileAddedToDownloads = {|
    /**
     * A file was added to the file download list. This update is sent only after file
     * download list is loaded for the first time
     */
    _: 'updateFileAddedToDownloads',
    /** The added file download */
    file_download: fileDownload,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  |}

  declare export type updateFileDownload = {|
    /**
     * A file download was changed. This update is sent only after file download list
     * is loaded for the first time
     */
    _: 'updateFileDownload',
    /** File identifier */
    file_id: number,
    /**
     * Point in time (Unix timestamp) when the file downloading was completed; 0 if
     * the file downloading isn't completed
     */
    complete_date: number,
    /** True, if downloading of the file is paused */
    is_paused: boolean,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  |}

  declare export type updateFileRemovedFromDownloads = {|
    /**
     * A file was removed from the file download list. This update is sent only after
     * file download list is loaded for the first time
     */
    _: 'updateFileRemovedFromDownloads',
    /** File identifier */
    file_id: number,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  |}

  declare export type updateApplicationVerificationRequired = {|
    /**
     * A request can't be completed unless application verification is performed; for
     * official mobile applications only. The method setApplicationVerificationToken
     * must be called once the verification is completed or failed
     */
    _: 'updateApplicationVerificationRequired',
    /** Unique identifier for the verification process */
    verification_id: number,
    /**
     * Unique base64url-encoded nonce for the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic)
     * for Android, or a unique string to compare with verify_nonce field from a push
     * notification for iOS
     */
    nonce: string,
    /** Cloud project number to pass to the Play Integrity API on Android */
    cloud_project_number: string,
  |}

  declare export type updateApplicationRecaptchaVerificationRequired = {|
    /**
     * A request can't be completed unless reCAPTCHA verification is performed; for
     * official mobile applications only. The method setApplicationVerificationToken
     * must be called once the verification is completed or failed
     */
    _: 'updateApplicationRecaptchaVerificationRequired',
    /** Unique identifier for the verification process */
    verification_id: number,
    /** The action for the check */
    action: string,
    /** Identifier of the reCAPTCHA key */
    recaptcha_key_id: string,
  |}

  declare export type updateCall = {|
    /** New call was created or information about a call was updated */
    _: 'updateCall',
    /** New data about a call */
    call: call,
  |}

  declare export type updateGroupCall = {|
    /** Information about a group call was updated */
    _: 'updateGroupCall',
    /** New data about a group call */
    group_call: groupCall,
  |}

  declare export type updateGroupCallParticipant = {|
    /**
     * Information about a group call participant was changed. The updates are sent
     * only after the group call is received through getGroupCall and only if the call
     * is joined or being joined
     */
    _: 'updateGroupCallParticipant',
    /** Identifier of group call */
    group_call_id: number,
    /** New data about a participant */
    participant: groupCallParticipant,
  |}

  declare export type updateNewCallSignalingData = {|
    /** New call signaling data arrived */
    _: 'updateNewCallSignalingData',
    /** The call identifier */
    call_id: number,
    /** The data */
    data: string /* base64 */,
  |}

  declare export type updateUserPrivacySettingRules = {|
    /** Some privacy setting rules have been changed */
    _: 'updateUserPrivacySettingRules',
    /** The privacy setting */
    setting: UserPrivacySetting,
    /** New privacy rules */
    rules: userPrivacySettingRules,
  |}

  declare export type updateUnreadMessageCount = {|
    /**
     * Number of unread messages in a chat list has changed. This update is sent only
     * if the message database is used
     */
    _: 'updateUnreadMessageCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Total number of unread messages */
    unread_count: number,
    /** Total number of unread messages in unmuted chats */
    unread_unmuted_count: number,
  |}

  declare export type updateUnreadChatCount = {|
    /**
     * Number of unread chats, i.e. with unread messages or marked as unread, has changed.
     * This update is sent only if the message database is used
     */
    _: 'updateUnreadChatCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Approximate total number of chats in the chat list */
    total_count: number,
    /** Total number of unread chats */
    unread_count: number,
    /** Total number of unread unmuted chats */
    unread_unmuted_count: number,
    /** Total number of chats marked as unread */
    marked_as_unread_count: number,
    /** Total number of unmuted chats marked as unread */
    marked_as_unread_unmuted_count: number,
  |}

  declare export type updateStory = {|
    /** A story was changed */
    _: 'updateStory',
    /** The new information about the story */
    story: story,
  |}

  declare export type updateStoryDeleted = {|
    /** A story became inaccessible */
    _: 'updateStoryDeleted',
    /** Identifier of the chat that posted the story */
    story_sender_chat_id: number,
    /** Story identifier */
    story_id: number,
  |}

  declare export type updateStorySendSucceeded = {|
    /** A story has been successfully sent */
    _: 'updateStorySendSucceeded',
    /** The sent story */
    story: story,
    /** The previous temporary story identifier */
    old_story_id: number,
  |}

  declare export type updateStorySendFailed = {|
    /**
     * A story failed to send. If the story sending is canceled, then updateStoryDeleted
     * will be received instead of this update
     */
    _: 'updateStorySendFailed',
    /** The failed to send story */
    story: story,
    /** The cause of the story sending failure */
    error: error,
    /** Type of the error; may be null if unknown */
    error_type?: CanSendStoryResult,
  |}

  declare export type updateChatActiveStories = {|
    /** The list of active stories posted by a specific chat has changed */
    _: 'updateChatActiveStories',
    /** The new list of active stories */
    active_stories: chatActiveStories,
  |}

  declare export type updateStoryListChatCount = {|
    /** Number of chats in a story list has changed */
    _: 'updateStoryListChatCount',
    /** The story list */
    story_list: StoryList,
    /** Approximate total number of chats with active stories in the list */
    chat_count: number,
  |}

  declare export type updateStoryStealthMode = {|
    /** Story stealth mode settings have changed */
    _: 'updateStoryStealthMode',
    /** Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled */
    active_until_date: number,
    /**
     * Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if
     * there is no active cooldown
     */
    cooldown_until_date: number,
  |}

  declare export type updateOption = {|
    /** An option changed its value */
    _: 'updateOption',
    /** The option name */
    name: string,
    /** The new option value */
    value: OptionValue,
  |}

  declare export type updateStickerSet = {|
    /** A sticker set has changed */
    _: 'updateStickerSet',
    /** The sticker set */
    sticker_set: stickerSet,
  |}

  declare export type updateInstalledStickerSets = {|
    /** The list of installed sticker sets was updated */
    _: 'updateInstalledStickerSets',
    /** Type of the affected stickers */
    sticker_type: StickerType,
    /** The new list of installed ordinary sticker sets */
    sticker_set_ids: Array<string>,
  |}

  declare export type updateTrendingStickerSets = {|
    /** The list of trending sticker sets was updated or some of them were viewed */
    _: 'updateTrendingStickerSets',
    /** Type of the affected stickers */
    sticker_type: StickerType,
    /**
     * The prefix of the list of trending sticker sets with the newest trending sticker
     * sets
     */
    sticker_sets: trendingStickerSets,
  |}

  declare export type updateRecentStickers = {|
    /** The list of recently used stickers was updated */
    _: 'updateRecentStickers',
    /**
     * True, if the list of stickers attached to photo or video files was updated;
     * otherwise, the list of sent stickers is updated
     */
    is_attached: boolean,
    /** The new list of file identifiers of recently used stickers */
    sticker_ids: Array<number>,
  |}

  declare export type updateFavoriteStickers = {|
    /** The list of favorite stickers was updated */
    _: 'updateFavoriteStickers',
    /** The new list of file identifiers of favorite stickers */
    sticker_ids: Array<number>,
  |}

  declare export type updateSavedAnimations = {|
    /** The list of saved animations was updated */
    _: 'updateSavedAnimations',
    /** The new list of file identifiers of saved animations */
    animation_ids: Array<number>,
  |}

  declare export type updateSavedNotificationSounds = {|
    /**
     * The list of saved notification sounds was updated. This update may not be sent
     * until information about a notification sound was requested for the first time
     */
    _: 'updateSavedNotificationSounds',
    /** The new list of identifiers of saved notification sounds */
    notification_sound_ids: Array<string>,
  |}

  declare export type updateDefaultBackground = {|
    /** The default background has changed */
    _: 'updateDefaultBackground',
    /** True, if default background for dark theme has changed */
    for_dark_theme: boolean,
    /** The new default background; may be null */
    background?: background,
  |}

  declare export type updateChatThemes = {|
    /** The list of available chat themes has changed */
    _: 'updateChatThemes',
    /** The new list of chat themes */
    chat_themes: Array<chatTheme>,
  |}

  declare export type updateAccentColors = {|
    /** The list of supported accent colors has changed */
    _: 'updateAccentColors',
    /**
     * Information about supported colors; colors with identifiers 0 (red), 1 (orange),
     * 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported
     * and aren't included in the list. The exact colors for the accent colors with
     * identifiers 0-6 must be taken from the app theme
     */
    colors: Array<accentColor>,
    /**
     * The list of accent color identifiers, which can be set through setAccentColor
     * and setChatAccentColor. The colors must be shown in the specified order
     */
    available_accent_color_ids: Array<number>,
  |}

  declare export type updateProfileAccentColors = {|
    /** The list of supported accent colors for user profiles has changed */
    _: 'updateProfileAccentColors',
    /** Information about supported colors */
    colors: Array<profileAccentColor>,
    /**
     * The list of accent color identifiers, which can be set through setProfileAccentColor
     * and setChatProfileAccentColor. The colors must be shown in the specified order
     */
    available_accent_color_ids: Array<number>,
  |}

  declare export type updateLanguagePackStrings = {|
    /** Some language pack strings have been updated */
    _: 'updateLanguagePackStrings',
    /** Localization target to which the language pack belongs */
    localization_target: string,
    /** Identifier of the updated language pack */
    language_pack_id: string,
    /** List of changed language pack strings; empty if all strings have changed */
    strings: Array<languagePackString>,
  |}

  declare export type updateConnectionState = {|
    /**
     * The connection state has changed. This update must be used only to show a human-readable
     * description of the connection state
     */
    _: 'updateConnectionState',
    /** The new connection state */
    state: ConnectionState,
  |}

  declare export type updateTermsOfService = {|
    /**
     * New terms of service must be accepted by the user. If the terms of service are
     * declined, then the deleteAccount method must be called with the reason "Decline
     * ToS update"
     */
    _: 'updateTermsOfService',
    /** Identifier of the terms of service */
    terms_of_service_id: string,
    /** The new terms of service */
    terms_of_service: termsOfService,
  |}

  declare export type updateUnconfirmedSession = {|
    /** The first unconfirmed session has changed */
    _: 'updateUnconfirmedSession',
    /** The unconfirmed session; may be null if none */
    session?: unconfirmedSession,
  |}

  declare export type updateAttachmentMenuBots = {|
    /** The list of bots added to attachment or side menu has changed */
    _: 'updateAttachmentMenuBots',
    /** The new list of bots. The bots must not be shown on scheduled messages screen */
    bots: Array<attachmentMenuBot>,
  |}

  declare export type updateWebAppMessageSent = {|
    /** A message was sent by an opened Web App, so the Web App needs to be closed */
    _: 'updateWebAppMessageSent',
    /** Identifier of Web App launch */
    web_app_launch_id: string,
  |}

  declare export type updateActiveEmojiReactions = {|
    /** The list of active emoji reactions has changed */
    _: 'updateActiveEmojiReactions',
    /** The new list of active emoji reactions */
    emojis: Array<string>,
  |}

  declare export type updateAvailableMessageEffects = {|
    /** The list of available message effects has changed */
    _: 'updateAvailableMessageEffects',
    /** The new list of available message effects from emoji reactions */
    reaction_effect_ids: Array<string>,
    /** The new list of available message effects from Premium stickers */
    sticker_effect_ids: Array<string>,
  |}

  declare export type updateDefaultReactionType = {|
    /** The type of default reaction has changed */
    _: 'updateDefaultReactionType',
    /** The new type of the default reaction */
    reaction_type: ReactionType,
  |}

  declare export type updateDefaultPaidReactionType = {|
    /** The type of default paid reaction has changed */
    _: 'updateDefaultPaidReactionType',
    /** The new type of the default paid reaction */
    type: PaidReactionType,
  |}

  declare export type updateSavedMessagesTags = {|
    /** Tags used in Saved Messages or a Saved Messages topic have changed */
    _: 'updateSavedMessagesTags',
    /**
     * Identifier of Saved Messages topic which tags were changed; 0 if tags for the
     * whole chat has changed
     */
    saved_messages_topic_id: number,
    /** The new tags */
    tags: savedMessagesTags,
  |}

  declare export type updateActiveLiveLocationMessages = {|
    /**
     * The list of messages with active live location that need to be updated by the
     * application has changed. The list is persistent across application restarts
     * only if the message database is used
     */
    _: 'updateActiveLiveLocationMessages',
    /** The list of messages with active live locations */
    messages: Array<message>,
  |}

  declare export type updateOwnedStarCount = {|
    /** The number of Telegram Stars owned by the current user has changed */
    _: 'updateOwnedStarCount',
    /** The new amount of owned Telegram Stars */
    star_amount: starAmount,
  |}

  declare export type updateChatRevenueAmount = {|
    /**
     * The revenue earned from sponsored messages in a chat has changed. If chat revenue
     * screen is opened, then getChatRevenueTransactions may be called to fetch new
     * transactions
     */
    _: 'updateChatRevenueAmount',
    /** Identifier of the chat */
    chat_id: number,
    /** New amount of earned revenue */
    revenue_amount: chatRevenueAmount,
  |}

  declare export type updateStarRevenueStatus = {|
    /**
     * The Telegram Star revenue earned by a bot or a chat has changed. If Telegram
     * Star transaction screen of the chat is opened, then getStarTransactions may
     * be called to fetch new transactions
     */
    _: 'updateStarRevenueStatus',
    /** Identifier of the owner of the Telegram Stars */
    owner_id: MessageSender,
    /** New Telegram Star revenue status */
    status: starRevenueStatus,
  |}

  declare export type updateSpeechRecognitionTrial = {|
    /**
     * The parameters of speech recognition without Telegram Premium subscription has
     * changed
     */
    _: 'updateSpeechRecognitionTrial',
    /**
     * The maximum allowed duration of media for speech recognition without Telegram
     * Premium subscription, in seconds
     */
    max_media_duration: number,
    /** The total number of allowed speech recognitions per week; 0 if none */
    weekly_count: number,
    /** Number of left speech recognition attempts this week */
    left_count: number,
    /**
     * Point in time (Unix timestamp) when the weekly number of tries will reset; 0
     * if unknown
     */
    next_reset_date: number,
  |}

  declare export type updateDiceEmojis = {|
    /** The list of supported dice emojis has changed */
    _: 'updateDiceEmojis',
    /** The new list of supported dice emojis */
    emojis: Array<string>,
  |}

  declare export type updateAnimatedEmojiMessageClicked = {|
    /**
     * Some animated emoji message was clicked and a big animated sticker must be played
     * if the message is visible on the screen. chatActionWatchingAnimations with the
     * text of the message needs to be sent if the sticker is played
     */
    _: 'updateAnimatedEmojiMessageClicked',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The animated sticker to be played */
    sticker: sticker,
  |}

  declare export type updateAnimationSearchParameters = {|
    /**
     * The parameters of animation search through getOption("animation_search_bot_username")
     * bot has changed
     */
    _: 'updateAnimationSearchParameters',
    /** Name of the animation search provider */
    provider: string,
    /** The new list of emojis suggested for searching */
    emojis: Array<string>,
  |}

  declare export type updateSuggestedActions = {|
    /** The list of suggested to the user actions has changed */
    _: 'updateSuggestedActions',
    /** Added suggested actions */
    added_actions: Array<SuggestedAction>,
    /** Removed suggested actions */
    removed_actions: Array<SuggestedAction>,
  |}

  declare export type updateSpeedLimitNotification = {|
    /**
     * Download or upload file speed for the user was limited, but it can be restored
     * by subscription to Telegram Premium. The notification can be postponed until
     * a being downloaded or uploaded file is visible to the user. Use getOption("premium_download_speedup")
     * or getOption("premium_upload_speedup") to get expected speedup after subscription
     * to Telegram Premium
     */
    _: 'updateSpeedLimitNotification',
    /** True, if upload speed was limited; false, if download speed was limited */
    is_upload: boolean,
  |}

  declare export type updateContactCloseBirthdays = {|
    /**
     * The list of contacts that had birthdays recently or will have birthday soon
     * has changed
     */
    _: 'updateContactCloseBirthdays',
    /** List of contact users with close birthday */
    close_birthday_users: Array<closeBirthdayUser>,
  |}

  declare export type updateAutosaveSettings = {|
    /** Autosave settings for some type of chats were updated */
    _: 'updateAutosaveSettings',
    /** Type of chats for which autosave settings were updated */
    scope: AutosaveSettingsScope,
    /** The new autosave settings; may be null if the settings are reset to default */
    settings?: scopeAutosaveSettings,
  |}

  declare export type updateBusinessConnection = {|
    /** A business connection has changed; for bots only */
    _: 'updateBusinessConnection',
    /** New data about the connection */
    connection: businessConnection,
  |}

  declare export type updateNewBusinessMessage = {|
    /** A new message was added to a business account; for bots only */
    _: 'updateNewBusinessMessage',
    /** Unique identifier of the business connection */
    connection_id: string,
    /** The new message */
    message: businessMessage,
  |}

  declare export type updateBusinessMessageEdited = {|
    /** A message in a business account was edited; for bots only */
    _: 'updateBusinessMessageEdited',
    /** Unique identifier of the business connection */
    connection_id: string,
    /** The edited message */
    message: businessMessage,
  |}

  declare export type updateBusinessMessagesDeleted = {|
    /** Messages in a business account were deleted; for bots only */
    _: 'updateBusinessMessagesDeleted',
    /** Unique identifier of the business connection */
    connection_id: string,
    /** Identifier of a chat in the business account in which messages were deleted */
    chat_id: number,
    /** Unique message identifiers of the deleted messages */
    message_ids: Array<number>,
  |}

  declare export type updateNewInlineQuery = {|
    /** A new incoming inline query; for bots only */
    _: 'updateNewInlineQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** The type of the chat from which the query originated; may be null if unknown */
    chat_type?: ChatType,
    /** Text of the query */
    query: string,
    /** Offset of the first entry to return */
    offset: string,
  |}

  declare export type updateNewChosenInlineResult = {|
    /** The user has chosen a result of an inline query; for bots only */
    _: 'updateNewChosenInlineResult',
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** Text of the query */
    query: string,
    /** Identifier of the chosen result */
    result_id: string,
    /** Identifier of the sent inline message, if known */
    inline_message_id: string,
  |}

  declare export type updateNewCallbackQuery = {|
    /** A new incoming callback query; for bots only */
    _: 'updateNewCallbackQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the chat where the query was sent */
    chat_id: number,
    /** Identifier of the message from which the query originated */
    message_id: number,
    /** Identifier that uniquely corresponds to the chat to which the message was sent */
    chat_instance: string,
    /** Query payload */
    payload: CallbackQueryPayload,
  |}

  declare export type updateNewInlineCallbackQuery = {|
    /** A new incoming callback query from a message sent via a bot; for bots only */
    _: 'updateNewInlineCallbackQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the inline message from which the query originated */
    inline_message_id: string,
    /** An identifier uniquely corresponding to the chat a message was sent to */
    chat_instance: string,
    /** Query payload */
    payload: CallbackQueryPayload,
  |}

  declare export type updateNewBusinessCallbackQuery = {|
    /** A new incoming callback query from a business message; for bots only */
    _: 'updateNewBusinessCallbackQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Unique identifier of the business connection */
    connection_id: string,
    /** The message from the business account from which the query originated */
    message: businessMessage,
    /** An identifier uniquely corresponding to the chat a message was sent to */
    chat_instance: string,
    /** Query payload */
    payload: CallbackQueryPayload,
  |}

  declare export type updateNewShippingQuery = {|
    /**
     * A new incoming shipping query; for bots only. Only for invoices with flexible
     * price
     */
    _: 'updateNewShippingQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Invoice payload */
    invoice_payload: string,
    /** User shipping address */
    shipping_address: address,
  |}

  declare export type updateNewPreCheckoutQuery = {|
    /**
     * A new incoming pre-checkout query; for bots only. Contains full information
     * about a checkout
     */
    _: 'updateNewPreCheckoutQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Currency for the product price */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /** Identifier of a shipping option chosen by the user; may be empty if not applicable */
    shipping_option_id: string,
    /** Information about the order; may be null */
    order_info?: orderInfo,
  |}

  declare export type updateNewCustomEvent = {|
    /** A new incoming event; for bots only */
    _: 'updateNewCustomEvent',
    /** A JSON-serialized event */
    event: string,
  |}

  declare export type updateNewCustomQuery = {|
    /** A new incoming query; for bots only */
    _: 'updateNewCustomQuery',
    /** The query identifier */
    id: string,
    /** JSON-serialized query data */
    data: string,
    /** Query timeout */
    timeout: number,
  |}

  declare export type updatePoll = {|
    /** A poll was updated; for bots only */
    _: 'updatePoll',
    /** New data about the poll */
    poll: poll,
  |}

  declare export type updatePollAnswer = {|
    /** A user changed the answer to a poll; for bots only */
    _: 'updatePollAnswer',
    /** Unique poll identifier */
    poll_id: string,
    /** Identifier of the message sender that changed the answer to the poll */
    voter_id: MessageSender,
    /** 0-based identifiers of answer options, chosen by the user */
    option_ids: Array<number>,
  |}

  declare export type updateChatMember = {|
    /** User rights changed in a chat; for bots only */
    _: 'updateChatMember',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the user, changing the rights */
    actor_user_id: number,
    /** Point in time (Unix timestamp) when the user rights were changed */
    date: number,
    /** If user has joined the chat using an invite link, the invite link; may be null */
    invite_link?: chatInviteLink,
    /**
     * True, if the user has joined the chat after sending a join request and being
     * approved by an administrator
     */
    via_join_request: boolean,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
    /** Previous chat member */
    old_chat_member: chatMember,
    /** New chat member */
    new_chat_member: chatMember,
  |}

  declare export type updateNewChatJoinRequest = {|
    /** A user sent a join request to a chat; for bots only */
    _: 'updateNewChatJoinRequest',
    /** Chat identifier */
    chat_id: number,
    /** Join request */
    request: chatJoinRequest,
    /** Chat identifier of the private chat with the user */
    user_chat_id: number,
    /** The invite link, which was used to send join request; may be null */
    invite_link?: chatInviteLink,
  |}

  declare export type updateChatBoost = {|
    /** A chat boost has changed; for bots only */
    _: 'updateChatBoost',
    /** Chat identifier */
    chat_id: number,
    /** New information about the boost */
    boost: chatBoost,
  |}

  declare export type updateMessageReaction = {|
    /** User changed its reactions on a message with public reactions; for bots only */
    _: 'updateMessageReaction',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Identifier of the user or chat that changed reactions */
    actor_id: MessageSender,
    /** Point in time (Unix timestamp) when the reactions were changed */
    date: number,
    /** Old list of chosen reactions */
    old_reaction_types: Array<ReactionType>,
    /** New list of chosen reactions */
    new_reaction_types: Array<ReactionType>,
  |}

  declare export type updateMessageReactions = {|
    /**
     * Reactions added to a message with anonymous reactions have changed; for bots
     * only
     */
    _: 'updateMessageReactions',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the reactions were changed */
    date: number,
    /** The list of reactions added to the message */
    reactions: Array<messageReaction>,
  |}

  declare export type updatePaidMediaPurchased = {|
    /** Paid media were purchased by a user; for bots only */
    _: 'updatePaidMediaPurchased',
    /** User identifier */
    user_id: number,
    /** Bot-specified payload for the paid media */
    payload: string,
  |}

  declare export type updates = {|
    /** Contains a list of updates */
    _: 'updates',
    /** List of updates */
    updates: Array<Update>,
  |}

  declare export type logStreamDefault = {|
    /** The log is written to stderr or an OS specific log */
    _: 'logStreamDefault',
  |}

  declare export type logStreamDefault$Input = {|
    /** The log is written to stderr or an OS specific log */
    +_: 'logStreamDefault',
  |}

  declare export type logStreamFile = {|
    /** The log is written to a file */
    _: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    path: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    max_file_size: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    redirect_stderr: boolean,
  |}

  declare export type logStreamFile$Input = {|
    /** The log is written to a file */
    +_: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    +path?: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    +max_file_size?: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    +redirect_stderr?: boolean,
  |}

  declare export type logStreamEmpty = {|
    /** The log is written nowhere */
    _: 'logStreamEmpty',
  |}

  declare export type logStreamEmpty$Input = {|
    /** The log is written nowhere */
    +_: 'logStreamEmpty',
  |}

  declare export type logVerbosityLevel = {|
    /** Contains a TDLib internal log verbosity level */
    _: 'logVerbosityLevel',
    /** Log verbosity level */
    verbosity_level: number,
  |}

  declare export type logTags = {|
    /** Contains a list of available TDLib internal log tags */
    _: 'logTags',
    /** List of log tags */
    tags: Array<string>,
  |}

  declare export type userSupportInfo = {|
    /** Contains custom information about the user */
    _: 'userSupportInfo',
    /** Information message */
    message: formattedText,
    /** Information author */
    author: string,
    /** Information change date */
    date: number,
  |}

  declare export type testInt = {|
    /** A simple object containing a number; for testing only */
    _: 'testInt',
    /** Number */
    value: number,
  |}

  declare export type testInt$Input = {|
    /** A simple object containing a number; for testing only */
    +_: 'testInt',
    /** Number */
    +value?: number,
  |}

  declare export type testString = {|
    /** A simple object containing a string; for testing only */
    _: 'testString',
    /** String */
    value: string,
  |}

  declare export type testString$Input = {|
    /** A simple object containing a string; for testing only */
    +_: 'testString',
    /** String */
    +value?: string,
  |}

  declare export type testBytes = {|
    /** A simple object containing a sequence of bytes; for testing only */
    _: 'testBytes',
    /** Bytes */
    value: string /* base64 */,
  |}

  declare export type testVectorInt = {|
    /** A simple object containing a vector of numbers; for testing only */
    _: 'testVectorInt',
    /** Vector of numbers */
    value: Array<number>,
  |}

  declare export type testVectorIntObject = {|
    /**
     * A simple object containing a vector of objects that hold a number; for testing
     * only
     */
    _: 'testVectorIntObject',
    /** Vector of objects */
    value: Array<testInt>,
  |}

  declare export type testVectorString = {|
    /** A simple object containing a vector of strings; for testing only */
    _: 'testVectorString',
    /** Vector of strings */
    value: Array<string>,
  |}

  declare export type testVectorStringObject = {|
    /**
     * A simple object containing a vector of objects that hold a string; for testing
     * only
     */
    _: 'testVectorStringObject',
    /** Vector of objects */
    value: Array<testString>,
  |}

  declare export type getAuthorizationState = {|
    /**
     * Returns the current authorization state; this is an offline request. For informational
     * purposes only. Use updateAuthorizationState instead to maintain the current
     * authorization state. Can be called before initialization
     */
    +_: 'getAuthorizationState',
  |}

  declare export type setTdlibParameters = {|
    /**
     * Sets the parameters for TDLib initialization. Works only when the current authorization
     * state is authorizationStateWaitTdlibParameters
     */
    +_: 'setTdlibParameters',
    /** Pass true to use Telegram test environment instead of the production environment */
    +use_test_dc?: boolean,
    /**
     * The path to the directory for the persistent database; if empty, the current
     * working directory will be used
     */
    +database_directory?: string,
    /**
     * The path to the directory for storing files; if empty, database_directory will
     * be used
     */
    +files_directory?: string,
    /**
     * Encryption key for the database. If the encryption key is invalid, then an error
     * with code 401 will be returned
     */
    +database_encryption_key?: string /* base64 */,
    /**
     * Pass true to keep information about downloaded and uploaded files between application
     * restarts
     */
    +use_file_database?: boolean,
    /**
     * Pass true to keep cache of users, basic groups, supergroups, channels and secret
     * chats between restarts. Implies use_file_database
     */
    +use_chat_info_database?: boolean,
    /** Pass true to keep cache of chats and messages between restarts. Implies use_chat_info_database */
    +use_message_database?: boolean,
    /** Pass true to enable support for secret chats */
    +use_secret_chats?: boolean,
    /** Application identifier for Telegram API access, which can be obtained at https://my.telegram.org */
    +api_id?: number,
    /**
     * Application identifier hash for Telegram API access, which can be obtained at
     * https://my.telegram.org
     */
    +api_hash?: string,
    /** IETF language tag of the user's operating system language; must be non-empty */
    +system_language_code?: string,
    /** Model of the device the application is being run on; must be non-empty */
    +device_model?: string,
    /**
     * Version of the operating system the application is being run on. If empty, the
     * version is automatically detected by TDLib
     */
    +system_version?: string,
    /** Application version; must be non-empty */
    +application_version?: string,
  |}

  declare export type setAuthenticationPhoneNumber = {|
    /**
     * Sets the phone number of the user and sends an authentication code to the user.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode,
     * authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
     */
    +_: 'setAuthenticationPhoneNumber',
    /** The phone number of the user, in international format */
    +phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    +settings?: phoneNumberAuthenticationSettings$Input,
  |}

  declare export type setAuthenticationEmailAddress = {|
    /**
     * Sets the email address of the user and sends an authentication code to the email
     * address. Works only when the current authorization state is authorizationStateWaitEmailAddress
     */
    +_: 'setAuthenticationEmailAddress',
    /** The email address of the user */
    +email_address?: string,
  |}

  declare export type resendAuthenticationCode = {|
    /**
     * Resends an authentication code to the user. Works only when the current authorization
     * state is authorizationStateWaitCode, the next_code_type of the result is not
     * null and the server-specified timeout has passed, or when the current authorization
     * state is authorizationStateWaitEmailCode
     */
    +_: 'resendAuthenticationCode',
    /** Reason of code resending; pass null if unknown */
    +reason?: ResendCodeReason$Input,
  |}

  declare export type checkAuthenticationEmailCode = {|
    /**
     * Checks the authentication of an email address. Works only when the current authorization
     * state is authorizationStateWaitEmailCode
     */
    +_: 'checkAuthenticationEmailCode',
    /** Email address authentication to check */
    +code?: EmailAddressAuthentication$Input,
  |}

  declare export type checkAuthenticationCode = {|
    /**
     * Checks the authentication code. Works only when the current authorization state
     * is authorizationStateWaitCode
     */
    +_: 'checkAuthenticationCode',
    /** Authentication code to check */
    +code?: string,
  |}

  declare export type requestQrCodeAuthentication = {|
    /**
     * Requests QR code authentication by scanning a QR code on another logged in device.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode,
     * authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
     */
    +_: 'requestQrCodeAuthentication',
    /** List of user identifiers of other users currently using the application */
    +other_user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type registerUser = {|
    /**
     * Finishes user registration. Works only when the current authorization state
     * is authorizationStateWaitRegistration
     */
    +_: 'registerUser',
    /** The first name of the user; 1-64 characters */
    +first_name?: string,
    /** The last name of the user; 0-64 characters */
    +last_name?: string,
    /**
     * Pass true to disable notification about the current user joining Telegram for
     * other users that added them to contact list
     */
    +disable_notification?: boolean,
  |}

  declare export type resetAuthenticationEmailAddress = {|
    /**
     * Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS"
     * if reset is still pending. Works only when the current authorization state is
     * authorizationStateWaitEmailCode and authorization_state.can_reset_email_address
     * == true
     */
    +_: 'resetAuthenticationEmailAddress',
  |}

  declare export type checkAuthenticationPassword = {|
    /**
     * Checks the 2-step verification password for correctness. Works only when the
     * current authorization state is authorizationStateWaitPassword
     */
    +_: 'checkAuthenticationPassword',
    /** The 2-step verification password to check */
    +password?: string,
  |}

  declare export type requestAuthenticationPasswordRecovery = {|
    /**
     * Requests to send a 2-step verification password recovery code to an email address
     * that was previously set up. Works only when the current authorization state
     * is authorizationStateWaitPassword
     */
    +_: 'requestAuthenticationPasswordRecovery',
  |}

  declare export type checkAuthenticationPasswordRecoveryCode = {|
    /**
     * Checks whether a 2-step verification password recovery code sent to an email
     * address is valid. Works only when the current authorization state is authorizationStateWaitPassword
     */
    +_: 'checkAuthenticationPasswordRecoveryCode',
    /** Recovery code to check */
    +recovery_code?: string,
  |}

  declare export type recoverAuthenticationPassword = {|
    /**
     * Recovers the 2-step verification password with a password recovery code sent
     * to an email address that was previously set up. Works only when the current
     * authorization state is authorizationStateWaitPassword
     */
    +_: 'recoverAuthenticationPassword',
    /** Recovery code to check */
    +recovery_code?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    +new_password?: string,
    /** New password hint; may be empty */
    +new_hint?: string,
  |}

  declare export type sendAuthenticationFirebaseSms = {|
    /**
     * Sends Firebase Authentication SMS to the phone number of the user. Works only
     * when the current authorization state is authorizationStateWaitCode and the server
     * returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
     */
    +_: 'sendAuthenticationFirebaseSms',
    /**
     * Play Integrity API or SafetyNet Attestation API token for the Android application,
     * or secret from push notification for the iOS application
     */
    +token?: string,
  |}

  declare export type reportAuthenticationCodeMissing = {|
    /**
     * Reports that authentication code wasn't delivered via SMS; for official mobile
     * applications only. Works only when the current authorization state is authorizationStateWaitCode
     */
    +_: 'reportAuthenticationCodeMissing',
    /** Current mobile network code */
    +mobile_network_code?: string,
  |}

  declare export type checkAuthenticationBotToken = {|
    /**
     * Checks the authentication token of a bot; to log in as a bot. Works only when
     * the current authorization state is authorizationStateWaitPhoneNumber. Can be
     * used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to
     * log in
     */
    +_: 'checkAuthenticationBotToken',
    /** The bot token */
    +token?: string,
  |}

  declare export type logOut = {|
    /**
     * Closes the TDLib instance after a proper logout. Requires an available network
     * connection. All local data will be destroyed. After the logout completes, updateAuthorizationState
     * with authorizationStateClosed will be sent
     */
    +_: 'logOut',
  |}

  declare export type close = {|
    /**
     * Closes the TDLib instance. All databases will be flushed to disk and properly
     * closed. After the close completes, updateAuthorizationState with authorizationStateClosed
     * will be sent. Can be called before initialization
     */
    +_: 'close',
  |}

  declare export type destroy = {|
    /**
     * Closes the TDLib instance, destroying all local data without a proper logout.
     * The current user session will remain in the list of all active sessions. All
     * local data will be destroyed. After the destruction completes updateAuthorizationState
     * with authorizationStateClosed will be sent. Can be called before authorization
     */
    +_: 'destroy',
  |}

  declare export type confirmQrCodeAuthentication = {|
    /**
     * Confirms QR code authentication on another device. Returns created session on
     * success
     */
    +_: 'confirmQrCodeAuthentication',
    /** A link from a QR code. The link must be scanned by the in-app camera */
    +link?: string,
  |}

  declare export type getCurrentState = {|
    /**
     * Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat
     * and others. This is especially useful if TDLib is run in a separate process.
     * Can be called before initialization
     */
    +_: 'getCurrentState',
  |}

  declare export type setDatabaseEncryptionKey = {|
    /**
     * Changes the database encryption key. Usually the encryption key is never changed
     * and is stored in some OS keychain
     */
    +_: 'setDatabaseEncryptionKey',
    /** New encryption key */
    +new_encryption_key?: string /* base64 */,
  |}

  declare export type getPasswordState = {|
    /** Returns the current state of 2-step verification */
    +_: 'getPasswordState',
  |}

  declare export type setPassword = {|
    /**
     * Changes the 2-step verification password for the current user. If a new recovery
     * email address is specified, then the change will not be applied until the new
     * recovery email address is confirmed
     */
    +_: 'setPassword',
    /** Previous 2-step verification password of the user */
    +old_password?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    +new_password?: string,
    /** New password hint; may be empty */
    +new_hint?: string,
    /** Pass true to change also the recovery email address */
    +set_recovery_email_address?: boolean,
    /** New recovery email address; may be empty */
    +new_recovery_email_address?: string,
  |}

  declare export type setLoginEmailAddress = {|
    /**
     * Changes the login email address of the user. The email address can be changed
     * only if the current user already has login email and passwordState.login_email_address_pattern
     * is non-empty. The change will not be applied until the new login email address
     * is confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID instead
     * of an email address, call checkLoginEmailAddressCode directly
     */
    +_: 'setLoginEmailAddress',
    /** New login email address */
    +new_login_email_address?: string,
  |}

  declare export type resendLoginEmailAddressCode = {|
    /** Resends the login email address verification code */
    +_: 'resendLoginEmailAddressCode',
  |}

  declare export type checkLoginEmailAddressCode = {|
    /** Checks the login email address authentication */
    +_: 'checkLoginEmailAddressCode',
    /** Email address authentication to check */
    +code?: EmailAddressAuthentication$Input,
  |}

  declare export type getRecoveryEmailAddress = {|
    /**
     * Returns a 2-step verification recovery email address that was previously set
     * up. This method can be used to verify a password provided by the user
     */
    +_: 'getRecoveryEmailAddress',
    /** The 2-step verification password for the current user */
    +password?: string,
  |}

  declare export type setRecoveryEmailAddress = {|
    /**
     * Changes the 2-step verification recovery email address of the user. If a new
     * recovery email address is specified, then the change will not be applied until
     * the new recovery email address is confirmed. If new_recovery_email_address is
     * the same as the email address that is currently set up, this call succeeds immediately
     * and aborts all other requests waiting for an email confirmation
     */
    +_: 'setRecoveryEmailAddress',
    /** The 2-step verification password of the current user */
    +password?: string,
    /** New recovery email address */
    +new_recovery_email_address?: string,
  |}

  declare export type checkRecoveryEmailAddressCode = {|
    /** Checks the 2-step verification recovery email address verification code */
    +_: 'checkRecoveryEmailAddressCode',
    /** Verification code to check */
    +code?: string,
  |}

  declare export type resendRecoveryEmailAddressCode = {|
    /** Resends the 2-step verification recovery email address verification code */
    +_: 'resendRecoveryEmailAddressCode',
  |}

  declare export type cancelRecoveryEmailAddressVerification = {|
    /** Cancels verification of the 2-step verification recovery email address */
    +_: 'cancelRecoveryEmailAddressVerification',
  |}

  declare export type requestPasswordRecovery = {|
    /**
     * Requests to send a 2-step verification password recovery code to an email address
     * that was previously set up
     */
    +_: 'requestPasswordRecovery',
  |}

  declare export type checkPasswordRecoveryCode = {|
    /**
     * Checks whether a 2-step verification password recovery code sent to an email
     * address is valid
     */
    +_: 'checkPasswordRecoveryCode',
    /** Recovery code to check */
    +recovery_code?: string,
  |}

  declare export type recoverPassword = {|
    /**
     * Recovers the 2-step verification password using a recovery code sent to an email
     * address that was previously set up
     */
    +_: 'recoverPassword',
    /** Recovery code to check */
    +recovery_code?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    +new_password?: string,
    /** New password hint; may be empty */
    +new_hint?: string,
  |}

  declare export type resetPassword = {|
    /**
     * Removes 2-step verification password without previous password and access to
     * recovery email address. The password can't be reset immediately and the request
     * needs to be repeated after the specified time
     */
    +_: 'resetPassword',
  |}

  declare export type cancelPasswordReset = {|
    /**
     * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date
     * > 0
     */
    +_: 'cancelPasswordReset',
  |}

  declare export type createTemporaryPassword = {|
    /** Creates a new temporary password for processing payments */
    +_: 'createTemporaryPassword',
    /** The 2-step verification password of the current user */
    +password?: string,
    /**
     * Time during which the temporary password will be valid, in seconds; must be
     * between 60 and 86400
     */
    +valid_for?: number,
  |}

  declare export type getTemporaryPasswordState = {|
    /** Returns information about the current temporary password */
    +_: 'getTemporaryPasswordState',
  |}

  declare export type getMe = {|
    /** Returns the current user */
    +_: 'getMe',
  |}

  declare export type getUser = {|
    /**
     * Returns information about a user by their identifier. This is an offline request
     * if the current user is not a bot
     */
    +_: 'getUser',
    /** User identifier */
    +user_id?: number,
  |}

  declare export type getUserFullInfo = {|
    /** Returns full information about a user by their identifier */
    +_: 'getUserFullInfo',
    /** User identifier */
    +user_id?: number,
  |}

  declare export type getBasicGroup = {|
    /**
     * Returns information about a basic group by its identifier. This is an offline
     * request if the current user is not a bot
     */
    +_: 'getBasicGroup',
    /** Basic group identifier */
    +basic_group_id?: number,
  |}

  declare export type getBasicGroupFullInfo = {|
    /** Returns full information about a basic group by its identifier */
    +_: 'getBasicGroupFullInfo',
    /** Basic group identifier */
    +basic_group_id?: number,
  |}

  declare export type getSupergroup = {|
    /**
     * Returns information about a supergroup or a channel by its identifier. This
     * is an offline request if the current user is not a bot
     */
    +_: 'getSupergroup',
    /** Supergroup or channel identifier */
    +supergroup_id?: number,
  |}

  declare export type getSupergroupFullInfo = {|
    /**
     * Returns full information about a supergroup or a channel by its identifier,
     * cached for up to 1 minute
     */
    +_: 'getSupergroupFullInfo',
    /** Supergroup or channel identifier */
    +supergroup_id?: number,
  |}

  declare export type getSecretChat = {|
    /**
     * Returns information about a secret chat by its identifier. This is an offline
     * request
     */
    +_: 'getSecretChat',
    /** Secret chat identifier */
    +secret_chat_id?: number,
  |}

  declare export type getChat = {|
    /**
     * Returns information about a chat by its identifier; this is an offline request
     * if the current user is not a bot
     */
    +_: 'getChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type getMessage = {|
    /**
     * Returns information about a message. Returns a 404 error if the message doesn't
     * exist
     */
    +_: 'getMessage',
    /** Identifier of the chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message to get */
    +message_id?: number,
  |}

  declare export type getMessageLocally = {|
    /**
     * Returns information about a message, if it is available without sending network
     * request. Returns a 404 error if message isn't available locally. This is an
     * offline request
     */
    +_: 'getMessageLocally',
    /** Identifier of the chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message to get */
    +message_id?: number,
  |}

  declare export type getRepliedMessage = {|
    /**
     * Returns information about a non-bundled message that is replied by a given message.
     * Also, returns the pinned message, the game message, the invoice message, the
     * message with a previously set same background, the giveaway message, and the
     * topic creation message for messages of the types messagePinMessage, messageGameScore,
     * messagePaymentSuccessful, messageChatSetBackground, messageGiveawayCompleted
     * and topic messages without non-bundled replied message respectively. Returns
     * a 404 error if the message doesn't exist
     */
    +_: 'getRepliedMessage',
    /** Identifier of the chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the reply message */
    +message_id?: number,
  |}

  declare export type getChatPinnedMessage = {|
    /**
     * Returns information about a newest pinned message in the chat. Returns a 404
     * error if the message doesn't exist
     */
    +_: 'getChatPinnedMessage',
    /** Identifier of the chat the message belongs to */
    +chat_id?: number,
  |}

  declare export type getCallbackQueryMessage = {|
    /**
     * Returns information about a message with the callback button that originated
     * a callback query; for bots only
     */
    +_: 'getCallbackQueryMessage',
    /** Identifier of the chat the message belongs to */
    +chat_id?: number,
    /** Message identifier */
    +message_id?: number,
    /** Identifier of the callback query */
    +callback_query_id?: number | string,
  |}

  declare export type getMessages = {|
    /**
     * Returns information about messages. If a message is not found, returns null
     * on the corresponding position of the result
     */
    +_: 'getMessages',
    /** Identifier of the chat the messages belong to */
    +chat_id?: number,
    /** Identifiers of the messages to get */
    +message_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getMessageProperties = {|
    /** Returns properties of a message; this is an offline request */
    +_: 'getMessageProperties',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
  |}

  declare export type getMessageThread = {|
    /**
     * Returns information about a message thread. Can be used only if messageProperties.can_get_message_thread
     * == true
     */
    +_: 'getMessageThread',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
  |}

  declare export type getMessageReadDate = {|
    /**
     * Returns read date of a recent outgoing message in a private chat. The method
     * can be called if messageProperties.can_get_read_date == true
     */
    +_: 'getMessageReadDate',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
  |}

  declare export type getMessageViewers = {|
    /**
     * Returns viewers of a recent outgoing message in a basic group or a supergroup
     * chat. For video notes and voice notes only users, opened content of the message,
     * are returned. The method can be called if messageProperties.can_get_viewers
     * == true
     */
    +_: 'getMessageViewers',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
  |}

  declare export type getFile = {|
    /** Returns information about a file; this is an offline request */
    +_: 'getFile',
    /** Identifier of the file to get */
    +file_id?: number,
  |}

  declare export type getRemoteFile = {|
    /**
     * Returns information about a file by its remote identifier; this is an offline
     * request. Can be used to register a URL as a file for further uploading, or sending
     * as a message. Even the request succeeds, the file can be used only if it is
     * still accessible to the user. For example, if the file is from a message, then
     * the message must be not deleted and accessible to the user. If the file database
     * is disabled, then the corresponding object with the file must be preloaded by
     * the application
     */
    +_: 'getRemoteFile',
    /** Remote identifier of the file to get */
    +remote_file_id?: string,
    /** File type; pass null if unknown */
    +file_type?: FileType$Input,
  |}

  declare export type loadChats = {|
    /**
     * Loads more chats from a chat list. The loaded chats and their positions in the
     * chat list will be sent through updates. Chats are sorted by the pair (chat.position.order,
     * chat.id) in descending order. Returns a 404 error if all chats have been loaded
     */
    +_: 'loadChats',
    /**
     * The chat list in which to load chats; pass null to load chats from the main
     * chat list
     */
    +chat_list?: ChatList$Input,
    /**
     * The maximum number of chats to be loaded. For optimal performance, the number
     * of loaded chats is chosen by TDLib and can be smaller than the specified limit,
     * even if the end of the list is not reached
     */
    +limit?: number,
  |}

  declare export type getChats = {|
    /**
     * Returns an ordered list of chats from the beginning of a chat list. For informational
     * purposes only. Use loadChats and updates processing instead to maintain chat
     * lists in a consistent state
     */
    +_: 'getChats',
    /**
     * The chat list in which to return chats; pass null to get chats from the main
     * chat list
     */
    +chat_list?: ChatList$Input,
    /** The maximum number of chats to be returned */
    +limit?: number,
  |}

  declare export type searchPublicChat = {|
    /**
     * Searches a public chat by its username. Currently, only private chats, supergroups
     * and channels can be public. Returns the chat if found; otherwise, an error is
     * returned
     */
    +_: 'searchPublicChat',
    /** Username to be resolved */
    +username?: string,
  |}

  declare export type searchPublicChats = {|
    /**
     * Searches public chats by looking for specified query in their username and title.
     * Currently, only private chats, supergroups and channels can be public. Returns
     * a meaningful number of results. Excludes private chats with contacts and chats
     * from the chat list from the results
     */
    +_: 'searchPublicChats',
    /** Query to search for */
    +query?: string,
  |}

  declare export type searchChats = {|
    /**
     * Searches for the specified query in the title and username of already known
     * chats; this is an offline request. Returns chats in the order seen in the main
     * chat list
     */
    +_: 'searchChats',
    /**
     * Query to search for. If the query is empty, returns up to 50 recently found
     * chats
     */
    +query?: string,
    /** The maximum number of chats to be returned */
    +limit?: number,
  |}

  declare export type searchChatsOnServer = {|
    /**
     * Searches for the specified query in the title and username of already known
     * chats via request to the server. Returns chats in the order seen in the main
     * chat list
     */
    +_: 'searchChatsOnServer',
    /** Query to search for */
    +query?: string,
    /** The maximum number of chats to be returned */
    +limit?: number,
  |}

  declare export type getRecommendedChats = {|
    /** Returns a list of channel chats recommended to the current user */
    +_: 'getRecommendedChats',
  |}

  declare export type getChatSimilarChats = {|
    /** Returns a list of chats similar to the given chat */
    +_: 'getChatSimilarChats',
    /** Identifier of the target chat; must be an identifier of a channel chat */
    +chat_id?: number,
  |}

  declare export type getChatSimilarChatCount = {|
    /** Returns approximate number of chats similar to the given chat */
    +_: 'getChatSimilarChatCount',
    /** Identifier of the target chat; must be an identifier of a channel chat */
    +chat_id?: number,
    /**
     * Pass true to get the number of chats without sending network requests, or -1
     * if the number of chats is unknown locally
     */
    +return_local?: boolean,
  |}

  declare export type openChatSimilarChat = {|
    /**
     * Informs TDLib that a chat was opened from the list of similar chats. The method
     * is independent of openChat and closeChat methods
     */
    +_: 'openChatSimilarChat',
    /** Identifier of the original chat, which similar chats were requested */
    +chat_id?: number,
    /** Identifier of the opened chat */
    +opened_chat_id?: number,
  |}

  declare export type getBotSimilarBots = {|
    /** Returns a list of bots similar to the given bot */
    +_: 'getBotSimilarBots',
    /** User identifier of the target bot */
    +bot_user_id?: number,
  |}

  declare export type getBotSimilarBotCount = {|
    /** Returns approximate number of bots similar to the given bot */
    +_: 'getBotSimilarBotCount',
    /** User identifier of the target bot */
    +bot_user_id?: number,
    /**
     * Pass true to get the number of bots without sending network requests, or -1
     * if the number of bots is unknown locally
     */
    +return_local?: boolean,
  |}

  declare export type openBotSimilarBot = {|
    /** Informs TDLib that a bot was opened from the list of similar bots */
    +_: 'openBotSimilarBot',
    /** Identifier of the original bot, which similar bots were requested */
    +bot_user_id?: number,
    /** Identifier of the opened bot */
    +opened_bot_user_id?: number,
  |}

  declare export type getTopChats = {|
    /** Returns a list of frequently used chats */
    +_: 'getTopChats',
    /** Category of chats to be returned */
    +category?: TopChatCategory$Input,
    /** The maximum number of chats to be returned; up to 30 */
    +limit?: number,
  |}

  declare export type removeTopChat = {|
    /**
     * Removes a chat from the list of frequently used chats. Supported only if the
     * chat info database is enabled
     */
    +_: 'removeTopChat',
    /** Category of frequently used chats */
    +category?: TopChatCategory$Input,
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type searchRecentlyFoundChats = {|
    /**
     * Searches for the specified query in the title and username of up to 50 recently
     * found chats; this is an offline request
     */
    +_: 'searchRecentlyFoundChats',
    /** Query to search for */
    +query?: string,
    /** The maximum number of chats to be returned */
    +limit?: number,
  |}

  declare export type addRecentlyFoundChat = {|
    /**
     * Adds a chat to the list of recently found chats. The chat is added to the beginning
     * of the list. If the chat is already in the list, it will be removed from the
     * list first
     */
    +_: 'addRecentlyFoundChat',
    /** Identifier of the chat to add */
    +chat_id?: number,
  |}

  declare export type removeRecentlyFoundChat = {|
    /** Removes a chat from the list of recently found chats */
    +_: 'removeRecentlyFoundChat',
    /** Identifier of the chat to be removed */
    +chat_id?: number,
  |}

  declare export type clearRecentlyFoundChats = {|
    /** Clears the list of recently found chats */
    +_: 'clearRecentlyFoundChats',
  |}

  declare export type getRecentlyOpenedChats = {|
    /**
     * Returns recently opened chats; this is an offline request. Returns chats in
     * the order of last opening
     */
    +_: 'getRecentlyOpenedChats',
    /** The maximum number of chats to be returned */
    +limit?: number,
  |}

  declare export type checkChatUsername = {|
    /** Checks whether a username can be set for a chat */
    +_: 'checkChatUsername',
    /**
     * Chat identifier; must be identifier of a supergroup chat, or a channel chat,
     * or a private chat with self, or 0 if the chat is being created
     */
    +chat_id?: number,
    /** Username to be checked */
    +username?: string,
  |}

  declare export type getCreatedPublicChats = {|
    /** Returns a list of public chats of the specified type, owned by the user */
    +_: 'getCreatedPublicChats',
    /** Type of the public chats to return */
    +type?: PublicChatType$Input,
  |}

  declare export type checkCreatedPublicChatsLimit = {|
    /**
     * Checks whether the maximum number of owned public chats has been reached. Returns
     * corresponding error if the limit was reached. The limit can be increased with
     * Telegram Premium
     */
    +_: 'checkCreatedPublicChatsLimit',
    /** Type of the public chats, for which to check the limit */
    +type?: PublicChatType$Input,
  |}

  declare export type getSuitableDiscussionChats = {|
    /**
     * Returns a list of basic group and supergroup chats, which can be used as a discussion
     * group for a channel. Returned basic group chats must be first upgraded to supergroups
     * before they can be set as a discussion group. To set a returned supergroup as
     * a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable
     * first
     */
    +_: 'getSuitableDiscussionChats',
  |}

  declare export type getInactiveSupergroupChats = {|
    /**
     * Returns a list of recently inactive supergroups and channels. Can be used when
     * user reaches limit on the number of joined supergroups and channels and receives
     * CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
     */
    +_: 'getInactiveSupergroupChats',
  |}

  declare export type getSuitablePersonalChats = {|
    /** Returns a list of channel chats, which can be used as a personal chat */
    +_: 'getSuitablePersonalChats',
  |}

  declare export type loadSavedMessagesTopics = {|
    /**
     * Loads more Saved Messages topics. The loaded topics will be sent through updateSavedMessagesTopic.
     * Topics are sorted by their topic.order in descending order. Returns a 404 error
     * if all topics have been loaded
     */
    +_: 'loadSavedMessagesTopics',
    /**
     * The maximum number of topics to be loaded. For optimal performance, the number
     * of loaded topics is chosen by TDLib and can be smaller than the specified limit,
     * even if the end of the list is not reached
     */
    +limit?: number,
  |}

  declare export type getSavedMessagesTopicHistory = {|
    /**
     * Returns messages in a Saved Messages topic. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    +_: 'getSavedMessagesTopicHistory',
    /** Identifier of Saved Messages topic which messages will be fetched */
    +saved_messages_topic_id?: number,
    /**
     * Identifier of the message starting from which messages must be fetched; use
     * 0 to get results from the last message
     */
    +from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset up to 99 to get additionally some newer messages
     */
    +offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type getSavedMessagesTopicMessageByDate = {|
    /**
     * Returns the last message sent in a Saved Messages topic no later than the specified
     * date
     */
    +_: 'getSavedMessagesTopicMessageByDate',
    /** Identifier of Saved Messages topic which message will be returned */
    +saved_messages_topic_id?: number,
    /** Point in time (Unix timestamp) relative to which to search for messages */
    +date?: number,
  |}

  declare export type deleteSavedMessagesTopicHistory = {|
    /** Deletes all messages in a Saved Messages topic */
    +_: 'deleteSavedMessagesTopicHistory',
    /** Identifier of Saved Messages topic which messages will be deleted */
    +saved_messages_topic_id?: number,
  |}

  declare export type deleteSavedMessagesTopicMessagesByDate = {|
    /**
     * Deletes all messages between the specified dates in a Saved Messages topic.
     * Messages sent in the last 30 seconds will not be deleted
     */
    +_: 'deleteSavedMessagesTopicMessagesByDate',
    /** Identifier of Saved Messages topic which messages will be deleted */
    +saved_messages_topic_id?: number,
    /** The minimum date of the messages to delete */
    +min_date?: number,
    /** The maximum date of the messages to delete */
    +max_date?: number,
  |}

  declare export type toggleSavedMessagesTopicIsPinned = {|
    /**
     * Changes the pinned state of a Saved Messages topic. There can be up to getOption("pinned_saved_messages_topic_count_max")
     * pinned topics. The limit can be increased with Telegram Premium
     */
    +_: 'toggleSavedMessagesTopicIsPinned',
    /** Identifier of Saved Messages topic to pin or unpin */
    +saved_messages_topic_id?: number,
    /** Pass true to pin the topic; pass false to unpin it */
    +is_pinned?: boolean,
  |}

  declare export type setPinnedSavedMessagesTopics = {|
    /** Changes the order of pinned Saved Messages topics */
    +_: 'setPinnedSavedMessagesTopics',
    /** Identifiers of the new pinned Saved Messages topics */
    +saved_messages_topic_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getGroupsInCommon = {|
    /**
     * Returns a list of common group chats with a given user. Chats are sorted by
     * their type and creation date
     */
    +_: 'getGroupsInCommon',
    /** User identifier */
    +user_id?: number,
    /** Chat identifier starting from which to return chats; use 0 for the first request */
    +offset_chat_id?: number,
    /** The maximum number of chats to be returned; up to 100 */
    +limit?: number,
  |}

  declare export type getChatHistory = {|
    /**
     * Returns messages in a chat. The messages are returned in reverse chronological
     * order (i.e., in order of decreasing message_id). For optimal performance, the
     * number of returned messages is chosen by TDLib. This is an offline request if
     * only_local is true
     */
    +_: 'getChatHistory',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    +from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset up to 99 to get additionally some newer messages
     */
    +offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
    /** Pass true to get only messages that are available without sending network requests */
    +only_local?: boolean,
  |}

  declare export type getMessageThreadHistory = {|
    /**
     * Returns messages in a message thread of a message. Can be used only if messageProperties.can_get_message_thread
     * == true. Message thread of a channel message is in the channel's linked supergroup.
     * The messages are returned in reverse chronological order (i.e., in order of
     * decreasing message_id). For optimal performance, the number of returned messages
     * is chosen by TDLib
     */
    +_: 'getMessageThreadHistory',
    /** Chat identifier */
    +chat_id?: number,
    /** Message identifier, which thread history needs to be returned */
    +message_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    +from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset up to 99 to get additionally some newer messages
     */
    +offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type deleteChatHistory = {|
    /**
     * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and
     * chat.can_be_deleted_for_all_users fields to find whether and how the method
     * can be applied to the chat
     */
    +_: 'deleteChatHistory',
    /** Chat identifier */
    +chat_id?: number,
    /** Pass true to remove the chat from all chat lists */
    +remove_from_chat_list?: boolean,
    /** Pass true to delete chat history for all users */
    +revoke?: boolean,
  |}

  declare export type deleteChat = {|
    /**
     * Deletes a chat along with all messages in the corresponding chat for all chat
     * members. For group chats this will release the usernames and remove all members.
     * Use the field chat.can_be_deleted_for_all_users to find whether the method can
     * be applied to the chat
     */
    +_: 'deleteChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type searchChatMessages = {|
    /**
     * Searches for messages with given words in the chat. Returns the results in reverse
     * chronological order, i.e. in order of decreasing message_id. Cannot be used
     * in secret chats with a non-empty query (searchSecretMessages must be used instead),
     * or without an enabled message database. For optimal performance, the number
     * of returned messages is chosen by TDLib and can be smaller than the specified
     * limit. A combination of query, sender_id, filter and message_thread_id search
     * criteria is expected to be supported, only if it is required for Telegram official
     * application implementation
     */
    +_: 'searchChatMessages',
    /** Identifier of the chat in which to search messages */
    +chat_id?: number,
    /** Query to search for */
    +query?: string,
    /**
     * Identifier of the sender of messages to search for; pass null to search for
     * messages from any sender. Not supported in secret chats
     */
    +sender_id?: MessageSender$Input,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    +from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset to get the specified message and some newer messages
     */
    +offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * -offset. For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    +filter?: SearchMessagesFilter$Input,
    /**
     * If not 0, only messages in the specified thread will be returned; supergroups
     * only
     */
    +message_thread_id?: number,
    /**
     * If not 0, only messages in the specified Saved Messages topic will be returned;
     * pass 0 to return all messages, or for chats other than Saved Messages
     */
    +saved_messages_topic_id?: number,
  |}

  declare export type searchMessages = {|
    /**
     * Searches for messages in all chats except secret chats. Returns the results
     * in reverse chronological order (i.e., in order of decreasing (date, chat_id,
     * message_id)). For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    +_: 'searchMessages',
    /**
     * Chat list in which to search messages; pass null to search in all chats regardless
     * of their chat list. Only Main and Archive chat lists are supported
     */
    +chat_list?: ChatList$Input,
    /** Query to search for */
    +query?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +limit?: number,
    /**
     * Additional filter for messages to search; pass null to search for all messages.
     * Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction,
     * searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are unsupported
     * in this function
     */
    +filter?: SearchMessagesFilter$Input,
    /**
     * Additional filter for type of the chat of the searched messages; pass null to
     * search for messages in all chats
     */
    +chat_type_filter?: SearchMessagesChatTypeFilter$Input,
    /** If not 0, the minimum date of the messages to return */
    +min_date?: number,
    /** If not 0, the maximum date of the messages to return */
    +max_date?: number,
  |}

  declare export type searchSecretMessages = {|
    /**
     * Searches for messages in secret chats. Returns the results in reverse chronological
     * order. For optimal performance, the number of returned messages is chosen by
     * TDLib
     */
    +_: 'searchSecretMessages',
    /**
     * Identifier of the chat in which to search. Specify 0 to search in all secret
     * chats
     */
    +chat_id?: number,
    /** Query to search for. If empty, searchChatMessages must be used instead */
    +query?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    +filter?: SearchMessagesFilter$Input,
  |}

  declare export type searchSavedMessages = {|
    /**
     * Searches for messages tagged by the given reaction and with the given words
     * in the Saved Messages chat; for Telegram Premium users only. Returns the results
     * in reverse chronological order, i.e. in order of decreasing message_id. For
     * optimal performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    +_: 'searchSavedMessages',
    /**
     * If not 0, only messages in the specified Saved Messages topic will be considered;
     * pass 0 to consider all messages
     */
    +saved_messages_topic_id?: number,
    /** Tag to search for; pass null to return all suitable messages */
    +tag?: ReactionType$Input,
    /** Query to search for */
    +query?: string,
    /**
     * Identifier of the message starting from which messages must be fetched; use
     * 0 to get results from the last message
     */
    +from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset to get the specified message and some newer messages
     */
    +offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * -offset. For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type searchCallMessages = {|
    /**
     * Searches for call messages. Returns the results in reverse chronological order
     * (i.e., in order of decreasing message_id). For optimal performance, the number
     * of returned messages is chosen by TDLib
     */
    +_: 'searchCallMessages',
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +limit?: number,
    /** Pass true to search only for messages with missed/declined calls */
    +only_missed?: boolean,
  |}

  declare export type searchOutgoingDocumentMessages = {|
    /**
     * Searches for outgoing messages with content of the type messageDocument in all
     * chats except secret chats. Returns the results in reverse chronological order
     */
    +_: 'searchOutgoingDocumentMessages',
    /** Query to search for in document file name and message caption */
    +query?: string,
    /** The maximum number of messages to be returned; up to 100 */
    +limit?: number,
  |}

  declare export type searchPublicMessagesByTag = {|
    /**
     * Searches for public channel posts containing the given hashtag or cashtag. For
     * optimal performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    +_: 'searchPublicMessagesByTag',
    /** Hashtag or cashtag to search for */
    +tag?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +limit?: number,
  |}

  declare export type searchPublicStoriesByTag = {|
    /**
     * Searches for public stories containing the given hashtag or cashtag. For optimal
     * performance, the number of returned stories is chosen by TDLib and can be smaller
     * than the specified limit
     */
    +_: 'searchPublicStoriesByTag',
    /**
     * Identifier of the chat that posted the stories to search for; pass 0 to search
     * stories in all chats
     */
    +story_sender_chat_id?: number,
    /** Hashtag or cashtag to search for */
    +tag?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of stories to be returned; up to 100. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +limit?: number,
  |}

  declare export type searchPublicStoriesByLocation = {|
    /**
     * Searches for public stories by the given address location. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +_: 'searchPublicStoriesByLocation',
    /** Address of the location */
    +address?: locationAddress$Input,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of stories to be returned; up to 100. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +limit?: number,
  |}

  declare export type searchPublicStoriesByVenue = {|
    /**
     * Searches for public stories from the given venue. For optimal performance, the
     * number of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    +_: 'searchPublicStoriesByVenue',
    /** Provider of the venue */
    +venue_provider?: string,
    /** Identifier of the venue in the provider database */
    +venue_id?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of stories to be returned; up to 100. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    +limit?: number,
  |}

  declare export type getSearchedForTags = {|
    /** Returns recently searched for hashtags or cashtags by their prefix */
    +_: 'getSearchedForTags',
    /** Prefix of hashtags or cashtags to return */
    +tag_prefix?: string,
    /** The maximum number of items to be returned */
    +limit?: number,
  |}

  declare export type removeSearchedForTag = {|
    /**
     * Removes a hashtag or a cashtag from the list of recently searched for hashtags
     * or cashtags
     */
    +_: 'removeSearchedForTag',
    /** Hashtag or cashtag to delete */
    +tag?: string,
  |}

  declare export type clearSearchedForTags = {|
    /** Clears the list of recently searched for hashtags or cashtags */
    +_: 'clearSearchedForTags',
    /**
     * Pass true to clear the list of recently searched for cashtags; otherwise, the
     * list of recently searched for hashtags will be cleared
     */
    +clear_cashtags?: boolean,
  |}

  declare export type deleteAllCallMessages = {|
    /** Deletes all call messages */
    +_: 'deleteAllCallMessages',
    /** Pass true to delete the messages for all users */
    +revoke?: boolean,
  |}

  declare export type searchChatRecentLocationMessages = {|
    /**
     * Returns information about the recent locations of chat members that were sent
     * to the chat. Returns up to 1 location message per user
     */
    +_: 'searchChatRecentLocationMessages',
    /** Chat identifier */
    +chat_id?: number,
    /** The maximum number of messages to be returned */
    +limit?: number,
  |}

  declare export type getChatMessageByDate = {|
    /**
     * Returns the last message sent in a chat no later than the specified date. Returns
     * a 404 error if such message doesn't exist
     */
    +_: 'getChatMessageByDate',
    /** Chat identifier */
    +chat_id?: number,
    /** Point in time (Unix timestamp) relative to which to search for messages */
    +date?: number,
  |}

  declare export type getChatSparseMessagePositions = {|
    /**
     * Returns sparse positions of messages of the specified type in the chat to be
     * used for shared media scroll implementation. Returns the results in reverse
     * chronological order (i.e., in order of decreasing message_id). Cannot be used
     * in secret chats or with searchMessagesFilterFailedToSend filter without an enabled
     * message database
     */
    +_: 'getChatSparseMessagePositions',
    /** Identifier of the chat in which to return information about message positions */
    +chat_id?: number,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are
     * unsupported in this function
     */
    +filter?: SearchMessagesFilter$Input,
    /** The message identifier from which to return information about message positions */
    +from_message_id?: number,
    /**
     * The expected number of message positions to be returned; 50-2000. A smaller
     * number of positions can be returned, if there are not enough appropriate messages
     */
    +limit?: number,
    /**
     * If not 0, only messages in the specified Saved Messages topic will be considered;
     * pass 0 to consider all messages, or for chats other than Saved Messages
     */
    +saved_messages_topic_id?: number,
  |}

  declare export type getChatMessageCalendar = {|
    /**
     * Returns information about the next messages of the specified type in the chat
     * split by days. Returns the results in reverse chronological order. Can return
     * partial result for the last returned day. Behavior of this method depends on
     * the value of the option "utc_time_offset"
     */
    +_: 'getChatMessageCalendar',
    /** Identifier of the chat in which to return information about messages */
    +chat_id?: number,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are
     * unsupported in this function
     */
    +filter?: SearchMessagesFilter$Input,
    /**
     * The message identifier from which to return information about messages; use
     * 0 to get results from the last message
     */
    +from_message_id?: number,
    /**
     * If not0, only messages in the specified Saved Messages topic will be considered;
     * pass 0 to consider all messages, or for chats other than Saved Messages
     */
    +saved_messages_topic_id?: number,
  |}

  declare export type getChatMessageCount = {|
    /** Returns approximate number of messages of the specified type in the chat */
    +_: 'getChatMessageCount',
    /** Identifier of the chat in which to count messages */
    +chat_id?: number,
    /**
     * Filter for message content; searchMessagesFilterEmpty is unsupported in this
     * function
     */
    +filter?: SearchMessagesFilter$Input,
    /**
     * If not 0, only messages in the specified Saved Messages topic will be counted;
     * pass 0 to count all messages, or for chats other than Saved Messages
     */
    +saved_messages_topic_id?: number,
    /**
     * Pass true to get the number of messages without sending network requests, or
     * -1 if the number of messages is unknown locally
     */
    +return_local?: boolean,
  |}

  declare export type getChatMessagePosition = {|
    /**
     * Returns approximate 1-based position of a message among messages, which can
     * be found by the specified filter in the chat. Cannot be used in secret chats
     */
    +_: 'getChatMessagePosition',
    /** Identifier of the chat in which to find message position */
    +chat_id?: number,
    /** Message identifier */
    +message_id?: number,
    /**
     * Filter for message content; searchMessagesFilterEmpty, searchMessagesFilterUnreadMention,
     * searchMessagesFilterUnreadReaction, and searchMessagesFilterFailedToSend are
     * unsupported in this function
     */
    +filter?: SearchMessagesFilter$Input,
    /**
     * If not 0, only messages in the specified thread will be considered; supergroups
     * only
     */
    +message_thread_id?: number,
    /**
     * If not 0, only messages in the specified Saved Messages topic will be considered;
     * pass 0 to consider all relevant messages, or for chats other than Saved Messages
     */
    +saved_messages_topic_id?: number,
  |}

  declare export type getChatScheduledMessages = {|
    /**
     * Returns all scheduled messages in a chat. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    +_: 'getChatScheduledMessages',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type getChatSponsoredMessages = {|
    /**
     * Returns sponsored messages to be shown in a chat; for channel chats and chats
     * with bots only
     */
    +_: 'getChatSponsoredMessages',
    /** Identifier of the chat */
    +chat_id?: number,
  |}

  declare export type clickChatSponsoredMessage = {|
    /**
     * Informs TDLib that the user opened the sponsored chat via the button, the name,
     * the chat photo, a mention in the sponsored message text, or the media in the
     * sponsored message
     */
    +_: 'clickChatSponsoredMessage',
    /** Chat identifier of the sponsored message */
    +chat_id?: number,
    /** Identifier of the sponsored message */
    +message_id?: number,
    /** Pass true if the media was clicked in the sponsored message */
    +is_media_click?: boolean,
    /**
     * Pass true if the user expanded the video from the sponsored message fullscreen
     * before the click
     */
    +from_fullscreen?: boolean,
  |}

  declare export type reportChatSponsoredMessage = {|
    /** Reports a sponsored message to Telegram moderators */
    +_: 'reportChatSponsoredMessage',
    /** Chat identifier of the sponsored message */
    +chat_id?: number,
    /** Identifier of the sponsored message */
    +message_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    +option_id?: string /* base64 */,
  |}

  declare export type removeNotification = {|
    /**
     * Removes an active notification from notification list. Needs to be called only
     * if the notification is removed by the current user
     */
    +_: 'removeNotification',
    /** Identifier of notification group to which the notification belongs */
    +notification_group_id?: number,
    /** Identifier of removed notification */
    +notification_id?: number,
  |}

  declare export type removeNotificationGroup = {|
    /**
     * Removes a group of active notifications. Needs to be called only if the notification
     * group is removed by the current user
     */
    +_: 'removeNotificationGroup',
    /** Notification group identifier */
    +notification_group_id?: number,
    /** The maximum identifier of removed notifications */
    +max_notification_id?: number,
  |}

  declare export type getMessageLink = {|
    /**
     * Returns an HTTPS link to a message in a chat. Available only if messageProperties.can_get_link,
     * or if messageProperties.can_get_media_timestamp_links and a media timestamp
     * link is generated. This is an offline request
     */
    +_: 'getMessageLink',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /**
     * If not 0, timestamp from which the video/audio/video note/voice note/story playing
     * must start, in seconds. The media can be in the message content or in its link
     * preview
     */
    +media_timestamp?: number,
    /** Pass true to create a link for the whole media album */
    +for_album?: boolean,
    /**
     * Pass true to create a link to the message as a channel post comment, in a message
     * thread, or a forum topic
     */
    +in_message_thread?: boolean,
  |}

  declare export type getMessageEmbeddingCode = {|
    /** Returns an HTML code for embedding the message. Available only if messageProperties.can_get_embedding_code */
    +_: 'getMessageEmbeddingCode',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** Pass true to return an HTML code for embedding of the whole media album */
    +for_album?: boolean,
  |}

  declare export type getMessageLinkInfo = {|
    /**
     * Returns information about a public or private message link. Can be called for
     * any internal link of the type internalLinkTypeMessage
     */
    +_: 'getMessageLinkInfo',
    /** The message link */
    +url?: string,
  |}

  declare export type translateText = {|
    /**
     * Translates a text to the given language. If the current user is a Telegram Premium
     * user, then text formatting is preserved
     */
    +_: 'translateText',
    /** Text to translate */
    +text?: formattedText$Input,
    /**
     * Language code of the language to which the message is translated. Must be one
     * of "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb",
     * "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl",
     * "en", "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha",
     * "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja",
     * "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky", "lo", "la", "lv", "lt", "lb",
     * "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or",
     * "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd",
     * "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo",
     * "zu"
     */
    +to_language_code?: string,
  |}

  declare export type translateMessageText = {|
    /**
     * Extracts text or caption of the given message and translates it to the given
     * language. If the current user is a Telegram Premium user, then text formatting
     * is preserved
     */
    +_: 'translateMessageText',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /**
     * Language code of the language to which the message is translated. Must be one
     * of "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb",
     * "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl",
     * "en", "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha",
     * "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja",
     * "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky", "lo", "la", "lv", "lt", "lb",
     * "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or",
     * "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd",
     * "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo",
     * "zu"
     */
    +to_language_code?: string,
  |}

  declare export type recognizeSpeech = {|
    /** Recognizes speech in a video note or a voice note message */
    +_: 'recognizeSpeech',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_recognize_speech to check
     * whether the message is suitable
     */
    +message_id?: number,
  |}

  declare export type rateSpeechRecognition = {|
    /** Rates recognized speech in a video note or a voice note message */
    +_: 'rateSpeechRecognition',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** Pass true if the speech recognition is good */
    +is_good?: boolean,
  |}

  declare export type getChatAvailableMessageSenders = {|
    /**
     * Returns the list of message sender identifiers, which can be used to send messages
     * in a chat
     */
    +_: 'getChatAvailableMessageSenders',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type setChatMessageSender = {|
    /** Selects a message sender to send messages in a chat */
    +_: 'setChatMessageSender',
    /** Chat identifier */
    +chat_id?: number,
    /** New message sender for the chat */
    +message_sender_id?: MessageSender$Input,
  |}

  declare export type sendMessage = {|
    /** Sends a message. Returns the sent message */
    +_: 'sendMessage',
    /** Target chat */
    +chat_id?: number,
    /** If not 0, the message thread identifier in which the message will be sent */
    +message_thread_id?: number,
    /** Information about the message or story to be replied; pass null if none */
    +reply_to?: InputMessageReplyTo$Input,
    /** Options to be used to send the message; pass null to use default options */
    +options?: messageSendOptions$Input,
    /** Markup for replying to the message; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
    /** The content of the message to be sent */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type sendMessageAlbum = {|
    /**
     * Sends 2-10 messages grouped together into an album. Currently, only audio, document,
     * photo and video messages can be grouped into an album. Documents and audio files
     * can be only grouped in an album with messages of the same type. Returns sent
     * messages
     */
    +_: 'sendMessageAlbum',
    /** Target chat */
    +chat_id?: number,
    /** If not 0, the message thread identifier in which the messages will be sent */
    +message_thread_id?: number,
    /** Information about the message or story to be replied; pass null if none */
    +reply_to?: InputMessageReplyTo$Input,
    /** Options to be used to send the messages; pass null to use default options */
    +options?: messageSendOptions$Input,
    /**
     * Contents of messages to be sent. At most 10 messages can be added to an album.
     * All messages must have the same value of show_caption_above_media
     */
    +input_message_contents?: $ReadOnlyArray<InputMessageContent$Input>,
  |}

  declare export type sendBotStartMessage = {|
    /**
     * Invites a bot to a chat (if it is not yet a member) and sends it the /start
     * command; requires can_invite_users member right. Bots can't be invited to a
     * private chat other than the chat with the bot. Bots can't be invited to channels
     * (although they can be added as admins) and secret chats. Returns the sent message
     */
    +_: 'sendBotStartMessage',
    /** Identifier of the bot */
    +bot_user_id?: number,
    /** Identifier of the target chat */
    +chat_id?: number,
    /** A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking) */
    +parameter?: string,
  |}

  declare export type sendInlineQueryResultMessage = {|
    /**
     * Sends the result of an inline query as a message. Returns the sent message.
     * Always clears a chat draft message
     */
    +_: 'sendInlineQueryResultMessage',
    /** Target chat */
    +chat_id?: number,
    /** If not 0, the message thread identifier in which the message will be sent */
    +message_thread_id?: number,
    /** Information about the message or story to be replied; pass null if none */
    +reply_to?: InputMessageReplyTo$Input,
    /** Options to be used to send the message; pass null to use default options */
    +options?: messageSendOptions$Input,
    /** Identifier of the inline query */
    +query_id?: number | string,
    /** Identifier of the inline query result */
    +result_id?: string,
    /**
     * Pass true to hide the bot, via which the message is sent. Can be used only for
     * bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"),
     * and getOption("venue_search_bot_username")
     */
    +hide_via_bot?: boolean,
  |}

  declare export type forwardMessages = {|
    /**
     * Forwards previously sent messages. Returns the forwarded messages in the same
     * order as the message identifiers passed in message_ids. If a message can't be
     * forwarded, null will be returned instead of the message
     */
    +_: 'forwardMessages',
    /** Identifier of the chat to which to forward messages */
    +chat_id?: number,
    /**
     * If not 0, the message thread identifier in which the message will be sent; for
     * forum threads only
     */
    +message_thread_id?: number,
    /** Identifier of the chat from which to forward messages */
    +from_chat_id?: number,
    /**
     * Identifiers of the messages to forward. Message identifiers must be in a strictly
     * increasing order. At most 100 messages can be forwarded simultaneously. A message
     * can be forwarded only if messageProperties.can_be_forwarded
     */
    +message_ids?: $ReadOnlyArray<number>,
    /** Options to be used to send the messages; pass null to use default options */
    +options?: messageSendOptions$Input,
    /**
     * Pass true to copy content of the messages without reference to the original
     * sender. Always true if the messages are forwarded to a secret chat or are local.
     * Use messageProperties.can_be_saved and messageProperties.can_be_copied_to_secret_chat
     * to check whether the message is suitable
     */
    +send_copy?: boolean,
    /**
     * Pass true to remove media captions of message copies. Ignored if send_copy is
     * false
     */
    +remove_caption?: boolean,
  |}

  declare export type sendQuickReplyShortcutMessages = {|
    /**
     * Sends messages from a quick reply shortcut. Requires Telegram Business subscription.
     * Can't be used to send paid messages
     */
    +_: 'sendQuickReplyShortcutMessages',
    /**
     * Identifier of the chat to which to send messages. The chat must be a private
     * chat with a regular user
     */
    +chat_id?: number,
    /** Unique identifier of the quick reply shortcut */
    +shortcut_id?: number,
    /**
     * Non-persistent identifier, which will be returned back in messageSendingStatePending
     * object and can be used to match sent messages and corresponding updateNewMessage
     * updates
     */
    +sending_id?: number,
  |}

  declare export type resendMessages = {|
    /**
     * Resends messages which failed to send. Can be called only for messages for which
     * messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after
     * time passed. If a message is re-sent, the corresponding failed to send message
     * is deleted. Returns the sent messages in the same order as the message identifiers
     * passed in message_ids. If a message can't be re-sent, null will be returned
     * instead of the message
     */
    +_: 'resendMessages',
    /** Identifier of the chat to send messages */
    +chat_id?: number,
    /**
     * Identifiers of the messages to resend. Message identifiers must be in a strictly
     * increasing order
     */
    +message_ids?: $ReadOnlyArray<number>,
    /**
     * New manually chosen quote from the message to be replied; pass null if none.
     * Ignored if more than one message is re-sent, or if messageSendingStateFailed.need_another_reply_quote
     * == false
     */
    +quote?: inputTextQuote$Input,
    /**
     * The number of Telegram Stars the user agreed to pay to send the messages. Ignored
     * if messageSendingStateFailed.required_paid_message_star_count == 0
     */
    +paid_message_star_count?: number,
  |}

  declare export type addLocalMessage = {|
    /**
     * Adds a local message to a chat. The message is persistent across application
     * restarts only if the message database is used. Returns the added message
     */
    +_: 'addLocalMessage',
    /** Target chat */
    +chat_id?: number,
    /** Identifier of the sender of the message */
    +sender_id?: MessageSender$Input,
    /** Information about the message or story to be replied; pass null if none */
    +reply_to?: InputMessageReplyTo$Input,
    /** Pass true to disable notification for the message */
    +disable_notification?: boolean,
    /** The content of the message to be added */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type deleteMessages = {|
    /** Deletes messages */
    +_: 'deleteMessages',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifiers of the messages to be deleted. Use messageProperties.can_be_deleted_only_for_self
     * and messageProperties.can_be_deleted_for_all_users to get suitable messages
     */
    +message_ids?: $ReadOnlyArray<number>,
    /**
     * Pass true to delete messages for all chat members. Always true for supergroups,
     * channels and secret chats
     */
    +revoke?: boolean,
  |}

  declare export type deleteChatMessagesBySender = {|
    /**
     * Deletes all messages sent by the specified message sender in a chat. Supported
     * only for supergroups; requires can_delete_messages administrator right
     */
    +_: 'deleteChatMessagesBySender',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the sender of messages to delete */
    +sender_id?: MessageSender$Input,
  |}

  declare export type deleteChatMessagesByDate = {|
    /**
     * Deletes all messages between the specified dates in a chat. Supported only for
     * private chats and basic groups. Messages sent in the last 30 seconds will not
     * be deleted
     */
    +_: 'deleteChatMessagesByDate',
    /** Chat identifier */
    +chat_id?: number,
    /** The minimum date of the messages to delete */
    +min_date?: number,
    /** The maximum date of the messages to delete */
    +max_date?: number,
    /** Pass true to delete chat messages for all users; private chats only */
    +revoke?: boolean,
  |}

  declare export type editMessageText = {|
    /**
     * Edits the text of a message (or a text of a game message). Returns the edited
     * message after the edit is completed on the server side
     */
    +_: 'editMessageText',
    /** The chat the message belongs to */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    +message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type editMessageLiveLocation = {|
    /**
     * Edits the message content of a live location. Messages can be edited for a limited
     * period of time specified in the live location. Returns the edited message after
     * the edit is completed on the server side
     */
    +_: 'editMessageLiveLocation',
    /** The chat the message belongs to */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    +message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    +location?: location$Input,
    /**
     * New time relative to the message send date, for which the location can be updated,
     * in seconds. If 0x7FFFFFFF specified, then the location can be updated forever.
     * Otherwise, must not exceed the current live_period by more than a day, and the
     * live location expiration date must remain in the next 90 days. Pass 0 to keep
     * the current live_period
     */
    +live_period?: number,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    +heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    +proximity_alert_radius?: number,
  |}

  declare export type editMessageMedia = {|
    /**
     * Edits the media content of a message, including message caption. If only the
     * caption needs to be edited, use editMessageCaption instead. The type of message
     * content in an album can't be changed with exception of replacing a photo with
     * a video or vice versa. Returns the edited message after the edit is completed
     * on the server side
     */
    +_: 'editMessageMedia',
    /** The chat the message belongs to */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_edit_media to check whether
     * the message can be edited
     */
    +message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type editMessageCaption = {|
    /**
     * Edits the message content caption. Returns the edited message after the edit
     * is completed on the server side
     */
    +_: 'editMessageCaption',
    /** The chat the message belongs to */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    +message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; 0-getOption("message_caption_length_max") characters;
     * pass null to remove caption
     */
    +caption?: formattedText$Input,
    /**
     * Pass true to show the caption above the media; otherwise, the caption will be
     * shown below the media. May be true only for animation, photo, and video messages
     */
    +show_caption_above_media?: boolean,
  |}

  declare export type editMessageReplyMarkup = {|
    /**
     * Edits the message reply markup; for bots only. Returns the edited message after
     * the edit is completed on the server side
     */
    +_: 'editMessageReplyMarkup',
    /** The chat the message belongs to */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    +message_id?: number,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
  |}

  declare export type editInlineMessageText = {|
    /** Edits the text of an inline text or game message sent via a bot; for bots only */
    +_: 'editInlineMessageText',
    /** Inline message identifier */
    +inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type editInlineMessageLiveLocation = {|
    /**
     * Edits the content of a live location in an inline message sent via a bot; for
     * bots only
     */
    +_: 'editInlineMessageLiveLocation',
    /** Inline message identifier */
    +inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    +location?: location$Input,
    /**
     * New time relative to the message send date, for which the location can be updated,
     * in seconds. If 0x7FFFFFFF specified, then the location can be updated forever.
     * Otherwise, must not exceed the current live_period by more than a day, and the
     * live location expiration date must remain in the next 90 days. Pass 0 to keep
     * the current live_period
     */
    +live_period?: number,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    +heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    +proximity_alert_radius?: number,
  |}

  declare export type editInlineMessageMedia = {|
    /**
     * Edits the media content of a message with a text, an animation, an audio, a
     * document, a photo or a video in an inline message sent via a bot; for bots only
     */
    +_: 'editInlineMessageMedia',
    /** Inline message identifier */
    +inline_message_id?: string,
    /** The new message reply markup; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type editInlineMessageCaption = {|
    /** Edits the caption of an inline message sent via a bot; for bots only */
    +_: 'editInlineMessageCaption',
    /** Inline message identifier */
    +inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
    /**
     * Pass true to show the caption above the media; otherwise, the caption will be
     * shown below the media. May be true only for animation, photo, and video messages
     */
    +show_caption_above_media?: boolean,
  |}

  declare export type editInlineMessageReplyMarkup = {|
    /** Edits the reply markup of an inline message sent via a bot; for bots only */
    +_: 'editInlineMessageReplyMarkup',
    /** Inline message identifier */
    +inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
  |}

  declare export type editMessageSchedulingState = {|
    /**
     * Edits the time when a scheduled message will be sent. Scheduling state of all
     * messages in the same album or forwarded together with the message will be also
     * changed
     */
    +_: 'editMessageSchedulingState',
    /** The chat the message belongs to */
    +chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_edit_scheduling_state to
     * check whether the message is suitable
     */
    +message_id?: number,
    /**
     * The new message scheduling state; pass null to send the message immediately.
     * Must be null for messages in the state messageSchedulingStateSendWhenVideoProcessed
     */
    +scheduling_state?: MessageSchedulingState$Input,
  |}

  declare export type setMessageFactCheck = {|
    /**
     * Changes the fact-check of a message. Can be only used if messageProperties.can_set_fact_check
     * == true
     */
    +_: 'setMessageFactCheck',
    /** The channel chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /**
     * New text of the fact-check; 0-getOption("fact_check_length_max") characters;
     * pass null to remove it. Only Bold, Italic, and TextUrl entities with https://t.me/
     * links are supported
     */
    +text?: formattedText$Input,
  |}

  declare export type sendBusinessMessage = {|
    /**
     * Sends a message on behalf of a business account; for bots only. Returns the
     * message after it was sent
     */
    +_: 'sendBusinessMessage',
    /** Unique identifier of business connection on behalf of which to send the request */
    +business_connection_id?: string,
    /** Target chat */
    +chat_id?: number,
    /** Information about the message to be replied; pass null if none */
    +reply_to?: InputMessageReplyTo$Input,
    /** Pass true to disable notification for the message */
    +disable_notification?: boolean,
    /**
     * Pass true if the content of the message must be protected from forwarding and
     * saving
     */
    +protect_content?: boolean,
    /** Identifier of the effect to apply to the message */
    +effect_id?: number | string,
    /** Markup for replying to the message; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
    /** The content of the message to be sent */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type sendBusinessMessageAlbum = {|
    /**
     * Sends 2-10 messages grouped together into an album on behalf of a business account;
     * for bots only. Currently, only audio, document, photo and video messages can
     * be grouped into an album. Documents and audio files can be only grouped in an
     * album with messages of the same type. Returns sent messages
     */
    +_: 'sendBusinessMessageAlbum',
    /** Unique identifier of business connection on behalf of which to send the request */
    +business_connection_id?: string,
    /** Target chat */
    +chat_id?: number,
    /** Information about the message to be replied; pass null if none */
    +reply_to?: InputMessageReplyTo$Input,
    /** Pass true to disable notification for the message */
    +disable_notification?: boolean,
    /**
     * Pass true if the content of the message must be protected from forwarding and
     * saving
     */
    +protect_content?: boolean,
    /** Identifier of the effect to apply to the message */
    +effect_id?: number | string,
    /**
     * Contents of messages to be sent. At most 10 messages can be added to an album.
     * All messages must have the same value of show_caption_above_media
     */
    +input_message_contents?: $ReadOnlyArray<InputMessageContent$Input>,
  |}

  declare export type editBusinessMessageText = {|
    /**
     * Edits the text of a text or game message sent on behalf of a business account;
     * for bots only
     */
    +_: 'editBusinessMessageText',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    +business_connection_id?: string,
    /** The chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type editBusinessMessageLiveLocation = {|
    /**
     * Edits the content of a live location in a message sent on behalf of a business
     * account; for bots only
     */
    +_: 'editBusinessMessageLiveLocation',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    +business_connection_id?: string,
    /** The chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    +location?: location$Input,
    /**
     * New time relative to the message send date, for which the location can be updated,
     * in seconds. If 0x7FFFFFFF specified, then the location can be updated forever.
     * Otherwise, must not exceed the current live_period by more than a day, and the
     * live location expiration date must remain in the next 90 days. Pass 0 to keep
     * the current live_period
     */
    +live_period?: number,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    +heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    +proximity_alert_radius?: number,
  |}

  declare export type editBusinessMessageMedia = {|
    /**
     * Edits the media content of a message with a text, an animation, an audio, a
     * document, a photo or a video in a message sent on behalf of a business account;
     * for bots only
     */
    +_: 'editBusinessMessageMedia',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    +business_connection_id?: string,
    /** The chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type editBusinessMessageCaption = {|
    /**
     * Edits the caption of a message sent on behalf of a business account; for bots
     * only
     */
    +_: 'editBusinessMessageCaption',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    +business_connection_id?: string,
    /** The chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max")
     * characters
     */
    +caption?: formattedText$Input,
    /**
     * Pass true to show the caption above the media; otherwise, the caption will be
     * shown below the media. May be true only for animation, photo, and video messages
     */
    +show_caption_above_media?: boolean,
  |}

  declare export type editBusinessMessageReplyMarkup = {|
    /**
     * Edits the reply markup of a message sent on behalf of a business account; for
     * bots only
     */
    +_: 'editBusinessMessageReplyMarkup',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    +business_connection_id?: string,
    /** The chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
  |}

  declare export type stopBusinessPoll = {|
    /** Stops a poll sent on behalf of a business account; for bots only */
    +_: 'stopBusinessPoll',
    /**
     * Unique identifier of business connection on behalf of which the message with
     * the poll was sent
     */
    +business_connection_id?: string,
    /** The chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message containing the poll */
    +message_id?: number,
    /** The new message reply markup; pass null if none */
    +reply_markup?: ReplyMarkup$Input,
  |}

  declare export type setBusinessMessageIsPinned = {|
    /** Pins or unpins a message sent on behalf of a business account; for bots only */
    +_: 'setBusinessMessageIsPinned',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    +business_connection_id?: string,
    /** The chat the message belongs to */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** Pass true to pin the message, pass false to unpin it */
    +is_pinned?: boolean,
  |}

  declare export type checkQuickReplyShortcutName = {|
    /** Checks validness of a name for a quick reply shortcut. Can be called synchronously */
    +_: 'checkQuickReplyShortcutName',
    /** The name of the shortcut; 1-32 characters */
    +name?: string,
  |}

  declare export type loadQuickReplyShortcuts = {|
    /**
     * Loads quick reply shortcuts created by the current user. The loaded data will
     * be sent through updateQuickReplyShortcut and updateQuickReplyShortcuts
     */
    +_: 'loadQuickReplyShortcuts',
  |}

  declare export type setQuickReplyShortcutName = {|
    /** Changes name of a quick reply shortcut */
    +_: 'setQuickReplyShortcutName',
    /** Unique identifier of the quick reply shortcut */
    +shortcut_id?: number,
    /** New name for the shortcut. Use checkQuickReplyShortcutName to check its validness */
    +name?: string,
  |}

  declare export type deleteQuickReplyShortcut = {|
    /** Deletes a quick reply shortcut */
    +_: 'deleteQuickReplyShortcut',
    /** Unique identifier of the quick reply shortcut */
    +shortcut_id?: number,
  |}

  declare export type reorderQuickReplyShortcuts = {|
    /** Changes the order of quick reply shortcuts */
    +_: 'reorderQuickReplyShortcuts',
    /** The new order of quick reply shortcuts */
    +shortcut_ids?: $ReadOnlyArray<number>,
  |}

  declare export type loadQuickReplyShortcutMessages = {|
    /**
     * Loads quick reply messages that can be sent by a given quick reply shortcut.
     * The loaded messages will be sent through updateQuickReplyShortcutMessages
     */
    +_: 'loadQuickReplyShortcutMessages',
    /** Unique identifier of the quick reply shortcut */
    +shortcut_id?: number,
  |}

  declare export type deleteQuickReplyShortcutMessages = {|
    /** Deletes specified quick reply messages */
    +_: 'deleteQuickReplyShortcutMessages',
    /** Unique identifier of the quick reply shortcut to which the messages belong */
    +shortcut_id?: number,
    /** Unique identifiers of the messages */
    +message_ids?: $ReadOnlyArray<number>,
  |}

  declare export type addQuickReplyShortcutMessage = {|
    /**
     * Adds a message to a quick reply shortcut. If shortcut doesn't exist and there
     * are less than getOption("quick_reply_shortcut_count_max") shortcuts, then a
     * new shortcut is created. The shortcut must not contain more than getOption("quick_reply_shortcut_message_count_max")
     * messages after adding the new message. Returns the added message
     */
    +_: 'addQuickReplyShortcutMessage',
    /** Name of the target shortcut */
    +shortcut_name?: string,
    /**
     * Identifier of a quick reply message in the same shortcut to be replied; pass
     * 0 if none
     */
    +reply_to_message_id?: number,
    /**
     * The content of the message to be added; inputMessagePoll, inputMessageForwarded
     * and inputMessageLocation with live_period aren't supported
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type addQuickReplyShortcutInlineQueryResultMessage = {|
    /**
     * Adds a message to a quick reply shortcut via inline bot. If shortcut doesn't
     * exist and there are less than getOption("quick_reply_shortcut_count_max") shortcuts,
     * then a new shortcut is created. The shortcut must not contain more than getOption("quick_reply_shortcut_message_count_max")
     * messages after adding the new message. Returns the added message
     */
    +_: 'addQuickReplyShortcutInlineQueryResultMessage',
    /** Name of the target shortcut */
    +shortcut_name?: string,
    /**
     * Identifier of a quick reply message in the same shortcut to be replied; pass
     * 0 if none
     */
    +reply_to_message_id?: number,
    /** Identifier of the inline query */
    +query_id?: number | string,
    /** Identifier of the inline query result */
    +result_id?: string,
    /**
     * Pass true to hide the bot, via which the message is sent. Can be used only for
     * bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"),
     * and getOption("venue_search_bot_username")
     */
    +hide_via_bot?: boolean,
  |}

  declare export type addQuickReplyShortcutMessageAlbum = {|
    /**
     * Adds 2-10 messages grouped together into an album to a quick reply shortcut.
     * Currently, only audio, document, photo and video messages can be grouped into
     * an album. Documents and audio files can be only grouped in an album with messages
     * of the same type. Returns sent messages
     */
    +_: 'addQuickReplyShortcutMessageAlbum',
    /** Name of the target shortcut */
    +shortcut_name?: string,
    /**
     * Identifier of a quick reply message in the same shortcut to be replied; pass
     * 0 if none
     */
    +reply_to_message_id?: number,
    /**
     * Contents of messages to be sent. At most 10 messages can be added to an album.
     * All messages must have the same value of show_caption_above_media
     */
    +input_message_contents?: $ReadOnlyArray<InputMessageContent$Input>,
  |}

  declare export type readdQuickReplyShortcutMessages = {|
    /**
     * Readds quick reply messages which failed to add. Can be called only for messages
     * for which messageSendingStateFailed.can_retry is true and after specified in
     * messageSendingStateFailed.retry_after time passed. If a message is readded,
     * the corresponding failed to send message is deleted. Returns the sent messages
     * in the same order as the message identifiers passed in message_ids. If a message
     * can't be readded, null will be returned instead of the message
     */
    +_: 'readdQuickReplyShortcutMessages',
    /** Name of the target shortcut */
    +shortcut_name?: string,
    /**
     * Identifiers of the quick reply messages to readd. Message identifiers must be
     * in a strictly increasing order
     */
    +message_ids?: $ReadOnlyArray<number>,
  |}

  declare export type editQuickReplyMessage = {|
    /**
     * Asynchronously edits the text, media or caption of a quick reply message. Use
     * quickReplyMessage.can_be_edited to check whether a message can be edited. Media
     * message can be edited only to a media message. The type of message content in
     * an album can't be changed with exception of replacing a photo with a video or
     * vice versa
     */
    +_: 'editQuickReplyMessage',
    /** Unique identifier of the quick reply shortcut with the message */
    +shortcut_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /**
     * New content of the message. Must be one of the following types: inputMessageText,
     * inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto
     * or inputMessageVideo
     */
    +input_message_content?: InputMessageContent$Input,
  |}

  declare export type getForumTopicDefaultIcons = {|
    /**
     * Returns the list of custom emoji, which can be used as forum topic icon by all
     * users
     */
    +_: 'getForumTopicDefaultIcons',
  |}

  declare export type createForumTopic = {|
    /**
     * Creates a topic in a forum supergroup chat; requires can_manage_topics administrator
     * or can_create_topics member right in the supergroup
     */
    +_: 'createForumTopic',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Name of the topic; 1-128 characters */
    +name?: string,
    /**
     * Icon of the topic. Icon color must be one of 0x6FB9F0, 0xFFD67E, 0xCB86DB, 0x8EEE98,
     * 0xFF93B2, or 0xFB6F5F. Telegram Premium users can use any custom emoji as topic
     * icon, other users can use only a custom emoji returned by getForumTopicDefaultIcons
     */
    +icon?: forumTopicIcon$Input,
  |}

  declare export type editForumTopic = {|
    /**
     * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics
     * right in the supergroup unless the user is creator of the topic
     */
    +_: 'editForumTopic',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Message thread identifier of the forum topic */
    +message_thread_id?: number,
    /**
     * New name of the topic; 0-128 characters. If empty, the previous topic name is
     * kept
     */
    +name?: string,
    /**
     * Pass true to edit the icon of the topic. Icon of the General topic can't be
     * edited
     */
    +edit_icon_custom_emoji?: boolean,
    /**
     * Identifier of the new custom emoji for topic icon; pass 0 to remove the custom
     * emoji. Ignored if edit_icon_custom_emoji is false. Telegram Premium users can
     * use any custom emoji, other users can use only a custom emoji returned by getForumTopicDefaultIcons
     */
    +icon_custom_emoji_id?: number | string,
  |}

  declare export type getForumTopic = {|
    /** Returns information about a forum topic */
    +_: 'getForumTopic',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Message thread identifier of the forum topic */
    +message_thread_id?: number,
  |}

  declare export type getForumTopicLink = {|
    /** Returns an HTTPS link to a topic in a forum chat. This is an offline request */
    +_: 'getForumTopicLink',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Message thread identifier of the forum topic */
    +message_thread_id?: number,
  |}

  declare export type getForumTopics = {|
    /**
     * Returns found forum topics in a forum chat. This is a temporary method for getting
     * information about topic list from the server
     */
    +_: 'getForumTopics',
    /** Identifier of the forum chat */
    +chat_id?: number,
    /** Query to search for in the forum topic's name */
    +query?: string,
    /**
     * The date starting from which the results need to be fetched. Use 0 or any date
     * in the future to get results from the last topic
     */
    +offset_date?: number,
    /**
     * The message identifier of the last message in the last found topic, or 0 for
     * the first request
     */
    +offset_message_id?: number,
    /** The message thread identifier of the last found topic, or 0 for the first request */
    +offset_message_thread_id?: number,
    /**
     * The maximum number of forum topics to be returned; up to 100. For optimal performance,
     * the number of returned forum topics is chosen by TDLib and can be smaller than
     * the specified limit
     */
    +limit?: number,
  |}

  declare export type setForumTopicNotificationSettings = {|
    /** Changes the notification settings of a forum topic */
    +_: 'setForumTopicNotificationSettings',
    /** Chat identifier */
    +chat_id?: number,
    /** Message thread identifier of the forum topic */
    +message_thread_id?: number,
    /**
     * New notification settings for the forum topic. If the topic is muted for more
     * than 366 days, it is considered to be muted forever
     */
    +notification_settings?: chatNotificationSettings$Input,
  |}

  declare export type toggleForumTopicIsClosed = {|
    /**
     * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics
     * right in the supergroup unless the user is creator of the topic
     */
    +_: 'toggleForumTopicIsClosed',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Message thread identifier of the forum topic */
    +message_thread_id?: number,
    /** Pass true to close the topic; pass false to reopen it */
    +is_closed?: boolean,
  |}

  declare export type toggleGeneralForumTopicIsHidden = {|
    /**
     * Toggles whether a General topic is hidden in a forum supergroup chat; requires
     * can_manage_topics right in the supergroup
     */
    +_: 'toggleGeneralForumTopicIsHidden',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Pass true to hide and close the General topic; pass false to unhide it */
    +is_hidden?: boolean,
  |}

  declare export type toggleForumTopicIsPinned = {|
    /**
     * Changes the pinned state of a forum topic; requires can_manage_topics right
     * in the supergroup. There can be up to getOption("pinned_forum_topic_count_max")
     * pinned forum topics
     */
    +_: 'toggleForumTopicIsPinned',
    /** Chat identifier */
    +chat_id?: number,
    /** Message thread identifier of the forum topic */
    +message_thread_id?: number,
    /** Pass true to pin the topic; pass false to unpin it */
    +is_pinned?: boolean,
  |}

  declare export type setPinnedForumTopics = {|
    /**
     * Changes the order of pinned forum topics; requires can_manage_topics right in
     * the supergroup
     */
    +_: 'setPinnedForumTopics',
    /** Chat identifier */
    +chat_id?: number,
    /** The new list of pinned forum topics */
    +message_thread_ids?: $ReadOnlyArray<number>,
  |}

  declare export type deleteForumTopic = {|
    /**
     * Deletes all messages in a forum topic; requires can_delete_messages administrator
     * right in the supergroup unless the user is creator of the topic, the topic has
     * no messages from other users and has at most 11 messages
     */
    +_: 'deleteForumTopic',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Message thread identifier of the forum topic */
    +message_thread_id?: number,
  |}

  declare export type getEmojiReaction = {|
    /**
     * Returns information about an emoji reaction. Returns a 404 error if the reaction
     * is not found
     */
    +_: 'getEmojiReaction',
    /** Text representation of the reaction */
    +emoji?: string,
  |}

  declare export type getCustomEmojiReactionAnimations = {|
    /** Returns TGS stickers with generic animations for custom emoji reactions */
    +_: 'getCustomEmojiReactionAnimations',
  |}

  declare export type getMessageAvailableReactions = {|
    /**
     * Returns reactions, which can be added to a message. The list can change after
     * updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo
     * for the message
     */
    +_: 'getMessageAvailableReactions',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** Number of reaction per row, 5-25 */
    +row_size?: number,
  |}

  declare export type clearRecentReactions = {|
    /** Clears the list of recently used reactions */
    +_: 'clearRecentReactions',
  |}

  declare export type addMessageReaction = {|
    /**
     * Adds a reaction or a tag to a message. Use getMessageAvailableReactions to receive
     * the list of available reactions for the message
     */
    +_: 'addMessageReaction',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /**
     * Type of the reaction to add. Use addPendingPaidMessageReaction instead to add
     * the paid reaction
     */
    +reaction_type?: ReactionType$Input,
    /** Pass true if the reaction is added with a big animation */
    +is_big?: boolean,
    /**
     * Pass true if the reaction needs to be added to recent reactions; tags are never
     * added to the list of recent reactions
     */
    +update_recent_reactions?: boolean,
  |}

  declare export type removeMessageReaction = {|
    /** Removes a reaction from a message. A chosen reaction can always be removed */
    +_: 'removeMessageReaction',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** Type of the reaction to remove. The paid reaction can't be removed */
    +reaction_type?: ReactionType$Input,
  |}

  declare export type getChatAvailablePaidMessageReactionSenders = {|
    /**
     * Returns the list of message sender identifiers, which can be used to send a
     * paid reaction in a chat
     */
    +_: 'getChatAvailablePaidMessageReactionSenders',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type addPendingPaidMessageReaction = {|
    /**
     * Adds the paid message reaction to a message. Use getMessageAvailableReactions
     * to check whether the reaction is available for the message
     */
    +_: 'addPendingPaidMessageReaction',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /**
     * Number of Telegram Stars to be used for the reaction. The total number of pending
     * paid reactions must not exceed getOption("paid_reaction_star_count_max")
     */
    +star_count?: number,
    /**
     * Type of the paid reaction; pass null if the user didn't choose reaction type
     * explicitly, for example, the reaction is set from the message bubble
     */
    +type?: PaidReactionType$Input,
  |}

  declare export type commitPendingPaidMessageReactions = {|
    /** Applies all pending paid reactions on a message */
    +_: 'commitPendingPaidMessageReactions',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
  |}

  declare export type removePendingPaidMessageReactions = {|
    /** Removes all pending paid reactions on a message */
    +_: 'removePendingPaidMessageReactions',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
  |}

  declare export type setPaidMessageReactionType = {|
    /**
     * Changes type of paid message reaction of the current user on a message. The
     * message must have paid reaction added by the current user
     */
    +_: 'setPaidMessageReactionType',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** New type of the paid reaction */
    +type?: PaidReactionType$Input,
  |}

  declare export type setMessageReactions = {|
    /** Sets reactions on a message; for bots only */
    +_: 'setMessageReactions',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** Types of the reaction to set; pass an empty list to remove the reactions */
    +reaction_types?: $ReadOnlyArray<ReactionType$Input>,
    /** Pass true if the reactions are added with a big animation */
    +is_big?: boolean,
  |}

  declare export type getMessageAddedReactions = {|
    /** Returns reactions added for a message, along with their sender */
    +_: 'getMessageAddedReactions',
    /** Identifier of the chat to which the message belongs */
    +chat_id?: number,
    /**
     * Identifier of the message. Use message.interaction_info.reactions.can_get_added_reactions
     * to check whether added reactions can be received for the message
     */
    +message_id?: number,
    /**
     * Type of the reactions to return; pass null to return all added reactions; reactionTypePaid
     * isn't supported
     */
    +reaction_type?: ReactionType$Input,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of reactions to be returned; must be positive and can't be
     * greater than 100
     */
    +limit?: number,
  |}

  declare export type setDefaultReactionType = {|
    /** Changes type of default reaction for the current user */
    +_: 'setDefaultReactionType',
    /** New type of the default reaction. The paid reaction can't be set as default */
    +reaction_type?: ReactionType$Input,
  |}

  declare export type getSavedMessagesTags = {|
    /** Returns tags used in Saved Messages or a Saved Messages topic */
    +_: 'getSavedMessagesTags',
    /**
     * Identifier of Saved Messages topic which tags will be returned; pass 0 to get
     * all Saved Messages tags
     */
    +saved_messages_topic_id?: number,
  |}

  declare export type setSavedMessagesTagLabel = {|
    /** Changes label of a Saved Messages tag; for Telegram Premium users only */
    +_: 'setSavedMessagesTagLabel',
    /** The tag which label will be changed */
    +tag?: ReactionType$Input,
    /** New label for the tag; 0-12 characters */
    +label?: string,
  |}

  declare export type getMessageEffect = {|
    /**
     * Returns information about a message effect. Returns a 404 error if the effect
     * is not found
     */
    +_: 'getMessageEffect',
    /** Unique identifier of the effect */
    +effect_id?: number | string,
  |}

  declare export type searchQuote = {|
    /**
     * Searches for a given quote in a text. Returns found quote start position in
     * UTF-16 code units. Returns a 404 error if the quote is not found. Can be called
     * synchronously
     */
    +_: 'searchQuote',
    /** Text in which to search for the quote */
    +text?: formattedText$Input,
    /** Quote to search for */
    +quote?: formattedText$Input,
    /** Approximate quote position in UTF-16 code units */
    +quote_position?: number,
  |}

  declare export type getTextEntities = {|
    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card
     * numbers, URLs, and email addresses) found in the text. Can be called synchronously
     */
    +_: 'getTextEntities',
    /** The text in which to look for entities */
    +text?: string,
  |}

  declare export type parseTextEntities = {|
    /**
     * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote,
     * ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities from
     * a marked-up text. Can be called synchronously
     */
    +_: 'parseTextEntities',
    /** The text to parse */
    +text?: string,
    /** Text parse mode */
    +parse_mode?: TextParseMode$Input,
  |}

  declare export type parseMarkdown = {|
    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup errors.
     * Can be called synchronously
     */
    +_: 'parseMarkdown',
    /**
     * The text to parse. For example, "__italic__ ~~strikethrough~~ ||spoiler|| **bold**
     * `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
     */
    +text?: formattedText$Input,
  |}

  declare export type getMarkdownText = {|
    /**
     * Replaces text entities with Markdown formatting in a human-friendly format.
     * Entities that can't be represented in Markdown unambiguously are kept as is.
     * Can be called synchronously
     */
    +_: 'getMarkdownText',
    /** The text */
    +text?: formattedText$Input,
  |}

  declare export type getCountryFlagEmoji = {|
    /**
     * Returns an emoji for the given country. Returns an empty string on failure.
     * Can be called synchronously
     */
    +_: 'getCountryFlagEmoji',
    /** A two-letter ISO 3166-1 alpha-2 country code as received from getCountries */
    +country_code?: string,
  |}

  declare export type getFileMimeType = {|
    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an empty
     * string on failure. Can be called synchronously
     */
    +_: 'getFileMimeType',
    /** The name of the file or path to the file */
    +file_name?: string,
  |}

  declare export type getFileExtension = {|
    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an empty
     * string on failure. Can be called synchronously
     */
    +_: 'getFileExtension',
    /** The MIME type of the file */
    +mime_type?: string,
  |}

  declare export type cleanFileName = {|
    /**
     * Removes potentially dangerous characters from the name of a file. Returns an
     * empty string on failure. Can be called synchronously
     */
    +_: 'cleanFileName',
    /** File name or path to the file */
    +file_name?: string,
  |}

  declare export type getLanguagePackString = {|
    /**
     * Returns a string stored in the local database from the specified localization
     * target and language pack by its key. Returns a 404 error if the string is not
     * found. Can be called synchronously
     */
    +_: 'getLanguagePackString',
    /** Path to the language pack database in which strings are stored */
    +language_pack_database_path?: string,
    /** Localization target to which the language pack belongs */
    +localization_target?: string,
    /** Language pack identifier */
    +language_pack_id?: string,
    /** Language pack key of the string to be returned */
    +key?: string,
  |}

  declare export type getJsonValue = {|
    /**
     * Converts a JSON-serialized string to corresponding JsonValue object. Can be
     * called synchronously
     */
    +_: 'getJsonValue',
    /** The JSON-serialized string */
    +json?: string,
  |}

  declare export type getJsonString = {|
    /**
     * Converts a JsonValue object to corresponding JSON-serialized string. Can be
     * called synchronously
     */
    +_: 'getJsonString',
    /** The JsonValue object */
    +json_value?: JsonValue$Input,
  |}

  declare export type getThemeParametersJsonString = {|
    /**
     * Converts a themeParameters object to corresponding JSON-serialized string. Can
     * be called synchronously
     */
    +_: 'getThemeParametersJsonString',
    /** Theme parameters to convert to JSON */
    +theme?: themeParameters$Input,
  |}

  declare export type setPollAnswer = {|
    /**
     * Changes the user answer to a poll. A poll in quiz mode can be answered only
     * once
     */
    +_: 'setPollAnswer',
    /** Identifier of the chat to which the poll belongs */
    +chat_id?: number,
    /** Identifier of the message containing the poll */
    +message_id?: number,
    /**
     * 0-based identifiers of answer options, chosen by the user. User can choose more
     * than 1 answer option only is the poll allows multiple answers
     */
    +option_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getPollVoters = {|
    /**
     * Returns message senders voted for the specified option in a non-anonymous polls.
     * For optimal performance, the number of returned users is chosen by TDLib
     */
    +_: 'getPollVoters',
    /** Identifier of the chat to which the poll belongs */
    +chat_id?: number,
    /** Identifier of the message containing the poll */
    +message_id?: number,
    /** 0-based identifier of the answer option */
    +option_id?: number,
    /** Number of voters to skip in the result; must be non-negative */
    +offset?: number,
    /**
     * The maximum number of voters to be returned; must be positive and can't be greater
     * than 50. For optimal performance, the number of returned voters is chosen by
     * TDLib and can be smaller than the specified limit, even if the end of the voter
     * list has not been reached
     */
    +limit?: number,
  |}

  declare export type stopPoll = {|
    /** Stops a poll */
    +_: 'stopPoll',
    /** Identifier of the chat to which the poll belongs */
    +chat_id?: number,
    /**
     * Identifier of the message containing the poll. Use messageProperties.can_be_edited
     * to check whether the poll can be stopped
     */
    +message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    +reply_markup?: ReplyMarkup$Input,
  |}

  declare export type hideSuggestedAction = {|
    /** Hides a suggested action */
    +_: 'hideSuggestedAction',
    /** Suggested action to hide */
    +action?: SuggestedAction$Input,
  |}

  declare export type hideContactCloseBirthdays = {|
    /** Hides the list of contacts that have close birthdays for 24 hours */
    +_: 'hideContactCloseBirthdays',
  |}

  declare export type getBusinessConnection = {|
    /**
     * Returns information about a business connection by its identifier; for bots
     * only
     */
    +_: 'getBusinessConnection',
    /** Identifier of the business connection to return */
    +connection_id?: string,
  |}

  declare export type getLoginUrlInfo = {|
    /**
     * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl.
     * The method needs to be called when the user presses the button
     */
    +_: 'getLoginUrlInfo',
    /** Chat identifier of the message with the button */
    +chat_id?: number,
    /** Message identifier of the message with the button. The message must not be scheduled */
    +message_id?: number,
    /** Button identifier */
    +button_id?: number,
  |}

  declare export type getLoginUrl = {|
    /**
     * Returns an HTTP URL which can be used to automatically authorize the user on
     * a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
     * Use the method getLoginUrlInfo to find whether a prior user confirmation is
     * needed. If an error is returned, then the button must be handled as an ordinary
     * URL button
     */
    +_: 'getLoginUrl',
    /** Chat identifier of the message with the button */
    +chat_id?: number,
    /** Message identifier of the message with the button */
    +message_id?: number,
    /** Button identifier */
    +button_id?: number,
    /** Pass true to allow the bot to send messages to the current user */
    +allow_write_access?: boolean,
  |}

  declare export type shareUsersWithBot = {|
    /**
     * Shares users after pressing a keyboardButtonTypeRequestUsers button with the
     * bot
     */
    +_: 'shareUsersWithBot',
    /** Identifier of the chat with the bot */
    +chat_id?: number,
    /** Identifier of the message with the button */
    +message_id?: number,
    /** Identifier of the button */
    +button_id?: number,
    /** Identifiers of the shared users */
    +shared_user_ids?: $ReadOnlyArray<number>,
    /**
     * Pass true to check that the users can be shared by the button instead of actually
     * sharing them
     */
    +only_check?: boolean,
  |}

  declare export type shareChatWithBot = {|
    /**
     * Shares a chat after pressing a keyboardButtonTypeRequestChat button with the
     * bot
     */
    +_: 'shareChatWithBot',
    /** Identifier of the chat with the bot */
    +chat_id?: number,
    /** Identifier of the message with the button */
    +message_id?: number,
    /** Identifier of the button */
    +button_id?: number,
    /** Identifier of the shared chat */
    +shared_chat_id?: number,
    /**
     * Pass true to check that the chat can be shared by the button instead of actually
     * sharing it. Doesn't check bot_is_member and bot_administrator_rights restrictions.
     * If the bot must be a member, then all chats from getGroupsInCommon and all chats,
     * where the user can add the bot, are suitable. In the latter case the bot will
     * be automatically added to the chat. If the bot must be an administrator, then
     * all chats, where the bot already has requested rights or can be added to administrators
     * by the user, are suitable. In the latter case the bot will be automatically
     * granted requested rights
     */
    +only_check?: boolean,
  |}

  declare export type getInlineQueryResults = {|
    /**
     * Sends an inline query to a bot and returns its results. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    +_: 'getInlineQueryResults',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** Identifier of the chat where the query was sent */
    +chat_id?: number,
    /** Location of the user; pass null if unknown or the bot doesn't need user's location */
    +user_location?: location$Input,
    /** Text of the query */
    +query?: string,
    /**
     * Offset of the first entry to return; use empty string to get the first chunk
     * of results
     */
    +offset?: string,
  |}

  declare export type answerInlineQuery = {|
    /** Sets the result of an inline query; for bots only */
    +_: 'answerInlineQuery',
    /** Identifier of the inline query */
    +inline_query_id?: number | string,
    /**
     * Pass true if results may be cached and returned only for the user that sent
     * the query. By default, results may be returned to any user who sends the same
     * query
     */
    +is_personal?: boolean,
    /** Button to be shown above inline query results; pass null if none */
    +button?: inlineQueryResultsButton$Input,
    /** The results of the query */
    +results?: $ReadOnlyArray<InputInlineQueryResult$Input>,
    /** Allowed time to cache the results of the query, in seconds */
    +cache_time?: number,
    /**
     * Offset for the next inline query; pass an empty string if there are no more
     * results
     */
    +next_offset?: string,
  |}

  declare export type savePreparedInlineMessage = {|
    /** Saves an inline message to be sent by the given user; for bots only */
    +_: 'savePreparedInlineMessage',
    /** Identifier of the user */
    +user_id?: number,
    /** The description of the message */
    +result?: InputInlineQueryResult$Input,
    /** Types of the chats to which the message can be sent */
    +chat_types?: targetChatTypes$Input,
  |}

  declare export type getPreparedInlineMessage = {|
    /** Saves an inline message to be sent by the given user */
    +_: 'getPreparedInlineMessage',
    /** Identifier of the bot that created the message */
    +bot_user_id?: number,
    /** Identifier of the prepared message */
    +prepared_message_id?: string,
  |}

  declare export type getGrossingWebAppBots = {|
    /** Returns the most grossing Web App bots */
    +_: 'getGrossingWebAppBots',
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /** The maximum number of bots to be returned; up to 100 */
    +limit?: number,
  |}

  declare export type searchWebApp = {|
    /**
     * Returns information about a Web App by its short name. Returns a 404 error if
     * the Web App is not found
     */
    +_: 'searchWebApp',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** Short name of the Web App */
    +web_app_short_name?: string,
  |}

  declare export type getWebAppPlaceholder = {|
    /**
     * Returns a default placeholder for Web Apps of a bot; this is an offline request.
     * Returns a 404 error if the placeholder isn't known
     */
    +_: 'getWebAppPlaceholder',
    /** Identifier of the target bot */
    +bot_user_id?: number,
  |}

  declare export type getWebAppLinkUrl = {|
    /**
     * Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp
     * is clicked
     */
    +_: 'getWebAppLinkUrl',
    /** Identifier of the chat in which the link was clicked; pass 0 if none */
    +chat_id?: number,
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** Short name of the Web App */
    +web_app_short_name?: string,
    /** Start parameter from internalLinkTypeWebApp */
    +start_parameter?: string,
    /** Pass true if the current user allowed the bot to send them messages */
    +allow_write_access?: boolean,
    /** Parameters to use to open the Web App */
    +parameters?: webAppOpenParameters$Input,
  |}

  declare export type getMainWebApp = {|
    /** Returns information needed to open the main Web App of a bot */
    +_: 'getMainWebApp',
    /** Identifier of the chat in which the Web App is opened; pass 0 if none */
    +chat_id?: number,
    /**
     * Identifier of the target bot. If the bot is restricted for the current user,
     * then show an error instead of calling the method
     */
    +bot_user_id?: number,
    /** Start parameter from internalLinkTypeMainWebApp */
    +start_parameter?: string,
    /** Parameters to use to open the Web App */
    +parameters?: webAppOpenParameters$Input,
  |}

  declare export type getWebAppUrl = {|
    /**
     * Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp
     * button, or an inlineQueryResultsButtonTypeWebApp button
     */
    +_: 'getWebAppUrl',
    /**
     * Identifier of the target bot. If the bot is restricted for the current user,
     * then show an error instead of calling the method
     */
    +bot_user_id?: number,
    /**
     * The URL from a keyboardButtonTypeWebApp button, inlineQueryResultsButtonTypeWebApp
     * button, or an empty string when the bot is opened from the side menu
     */
    +url?: string,
    /** Parameters to use to open the Web App */
    +parameters?: webAppOpenParameters$Input,
  |}

  declare export type sendWebAppData = {|
    /** Sends data received from a keyboardButtonTypeWebApp Web App to a bot */
    +_: 'sendWebAppData',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    +button_text?: string,
    /** The data */
    +data?: string,
  |}

  declare export type openWebApp = {|
    /**
     * Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton
     * button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp
     * button. For each bot, a confirmation alert about data sent to the bot must be
     * shown once
     */
    +_: 'openWebApp',
    /**
     * Identifier of the chat in which the Web App is opened. The Web App can't be
     * opened in secret chats
     */
    +chat_id?: number,
    /**
     * Identifier of the bot, providing the Web App. If the bot is restricted for the
     * current user, then show an error instead of calling the method
     */
    +bot_user_id?: number,
    /**
     * The URL from an inlineKeyboardButtonTypeWebApp button, a botMenuButton button,
     * an internalLinkTypeAttachmentMenuBot link, or an empty string otherwise
     */
    +url?: string,
    /** If not 0, the message thread identifier in which the message will be sent */
    +message_thread_id?: number,
    /**
     * Information about the message or story to be replied in the message sent by
     * the Web App; pass null if none
     */
    +reply_to?: InputMessageReplyTo$Input,
    /** Parameters to use to open the Web App */
    +parameters?: webAppOpenParameters$Input,
  |}

  declare export type closeWebApp = {|
    /** Informs TDLib that a previously opened Web App was closed */
    +_: 'closeWebApp',
    /** Identifier of Web App launch, received from openWebApp */
    +web_app_launch_id?: number | string,
  |}

  declare export type answerWebAppQuery = {|
    /**
     * Sets the result of interaction with a Web App and sends corresponding message
     * on behalf of the user to the chat from which the query originated; for bots
     * only
     */
    +_: 'answerWebAppQuery',
    /** Identifier of the Web App query */
    +web_app_query_id?: string,
    /** The result of the query */
    +result?: InputInlineQueryResult$Input,
  |}

  declare export type checkWebAppFileDownload = {|
    /** Checks whether a file can be downloaded and saved locally by Web App request */
    +_: 'checkWebAppFileDownload',
    /** Identifier of the bot, providing the Web App */
    +bot_user_id?: number,
    /** Name of the file */
    +file_name?: string,
    /** URL of the file */
    +url?: string,
  |}

  declare export type getCallbackQueryAnswer = {|
    /**
     * Sends a callback query to a bot and returns an answer. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    +_: 'getCallbackQueryAnswer',
    /** Identifier of the chat with the message */
    +chat_id?: number,
    /**
     * Identifier of the message from which the query originated. The message must
     * not be scheduled
     */
    +message_id?: number,
    /** Query payload */
    +payload?: CallbackQueryPayload$Input,
  |}

  declare export type answerCallbackQuery = {|
    /** Sets the result of a callback query; for bots only */
    +_: 'answerCallbackQuery',
    /** Identifier of the callback query */
    +callback_query_id?: number | string,
    /** Text of the answer */
    +text?: string,
    /** Pass true to show an alert to the user instead of a toast notification */
    +show_alert?: boolean,
    /** URL to be opened */
    +url?: string,
    /** Time during which the result of the query can be cached, in seconds */
    +cache_time?: number,
  |}

  declare export type answerShippingQuery = {|
    /** Sets the result of a shipping query; for bots only */
    +_: 'answerShippingQuery',
    /** Identifier of the shipping query */
    +shipping_query_id?: number | string,
    /** Available shipping options */
    +shipping_options?: $ReadOnlyArray<shippingOption$Input>,
    /** An error message, empty on success */
    +error_message?: string,
  |}

  declare export type answerPreCheckoutQuery = {|
    /** Sets the result of a pre-checkout query; for bots only */
    +_: 'answerPreCheckoutQuery',
    /** Identifier of the pre-checkout query */
    +pre_checkout_query_id?: number | string,
    /** An error message, empty on success */
    +error_message?: string,
  |}

  declare export type setGameScore = {|
    /** Updates the game score of the specified user in the game; for bots only */
    +_: 'setGameScore',
    /** The chat to which the message with the game belongs */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** Pass true to edit the game message to include the current scoreboard */
    +edit_message?: boolean,
    /** User identifier */
    +user_id?: number,
    /** The new score */
    +score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    +force?: boolean,
  |}

  declare export type setInlineGameScore = {|
    /** Updates the game score of the specified user in a game; for bots only */
    +_: 'setInlineGameScore',
    /** Inline message identifier */
    +inline_message_id?: string,
    /** Pass true to edit the game message to include the current scoreboard */
    +edit_message?: boolean,
    /** User identifier */
    +user_id?: number,
    /** The new score */
    +score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    +force?: boolean,
  |}

  declare export type getGameHighScores = {|
    /**
     * Returns the high scores for a game and some part of the high score table in
     * the range of the specified user; for bots only
     */
    +_: 'getGameHighScores',
    /** The chat that contains the message with the game */
    +chat_id?: number,
    /** Identifier of the message */
    +message_id?: number,
    /** User identifier */
    +user_id?: number,
  |}

  declare export type getInlineGameHighScores = {|
    /**
     * Returns game high scores and some part of the high score table in the range
     * of the specified user; for bots only
     */
    +_: 'getInlineGameHighScores',
    /** Inline message identifier */
    +inline_message_id?: string,
    /** User identifier */
    +user_id?: number,
  |}

  declare export type deleteChatReplyMarkup = {|
    /**
     * Deletes the default reply markup from a chat. Must be called after a one-time
     * keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup
     * update will be sent if the reply markup is changed
     */
    +_: 'deleteChatReplyMarkup',
    /** Chat identifier */
    +chat_id?: number,
    /** The message identifier of the used keyboard */
    +message_id?: number,
  |}

  declare export type sendChatAction = {|
    /** Sends a notification about user activity in a chat */
    +_: 'sendChatAction',
    /** Chat identifier */
    +chat_id?: number,
    /** If not 0, the message thread identifier in which the action was performed */
    +message_thread_id?: number,
    /**
     * Unique identifier of business connection on behalf of which to send the request;
     * for bots only
     */
    +business_connection_id?: string,
    /** The action description; pass null to cancel the currently active action */
    +action?: ChatAction$Input,
  |}

  declare export type openChat = {|
    /**
     * Informs TDLib that the chat is opened by the user. Many useful activities depend
     * on the chat being opened or closed (e.g., in supergroups and channels all updates
     * are received only for opened chats)
     */
    +_: 'openChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type closeChat = {|
    /**
     * Informs TDLib that the chat is closed by the user. Many useful activities depend
     * on the chat being opened or closed
     */
    +_: 'closeChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type viewMessages = {|
    /**
     * Informs TDLib that messages are being viewed by the user. Sponsored messages
     * must be marked as viewed only when the entire text of the message is shown on
     * the screen (excluding the button). Many useful activities depend on whether
     * the messages are currently being viewed or not (e.g., marking messages as read,
     * incrementing a view counter, updating a view counter, removing deleted messages
     * in supergroups and channels)
     */
    +_: 'viewMessages',
    /** Chat identifier */
    +chat_id?: number,
    /** The identifiers of the messages being viewed */
    +message_ids?: $ReadOnlyArray<number>,
    /**
     * Source of the message view; pass null to guess the source based on chat open
     * state
     */
    +source?: MessageSource$Input,
    /** Pass true to mark as read the specified messages even the chat is closed */
    +force_read?: boolean,
  |}

  declare export type openMessageContent = {|
    /**
     * Informs TDLib that the message content has been opened (e.g., the user has opened
     * a photo, video, document, location or venue, or has listened to an audio file
     * or voice note message). An updateMessageContentOpened update will be generated
     * if something has changed
     */
    +_: 'openMessageContent',
    /** Chat identifier of the message */
    +chat_id?: number,
    /** Identifier of the message with the opened content */
    +message_id?: number,
  |}

  declare export type clickAnimatedEmojiMessage = {|
    /**
     * Informs TDLib that a message with an animated emoji was clicked by the user.
     * Returns a big animated sticker to be played or a 404 error if usual animation
     * needs to be played
     */
    +_: 'clickAnimatedEmojiMessage',
    /** Chat identifier of the message */
    +chat_id?: number,
    /** Identifier of the clicked message */
    +message_id?: number,
  |}

  declare export type getInternalLink = {|
    /** Returns an HTTPS or a tg: link with the given type. Can be called before authorization */
    +_: 'getInternalLink',
    /** Expected type of the link */
    +type?: InternalLinkType$Input,
    /**
     * Pass true to create an HTTPS link (only available for some link types); pass
     * false to create a tg: link
     */
    +is_http?: boolean,
  |}

  declare export type getInternalLinkType = {|
    /**
     * Returns information about the type of internal link. Returns a 404 error if
     * the link is not internal. Can be called before authorization
     */
    +_: 'getInternalLinkType',
    /** The link */
    +link?: string,
  |}

  declare export type getExternalLinkInfo = {|
    /**
     * Returns information about an action to be done when the current user clicks
     * an external link. Don't use this method for links from secret chats if link
     * preview is disabled in secret chats
     */
    +_: 'getExternalLinkInfo',
    /** The link */
    +link?: string,
  |}

  declare export type getExternalLink = {|
    /**
     * Returns an HTTP URL which can be used to automatically authorize the current
     * user on a website after clicking an HTTP link. Use the method getExternalLinkInfo
     * to find whether a prior user confirmation is needed
     */
    +_: 'getExternalLink',
    /** The HTTP link */
    +link?: string,
    /**
     * Pass true if the current user allowed the bot, returned in getExternalLinkInfo,
     * to send them messages
     */
    +allow_write_access?: boolean,
  |}

  declare export type readAllChatMentions = {|
    /** Marks all mentions in a chat as read */
    +_: 'readAllChatMentions',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type readAllMessageThreadMentions = {|
    /** Marks all mentions in a forum topic as read */
    +_: 'readAllMessageThreadMentions',
    /** Chat identifier */
    +chat_id?: number,
    /** Message thread identifier in which mentions are marked as read */
    +message_thread_id?: number,
  |}

  declare export type readAllChatReactions = {|
    /** Marks all reactions in a chat or a forum topic as read */
    +_: 'readAllChatReactions',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type readAllMessageThreadReactions = {|
    /** Marks all reactions in a forum topic as read */
    +_: 'readAllMessageThreadReactions',
    /** Chat identifier */
    +chat_id?: number,
    /** Message thread identifier in which reactions are marked as read */
    +message_thread_id?: number,
  |}

  declare export type createPrivateChat = {|
    /** Returns an existing chat corresponding to a given user */
    +_: 'createPrivateChat',
    /** User identifier */
    +user_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    +force?: boolean,
  |}

  declare export type createBasicGroupChat = {|
    /** Returns an existing chat corresponding to a known basic group */
    +_: 'createBasicGroupChat',
    /** Basic group identifier */
    +basic_group_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    +force?: boolean,
  |}

  declare export type createSupergroupChat = {|
    /** Returns an existing chat corresponding to a known supergroup or channel */
    +_: 'createSupergroupChat',
    /** Supergroup or channel identifier */
    +supergroup_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    +force?: boolean,
  |}

  declare export type createSecretChat = {|
    /** Returns an existing chat corresponding to a known secret chat */
    +_: 'createSecretChat',
    /** Secret chat identifier */
    +secret_chat_id?: number,
  |}

  declare export type createNewBasicGroupChat = {|
    /**
     * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate.
     * Returns information about the newly created chat
     */
    +_: 'createNewBasicGroupChat',
    /**
     * Identifiers of users to be added to the basic group; may be empty to create
     * a basic group without other members
     */
    +user_ids?: $ReadOnlyArray<number>,
    /** Title of the new basic group; 1-128 characters */
    +title?: string,
    /**
     * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400
     * and be divisible by 86400. If 0, then messages aren't deleted automatically
     */
    +message_auto_delete_time?: number,
  |}

  declare export type createNewSupergroupChat = {|
    /**
     * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate.
     * Returns the newly created chat
     */
    +_: 'createNewSupergroupChat',
    /** Title of the new chat; 1-128 characters */
    +title?: string,
    /** Pass true to create a forum supergroup chat */
    +is_forum?: boolean,
    /** Pass true to create a channel chat; ignored if a forum is created */
    +is_channel?: boolean,
    /** Chat description; 0-255 characters */
    +description?: string,
    /**
     * Chat location if a location-based supergroup is being created; pass null to
     * create an ordinary supergroup chat
     */
    +location?: chatLocation$Input,
    /**
     * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400
     * and be divisible by 86400. If 0, then messages aren't deleted automatically
     */
    +message_auto_delete_time?: number,
    /** Pass true to create a supergroup for importing messages using importMessages */
    +for_import?: boolean,
  |}

  declare export type createNewSecretChat = {|
    /** Creates a new secret chat. Returns the newly created chat */
    +_: 'createNewSecretChat',
    /** Identifier of the target user */
    +user_id?: number,
  |}

  declare export type upgradeBasicGroupChatToSupergroupChat = {|
    /**
     * Creates a new supergroup from an existing basic group and sends a corresponding
     * messageChatUpgradeTo and messageChatUpgradeFrom; requires owner privileges.
     * Deactivates the original basic group
     */
    +_: 'upgradeBasicGroupChatToSupergroupChat',
    /** Identifier of the chat to upgrade */
    +chat_id?: number,
  |}

  declare export type getChatListsToAddChat = {|
    /** Returns chat lists to which the chat can be added. This is an offline request */
    +_: 'getChatListsToAddChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type addChatToList = {|
    /**
     * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive
     * chat lists, so it is automatically removed from another one if needed
     */
    +_: 'addChatToList',
    /** Chat identifier */
    +chat_id?: number,
    /** The chat list. Use getChatListsToAddChat to get suitable chat lists */
    +chat_list?: ChatList$Input,
  |}

  declare export type getChatFolder = {|
    /** Returns information about a chat folder by its identifier */
    +_: 'getChatFolder',
    /** Chat folder identifier */
    +chat_folder_id?: number,
  |}

  declare export type createChatFolder = {|
    /**
     * Creates new chat folder. Returns information about the created chat folder.
     * There can be up to getOption("chat_folder_count_max") chat folders, but the
     * limit can be increased with Telegram Premium
     */
    +_: 'createChatFolder',
    /** The new chat folder */
    +folder?: chatFolder$Input,
  |}

  declare export type editChatFolder = {|
    /** Edits existing chat folder. Returns information about the edited chat folder */
    +_: 'editChatFolder',
    /** Chat folder identifier */
    +chat_folder_id?: number,
    /** The edited chat folder */
    +folder?: chatFolder$Input,
  |}

  declare export type deleteChatFolder = {|
    /** Deletes existing chat folder */
    +_: 'deleteChatFolder',
    /** Chat folder identifier */
    +chat_folder_id?: number,
    /**
     * Identifiers of the chats to leave. The chats must be pinned or always included
     * in the folder
     */
    +leave_chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getChatFolderChatsToLeave = {|
    /**
     * Returns identifiers of pinned or always included chats from a chat folder, which
     * are suggested to be left when the chat folder is deleted
     */
    +_: 'getChatFolderChatsToLeave',
    /** Chat folder identifier */
    +chat_folder_id?: number,
  |}

  declare export type getChatFolderChatCount = {|
    /**
     * Returns approximate number of chats in a being created chat folder. Main and
     * archive chat lists must be fully preloaded for this function to work correctly
     */
    +_: 'getChatFolderChatCount',
    /** The new chat folder */
    +folder?: chatFolder$Input,
  |}

  declare export type reorderChatFolders = {|
    /** Changes the order of chat folders */
    +_: 'reorderChatFolders',
    /** Identifiers of chat folders in the new correct order */
    +chat_folder_ids?: $ReadOnlyArray<number>,
    /**
     * Position of the main chat list among chat folders, 0-based. Can be non-zero
     * only for Premium users
     */
    +main_chat_list_position?: number,
  |}

  declare export type toggleChatFolderTags = {|
    /** Toggles whether chat folder tags are enabled */
    +_: 'toggleChatFolderTags',
    /** Pass true to enable folder tags; pass false to disable them */
    +are_tags_enabled?: boolean,
  |}

  declare export type getRecommendedChatFolders = {|
    /** Returns recommended chat folders for the current user */
    +_: 'getRecommendedChatFolders',
  |}

  declare export type getChatFolderDefaultIconName = {|
    /** Returns default icon name for a folder. Can be called synchronously */
    +_: 'getChatFolderDefaultIconName',
    /** Chat folder */
    +folder?: chatFolder$Input,
  |}

  declare export type getChatsForChatFolderInviteLink = {|
    /**
     * Returns identifiers of chats from a chat folder, suitable for adding to a chat
     * folder invite link
     */
    +_: 'getChatsForChatFolderInviteLink',
    /** Chat folder identifier */
    +chat_folder_id?: number,
  |}

  declare export type createChatFolderInviteLink = {|
    /**
     * Creates a new invite link for a chat folder. A link can be created for a chat
     * folder if it has only pinned and included chats
     */
    +_: 'createChatFolderInviteLink',
    /** Chat folder identifier */
    +chat_folder_id?: number,
    /** Name of the link; 0-32 characters */
    +name?: string,
    /**
     * Identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink
     * to get suitable chats. Basic groups will be automatically converted to supergroups
     * before link creation
     */
    +chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getChatFolderInviteLinks = {|
    /** Returns invite links created by the current user for a shareable chat folder */
    +_: 'getChatFolderInviteLinks',
    /** Chat folder identifier */
    +chat_folder_id?: number,
  |}

  declare export type editChatFolderInviteLink = {|
    /** Edits an invite link for a chat folder */
    +_: 'editChatFolderInviteLink',
    /** Chat folder identifier */
    +chat_folder_id?: number,
    /** Invite link to be edited */
    +invite_link?: string,
    /** New name of the link; 0-32 characters */
    +name?: string,
    /**
     * New identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink
     * to get suitable chats. Basic groups will be automatically converted to supergroups
     * before link editing
     */
    +chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type deleteChatFolderInviteLink = {|
    /** Deletes an invite link for a chat folder */
    +_: 'deleteChatFolderInviteLink',
    /** Chat folder identifier */
    +chat_folder_id?: number,
    /** Invite link to be deleted */
    +invite_link?: string,
  |}

  declare export type checkChatFolderInviteLink = {|
    /**
     * Checks the validity of an invite link for a chat folder and returns information
     * about the corresponding chat folder
     */
    +_: 'checkChatFolderInviteLink',
    /** Invite link to be checked */
    +invite_link?: string,
  |}

  declare export type addChatFolderByInviteLink = {|
    /** Adds a chat folder by an invite link */
    +_: 'addChatFolderByInviteLink',
    /** Invite link for the chat folder */
    +invite_link?: string,
    /**
     * Identifiers of the chats added to the chat folder. The chats are automatically
     * joined if they aren't joined yet
     */
    +chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getChatFolderNewChats = {|
    /**
     * Returns new chats added to a shareable chat folder by its owner. The method
     * must be called at most once in getOption("chat_folder_new_chats_update_period")
     * for the given chat folder
     */
    +_: 'getChatFolderNewChats',
    /** Chat folder identifier */
    +chat_folder_id?: number,
  |}

  declare export type processChatFolderNewChats = {|
    /** Process new chats added to a shareable chat folder by its owner */
    +_: 'processChatFolderNewChats',
    /** Chat folder identifier */
    +chat_folder_id?: number,
    /**
     * Identifiers of the new chats, which are added to the chat folder. The chats
     * are automatically joined if they aren't joined yet
     */
    +added_chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getArchiveChatListSettings = {|
    /**
     * Returns settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    +_: 'getArchiveChatListSettings',
  |}

  declare export type setArchiveChatListSettings = {|
    /**
     * Changes settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    +_: 'setArchiveChatListSettings',
    /** New settings */
    +settings?: archiveChatListSettings$Input,
  |}

  declare export type setChatTitle = {|
    /**
     * Changes the chat title. Supported only for basic groups, supergroups and channels.
     * Requires can_change_info member right
     */
    +_: 'setChatTitle',
    /** Chat identifier */
    +chat_id?: number,
    /** New title of the chat; 1-128 characters */
    +title?: string,
  |}

  declare export type setChatPhoto = {|
    /**
     * Changes the photo of a chat. Supported only for basic groups, supergroups and
     * channels. Requires can_change_info member right
     */
    +_: 'setChatPhoto',
    /** Chat identifier */
    +chat_id?: number,
    /** New chat photo; pass null to delete the chat photo */
    +photo?: InputChatPhoto$Input,
  |}

  declare export type setChatAccentColor = {|
    /**
     * Changes accent color and background custom emoji of a channel chat. Requires
     * can_change_info administrator right
     */
    +_: 'setChatAccentColor',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifier of the accent color to use. The chat must have at least accentColor.min_channel_chat_boost_level
     * boost level to pass the corresponding color
     */
    +accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background; 0 if none. Use chatBoostLevelFeatures.can_set_background_custom_emoji
     * to check whether a custom emoji can be set
     */
    +background_custom_emoji_id?: number | string,
  |}

  declare export type setChatProfileAccentColor = {|
    /**
     * Changes accent color and background custom emoji for profile of a supergroup
     * or channel chat. Requires can_change_info administrator right
     */
    +_: 'setChatProfileAccentColor',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifier of the accent color to use for profile; pass -1 if none. The chat
     * must have at least profileAccentColor.min_supergroup_chat_boost_level for supergroups
     * or profileAccentColor.min_channel_chat_boost_level for channels boost level
     * to pass the corresponding color
     */
    +profile_accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the chat's profile photo background;
     * 0 if none. Use chatBoostLevelFeatures.can_set_profile_background_custom_emoji
     * to check whether a custom emoji can be set
     */
    +profile_background_custom_emoji_id?: number | string,
  |}

  declare export type setChatMessageAutoDeleteTime = {|
    /**
     * Changes the message auto-delete or self-destruct (for secret chats) time in
     * a chat. Requires change_info administrator right in basic groups, supergroups
     * and channels. Message auto-delete time can't be changed in a chat with the current
     * user (Saved Messages) and the chat 777000 (Telegram).
     */
    +_: 'setChatMessageAutoDeleteTime',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * New time value, in seconds; unless the chat is secret, it must be from 0 up
     * to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted
     * automatically
     */
    +message_auto_delete_time?: number,
  |}

  declare export type setChatEmojiStatus = {|
    /**
     * Changes the emoji status of a chat. Use chatBoostLevelFeatures.can_set_emoji_status
     * to check whether an emoji status can be set. Requires can_change_info administrator
     * right
     */
    +_: 'setChatEmojiStatus',
    /** Chat identifier */
    +chat_id?: number,
    /** New emoji status; pass null to remove emoji status */
    +emoji_status?: emojiStatus$Input,
  |}

  declare export type setChatPermissions = {|
    /**
     * Changes the chat members permissions. Supported only for basic groups and supergroups.
     * Requires can_restrict_members administrator right
     */
    +_: 'setChatPermissions',
    /** Chat identifier */
    +chat_id?: number,
    /** New non-administrator members permissions in the chat */
    +permissions?: chatPermissions$Input,
  |}

  declare export type setChatBackground = {|
    /**
     * Sets the background in a specific chat. Supported only in private and secret
     * chats with non-deleted users, and in chats with sufficient boost level and can_change_info
     * administrator right
     */
    +_: 'setChatBackground',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * The input background to use; pass null to create a new filled or chat theme
     * background
     */
    +background?: InputBackground$Input,
    /**
     * Background type; pass null to use default background type for the chosen background;
     * backgroundTypeChatTheme isn't supported for private and secret chats. Use chatBoostLevelFeatures.chat_theme_background_count
     * and chatBoostLevelFeatures.can_set_custom_background to check whether the background
     * type can be set in the boosted chat
     */
    +type?: BackgroundType$Input,
    /**
     * Dimming of the background in dark themes, as a percentage; 0-100. Applied only
     * to Wallpaper and Fill types of background
     */
    +dark_theme_dimming?: number,
    /**
     * Pass true to set background only for self; pass false to set background for
     * all chat users. Always false for backgrounds set in boosted chats. Background
     * can be set for both users only by Telegram Premium users and if set background
     * isn't of the type inputBackgroundPrevious
     */
    +only_for_self?: boolean,
  |}

  declare export type deleteChatBackground = {|
    /** Deletes background in a specific chat */
    +_: 'deleteChatBackground',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Pass true to restore previously set background. Can be used only in private
     * and secret chats with non-deleted users if userFullInfo.set_chat_background
     * == true. Supposed to be used from messageChatSetBackground messages with the
     * currently set background that was set for both sides by the other user
     */
    +restore_previous?: boolean,
  |}

  declare export type setChatTheme = {|
    /** Changes the chat theme. Supported only in private and secret chats */
    +_: 'setChatTheme',
    /** Chat identifier */
    +chat_id?: number,
    /** Name of the new chat theme; pass an empty string to return the default theme */
    +theme_name?: string,
  |}

  declare export type setChatDraftMessage = {|
    /** Changes the draft message in a chat */
    +_: 'setChatDraftMessage',
    /** Chat identifier */
    +chat_id?: number,
    /** If not 0, the message thread identifier in which the draft was changed */
    +message_thread_id?: number,
    /**
     * New draft message; pass null to remove the draft. All files in draft message
     * content must be of the type inputFileLocal. Media thumbnails and captions are
     * ignored
     */
    +draft_message?: draftMessage$Input,
  |}

  declare export type setChatNotificationSettings = {|
    /**
     * Changes the notification settings of a chat. Notification settings of a chat
     * with the current user (Saved Messages) can't be changed
     */
    +_: 'setChatNotificationSettings',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * New notification settings for the chat. If the chat is muted for more than 366
     * days, it is considered to be muted forever
     */
    +notification_settings?: chatNotificationSettings$Input,
  |}

  declare export type toggleChatHasProtectedContent = {|
    /**
     * Changes the ability of users to save, forward, or copy chat content. Supported
     * only for basic groups, supergroups and channels. Requires owner privileges
     */
    +_: 'toggleChatHasProtectedContent',
    /** Chat identifier */
    +chat_id?: number,
    /** New value of has_protected_content */
    +has_protected_content?: boolean,
  |}

  declare export type toggleChatViewAsTopics = {|
    /** Changes the view_as_topics setting of a forum chat or Saved Messages */
    +_: 'toggleChatViewAsTopics',
    /** Chat identifier */
    +chat_id?: number,
    /** New value of view_as_topics */
    +view_as_topics?: boolean,
  |}

  declare export type toggleChatIsTranslatable = {|
    /** Changes the translatable state of a chat */
    +_: 'toggleChatIsTranslatable',
    /** Chat identifier */
    +chat_id?: number,
    /** New value of is_translatable */
    +is_translatable?: boolean,
  |}

  declare export type toggleChatIsMarkedAsUnread = {|
    /** Changes the marked as unread state of a chat */
    +_: 'toggleChatIsMarkedAsUnread',
    /** Chat identifier */
    +chat_id?: number,
    /** New value of is_marked_as_unread */
    +is_marked_as_unread?: boolean,
  |}

  declare export type toggleChatDefaultDisableNotification = {|
    /**
     * Changes the value of the default disable_notification parameter, used when a
     * message is sent to a chat
     */
    +_: 'toggleChatDefaultDisableNotification',
    /** Chat identifier */
    +chat_id?: number,
    /** New value of default_disable_notification */
    +default_disable_notification?: boolean,
  |}

  declare export type setChatAvailableReactions = {|
    /**
     * Changes reactions, available in a chat. Available for basic groups, supergroups,
     * and channels. Requires can_change_info member right
     */
    +_: 'setChatAvailableReactions',
    /** Identifier of the chat */
    +chat_id?: number,
    /**
     * Reactions available in the chat. All explicitly specified emoji reactions must
     * be active. In channel chats up to the chat's boost level custom emoji reactions
     * can be explicitly specified
     */
    +available_reactions?: ChatAvailableReactions$Input,
  |}

  declare export type setChatClientData = {|
    /** Changes application-specific data associated with a chat */
    +_: 'setChatClientData',
    /** Chat identifier */
    +chat_id?: number,
    /** New value of client_data */
    +client_data?: string,
  |}

  declare export type setChatDescription = {|
    /**
     * Changes information about a chat. Available for basic groups, supergroups, and
     * channels. Requires can_change_info member right
     */
    +_: 'setChatDescription',
    /** Identifier of the chat */
    +chat_id?: number,
    /** New chat description; 0-255 characters */
    +description?: string,
  |}

  declare export type setChatDiscussionGroup = {|
    /**
     * Changes the discussion group of a channel chat; requires can_change_info administrator
     * right in the channel if it is specified
     */
    +_: 'setChatDiscussionGroup',
    /**
     * Identifier of the channel chat. Pass 0 to remove a link from the supergroup
     * passed in the second argument to a linked channel chat (requires can_pin_messages
     * member right in the supergroup)
     */
    +chat_id?: number,
    /**
     * Identifier of a new channel's discussion group. Use 0 to remove the discussion
     * group. Use the method getSuitableDiscussionChats to find all suitable groups.
     * Basic group chats must be first upgraded to supergroup chats. If new chat members
     * don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable
     * must be used first to change that
     */
    +discussion_chat_id?: number,
  |}

  declare export type setChatLocation = {|
    /**
     * Changes the location of a chat. Available only for some location-based supergroups,
     * use supergroupFullInfo.can_set_location to check whether the method is allowed
     * to use
     */
    +_: 'setChatLocation',
    /** Chat identifier */
    +chat_id?: number,
    /** New location for the chat; must be valid and not null */
    +location?: chatLocation$Input,
  |}

  declare export type setChatSlowModeDelay = {|
    /**
     * Changes the slow mode delay of a chat. Available only for supergroups; requires
     * can_restrict_members right
     */
    +_: 'setChatSlowModeDelay',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60,
     * 300, 900, 3600
     */
    +slow_mode_delay?: number,
  |}

  declare export type pinChatMessage = {|
    /** Pins a message in a chat. A message can be pinned only if messageProperties.can_be_pinned */
    +_: 'pinChatMessage',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Identifier of the new pinned message */
    +message_id?: number,
    /**
     * Pass true to disable notification about the pinned message. Notifications are
     * always disabled in channels and private chats
     */
    +disable_notification?: boolean,
    /** Pass true to pin the message only for self; private chats only */
    +only_for_self?: boolean,
  |}

  declare export type unpinChatMessage = {|
    /**
     * Removes a pinned message from a chat; requires can_pin_messages member right
     * if the chat is a basic group or supergroup, or can_edit_messages administrator
     * right if the chat is a channel
     */
    +_: 'unpinChatMessage',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Identifier of the removed pinned message */
    +message_id?: number,
  |}

  declare export type unpinAllChatMessages = {|
    /**
     * Removes all pinned messages from a chat; requires can_pin_messages member right
     * if the chat is a basic group or supergroup, or can_edit_messages administrator
     * right if the chat is a channel
     */
    +_: 'unpinAllChatMessages',
    /** Identifier of the chat */
    +chat_id?: number,
  |}

  declare export type unpinAllMessageThreadMessages = {|
    /**
     * Removes all pinned messages from a forum topic; requires can_pin_messages member
     * right in the supergroup
     */
    +_: 'unpinAllMessageThreadMessages',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Message thread identifier in which messages will be unpinned */
    +message_thread_id?: number,
  |}

  declare export type joinChat = {|
    /**
     * Adds the current user as a new member to a chat. Private and secret chats can't
     * be joined using this method. May return an error with a message "INVITE_REQUEST_SENT"
     * if only a join request was created
     */
    +_: 'joinChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type leaveChat = {|
    /**
     * Removes the current user from chat members. Private and secret chats can't be
     * left using this method
     */
    +_: 'leaveChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type addChatMember = {|
    /**
     * Adds a new member to a chat; requires can_invite_users member right. Members
     * can't be added to private or secret chats. Returns information about members
     * that weren't added
     */
    +_: 'addChatMember',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the user */
    +user_id?: number,
    /**
     * The number of earlier messages from the chat to be forwarded to the new member;
     * up to 100. Ignored for supergroups and channels, or if the added user is a bot
     */
    +forward_limit?: number,
  |}

  declare export type addChatMembers = {|
    /**
     * Adds multiple new members to a chat; requires can_invite_users member right.
     * Currently, this method is only available for supergroups and channels. This
     * method can't be used to join a chat. Members can't be added to a channel if
     * it has more than 200 members. Returns information about members that weren't
     * added
     */
    +_: 'addChatMembers',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifiers of the users to be added to the chat. The maximum number of added
     * users is 20 for supergroups and 100 for channels
     */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type setChatMemberStatus = {|
    /**
     * Changes the status of a chat member; requires can_invite_users member right
     * to add a chat member, can_promote_members administrator right to change administrator
     * rights of the member, and can_restrict_members administrator right to change
     * restrictions of a user. This function is currently not suitable for transferring
     * chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember
     * if some additional parameters needs to be passed
     */
    +_: 'setChatMemberStatus',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Member identifier. Chats can be only banned and unbanned in supergroups and
     * channels
     */
    +member_id?: MessageSender$Input,
    /** The new status of the member in the chat */
    +status?: ChatMemberStatus$Input,
  |}

  declare export type banChatMember = {|
    /**
     * Bans a member in a chat; requires can_restrict_members administrator right.
     * Members can't be banned in private or secret chats. In supergroups and channels,
     * the user will not be able to return to the group on their own using invite links,
     * etc., unless unbanned first
     */
    +_: 'banChatMember',
    /** Chat identifier */
    +chat_id?: number,
    /** Member identifier */
    +member_id?: MessageSender$Input,
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Ignored in basic
     * groups and if a chat is banned
     */
    +banned_until_date?: number,
    /**
     * Pass true to delete all messages in the chat for the user that is being removed.
     * Always true for supergroups and channels
     */
    +revoke_messages?: boolean,
  |}

  declare export type canTransferOwnership = {|
    /**
     * Checks whether the current session can be used to transfer a chat ownership
     * to another user
     */
    +_: 'canTransferOwnership',
  |}

  declare export type transferChatOwnership = {|
    /**
     * Changes the owner of a chat; requires owner privileges in the chat. Use the
     * method canTransferOwnership to check whether the ownership can be transferred
     * from the current session. Available only for supergroups and channel chats
     */
    +_: 'transferChatOwnership',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifier of the user to which transfer the ownership. The ownership can't
     * be transferred to a bot or to a deleted user
     */
    +user_id?: number,
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type getChatMember = {|
    /** Returns information about a single member of a chat */
    +_: 'getChatMember',
    /** Chat identifier */
    +chat_id?: number,
    /** Member identifier */
    +member_id?: MessageSender$Input,
  |}

  declare export type searchChatMembers = {|
    /**
     * Searches for a specified query in the first name, last name and usernames of
     * the members of a specified chat. Requires administrator rights if the chat is
     * a channel
     */
    +_: 'searchChatMembers',
    /** Chat identifier */
    +chat_id?: number,
    /** Query to search for */
    +query?: string,
    /** The maximum number of users to be returned; up to 200 */
    +limit?: number,
    /** The type of users to search for; pass null to search among all chat members */
    +filter?: ChatMembersFilter$Input,
  |}

  declare export type getChatAdministrators = {|
    /** Returns a list of administrators of the chat with their custom titles */
    +_: 'getChatAdministrators',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type clearAllDraftMessages = {|
    /** Clears message drafts in all chats */
    +_: 'clearAllDraftMessages',
    /** Pass true to keep local message drafts in secret chats */
    +exclude_secret_chats?: boolean,
  |}

  declare export type getSavedNotificationSound = {|
    /**
     * Returns saved notification sound by its identifier. Returns a 404 error if there
     * is no saved notification sound with the specified identifier
     */
    +_: 'getSavedNotificationSound',
    /** Identifier of the notification sound */
    +notification_sound_id?: number | string,
  |}

  declare export type getSavedNotificationSounds = {|
    /**
     * Returns the list of saved notification sounds. If a sound isn't in the list,
     * then default sound needs to be used
     */
    +_: 'getSavedNotificationSounds',
  |}

  declare export type addSavedNotificationSound = {|
    /**
     * Adds a new notification sound to the list of saved notification sounds. The
     * new notification sound is added to the top of the list. If it is already in
     * the list, its position isn't changed
     */
    +_: 'addSavedNotificationSound',
    /** Notification sound file to add */
    +sound?: InputFile$Input,
  |}

  declare export type removeSavedNotificationSound = {|
    /** Removes a notification sound from the list of saved notification sounds */
    +_: 'removeSavedNotificationSound',
    /** Identifier of the notification sound */
    +notification_sound_id?: number | string,
  |}

  declare export type getChatNotificationSettingsExceptions = {|
    /** Returns the list of chats with non-default notification settings for new messages */
    +_: 'getChatNotificationSettingsExceptions',
    /**
     * If specified, only chats from the scope will be returned; pass null to return
     * chats from all scopes
     */
    +scope?: NotificationSettingsScope$Input,
    /** Pass true to include in the response chats with only non-default sound */
    +compare_sound?: boolean,
  |}

  declare export type getScopeNotificationSettings = {|
    /** Returns the notification settings for chats of a given type */
    +_: 'getScopeNotificationSettings',
    /** Types of chats for which to return the notification settings information */
    +scope?: NotificationSettingsScope$Input,
  |}

  declare export type setScopeNotificationSettings = {|
    /** Changes notification settings for chats of a given type */
    +_: 'setScopeNotificationSettings',
    /** Types of chats for which to change the notification settings */
    +scope?: NotificationSettingsScope$Input,
    /** The new notification settings for the given scope */
    +notification_settings?: scopeNotificationSettings$Input,
  |}

  declare export type setReactionNotificationSettings = {|
    /** Changes notification settings for reactions */
    +_: 'setReactionNotificationSettings',
    /** The new notification settings for reactions */
    +notification_settings?: reactionNotificationSettings$Input,
  |}

  declare export type resetAllNotificationSettings = {|
    /**
     * Resets all chat and scope notification settings to their default values. By
     * default, all chats are unmuted and message previews are shown
     */
    +_: 'resetAllNotificationSettings',
  |}

  declare export type toggleChatIsPinned = {|
    /**
     * Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max")
     * pinned non-secret chats and the same number of secret chats in the main/archive
     * chat list. The limit can be increased with Telegram Premium
     */
    +_: 'toggleChatIsPinned',
    /** Chat list in which to change the pinned state of the chat */
    +chat_list?: ChatList$Input,
    /** Chat identifier */
    +chat_id?: number,
    /** Pass true to pin the chat; pass false to unpin it */
    +is_pinned?: boolean,
  |}

  declare export type setPinnedChats = {|
    /** Changes the order of pinned chats */
    +_: 'setPinnedChats',
    /** Chat list in which to change the order of pinned chats */
    +chat_list?: ChatList$Input,
    /** The new list of pinned chats */
    +chat_ids?: $ReadOnlyArray<number>,
  |}

  declare export type readChatList = {|
    /** Traverse all chats in a chat list and marks all messages in the chats as read */
    +_: 'readChatList',
    /** Chat list in which to mark all chats as read */
    +chat_list?: ChatList$Input,
  |}

  declare export type getCurrentWeather = {|
    /** Returns the current weather in the given location */
    +_: 'getCurrentWeather',
    /** The location */
    +location?: location$Input,
  |}

  declare export type getStory = {|
    /** Returns a story */
    +_: 'getStory',
    /** Identifier of the chat that posted the story */
    +story_sender_chat_id?: number,
    /** Story identifier */
    +story_id?: number,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    +only_local?: boolean,
  |}

  declare export type getChatsToSendStories = {|
    /**
     * Returns supergroup and channel chats in which the current user has the right
     * to post stories. The chats must be rechecked with canSendStory before actually
     * trying to post a story there
     */
    +_: 'getChatsToSendStories',
  |}

  declare export type canSendStory = {|
    /**
     * Checks whether the current user can send a story on behalf of a chat; requires
     * can_post_stories right for supergroup and channel chats
     */
    +_: 'canSendStory',
    /**
     * Chat identifier. Pass Saved Messages chat identifier when posting a story on
     * behalf of the current user
     */
    +chat_id?: number,
  |}

  declare export type sendStory = {|
    /**
     * Sends a new story to a chat; requires can_post_stories right for supergroup
     * and channel chats. Returns a temporary story
     */
    +_: 'sendStory',
    /**
     * Identifier of the chat that will post the story. Pass Saved Messages chat identifier
     * when posting a story on behalf of the current user
     */
    +chat_id?: number,
    /** Content of the story */
    +content?: InputStoryContent$Input,
    /** Clickable rectangle areas to be shown on the story media; pass null if none */
    +areas?: inputStoryAreas$Input,
    /**
     * Story caption; pass null to use an empty caption; 0-getOption("story_caption_length_max")
     * characters; can have entities only if getOption("can_use_text_entities_in_story_caption")
     */
    +caption?: formattedText$Input,
    /**
     * The privacy settings for the story; ignored for stories sent to supergroup and
     * channel chats
     */
    +privacy_settings?: StoryPrivacySettings$Input,
    /**
     * Period after which the story is moved to archive, in seconds; must be one of
     * 6 * 3600, 12 * 3600, 86400, or 2 * 86400 for Telegram Premium users, and 86400
     * otherwise
     */
    +active_period?: number,
    /**
     * Full identifier of the original story, which content was used to create the
     * story; pass null if the story isn't repost of another story
     */
    +from_story_full_id?: storyFullId$Input,
    /** Pass true to keep the story accessible after expiration */
    +is_posted_to_chat_page?: boolean,
    /**
     * Pass true if the content of the story must be protected from forwarding and
     * screenshotting
     */
    +protect_content?: boolean,
  |}

  declare export type editStory = {|
    /**
     * Changes content and caption of a story. Can be called only if story.can_be_edited
     * == true
     */
    +_: 'editStory',
    /** Identifier of the chat that posted the story */
    +story_sender_chat_id?: number,
    /** Identifier of the story to edit */
    +story_id?: number,
    /** New content of the story; pass null to keep the current content */
    +content?: InputStoryContent$Input,
    /**
     * New clickable rectangle areas to be shown on the story media; pass null to keep
     * the current areas. Areas can't be edited if story content isn't changed
     */
    +areas?: inputStoryAreas$Input,
    /** New story caption; pass null to keep the current caption */
    +caption?: formattedText$Input,
  |}

  declare export type editStoryCover = {|
    /**
     * Changes cover of a video story. Can be called only if story.can_be_edited ==
     * true and the story isn't being edited now
     */
    +_: 'editStoryCover',
    /** Identifier of the chat that posted the story */
    +story_sender_chat_id?: number,
    /** Identifier of the story to edit */
    +story_id?: number,
    /** New timestamp of the frame, which will be used as video thumbnail */
    +cover_frame_timestamp?: number,
  |}

  declare export type setStoryPrivacySettings = {|
    /**
     * Changes privacy settings of a story. The method can be called only for stories
     * posted on behalf of the current user and if story.can_be_edited == true
     */
    +_: 'setStoryPrivacySettings',
    /** Identifier of the story */
    +story_id?: number,
    /** The new privacy settings for the story */
    +privacy_settings?: StoryPrivacySettings$Input,
  |}

  declare export type toggleStoryIsPostedToChatPage = {|
    /**
     * Toggles whether a story is accessible after expiration. Can be called only if
     * story.can_toggle_is_posted_to_chat_page == true
     */
    +_: 'toggleStoryIsPostedToChatPage',
    /** Identifier of the chat that posted the story */
    +story_sender_chat_id?: number,
    /** Identifier of the story */
    +story_id?: number,
    /**
     * Pass true to make the story accessible after expiration; pass false to make
     * it private
     */
    +is_posted_to_chat_page?: boolean,
  |}

  declare export type deleteStory = {|
    /**
     * Deletes a previously sent story. Can be called only if story.can_be_deleted
     * == true
     */
    +_: 'deleteStory',
    /** Identifier of the chat that posted the story */
    +story_sender_chat_id?: number,
    /** Identifier of the story to delete */
    +story_id?: number,
  |}

  declare export type getStoryNotificationSettingsExceptions = {|
    /** Returns the list of chats with non-default notification settings for stories */
    +_: 'getStoryNotificationSettingsExceptions',
  |}

  declare export type loadActiveStories = {|
    /**
     * Loads more active stories from a story list. The loaded stories will be sent
     * through updates. Active stories are sorted by the pair (active_stories.order,
     * active_stories.story_sender_chat_id) in descending order. Returns a 404 error
     * if all active stories have been loaded
     */
    +_: 'loadActiveStories',
    /** The story list in which to load active stories */
    +story_list?: StoryList$Input,
  |}

  declare export type setChatActiveStoriesList = {|
    /** Changes story list in which stories from the chat are shown */
    +_: 'setChatActiveStoriesList',
    /** Identifier of the chat that posted stories */
    +chat_id?: number,
    /** New list for active stories posted by the chat */
    +story_list?: StoryList$Input,
  |}

  declare export type getChatActiveStories = {|
    /** Returns the list of active stories posted by the given chat */
    +_: 'getChatActiveStories',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type getChatPostedToChatPageStories = {|
    /**
     * Returns the list of stories that posted by the given chat to its chat page.
     * If from_story_id == 0, then pinned stories are returned first. Then, stories
     * are returned in reverse chronological order (i.e., in order of decreasing story_id).
     * For optimal performance, the number of returned stories is chosen by TDLib
     */
    +_: 'getChatPostedToChatPageStories',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifier of the story starting from which stories must be returned; use 0
     * to get results from pinned and the newest story
     */
    +from_story_id?: number,
    /**
     * The maximum number of stories to be returned. For optimal performance, the number
     * of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    +limit?: number,
  |}

  declare export type getChatArchivedStories = {|
    /**
     * Returns the list of all stories posted by the given chat; requires can_edit_stories
     * right in the chat. The stories are returned in reverse chronological order (i.e.,
     * in order of decreasing story_id). For optimal performance, the number of returned
     * stories is chosen by TDLib
     */
    +_: 'getChatArchivedStories',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Identifier of the story starting from which stories must be returned; use 0
     * to get results from the last story
     */
    +from_story_id?: number,
    /**
     * The maximum number of stories to be returned. For optimal performance, the number
     * of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    +limit?: number,
  |}

  declare export type setChatPinnedStories = {|
    /**
     * Changes the list of pinned stories on a chat page; requires can_edit_stories
     * right in the chat
     */
    +_: 'setChatPinnedStories',
    /** Identifier of the chat that posted the stories */
    +chat_id?: number,
    /**
     * New list of pinned stories. All stories must be posted to the chat page first.
     * There can be up to getOption("pinned_story_count_max") pinned stories on a chat
     * page
     */
    +story_ids?: $ReadOnlyArray<number>,
  |}

  declare export type openStory = {|
    /** Informs TDLib that a story is opened and is being viewed by the user */
    +_: 'openStory',
    /** The identifier of the sender of the opened story */
    +story_sender_chat_id?: number,
    /** The identifier of the story */
    +story_id?: number,
  |}

  declare export type closeStory = {|
    /** Informs TDLib that a story is closed by the user */
    +_: 'closeStory',
    /** The identifier of the sender of the story to close */
    +story_sender_chat_id?: number,
    /** The identifier of the story */
    +story_id?: number,
  |}

  declare export type getStoryAvailableReactions = {|
    /** Returns reactions, which can be chosen for a story */
    +_: 'getStoryAvailableReactions',
    /** Number of reaction per row, 5-25 */
    +row_size?: number,
  |}

  declare export type setStoryReaction = {|
    /** Changes chosen reaction on a story that has already been sent */
    +_: 'setStoryReaction',
    /** The identifier of the sender of the story */
    +story_sender_chat_id?: number,
    /** The identifier of the story */
    +story_id?: number,
    /**
     * Type of the reaction to set; pass null to remove the reaction. Custom emoji
     * reactions can be used only by Telegram Premium users. Paid reactions can't be
     * set
     */
    +reaction_type?: ReactionType$Input,
    /** Pass true if the reaction needs to be added to recent reactions */
    +update_recent_reactions?: boolean,
  |}

  declare export type getStoryInteractions = {|
    /**
     * Returns interactions with a story. The method can be called only for stories
     * posted on behalf of the current user
     */
    +_: 'getStoryInteractions',
    /** Story identifier */
    +story_id?: number,
    /**
     * Query to search for in names, usernames and titles; may be empty to get all
     * relevant interactions
     */
    +query?: string,
    /**
     * Pass true to get only interactions by contacts; pass false to get all relevant
     * interactions
     */
    +only_contacts?: boolean,
    /**
     * Pass true to get forwards and reposts first, then reactions, then other views;
     * pass false to get interactions sorted just by interaction date
     */
    +prefer_forwards?: boolean,
    /**
     * Pass true to get interactions with reaction first; pass false to get interactions
     * sorted just by interaction date. Ignored if prefer_forwards == true
     */
    +prefer_with_reaction?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /** The maximum number of story interactions to return */
    +limit?: number,
  |}

  declare export type getChatStoryInteractions = {|
    /**
     * Returns interactions with a story posted in a chat. Can be used only if story
     * is posted on behalf of a chat and the user is an administrator in the chat
     */
    +_: 'getChatStoryInteractions',
    /** The identifier of the sender of the story */
    +story_sender_chat_id?: number,
    /** Story identifier */
    +story_id?: number,
    /**
     * Pass the default heart reaction or a suggested reaction type to receive only
     * interactions with the specified reaction type; pass null to receive all interactions;
     * reactionTypePaid isn't supported
     */
    +reaction_type?: ReactionType$Input,
    /**
     * Pass true to get forwards and reposts first, then reactions, then other views;
     * pass false to get interactions sorted just by interaction date
     */
    +prefer_forwards?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /** The maximum number of story interactions to return */
    +limit?: number,
  |}

  declare export type reportStory = {|
    /** Reports a story to the Telegram moderators */
    +_: 'reportStory',
    /** The identifier of the sender of the story to report */
    +story_sender_chat_id?: number,
    /** The identifier of the story to report */
    +story_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    +option_id?: string /* base64 */,
    /** Additional report details; 0-1024 characters; leave empty for the initial request */
    +text?: string,
  |}

  declare export type activateStoryStealthMode = {|
    /**
     * Activates stealth mode for stories, which hides all views of stories from the
     * current user in the last "story_stealth_mode_past_period" seconds and for the
     * next "story_stealth_mode_future_period" seconds; for Telegram Premium users
     * only
     */
    +_: 'activateStoryStealthMode',
  |}

  declare export type getStoryPublicForwards = {|
    /**
     * Returns forwards of a story as a message to public chats and reposts by public
     * channels. Can be used only if the story is posted on behalf of the current user
     * or story.can_get_statistics == true. For optimal performance, the number of
     * returned messages and stories is chosen by TDLib
     */
    +_: 'getStoryPublicForwards',
    /** The identifier of the sender of the story */
    +story_sender_chat_id?: number,
    /** The identifier of the story */
    +story_id?: number,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of messages and stories to be returned; must be positive
     * and can't be greater than 100. For optimal performance, the number of returned
     * objects is chosen by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type getChatBoostLevelFeatures = {|
    /**
     * Returns the list of features available on the specific chat boost level; this
     * is an offline request
     */
    +_: 'getChatBoostLevelFeatures',
    /**
     * Pass true to get the list of features for channels; pass false to get the list
     * of features for supergroups
     */
    +is_channel?: boolean,
    /** Chat boost level */
    +level?: number,
  |}

  declare export type getChatBoostFeatures = {|
    /**
     * Returns the list of features available for different chat boost levels; this
     * is an offline request
     */
    +_: 'getChatBoostFeatures',
    /**
     * Pass true to get the list of features for channels; pass false to get the list
     * of features for supergroups
     */
    +is_channel?: boolean,
  |}

  declare export type getAvailableChatBoostSlots = {|
    /** Returns the list of available chat boost slots for the current user */
    +_: 'getAvailableChatBoostSlots',
  |}

  declare export type getChatBoostStatus = {|
    /** Returns the current boost status for a supergroup or a channel chat */
    +_: 'getChatBoostStatus',
    /** Identifier of the chat */
    +chat_id?: number,
  |}

  declare export type boostChat = {|
    /**
     * Boosts a chat and returns the list of available chat boost slots for the current
     * user after the boost
     */
    +_: 'boostChat',
    /** Identifier of the chat */
    +chat_id?: number,
    /**
     * Identifiers of boost slots of the current user from which to apply boosts to
     * the chat
     */
    +slot_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getChatBoostLink = {|
    /** Returns an HTTPS link to boost the specified supergroup or channel chat */
    +_: 'getChatBoostLink',
    /** Identifier of the chat */
    +chat_id?: number,
  |}

  declare export type getChatBoostLinkInfo = {|
    /**
     * Returns information about a link to boost a chat. Can be called for any internal
     * link of the type internalLinkTypeChatBoost
     */
    +_: 'getChatBoostLinkInfo',
    /** The link to boost a chat */
    +url?: string,
  |}

  declare export type getChatBoosts = {|
    /**
     * Returns the list of boosts applied to a chat; requires administrator rights
     * in the chat
     */
    +_: 'getChatBoosts',
    /** Identifier of the chat */
    +chat_id?: number,
    /**
     * Pass true to receive only boosts received from gift codes and giveaways created
     * by the chat
     */
    +only_gift_codes?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of boosts to be returned; up to 100. For optimal performance,
     * the number of returned boosts can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type getUserChatBoosts = {|
    /**
     * Returns the list of boosts applied to a chat by a given user; requires administrator
     * rights in the chat; for bots only
     */
    +_: 'getUserChatBoosts',
    /** Identifier of the chat */
    +chat_id?: number,
    /** Identifier of the user */
    +user_id?: number,
  |}

  declare export type getAttachmentMenuBot = {|
    /** Returns information about a bot that can be added to attachment or side menu */
    +_: 'getAttachmentMenuBot',
    /** Bot's user identifier */
    +bot_user_id?: number,
  |}

  declare export type toggleBotIsAddedToAttachmentMenu = {|
    /**
     * Adds or removes a bot to attachment and side menu. Bot can be added to the menu,
     * only if userTypeBot.can_be_added_to_attachment_menu == true
     */
    +_: 'toggleBotIsAddedToAttachmentMenu',
    /** Bot's user identifier */
    +bot_user_id?: number,
    /**
     * Pass true to add the bot to attachment menu; pass false to remove the bot from
     * attachment menu
     */
    +is_added?: boolean,
    /**
     * Pass true if the current user allowed the bot to send them messages. Ignored
     * if is_added is false
     */
    +allow_write_access?: boolean,
  |}

  declare export type getThemedEmojiStatuses = {|
    /**
     * Returns up to 8 emoji statuses, which must be shown right after the default
     * Premium Badge in the emoji status list for self status
     */
    +_: 'getThemedEmojiStatuses',
  |}

  declare export type getRecentEmojiStatuses = {|
    /** Returns recent emoji statuses for self status */
    +_: 'getRecentEmojiStatuses',
  |}

  declare export type getUpgradedGiftEmojiStatuses = {|
    /** Returns available upgraded gift emoji statuses for self status */
    +_: 'getUpgradedGiftEmojiStatuses',
  |}

  declare export type getDefaultEmojiStatuses = {|
    /** Returns default emoji statuses for self status */
    +_: 'getDefaultEmojiStatuses',
  |}

  declare export type clearRecentEmojiStatuses = {|
    /** Clears the list of recently used emoji statuses for self status */
    +_: 'clearRecentEmojiStatuses',
  |}

  declare export type getThemedChatEmojiStatuses = {|
    /**
     * Returns up to 8 emoji statuses, which must be shown in the emoji status list
     * for chats
     */
    +_: 'getThemedChatEmojiStatuses',
  |}

  declare export type getDefaultChatEmojiStatuses = {|
    /** Returns default emoji statuses for chats */
    +_: 'getDefaultChatEmojiStatuses',
  |}

  declare export type getDisallowedChatEmojiStatuses = {|
    /**
     * Returns the list of emoji statuses, which can't be used as chat emoji status,
     * even they are from a sticker set with is_allowed_as_chat_emoji_status == true
     */
    +_: 'getDisallowedChatEmojiStatuses',
  |}

  declare export type downloadFile = {|
    /**
     * Downloads a file from the cloud. Download progress and completion of the download
     * will be notified through updateFile updates
     */
    +_: 'downloadFile',
    /** Identifier of the file to download */
    +file_id?: number,
    /**
     * Priority of the download (1-32). The higher the priority, the earlier the file
     * will be downloaded. If the priorities of two files are equal, then the last
     * one for which downloadFile/addFileToDownloads was called will be downloaded
     * first
     */
    +priority?: number,
    /** The starting position from which the file needs to be downloaded */
    +offset?: number,
    /**
     * Number of bytes which need to be downloaded starting from the "offset" position
     * before the download will automatically be canceled; use 0 to download without
     * a limit
     */
    +limit?: number,
    /**
     * Pass true to return response only after the file download has succeeded, has
     * failed, has been canceled, or a new downloadFile request with different offset/limit
     * parameters was sent; pass false to return file state immediately, just after
     * the download has been started
     */
    +synchronous?: boolean,
  |}

  declare export type getFileDownloadedPrefixSize = {|
    /** Returns file downloaded prefix size from a given offset, in bytes */
    +_: 'getFileDownloadedPrefixSize',
    /** Identifier of the file */
    +file_id?: number,
    /** Offset from which downloaded prefix size needs to be calculated */
    +offset?: number,
  |}

  declare export type cancelDownloadFile = {|
    /**
     * Stops the downloading of a file. If a file has already been downloaded, does
     * nothing
     */
    +_: 'cancelDownloadFile',
    /** Identifier of a file to stop downloading */
    +file_id?: number,
    /**
     * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't
     * been sent to server
     */
    +only_if_pending?: boolean,
  |}

  declare export type getSuggestedFileName = {|
    /** Returns suggested name for saving a file in a given directory */
    +_: 'getSuggestedFileName',
    /** Identifier of the file */
    +file_id?: number,
    /** Directory in which the file is expected to be saved */
    +directory?: string,
  |}

  declare export type preliminaryUploadFile = {|
    /**
     * Preliminary uploads a file to the cloud before sending it in a message, which
     * can be useful for uploading of being recorded voice and video notes. In all
     * other cases there is no need to preliminary upload a file. Updates updateFile
     * will be used to notify about upload progress. The upload will not be completed
     * until the file is sent in a message
     */
    +_: 'preliminaryUploadFile',
    /** File to upload */
    +file?: InputFile$Input,
    /** File type; pass null if unknown */
    +file_type?: FileType$Input,
    /**
     * Priority of the upload (1-32). The higher the priority, the earlier the file
     * will be uploaded. If the priorities of two files are equal, then the first one
     * for which preliminaryUploadFile was called will be uploaded first
     */
    +priority?: number,
  |}

  declare export type cancelPreliminaryUploadFile = {|
    /**
     * Stops the preliminary uploading of a file. Supported only for files uploaded
     * by using preliminaryUploadFile
     */
    +_: 'cancelPreliminaryUploadFile',
    /** Identifier of the file to stop uploading */
    +file_id?: number,
  |}

  declare export type writeGeneratedFilePart = {|
    /**
     * Writes a part of a generated file. This method is intended to be used only if
     * the application has no direct access to TDLib's file system, because it is usually
     * slower than a direct write to the destination file
     */
    +_: 'writeGeneratedFilePart',
    /** The identifier of the generation process */
    +generation_id?: number | string,
    /** The offset from which to write the data to the file */
    +offset?: number,
    /** The data to write */
    +data?: string /* base64 */,
  |}

  declare export type setFileGenerationProgress = {|
    /** Informs TDLib on a file generation progress */
    +_: 'setFileGenerationProgress',
    /** The identifier of the generation process */
    +generation_id?: number | string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    +expected_size?: number,
    /** The number of bytes already generated */
    +local_prefix_size?: number,
  |}

  declare export type finishFileGeneration = {|
    /** Finishes the file generation */
    +_: 'finishFileGeneration',
    /** The identifier of the generation process */
    +generation_id?: number | string,
    /**
     * If passed, the file generation has failed and must be terminated; pass null
     * if the file generation succeeded
     */
    +error?: error$Input,
  |}

  declare export type readFilePart = {|
    /**
     * Reads a part of a file from the TDLib file cache and returns read bytes. This
     * method is intended to be used only if the application has no direct access to
     * TDLib's file system, because it is usually slower than a direct read from the
     * file
     */
    +_: 'readFilePart',
    /** Identifier of the file. The file must be located in the TDLib file cache */
    +file_id?: number,
    /** The offset from which to read the file */
    +offset?: number,
    /**
     * Number of bytes to read. An error will be returned if there are not enough bytes
     * available in the file from the specified position. Pass 0 to read all available
     * data from the specified position
     */
    +count?: number,
  |}

  declare export type deleteFile = {|
    /** Deletes a file from the TDLib file cache */
    +_: 'deleteFile',
    /** Identifier of the file to delete */
    +file_id?: number,
  |}

  declare export type addFileToDownloads = {|
    /**
     * Adds a file from a message to the list of file downloads. Download progress
     * and completion of the download will be notified through updateFile updates.
     * If message database is used, the list of file downloads is persistent across
     * application restarts. The downloading is independent of download using downloadFile,
     * i.e. it continues if downloadFile is canceled or is used to download a part
     * of the file
     */
    +_: 'addFileToDownloads',
    /** Identifier of the file to download */
    +file_id?: number,
    /** Chat identifier of the message with the file */
    +chat_id?: number,
    /** Message identifier */
    +message_id?: number,
    /**
     * Priority of the download (1-32). The higher the priority, the earlier the file
     * will be downloaded. If the priorities of two files are equal, then the last
     * one for which downloadFile/addFileToDownloads was called will be downloaded
     * first
     */
    +priority?: number,
  |}

  declare export type toggleDownloadIsPaused = {|
    /** Changes pause state of a file in the file download list */
    +_: 'toggleDownloadIsPaused',
    /** Identifier of the downloaded file */
    +file_id?: number,
    /** Pass true if the download is paused */
    +is_paused?: boolean,
  |}

  declare export type toggleAllDownloadsArePaused = {|
    /** Changes pause state of all files in the file download list */
    +_: 'toggleAllDownloadsArePaused',
    /** Pass true to pause all downloads; pass false to unpause them */
    +are_paused?: boolean,
  |}

  declare export type removeFileFromDownloads = {|
    /** Removes a file from the file download list */
    +_: 'removeFileFromDownloads',
    /** Identifier of the downloaded file */
    +file_id?: number,
    /** Pass true to delete the file from the TDLib file cache */
    +delete_from_cache?: boolean,
  |}

  declare export type removeAllFilesFromDownloads = {|
    /** Removes all files from the file download list */
    +_: 'removeAllFilesFromDownloads',
    /** Pass true to remove only active downloads, including paused */
    +only_active?: boolean,
    /** Pass true to remove only completed downloads */
    +only_completed?: boolean,
    /** Pass true to delete the file from the TDLib file cache */
    +delete_from_cache?: boolean,
  |}

  declare export type searchFileDownloads = {|
    /**
     * Searches for files in the file download list or recently downloaded files from
     * the list
     */
    +_: 'searchFileDownloads',
    /** Query to search for; may be empty to return all downloaded files */
    +query?: string,
    /** Pass true to search only for active downloads, including paused */
    +only_active?: boolean,
    /** Pass true to search only for completed downloads */
    +only_completed?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /** The maximum number of files to be returned */
    +limit?: number,
  |}

  declare export type setApplicationVerificationToken = {|
    /**
     * Application or reCAPTCHA verification has been completed. Can be called before
     * authorization
     */
    +_: 'setApplicationVerificationToken',
    /**
     * Unique identifier for the verification process as received from updateApplicationVerificationRequired
     * or updateApplicationRecaptchaVerificationRequired
     */
    +verification_id?: number,
    /**
     * Play Integrity API token for the Android application, or secret from push notification
     * for the iOS application for application verification, or reCAPTCHA token for
     * reCAPTCHA verifications; pass an empty string to abort verification and receive
     * error VERIFICATION_FAILED for the request
     */
    +token?: string,
  |}

  declare export type getMessageFileType = {|
    /** Returns information about a file with messages exported from another application */
    +_: 'getMessageFileType',
    /** Beginning of the message file; up to 100 first lines */
    +message_file_head?: string,
  |}

  declare export type getMessageImportConfirmationText = {|
    /**
     * Returns a confirmation text to be shown to the user before starting message
     * import
     */
    +_: 'getMessageImportConfirmationText',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info member right
     */
    +chat_id?: number,
  |}

  declare export type importMessages = {|
    /** Imports messages exported from another app */
    +_: 'importMessages',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info member right
     */
    +chat_id?: number,
    /**
     * File with messages to import. Only inputFileLocal and inputFileGenerated are
     * supported. The file must not be previously uploaded
     */
    +message_file?: InputFile$Input,
    /**
     * Files used in the imported messages. Only inputFileLocal and inputFileGenerated
     * are supported. The files must not be previously uploaded
     */
    +attached_files?: $ReadOnlyArray<InputFile$Input>,
  |}

  declare export type replacePrimaryChatInviteLink = {|
    /**
     * Replaces current primary invite link for a chat with a new primary invite link.
     * Available for basic groups, supergroups, and channels. Requires administrator
     * privileges and can_invite_users right
     */
    +_: 'replacePrimaryChatInviteLink',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type createChatInviteLink = {|
    /**
     * Creates a new invite link for a chat. Available for basic groups, supergroups,
     * and channels. Requires administrator privileges and can_invite_users right in
     * the chat
     */
    +_: 'createChatInviteLink',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link name; 0-32 characters */
    +name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    +expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    +member_limit?: number,
    /**
     * Pass true if users joining the chat via the link need to be approved by chat
     * administrators. In this case, member_limit must be 0
     */
    +creates_join_request?: boolean,
  |}

  declare export type createChatSubscriptionInviteLink = {|
    /**
     * Creates a new subscription invite link for a channel chat. Requires can_invite_users
     * right in the chat
     */
    +_: 'createChatSubscriptionInviteLink',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link name; 0-32 characters */
    +name?: string,
    /**
     * Information about subscription plan that will be applied to the users joining
     * the chat via the link. Subscription period must be 2592000 in production environment,
     * and 60 or 300 if Telegram test environment is used
     */
    +subscription_pricing?: starSubscriptionPricing$Input,
  |}

  declare export type editChatInviteLink = {|
    /**
     * Edits a non-primary invite link for a chat. Available for basic groups, supergroups,
     * and channels. If the link creates a subscription, then expiration_date, member_limit
     * and creates_join_request must not be used. Requires administrator privileges
     * and can_invite_users right in the chat for own links and owner privileges for
     * other links
     */
    +_: 'editChatInviteLink',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link to be edited */
    +invite_link?: string,
    /** Invite link name; 0-32 characters */
    +name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    +expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    +member_limit?: number,
    /**
     * Pass true if users joining the chat via the link need to be approved by chat
     * administrators. In this case, member_limit must be 0
     */
    +creates_join_request?: boolean,
  |}

  declare export type editChatSubscriptionInviteLink = {|
    /**
     * Edits a subscription invite link for a channel chat. Requires can_invite_users
     * right in the chat for own links and owner privileges for other links
     */
    +_: 'editChatSubscriptionInviteLink',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link to be edited */
    +invite_link?: string,
    /** Invite link name; 0-32 characters */
    +name?: string,
  |}

  declare export type getChatInviteLink = {|
    /**
     * Returns information about an invite link. Requires administrator privileges
     * and can_invite_users right in the chat to get own links and owner privileges
     * to get other links
     */
    +_: 'getChatInviteLink',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link to get */
    +invite_link?: string,
  |}

  declare export type getChatInviteLinkCounts = {|
    /**
     * Returns the list of chat administrators with number of their invite links. Requires
     * owner privileges in the chat
     */
    +_: 'getChatInviteLinkCounts',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type getChatInviteLinks = {|
    /**
     * Returns invite links for a chat created by specified administrator. Requires
     * administrator privileges and can_invite_users right in the chat to get own links
     * and owner privileges to get other links
     */
    +_: 'getChatInviteLinks',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * User identifier of a chat administrator. Must be an identifier of the current
     * user for non-owner
     */
    +creator_user_id?: number,
    /** Pass true if revoked links needs to be returned instead of active or expired */
    +is_revoked?: boolean,
    /**
     * Creation date of an invite link starting after which to return invite links;
     * use 0 to get results from the beginning
     */
    +offset_date?: number,
    /**
     * Invite link starting after which to return invite links; use empty string to
     * get results from the beginning
     */
    +offset_invite_link?: string,
    /** The maximum number of invite links to return; up to 100 */
    +limit?: number,
  |}

  declare export type getChatInviteLinkMembers = {|
    /**
     * Returns chat members joined a chat via an invite link. Requires administrator
     * privileges and can_invite_users right in the chat for own links and owner privileges
     * for other links
     */
    +_: 'getChatInviteLinkMembers',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link for which to return chat members */
    +invite_link?: string,
    /**
     * Pass true if the link is a subscription link and only members with expired subscription
     * must be returned
     */
    +only_with_expired_subscription?: boolean,
    /**
     * A chat member from which to return next chat members; pass null to get results
     * from the beginning
     */
    +offset_member?: chatInviteLinkMember$Input,
    /** The maximum number of chat members to return; up to 100 */
    +limit?: number,
  |}

  declare export type revokeChatInviteLink = {|
    /**
     * Revokes invite link for a chat. Available for basic groups, supergroups, and
     * channels. Requires administrator privileges and can_invite_users right in the
     * chat for own links and owner privileges for other links. If a primary link is
     * revoked, then additionally to the revoked link returns new primary link
     */
    +_: 'revokeChatInviteLink',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link to be revoked */
    +invite_link?: string,
  |}

  declare export type deleteRevokedChatInviteLink = {|
    /**
     * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users
     * right in the chat for own links and owner privileges for other links
     */
    +_: 'deleteRevokedChatInviteLink',
    /** Chat identifier */
    +chat_id?: number,
    /** Invite link to revoke */
    +invite_link?: string,
  |}

  declare export type deleteAllRevokedChatInviteLinks = {|
    /**
     * Deletes all revoked chat invite links created by a given chat administrator.
     * Requires administrator privileges and can_invite_users right in the chat for
     * own links and owner privileges for other links
     */
    +_: 'deleteAllRevokedChatInviteLinks',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * User identifier of a chat administrator, which links will be deleted. Must be
     * an identifier of the current user for non-owner
     */
    +creator_user_id?: number,
  |}

  declare export type checkChatInviteLink = {|
    /**
     * Checks the validity of an invite link for a chat and returns information about
     * the corresponding chat
     */
    +_: 'checkChatInviteLink',
    /** Invite link to be checked */
    +invite_link?: string,
  |}

  declare export type joinChatByInviteLink = {|
    /**
     * Uses an invite link to add the current user to the chat if possible. May return
     * an error with a message "INVITE_REQUEST_SENT" if only a join request was created
     */
    +_: 'joinChatByInviteLink',
    /** Invite link to use */
    +invite_link?: string,
  |}

  declare export type getChatJoinRequests = {|
    /** Returns pending join requests in a chat */
    +_: 'getChatJoinRequests',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Invite link for which to return join requests. If empty, all join requests will
     * be returned. Requires administrator privileges and can_invite_users right in
     * the chat for own links and owner privileges for other links
     */
    +invite_link?: string,
    /**
     * A query to search for in the first names, last names and usernames of the users
     * to return
     */
    +query?: string,
    /**
     * A chat join request from which to return next requests; pass null to get results
     * from the beginning
     */
    +offset_request?: chatJoinRequest$Input,
    /** The maximum number of requests to join the chat to return */
    +limit?: number,
  |}

  declare export type processChatJoinRequest = {|
    /** Handles a pending join request in a chat */
    +_: 'processChatJoinRequest',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the user that sent the request */
    +user_id?: number,
    /** Pass true to approve the request; pass false to decline it */
    +approve?: boolean,
  |}

  declare export type processChatJoinRequests = {|
    /** Handles all pending join requests for a given link in a chat */
    +_: 'processChatJoinRequests',
    /** Chat identifier */
    +chat_id?: number,
    /**
     * Invite link for which to process join requests. If empty, all join requests
     * will be processed. Requires administrator privileges and can_invite_users right
     * in the chat for own links and owner privileges for other links
     */
    +invite_link?: string,
    /** Pass true to approve all requests; pass false to decline them */
    +approve?: boolean,
  |}

  declare export type createCall = {|
    /** Creates a new call */
    +_: 'createCall',
    /** Identifier of the user to be called */
    +user_id?: number,
    /** The call protocols supported by the application */
    +protocol?: callProtocol$Input,
    /** Pass true to create a video call */
    +is_video?: boolean,
    /**
     * Identifier of the group call to which the user will be added after exchanging
     * private key via the call; pass 0 if none
     */
    +group_call_id?: number,
  |}

  declare export type acceptCall = {|
    /** Accepts an incoming call */
    +_: 'acceptCall',
    /** Call identifier */
    +call_id?: number,
    /** The call protocols supported by the application */
    +protocol?: callProtocol$Input,
  |}

  declare export type sendCallSignalingData = {|
    /** Sends call signaling data */
    +_: 'sendCallSignalingData',
    /** Call identifier */
    +call_id?: number,
    /** The data */
    +data?: string /* base64 */,
  |}

  declare export type discardCall = {|
    /** Discards a call */
    +_: 'discardCall',
    /** Call identifier */
    +call_id?: number,
    /** Pass true if the user was disconnected */
    +is_disconnected?: boolean,
    /** The call duration, in seconds */
    +duration?: number,
    /** Pass true if the call was a video call */
    +is_video?: boolean,
    /** Identifier of the connection used during the call */
    +connection_id?: number | string,
  |}

  declare export type sendCallRating = {|
    /** Sends a call rating */
    +_: 'sendCallRating',
    /** Call identifier */
    +call_id?: number,
    /** Call rating; 1-5 */
    +rating?: number,
    /** An optional user comment if the rating is less than 5 */
    +comment?: string,
    /** List of the exact types of problems with the call, specified by the user */
    +problems?: $ReadOnlyArray<CallProblem$Input>,
  |}

  declare export type sendCallDebugInformation = {|
    /** Sends debug information for a call to Telegram servers */
    +_: 'sendCallDebugInformation',
    /** Call identifier */
    +call_id?: number,
    /** Debug information in application-specific format */
    +debug_information?: string,
  |}

  declare export type sendCallLog = {|
    /** Sends log file for a call to Telegram servers */
    +_: 'sendCallLog',
    /** Call identifier */
    +call_id?: number,
    /** Call log file. Only inputFileLocal and inputFileGenerated are supported */
    +log_file?: InputFile$Input,
  |}

  declare export type getVideoChatAvailableParticipants = {|
    /**
     * Returns the list of participant identifiers, on whose behalf a video chat in
     * the chat can be joined
     */
    +_: 'getVideoChatAvailableParticipants',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type setVideoChatDefaultParticipant = {|
    /**
     * Changes default participant identifier, on whose behalf a video chat in the
     * chat will be joined
     */
    +_: 'setVideoChatDefaultParticipant',
    /** Chat identifier */
    +chat_id?: number,
    /** Default group call participant identifier to join the video chats */
    +default_participant_id?: MessageSender$Input,
  |}

  declare export type createVideoChat = {|
    /**
     * Creates a video chat (a group call bound to a chat). Available only for basic
     * groups, supergroups and channels; requires can_manage_video_chats administrator
     * right
     */
    +_: 'createVideoChat',
    /** Identifier of a chat in which the video chat will be created */
    +chat_id?: number,
    /** Group call title; if empty, chat title will be used */
    +title?: string,
    /**
     * Point in time (Unix timestamp) when the group call is expected to be started
     * by an administrator; 0 to start the video chat immediately. The date must be
     * at least 10 seconds and at most 8 days in the future
     */
    +start_date?: number,
    /** Pass true to create an RTMP stream instead of an ordinary video chat */
    +is_rtmp_stream?: boolean,
  |}

  declare export type createGroupCall = {|
    /** Creates a group call from a one-to-one call */
    +_: 'createGroupCall',
    /** Call identifier */
    +call_id?: number,
  |}

  declare export type getVideoChatRtmpUrl = {|
    /**
     * Returns RTMP URL for streaming to the chat; requires can_manage_video_chats
     * administrator right
     */
    +_: 'getVideoChatRtmpUrl',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type replaceVideoChatRtmpUrl = {|
    /** Replaces the current RTMP URL for streaming to the chat; requires owner privileges */
    +_: 'replaceVideoChatRtmpUrl',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type getGroupCall = {|
    /** Returns information about a group call */
    +_: 'getGroupCall',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type startScheduledGroupCall = {|
    /** Starts a scheduled group call */
    +_: 'startScheduledGroupCall',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type toggleGroupCallEnabledStartNotification = {|
    /**
     * Toggles whether the current user will receive a notification when the group
     * call starts; scheduled group calls only
     */
    +_: 'toggleGroupCallEnabledStartNotification',
    /** Group call identifier */
    +group_call_id?: number,
    /** New value of the enabled_start_notification setting */
    +enabled_start_notification?: boolean,
  |}

  declare export type joinGroupCall = {|
    /** Joins an active group call. Returns join response payload for tgcalls */
    +_: 'joinGroupCall',
    /** Group call identifier */
    +group_call_id?: number,
    /**
     * Identifier of a group call participant, which will be used to join the call;
     * pass null to join as self; video chats only
     */
    +participant_id?: MessageSender$Input,
    /** Caller audio channel synchronization source identifier; received from tgcalls */
    +audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    +payload?: string,
    /** Pass true to join the call with muted microphone */
    +is_muted?: boolean,
    /** Pass true if the user's video is enabled */
    +is_my_video_enabled?: boolean,
    /**
     * If non-empty, invite hash to be used to join the group call without being muted
     * by administrators
     */
    +invite_hash?: string,
    /**
     * Fingerprint of the encryption key for E2E group calls not bound to a chat; pass
     * 0 for voice chats
     */
    +key_fingerprint?: number | string,
  |}

  declare export type startGroupCallScreenSharing = {|
    /**
     * Starts screen sharing in a joined group call. Returns join response payload
     * for tgcalls
     */
    +_: 'startGroupCallScreenSharing',
    /** Group call identifier */
    +group_call_id?: number,
    /**
     * Screen sharing audio channel synchronization source identifier; received from
     * tgcalls
     */
    +audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    +payload?: string,
  |}

  declare export type toggleGroupCallScreenSharingIsPaused = {|
    /** Pauses or unpauses screen sharing in a joined group call */
    +_: 'toggleGroupCallScreenSharingIsPaused',
    /** Group call identifier */
    +group_call_id?: number,
    /** Pass true to pause screen sharing; pass false to unpause it */
    +is_paused?: boolean,
  |}

  declare export type endGroupCallScreenSharing = {|
    /** Ends screen sharing in a joined group call */
    +_: 'endGroupCallScreenSharing',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type setGroupCallTitle = {|
    /** Sets group call title. Requires groupCall.can_be_managed group call flag */
    +_: 'setGroupCallTitle',
    /** Group call identifier */
    +group_call_id?: number,
    /** New group call title; 1-64 characters */
    +title?: string,
  |}

  declare export type toggleGroupCallMuteNewParticipants = {|
    /**
     * Toggles whether new participants of a group call can be unmuted only by administrators
     * of the group call. Requires groupCall.can_toggle_mute_new_participants group
     * call flag
     */
    +_: 'toggleGroupCallMuteNewParticipants',
    /** Group call identifier */
    +group_call_id?: number,
    /** New value of the mute_new_participants setting */
    +mute_new_participants?: boolean,
  |}

  declare export type inviteGroupCallParticipants = {|
    /**
     * Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants
     * for video chats
     */
    +_: 'inviteGroupCallParticipants',
    /** Group call identifier */
    +group_call_id?: number,
    /** User identifiers. At most 10 users can be invited simultaneously */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getGroupCallInviteLink = {|
    /** Returns invite link to a video chat in a public chat */
    +_: 'getGroupCallInviteLink',
    /** Group call identifier */
    +group_call_id?: number,
    /**
     * Pass true if the invite link needs to contain an invite hash, passing which
     * to joinGroupCall would allow the invited user to unmute themselves. Requires
     * groupCall.can_be_managed group call flag
     */
    +can_self_unmute?: boolean,
  |}

  declare export type revokeGroupCallInviteLink = {|
    /**
     * Revokes invite link for a group call. Requires groupCall.can_be_managed group
     * call flag
     */
    +_: 'revokeGroupCallInviteLink',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type startGroupCallRecording = {|
    /**
     * Starts recording of an active group call. Requires groupCall.can_be_managed
     * group call flag
     */
    +_: 'startGroupCallRecording',
    /** Group call identifier */
    +group_call_id?: number,
    /** Group call recording title; 0-64 characters */
    +title?: string,
    /** Pass true to record a video file instead of an audio file */
    +record_video?: boolean,
    /** Pass true to use portrait orientation for video instead of landscape one */
    +use_portrait_orientation?: boolean,
  |}

  declare export type endGroupCallRecording = {|
    /**
     * Ends recording of an active group call. Requires groupCall.can_be_managed group
     * call flag
     */
    +_: 'endGroupCallRecording',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type toggleGroupCallIsMyVideoPaused = {|
    /** Toggles whether current user's video is paused */
    +_: 'toggleGroupCallIsMyVideoPaused',
    /** Group call identifier */
    +group_call_id?: number,
    /** Pass true if the current user's video is paused */
    +is_my_video_paused?: boolean,
  |}

  declare export type toggleGroupCallIsMyVideoEnabled = {|
    /** Toggles whether current user's video is enabled */
    +_: 'toggleGroupCallIsMyVideoEnabled',
    /** Group call identifier */
    +group_call_id?: number,
    /** Pass true if the current user's video is enabled */
    +is_my_video_enabled?: boolean,
  |}

  declare export type setGroupCallParticipantIsSpeaking = {|
    /** Informs TDLib that speaking state of a participant of an active group has changed */
    +_: 'setGroupCallParticipantIsSpeaking',
    /** Group call identifier */
    +group_call_id?: number,
    /**
     * Group call participant's synchronization audio source identifier, or 0 for the
     * current user
     */
    +audio_source?: number,
    /** Pass true if the user is speaking */
    +is_speaking?: boolean,
  |}

  declare export type toggleGroupCallParticipantIsMuted = {|
    /**
     * Toggles whether a participant of an active group call is muted, unmuted, or
     * allowed to unmute themselves
     */
    +_: 'toggleGroupCallParticipantIsMuted',
    /** Group call identifier */
    +group_call_id?: number,
    /** Participant identifier */
    +participant_id?: MessageSender$Input,
    /** Pass true to mute the user; pass false to unmute them */
    +is_muted?: boolean,
  |}

  declare export type setGroupCallParticipantVolumeLevel = {|
    /**
     * Changes volume level of a participant of an active group call. If the current
     * user can manage the group call, then the participant's volume level will be
     * changed for all users with the default volume level
     */
    +_: 'setGroupCallParticipantVolumeLevel',
    /** Group call identifier */
    +group_call_id?: number,
    /** Participant identifier */
    +participant_id?: MessageSender$Input,
    /** New participant's volume level; 1-20000 in hundreds of percents */
    +volume_level?: number,
  |}

  declare export type toggleGroupCallParticipantIsHandRaised = {|
    /** Toggles whether a group call participant hand is rased */
    +_: 'toggleGroupCallParticipantIsHandRaised',
    /** Group call identifier */
    +group_call_id?: number,
    /** Participant identifier */
    +participant_id?: MessageSender$Input,
    /**
     * Pass true if the user's hand needs to be raised. Only self hand can be raised.
     * Requires groupCall.can_be_managed group call flag to lower other's hand
     */
    +is_hand_raised?: boolean,
  |}

  declare export type loadGroupCallParticipants = {|
    /**
     * Loads more participants of a group call. The loaded participants will be received
     * through updates. Use the field groupCall.loaded_all_participants to check whether
     * all participants have already been loaded
     */
    +_: 'loadGroupCallParticipants',
    /**
     * Group call identifier. The group call must be previously received through getGroupCall
     * and must be joined or being joined
     */
    +group_call_id?: number,
    /** The maximum number of participants to load; up to 100 */
    +limit?: number,
  |}

  declare export type leaveGroupCall = {|
    /** Leaves a group call */
    +_: 'leaveGroupCall',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type endGroupCall = {|
    /** Ends a group call. Requires groupCall.can_be_managed */
    +_: 'endGroupCall',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type getGroupCallStreams = {|
    /** Returns information about available group call streams */
    +_: 'getGroupCallStreams',
    /** Group call identifier */
    +group_call_id?: number,
  |}

  declare export type getGroupCallStreamSegment = {|
    /**
     * Returns a file with a segment of a group call stream in a modified OGG format
     * for audio or MPEG-4 format for video
     */
    +_: 'getGroupCallStreamSegment',
    /** Group call identifier */
    +group_call_id?: number,
    /** Point in time when the stream segment begins; Unix timestamp in milliseconds */
    +time_offset?: number,
    /** Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds */
    +scale?: number,
    /** Identifier of an audio/video channel to get as received from tgcalls */
    +channel_id?: number,
    /**
     * Video quality as received from tgcalls; pass null to get the worst available
     * quality
     */
    +video_quality?: GroupCallVideoQuality$Input,
  |}

  declare export type setMessageSenderBlockList = {|
    /**
     * Changes the block list of a message sender. Currently, only users and supergroup
     * chats can be blocked
     */
    +_: 'setMessageSenderBlockList',
    /** Identifier of a message sender to block/unblock */
    +sender_id?: MessageSender$Input,
    /** New block list for the message sender; pass null to unblock the message sender */
    +block_list?: BlockList$Input,
  |}

  declare export type blockMessageSenderFromReplies = {|
    /** Blocks an original sender of a message in the Replies chat */
    +_: 'blockMessageSenderFromReplies',
    /** The identifier of an incoming message in the Replies chat */
    +message_id?: number,
    /** Pass true to delete the message */
    +delete_message?: boolean,
    /** Pass true to delete all messages from the same sender */
    +delete_all_messages?: boolean,
    /** Pass true to report the sender to the Telegram moderators */
    +report_spam?: boolean,
  |}

  declare export type getBlockedMessageSenders = {|
    /** Returns users and chats that were blocked by the current user */
    +_: 'getBlockedMessageSenders',
    /** Block list from which to return users */
    +block_list?: BlockList$Input,
    /** Number of users and chats to skip in the result; must be non-negative */
    +offset?: number,
    /** The maximum number of users and chats to return; up to 100 */
    +limit?: number,
  |}

  declare export type addContact = {|
    /** Adds a user to the contact list or edits an existing contact by their user identifier */
    +_: 'addContact',
    /**
     * The contact to add or edit; phone number may be empty and needs to be specified
     * only if known, vCard is ignored
     */
    +contact?: contact$Input,
    /**
     * Pass true to share the current user's phone number with the new contact. A corresponding
     * rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field
     * userFullInfo.need_phone_number_privacy_exception to check whether the current
     * user needs to be asked to share their phone number
     */
    +share_phone_number?: boolean,
  |}

  declare export type importContacts = {|
    /**
     * Adds new contacts or edits existing contacts by their phone numbers; contacts'
     * user identifiers are ignored
     */
    +_: 'importContacts',
    /**
     * The list of contacts to import or edit; contacts' vCard are ignored and are
     * not imported
     */
    +contacts?: $ReadOnlyArray<contact$Input>,
  |}

  declare export type getContacts = {|
    /** Returns all contacts of the user */
    +_: 'getContacts',
  |}

  declare export type searchContacts = {|
    /**
     * Searches for the specified query in the first names, last names and usernames
     * of the known user contacts
     */
    +_: 'searchContacts',
    /** Query to search for; may be empty to return all contacts */
    +query?: string,
    /** The maximum number of users to be returned */
    +limit?: number,
  |}

  declare export type removeContacts = {|
    /** Removes users from the contact list */
    +_: 'removeContacts',
    /** Identifiers of users to be deleted */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getImportedContactCount = {|
    /** Returns the total number of imported contacts */
    +_: 'getImportedContactCount',
  |}

  declare export type changeImportedContacts = {|
    /**
     * Changes imported contacts using the list of contacts saved on the device. Imports
     * newly added contacts and, if at least the file database is enabled, deletes
     * recently deleted contacts. Query result depends on the result of the previous
     * query, so only one query is possible at the same time
     */
    +_: 'changeImportedContacts',
    /** The new list of contacts, contact's vCard are ignored and are not imported */
    +contacts?: $ReadOnlyArray<contact$Input>,
  |}

  declare export type clearImportedContacts = {|
    /** Clears all imported contacts, contact list remains unchanged */
    +_: 'clearImportedContacts',
  |}

  declare export type setCloseFriends = {|
    /** Changes the list of close friends of the current user */
    +_: 'setCloseFriends',
    /**
     * User identifiers of close friends; the users must be contacts of the current
     * user
     */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getCloseFriends = {|
    /** Returns all close friends of the current user */
    +_: 'getCloseFriends',
  |}

  declare export type setUserPersonalProfilePhoto = {|
    /** Changes a personal profile photo of a contact user */
    +_: 'setUserPersonalProfilePhoto',
    /** User identifier */
    +user_id?: number,
    /**
     * Profile photo to set; pass null to delete the photo; inputChatPhotoPrevious
     * isn't supported in this function
     */
    +photo?: InputChatPhoto$Input,
  |}

  declare export type suggestUserProfilePhoto = {|
    /**
     * Suggests a profile photo to another regular user with common messages and allowing
     * non-paid messages
     */
    +_: 'suggestUserProfilePhoto',
    /** User identifier */
    +user_id?: number,
    /** Profile photo to suggest; inputChatPhotoPrevious isn't supported in this function */
    +photo?: InputChatPhoto$Input,
  |}

  declare export type toggleBotCanManageEmojiStatus = {|
    /** Toggles whether the bot can manage emoji status of the current user */
    +_: 'toggleBotCanManageEmojiStatus',
    /** User identifier of the bot */
    +bot_user_id?: number,
    /**
     * Pass true if the bot is allowed to change emoji status of the user; pass false
     * otherwise
     */
    +can_manage_emoji_status?: boolean,
  |}

  declare export type setUserEmojiStatus = {|
    /** Changes the emoji status of a user; for bots only */
    +_: 'setUserEmojiStatus',
    /** Identifier of the user */
    +user_id?: number,
    /** New emoji status; pass null to switch to the default badge */
    +emoji_status?: emojiStatus$Input,
  |}

  declare export type searchUserByPhoneNumber = {|
    /**
     * Searches a user by their phone number. Returns a 404 error if the user can't
     * be found
     */
    +_: 'searchUserByPhoneNumber',
    /** Phone number to search for */
    +phone_number?: string,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    +only_local?: boolean,
  |}

  declare export type sharePhoneNumber = {|
    /**
     * Shares the phone number of the current user with a mutual contact. Supposed
     * to be called when the user clicks on chatActionBarSharePhoneNumber
     */
    +_: 'sharePhoneNumber',
    /**
     * Identifier of the user with whom to share the phone number. The user must be
     * a mutual contact
     */
    +user_id?: number,
  |}

  declare export type getUserProfilePhotos = {|
    /** Returns the profile photos of a user. Personal and public photo aren't returned */
    +_: 'getUserProfilePhotos',
    /** User identifier */
    +user_id?: number,
    /** The number of photos to skip; must be non-negative */
    +offset?: number,
    /** The maximum number of photos to be returned; up to 100 */
    +limit?: number,
  |}

  declare export type getStickerOutline = {|
    /**
     * Returns outline of a sticker; this is an offline request. Returns a 404 error
     * if the outline isn't known
     */
    +_: 'getStickerOutline',
    /** File identifier of the sticker */
    +sticker_file_id?: number,
    /** Pass true to get the outline scaled for animated emoji */
    +for_animated_emoji?: boolean,
    /** Pass true to get the outline scaled for clicked animated emoji message */
    +for_clicked_animated_emoji_message?: boolean,
  |}

  declare export type getStickers = {|
    /**
     * Returns stickers from the installed sticker sets that correspond to any of the
     * given emoji or can be found by sticker-specific keywords. If the query is non-empty,
     * then favorite, recently used or trending stickers may also be returned
     */
    +_: 'getStickers',
    /** Type of the stickers to return */
    +sticker_type?: StickerType$Input,
    /**
     * Search query; a space-separated list of emojis or a keyword prefix. If empty,
     * returns all known installed stickers
     */
    +query?: string,
    /** The maximum number of stickers to be returned */
    +limit?: number,
    /**
     * Chat identifier for which to return stickers. Available custom emoji stickers
     * may be different for different chats
     */
    +chat_id?: number,
  |}

  declare export type getAllStickerEmojis = {|
    /**
     * Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type,
     * query, 1000000, chat_id)
     */
    +_: 'getAllStickerEmojis',
    /** Type of the stickers to search for */
    +sticker_type?: StickerType$Input,
    /** Search query */
    +query?: string,
    /** Chat identifier for which to find stickers */
    +chat_id?: number,
    /**
     * Pass true if only main emoji for each found sticker must be included in the
     * result
     */
    +return_only_main_emoji?: boolean,
  |}

  declare export type searchStickers = {|
    /**
     * Searches for stickers from public sticker sets that correspond to any of the
     * given emoji
     */
    +_: 'searchStickers',
    /** Type of the stickers to return */
    +sticker_type?: StickerType$Input,
    /** Space-separated list of emojis to search for */
    +emojis?: string,
    /** Query to search for; may be empty to search for emoji only */
    +query?: string,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    +input_language_codes?: $ReadOnlyArray<string>,
    /** The offset from which to return the stickers; must be non-negative */
    +offset?: number,
    /** The maximum number of stickers to be returned; 0-100 */
    +limit?: number,
  |}

  declare export type getGreetingStickers = {|
    /**
     * Returns greeting stickers from regular sticker sets that can be used for the
     * start page of other users
     */
    +_: 'getGreetingStickers',
  |}

  declare export type getPremiumStickers = {|
    /** Returns premium stickers from regular sticker sets */
    +_: 'getPremiumStickers',
    /** The maximum number of stickers to be returned; 0-100 */
    +limit?: number,
  |}

  declare export type getInstalledStickerSets = {|
    /** Returns a list of installed sticker sets */
    +_: 'getInstalledStickerSets',
    /** Type of the sticker sets to return */
    +sticker_type?: StickerType$Input,
  |}

  declare export type getArchivedStickerSets = {|
    /** Returns a list of archived sticker sets */
    +_: 'getArchivedStickerSets',
    /** Type of the sticker sets to return */
    +sticker_type?: StickerType$Input,
    /**
     * Identifier of the sticker set from which to return the result; use 0 to get
     * results from the beginning
     */
    +offset_sticker_set_id?: number | string,
    /** The maximum number of sticker sets to return; up to 100 */
    +limit?: number,
  |}

  declare export type getTrendingStickerSets = {|
    /**
     * Returns a list of trending sticker sets. For optimal performance, the number
     * of returned sticker sets is chosen by TDLib
     */
    +_: 'getTrendingStickerSets',
    /** Type of the sticker sets to return */
    +sticker_type?: StickerType$Input,
    /** The offset from which to return the sticker sets; must be non-negative */
    +offset?: number,
    /**
     * The maximum number of sticker sets to be returned; up to 100. For optimal performance,
     * the number of returned sticker sets is chosen by TDLib and can be smaller than
     * the specified limit, even if the end of the list has not been reached
     */
    +limit?: number,
  |}

  declare export type getAttachedStickerSets = {|
    /**
     * Returns a list of sticker sets attached to a file, including regular, mask,
     * and emoji sticker sets. Currently, only animations, photos, and videos can have
     * attached sticker sets
     */
    +_: 'getAttachedStickerSets',
    /** File identifier */
    +file_id?: number,
  |}

  declare export type getStickerSet = {|
    /** Returns information about a sticker set by its identifier */
    +_: 'getStickerSet',
    /** Identifier of the sticker set */
    +set_id?: number | string,
  |}

  declare export type getStickerSetName = {|
    /** Returns name of a sticker set by its identifier */
    +_: 'getStickerSetName',
    /** Identifier of the sticker set */
    +set_id?: number | string,
  |}

  declare export type searchStickerSet = {|
    /** Searches for a sticker set by its name */
    +_: 'searchStickerSet',
    /** Name of the sticker set */
    +name?: string,
    /** Pass true to ignore local cache of sticker sets and always send a network request */
    +ignore_cache?: boolean,
  |}

  declare export type searchInstalledStickerSets = {|
    /**
     * Searches for installed sticker sets by looking for specified query in their
     * title and name
     */
    +_: 'searchInstalledStickerSets',
    /** Type of the sticker sets to search for */
    +sticker_type?: StickerType$Input,
    /** Query to search for */
    +query?: string,
    /** The maximum number of sticker sets to return */
    +limit?: number,
  |}

  declare export type searchStickerSets = {|
    /**
     * Searches for sticker sets by looking for specified query in their title and
     * name. Excludes installed sticker sets from the results
     */
    +_: 'searchStickerSets',
    /** Type of the sticker sets to return */
    +sticker_type?: StickerType$Input,
    /** Query to search for */
    +query?: string,
  |}

  declare export type changeStickerSet = {|
    /** Installs/uninstalls or activates/archives a sticker set */
    +_: 'changeStickerSet',
    /** Identifier of the sticker set */
    +set_id?: number | string,
    /** The new value of is_installed */
    +is_installed?: boolean,
    /**
     * The new value of is_archived. A sticker set can't be installed and archived
     * simultaneously
     */
    +is_archived?: boolean,
  |}

  declare export type viewTrendingStickerSets = {|
    /** Informs the server that some trending sticker sets have been viewed by the user */
    +_: 'viewTrendingStickerSets',
    /** Identifiers of viewed trending sticker sets */
    +sticker_set_ids?: $ReadOnlyArray<number | string>,
  |}

  declare export type reorderInstalledStickerSets = {|
    /** Changes the order of installed sticker sets */
    +_: 'reorderInstalledStickerSets',
    /** Type of the sticker sets to reorder */
    +sticker_type?: StickerType$Input,
    /** Identifiers of installed sticker sets in the new correct order */
    +sticker_set_ids?: $ReadOnlyArray<number | string>,
  |}

  declare export type getRecentStickers = {|
    /** Returns a list of recently used stickers */
    +_: 'getRecentStickers',
    /**
     * Pass true to return stickers and masks that were recently attached to photos
     * or video files; pass false to return recently sent stickers
     */
    +is_attached?: boolean,
  |}

  declare export type addRecentSticker = {|
    /**
     * Manually adds a new sticker to the list of recently used stickers. The new sticker
     * is added to the top of the list. If the sticker was already in the list, it
     * is removed from the list first. Only stickers belonging to a sticker set or
     * in WEBP or WEBM format can be added to this list. Emoji stickers can't be added
     * to recent stickers
     */
    +_: 'addRecentSticker',
    /**
     * Pass true to add the sticker to the list of stickers recently attached to photo
     * or video files; pass false to add the sticker to the list of recently sent stickers
     */
    +is_attached?: boolean,
    /** Sticker file to add */
    +sticker?: InputFile$Input,
  |}

  declare export type removeRecentSticker = {|
    /** Removes a sticker from the list of recently used stickers */
    +_: 'removeRecentSticker',
    /**
     * Pass true to remove the sticker from the list of stickers recently attached
     * to photo or video files; pass false to remove the sticker from the list of recently
     * sent stickers
     */
    +is_attached?: boolean,
    /** Sticker file to delete */
    +sticker?: InputFile$Input,
  |}

  declare export type clearRecentStickers = {|
    /** Clears the list of recently used stickers */
    +_: 'clearRecentStickers',
    /**
     * Pass true to clear the list of stickers recently attached to photo or video
     * files; pass false to clear the list of recently sent stickers
     */
    +is_attached?: boolean,
  |}

  declare export type getFavoriteStickers = {|
    /** Returns favorite stickers */
    +_: 'getFavoriteStickers',
  |}

  declare export type addFavoriteSticker = {|
    /**
     * Adds a new sticker to the list of favorite stickers. The new sticker is added
     * to the top of the list. If the sticker was already in the list, it is removed
     * from the list first. Only stickers belonging to a sticker set or in WEBP or
     * WEBM format can be added to this list. Emoji stickers can't be added to favorite
     * stickers
     */
    +_: 'addFavoriteSticker',
    /** Sticker file to add */
    +sticker?: InputFile$Input,
  |}

  declare export type removeFavoriteSticker = {|
    /** Removes a sticker from the list of favorite stickers */
    +_: 'removeFavoriteSticker',
    /** Sticker file to delete from the list */
    +sticker?: InputFile$Input,
  |}

  declare export type getStickerEmojis = {|
    /**
     * Returns emoji corresponding to a sticker. The list is only for informational
     * purposes, because a sticker is always sent with a fixed emoji from the corresponding
     * Sticker object
     */
    +_: 'getStickerEmojis',
    /** Sticker file identifier */
    +sticker?: InputFile$Input,
  |}

  declare export type searchEmojis = {|
    /**
     * Searches for emojis by keywords. Supported only if the file database is enabled.
     * Order of results is unspecified
     */
    +_: 'searchEmojis',
    /** Text to search for */
    +text?: string,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    +input_language_codes?: $ReadOnlyArray<string>,
  |}

  declare export type getKeywordEmojis = {|
    /**
     * Return emojis matching the keyword. Supported only if the file database is enabled.
     * Order of results is unspecified
     */
    +_: 'getKeywordEmojis',
    /** Text to search for */
    +text?: string,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    +input_language_codes?: $ReadOnlyArray<string>,
  |}

  declare export type getEmojiCategories = {|
    /** Returns available emoji categories */
    +_: 'getEmojiCategories',
    /** Type of emoji categories to return; pass null to get default emoji categories */
    +type?: EmojiCategoryType$Input,
  |}

  declare export type getAnimatedEmoji = {|
    /**
     * Returns an animated emoji corresponding to a given emoji. Returns a 404 error
     * if the emoji has no animated emoji
     */
    +_: 'getAnimatedEmoji',
    /** The emoji */
    +emoji?: string,
  |}

  declare export type getEmojiSuggestionsUrl = {|
    /**
     * Returns an HTTP URL which can be used to automatically log in to the translation
     * platform and suggest new emoji replacements. The URL will be valid for 30 seconds
     * after generation
     */
    +_: 'getEmojiSuggestionsUrl',
    /** Language code for which the emoji replacements will be suggested */
    +language_code?: string,
  |}

  declare export type getCustomEmojiStickers = {|
    /**
     * Returns the list of custom emoji stickers by their identifiers. Stickers are
     * returned in arbitrary order. Only found stickers are returned
     */
    +_: 'getCustomEmojiStickers',
    /**
     * Identifiers of custom emoji stickers. At most 200 custom emoji stickers can
     * be received simultaneously
     */
    +custom_emoji_ids?: $ReadOnlyArray<number | string>,
  |}

  declare export type getDefaultChatPhotoCustomEmojiStickers = {|
    /** Returns default list of custom emoji stickers for placing on a chat photo */
    +_: 'getDefaultChatPhotoCustomEmojiStickers',
  |}

  declare export type getDefaultProfilePhotoCustomEmojiStickers = {|
    /** Returns default list of custom emoji stickers for placing on a profile photo */
    +_: 'getDefaultProfilePhotoCustomEmojiStickers',
  |}

  declare export type getDefaultBackgroundCustomEmojiStickers = {|
    /** Returns default list of custom emoji stickers for reply background */
    +_: 'getDefaultBackgroundCustomEmojiStickers',
  |}

  declare export type getSavedAnimations = {|
    /** Returns saved animations */
    +_: 'getSavedAnimations',
  |}

  declare export type addSavedAnimation = {|
    /**
     * Manually adds a new animation to the list of saved animations. The new animation
     * is added to the beginning of the list. If the animation was already in the list,
     * it is removed first. Only non-secret video animations with MIME type "video/mp4"
     * can be added to the list
     */
    +_: 'addSavedAnimation',
    /**
     * The animation file to be added. Only animations known to the server (i.e., successfully
     * sent via a message) can be added to the list
     */
    +animation?: InputFile$Input,
  |}

  declare export type removeSavedAnimation = {|
    /** Removes an animation from the list of saved animations */
    +_: 'removeSavedAnimation',
    /** Animation file to be removed */
    +animation?: InputFile$Input,
  |}

  declare export type getRecentInlineBots = {|
    /** Returns up to 20 recently used inline bots in the order of their last usage */
    +_: 'getRecentInlineBots',
  |}

  declare export type getOwnedBots = {|
    /** Returns the list of bots owned by the current user */
    +_: 'getOwnedBots',
  |}

  declare export type searchHashtags = {|
    /** Searches for recently used hashtags by their prefix */
    +_: 'searchHashtags',
    /** Hashtag prefix to search for */
    +prefix?: string,
    /** The maximum number of hashtags to be returned */
    +limit?: number,
  |}

  declare export type removeRecentHashtag = {|
    /** Removes a hashtag from the list of recently used hashtags */
    +_: 'removeRecentHashtag',
    /** Hashtag to delete */
    +hashtag?: string,
  |}

  declare export type getLinkPreview = {|
    /**
     * Returns a link preview by the text of a message. Do not call this function too
     * often. Returns a 404 error if the text has no link preview
     */
    +_: 'getLinkPreview',
    /** Message text with formatting */
    +text?: formattedText$Input,
    /**
     * Options to be used for generation of the link preview; pass null to use default
     * link preview options
     */
    +link_preview_options?: linkPreviewOptions$Input,
  |}

  declare export type getWebPageInstantView = {|
    /**
     * Returns an instant view version of a web page if available. This is an offline
     * request if only_local is true. Returns a 404 error if the web page has no instant
     * view page
     */
    +_: 'getWebPageInstantView',
    /** The web page URL */
    +url?: string,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    +only_local?: boolean,
  |}

  declare export type setProfilePhoto = {|
    /** Changes a profile photo for the current user */
    +_: 'setProfilePhoto',
    /** Profile photo to set */
    +photo?: InputChatPhoto$Input,
    /**
     * Pass true to set a public photo, which will be visible even the main photo is
     * hidden by privacy settings
     */
    +is_public?: boolean,
  |}

  declare export type deleteProfilePhoto = {|
    /** Deletes a profile photo */
    +_: 'deleteProfilePhoto',
    /** Identifier of the profile photo to delete */
    +profile_photo_id?: number | string,
  |}

  declare export type setAccentColor = {|
    /**
     * Changes accent color and background custom emoji for the current user; for Telegram
     * Premium users only
     */
    +_: 'setAccentColor',
    /** Identifier of the accent color to use */
    +accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background; 0 if none
     */
    +background_custom_emoji_id?: number | string,
  |}

  declare export type setProfileAccentColor = {|
    /**
     * Changes accent color and background custom emoji for profile of the current
     * user; for Telegram Premium users only
     */
    +_: 'setProfileAccentColor',
    /** Identifier of the accent color to use for profile; pass -1 if none */
    +profile_accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the user's profile photo background;
     * 0 if none
     */
    +profile_background_custom_emoji_id?: number | string,
  |}

  declare export type setName = {|
    /** Changes the first and last name of the current user */
    +_: 'setName',
    /** The new value of the first name for the current user; 1-64 characters */
    +first_name?: string,
    /** The new value of the optional last name for the current user; 0-64 characters */
    +last_name?: string,
  |}

  declare export type setBio = {|
    /** Changes the bio of the current user */
    +_: 'setBio',
    /**
     * The new value of the user bio; 0-getOption("bio_length_max") characters without
     * line feeds
     */
    +bio?: string,
  |}

  declare export type setUsername = {|
    /** Changes the editable username of the current user */
    +_: 'setUsername',
    /**
     * The new value of the username. Use an empty string to remove the username. The
     * username can't be completely removed if there is another active or disabled
     * username
     */
    +username?: string,
  |}

  declare export type toggleUsernameIsActive = {|
    /**
     * Changes active state for a username of the current user. The editable username
     * can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH"
     * if the maximum number of active usernames has been reached
     */
    +_: 'toggleUsernameIsActive',
    /** The username to change */
    +username?: string,
    /** Pass true to activate the username; pass false to disable it */
    +is_active?: boolean,
  |}

  declare export type reorderActiveUsernames = {|
    /** Changes order of active usernames of the current user */
    +_: 'reorderActiveUsernames',
    /** The new order of active usernames. All currently active usernames must be specified */
    +usernames?: $ReadOnlyArray<string>,
  |}

  declare export type setBirthdate = {|
    /** Changes the birthdate of the current user */
    +_: 'setBirthdate',
    /** The new value of the current user's birthdate; pass null to remove the birthdate */
    +birthdate?: birthdate$Input,
  |}

  declare export type setPersonalChat = {|
    /** Changes the personal chat of the current user */
    +_: 'setPersonalChat',
    /**
     * Identifier of the new personal chat; pass 0 to remove the chat. Use getSuitablePersonalChats
     * to get suitable chats
     */
    +chat_id?: number,
  |}

  declare export type setEmojiStatus = {|
    /** Changes the emoji status of the current user; for Telegram Premium users only */
    +_: 'setEmojiStatus',
    /** New emoji status; pass null to switch to the default badge */
    +emoji_status?: emojiStatus$Input,
  |}

  declare export type toggleHasSponsoredMessagesEnabled = {|
    /**
     * Toggles whether the current user has sponsored messages enabled. The setting
     * has no effect for users without Telegram Premium for which sponsored messages
     * are always enabled
     */
    +_: 'toggleHasSponsoredMessagesEnabled',
    /**
     * Pass true to enable sponsored messages for the current user; false to disable
     * them
     */
    +has_sponsored_messages_enabled?: boolean,
  |}

  declare export type setBusinessLocation = {|
    /**
     * Changes the business location of the current user. Requires Telegram Business
     * subscription
     */
    +_: 'setBusinessLocation',
    /** The new location of the business; pass null to remove the location */
    +location?: businessLocation$Input,
  |}

  declare export type setBusinessOpeningHours = {|
    /**
     * Changes the business opening hours of the current user. Requires Telegram Business
     * subscription
     */
    +_: 'setBusinessOpeningHours',
    /**
     * The new opening hours of the business; pass null to remove the opening hours;
     * up to 28 time intervals can be specified
     */
    +opening_hours?: businessOpeningHours$Input,
  |}

  declare export type setBusinessGreetingMessageSettings = {|
    /**
     * Changes the business greeting message settings of the current user. Requires
     * Telegram Business subscription
     */
    +_: 'setBusinessGreetingMessageSettings',
    /**
     * The new settings for the greeting message of the business; pass null to disable
     * the greeting message
     */
    +greeting_message_settings?: businessGreetingMessageSettings$Input,
  |}

  declare export type setBusinessAwayMessageSettings = {|
    /**
     * Changes the business away message settings of the current user. Requires Telegram
     * Business subscription
     */
    +_: 'setBusinessAwayMessageSettings',
    /**
     * The new settings for the away message of the business; pass null to disable
     * the away message
     */
    +away_message_settings?: businessAwayMessageSettings$Input,
  |}

  declare export type setBusinessStartPage = {|
    /**
     * Changes the business start page of the current user. Requires Telegram Business
     * subscription
     */
    +_: 'setBusinessStartPage',
    /** The new start page of the business; pass null to remove custom start page */
    +start_page?: inputBusinessStartPage$Input,
  |}

  declare export type sendPhoneNumberCode = {|
    /**
     * Sends a code to the specified phone number. Aborts previous phone number verification
     * if there was one. On success, returns information about the sent code
     */
    +_: 'sendPhoneNumberCode',
    /** The phone number, in international format */
    +phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    +settings?: phoneNumberAuthenticationSettings$Input,
    /** Type of the request for which the code is sent */
    +type?: PhoneNumberCodeType$Input,
  |}

  declare export type sendPhoneNumberFirebaseSms = {|
    /**
     * Sends Firebase Authentication SMS to the specified phone number. Works only
     * when received a code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
     */
    +_: 'sendPhoneNumberFirebaseSms',
    /**
     * Play Integrity API or SafetyNet Attestation API token for the Android application,
     * or secret from push notification for the iOS application
     */
    +token?: string,
  |}

  declare export type reportPhoneNumberCodeMissing = {|
    /**
     * Reports that authentication code wasn't delivered via SMS to the specified phone
     * number; for official mobile applications only
     */
    +_: 'reportPhoneNumberCodeMissing',
    /** Current mobile network code */
    +mobile_network_code?: string,
  |}

  declare export type resendPhoneNumberCode = {|
    /**
     * Resends the authentication code sent to a phone number. Works only if the previously
     * received authenticationCodeInfo next_code_type was not null and the server-specified
     * timeout has passed
     */
    +_: 'resendPhoneNumberCode',
    /** Reason of code resending; pass null if unknown */
    +reason?: ResendCodeReason$Input,
  |}

  declare export type checkPhoneNumberCode = {|
    /**
     * Check the authentication code and completes the request for which the code was
     * sent if appropriate
     */
    +_: 'checkPhoneNumberCode',
    /** Authentication code to check */
    +code?: string,
  |}

  declare export type getBusinessConnectedBot = {|
    /**
     * Returns the business bot that is connected to the current user account. Returns
     * a 404 error if there is no connected bot
     */
    +_: 'getBusinessConnectedBot',
  |}

  declare export type setBusinessConnectedBot = {|
    /** Adds or changes business bot that is connected to the current user account */
    +_: 'setBusinessConnectedBot',
    /** Connection settings for the bot */
    +bot?: businessConnectedBot$Input,
  |}

  declare export type deleteBusinessConnectedBot = {|
    /** Deletes the business bot that is connected to the current user account */
    +_: 'deleteBusinessConnectedBot',
    /** Unique user identifier for the bot */
    +bot_user_id?: number,
  |}

  declare export type toggleBusinessConnectedBotChatIsPaused = {|
    /** Pauses or resumes the connected business bot in a specific chat */
    +_: 'toggleBusinessConnectedBotChatIsPaused',
    /** Chat identifier */
    +chat_id?: number,
    /** Pass true to pause the connected bot in the chat; pass false to resume the bot */
    +is_paused?: boolean,
  |}

  declare export type removeBusinessConnectedBotFromChat = {|
    /**
     * Removes the connected business bot from a specific chat by adding the chat to
     * businessRecipients.excluded_chat_ids
     */
    +_: 'removeBusinessConnectedBotFromChat',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type getBusinessChatLinks = {|
    /** Returns business chat links created for the current account */
    +_: 'getBusinessChatLinks',
  |}

  declare export type createBusinessChatLink = {|
    /**
     * Creates a business chat link for the current account. Requires Telegram Business
     * subscription. There can be up to getOption("business_chat_link_count_max") links
     * created. Returns the created link
     */
    +_: 'createBusinessChatLink',
    /** Information about the link to create */
    +link_info?: inputBusinessChatLink$Input,
  |}

  declare export type editBusinessChatLink = {|
    /**
     * Edits a business chat link of the current account. Requires Telegram Business
     * subscription. Returns the edited link
     */
    +_: 'editBusinessChatLink',
    /** The link to edit */
    +link?: string,
    /** New description of the link */
    +link_info?: inputBusinessChatLink$Input,
  |}

  declare export type deleteBusinessChatLink = {|
    /** Deletes a business chat link of the current account */
    +_: 'deleteBusinessChatLink',
    /** The link to delete */
    +link?: string,
  |}

  declare export type getBusinessChatLinkInfo = {|
    /** Returns information about a business chat link */
    +_: 'getBusinessChatLinkInfo',
    /** Name of the link */
    +link_name?: string,
  |}

  declare export type getUserLink = {|
    /**
     * Returns an HTTPS link, which can be used to get information about the current
     * user
     */
    +_: 'getUserLink',
  |}

  declare export type searchUserByToken = {|
    /** Searches a user by a token from the user's link */
    +_: 'searchUserByToken',
    /** Token to search for */
    +token?: string,
  |}

  declare export type setCommands = {|
    /**
     * Sets the list of commands supported by the bot for the given user scope and
     * language; for bots only
     */
    +_: 'setCommands',
    /**
     * The scope to which the commands are relevant; pass null to change commands in
     * the default bot command scope
     */
    +scope?: BotCommandScope$Input,
    /**
     * A two-letter ISO 639-1 language code. If empty, the commands will be applied
     * to all users from the given scope, for which language there are no dedicated
     * commands
     */
    +language_code?: string,
    /** List of the bot's commands */
    +commands?: $ReadOnlyArray<botCommand$Input>,
  |}

  declare export type deleteCommands = {|
    /**
     * Deletes commands supported by the bot for the given user scope and language;
     * for bots only
     */
    +_: 'deleteCommands',
    /**
     * The scope to which the commands are relevant; pass null to delete commands in
     * the default bot command scope
     */
    +scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 language code or an empty string */
    +language_code?: string,
  |}

  declare export type getCommands = {|
    /**
     * Returns the list of commands supported by the bot for the given user scope and
     * language; for bots only
     */
    +_: 'getCommands',
    /**
     * The scope to which the commands are relevant; pass null to get commands in the
     * default bot command scope
     */
    +scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 language code or an empty string */
    +language_code?: string,
  |}

  declare export type setMenuButton = {|
    /** Sets menu button for the given user or for all users; for bots only */
    +_: 'setMenuButton',
    /** Identifier of the user or 0 to set menu button for all users */
    +user_id?: number,
    /** New menu button */
    +menu_button?: botMenuButton$Input,
  |}

  declare export type getMenuButton = {|
    /** Returns menu button set by the bot for the given user; for bots only */
    +_: 'getMenuButton',
    /** Identifier of the user or 0 to get the default menu button */
    +user_id?: number,
  |}

  declare export type setDefaultGroupAdministratorRights = {|
    /**
     * Sets default administrator rights for adding the bot to basic group and supergroup
     * chats; for bots only
     */
    +_: 'setDefaultGroupAdministratorRights',
    /**
     * Default administrator rights for adding the bot to basic group and supergroup
     * chats; pass null to remove default rights
     */
    +default_group_administrator_rights?: chatAdministratorRights$Input,
  |}

  declare export type setDefaultChannelAdministratorRights = {|
    /**
     * Sets default administrator rights for adding the bot to channel chats; for bots
     * only
     */
    +_: 'setDefaultChannelAdministratorRights',
    /**
     * Default administrator rights for adding the bot to channels; pass null to remove
     * default rights
     */
    +default_channel_administrator_rights?: chatAdministratorRights$Input,
  |}

  declare export type canBotSendMessages = {|
    /**
     * Checks whether the specified bot can send messages to the user. Returns a 404
     * error if can't and the access can be granted by call to allowBotToSendMessages
     */
    +_: 'canBotSendMessages',
    /** Identifier of the target bot */
    +bot_user_id?: number,
  |}

  declare export type allowBotToSendMessages = {|
    /** Allows the specified bot to send messages to the user */
    +_: 'allowBotToSendMessages',
    /** Identifier of the target bot */
    +bot_user_id?: number,
  |}

  declare export type sendWebAppCustomRequest = {|
    /** Sends a custom request from a Web App */
    +_: 'sendWebAppCustomRequest',
    /** Identifier of the bot */
    +bot_user_id?: number,
    /** The method name */
    +method?: string,
    /** JSON-serialized method parameters */
    +parameters?: string,
  |}

  declare export type getBotMediaPreviews = {|
    /** Returns the list of media previews of a bot */
    +_: 'getBotMediaPreviews',
    /** Identifier of the target bot. The bot must have the main Web App */
    +bot_user_id?: number,
  |}

  declare export type getBotMediaPreviewInfo = {|
    /**
     * Returns the list of media previews for the given language and the list of languages
     * for which the bot has dedicated previews
     */
    +_: 'getBotMediaPreviewInfo',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    +bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code for which to get previews. If empty, then
     * default previews are returned
     */
    +language_code?: string,
  |}

  declare export type addBotMediaPreview = {|
    /**
     * Adds a new media preview to the beginning of the list of media previews of a
     * bot. Returns the added preview after addition is completed server-side. The
     * total number of previews must not exceed getOption("bot_media_preview_count_max")
     * for the given language
     */
    +_: 'addBotMediaPreview',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    +bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code for which preview is added. If empty, then
     * the preview will be shown to all users for whose languages there are no dedicated
     * previews. If non-empty, then there must be an official language pack of the
     * same name, which is returned by getLocalizationTargetInfo
     */
    +language_code?: string,
    /** Content of the added preview */
    +content?: InputStoryContent$Input,
  |}

  declare export type editBotMediaPreview = {|
    /**
     * Replaces media preview in the list of media previews of a bot. Returns the new
     * preview after edit is completed server-side
     */
    +_: 'editBotMediaPreview',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    +bot_user_id?: number,
    /** Language code of the media preview to edit */
    +language_code?: string,
    /** File identifier of the media to replace */
    +file_id?: number,
    /** Content of the new preview */
    +content?: InputStoryContent$Input,
  |}

  declare export type reorderBotMediaPreviews = {|
    /** Changes order of media previews in the list of media previews of a bot */
    +_: 'reorderBotMediaPreviews',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    +bot_user_id?: number,
    /** Language code of the media previews to reorder */
    +language_code?: string,
    /** File identifiers of the media in the new order */
    +file_ids?: $ReadOnlyArray<number>,
  |}

  declare export type deleteBotMediaPreviews = {|
    /** Delete media previews from the list of media previews of a bot */
    +_: 'deleteBotMediaPreviews',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    +bot_user_id?: number,
    /** Language code of the media previews to delete */
    +language_code?: string,
    /** File identifiers of the media to delete */
    +file_ids?: $ReadOnlyArray<number>,
  |}

  declare export type setBotName = {|
    /** Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true */
    +_: 'setBotName',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the name will be shown to all
     * users for whose languages there is no dedicated name
     */
    +language_code?: string,
    /**
     * New bot's name on the specified language; 0-64 characters; must be non-empty
     * if language code is empty
     */
    +name?: string,
  |}

  declare export type getBotName = {|
    /**
     * Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    +_: 'getBotName',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    +language_code?: string,
  |}

  declare export type setBotProfilePhoto = {|
    /** Changes a profile photo for a bot */
    +_: 'setBotProfilePhoto',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** Profile photo to set; pass null to delete the chat photo */
    +photo?: InputChatPhoto$Input,
  |}

  declare export type toggleBotUsernameIsActive = {|
    /**
     * Changes active state for a username of a bot. The editable username can't be
     * disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if
     * the maximum number of active usernames has been reached. Can be called only
     * if userTypeBot.can_be_edited == true
     */
    +_: 'toggleBotUsernameIsActive',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** The username to change */
    +username?: string,
    /** Pass true to activate the username; pass false to disable it */
    +is_active?: boolean,
  |}

  declare export type reorderBotActiveUsernames = {|
    /**
     * Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    +_: 'reorderBotActiveUsernames',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** The new order of active usernames. All currently active usernames must be specified */
    +usernames?: $ReadOnlyArray<string>,
  |}

  declare export type setBotInfoDescription = {|
    /**
     * Sets the text shown in the chat with a bot if the chat is empty. Can be called
     * only if userTypeBot.can_be_edited == true
     */
    +_: 'setBotInfoDescription',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the description will be shown
     * to all users for whose languages there is no dedicated description
     */
    +language_code?: string,
    /** New bot's description on the specified language */
    +description?: string,
  |}

  declare export type getBotInfoDescription = {|
    /**
     * Returns the text shown in the chat with a bot if the chat is empty in the given
     * language. Can be called only if userTypeBot.can_be_edited == true
     */
    +_: 'getBotInfoDescription',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    +language_code?: string,
  |}

  declare export type setBotInfoShortDescription = {|
    /**
     * Sets the text shown on a bot's profile page and sent together with the link
     * when users share the bot. Can be called only if userTypeBot.can_be_edited ==
     * true
     */
    +_: 'setBotInfoShortDescription',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the short description will be
     * shown to all users for whose languages there is no dedicated description
     */
    +language_code?: string,
    /** New bot's short description on the specified language */
    +short_description?: string,
  |}

  declare export type getBotInfoShortDescription = {|
    /**
     * Returns the text shown on a bot's profile page and sent together with the link
     * when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    +_: 'getBotInfoShortDescription',
    /** Identifier of the target bot */
    +bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    +language_code?: string,
  |}

  declare export type setMessageSenderBotVerification = {|
    /** Changes the verification status of a user or a chat by an owned bot */
    +_: 'setMessageSenderBotVerification',
    /** Identifier of the owned bot, which will verify the user or the chat */
    +bot_user_id?: number,
    /**
     * Identifier of the user or the supergroup or channel chat, which will be verified
     * by the bot
     */
    +verified_id?: MessageSender$Input,
    /**
     * Custom description of verification reason; 0-getOption("bot_verification_custom_description_length_max").
     * If empty, then "was verified by organization "organization_name"" will be used
     * as description. Can be specified only if the bot is allowed to provide custom
     * description
     */
    +custom_description?: string,
  |}

  declare export type removeMessageSenderBotVerification = {|
    /** Removes the verification status of a user or a chat by an owned bot */
    +_: 'removeMessageSenderBotVerification',
    /** Identifier of the owned bot, which verified the user or the chat */
    +bot_user_id?: number,
    /**
     * Identifier of the user or the supergroup or channel chat, which verification
     * is removed
     */
    +verified_id?: MessageSender$Input,
  |}

  declare export type getActiveSessions = {|
    /** Returns all active sessions of the current user */
    +_: 'getActiveSessions',
  |}

  declare export type terminateSession = {|
    /** Terminates a session of the current user */
    +_: 'terminateSession',
    /** Session identifier */
    +session_id?: number | string,
  |}

  declare export type terminateAllOtherSessions = {|
    /** Terminates all other sessions of the current user */
    +_: 'terminateAllOtherSessions',
  |}

  declare export type confirmSession = {|
    /** Confirms an unconfirmed session of the current user from another device */
    +_: 'confirmSession',
    /** Session identifier */
    +session_id?: number | string,
  |}

  declare export type toggleSessionCanAcceptCalls = {|
    /** Toggles whether a session can accept incoming calls */
    +_: 'toggleSessionCanAcceptCalls',
    /** Session identifier */
    +session_id?: number | string,
    /** Pass true to allow accepting incoming calls by the session; pass false otherwise */
    +can_accept_calls?: boolean,
  |}

  declare export type toggleSessionCanAcceptSecretChats = {|
    /** Toggles whether a session can accept incoming secret chats */
    +_: 'toggleSessionCanAcceptSecretChats',
    /** Session identifier */
    +session_id?: number | string,
    /** Pass true to allow accepting secret chats by the session; pass false otherwise */
    +can_accept_secret_chats?: boolean,
  |}

  declare export type setInactiveSessionTtl = {|
    /**
     * Changes the period of inactivity after which sessions will automatically be
     * terminated
     */
    +_: 'setInactiveSessionTtl',
    /**
     * New number of days of inactivity before sessions will be automatically terminated;
     * 1-366 days
     */
    +inactive_session_ttl_days?: number,
  |}

  declare export type getConnectedWebsites = {|
    /** Returns all website where the current user used Telegram to log in */
    +_: 'getConnectedWebsites',
  |}

  declare export type disconnectWebsite = {|
    /** Disconnects website from the current user's Telegram account */
    +_: 'disconnectWebsite',
    /** Website identifier */
    +website_id?: number | string,
  |}

  declare export type disconnectAllWebsites = {|
    /** Disconnects all websites from the current user's Telegram account */
    +_: 'disconnectAllWebsites',
  |}

  declare export type setSupergroupUsername = {|
    /**
     * Changes the editable username of a supergroup or channel, requires owner privileges
     * in the supergroup or channel
     */
    +_: 'setSupergroupUsername',
    /** Identifier of the supergroup or channel */
    +supergroup_id?: number,
    /**
     * New value of the username. Use an empty string to remove the username. The username
     * can't be completely removed if there is another active or disabled username
     */
    +username?: string,
  |}

  declare export type toggleSupergroupUsernameIsActive = {|
    /**
     * Changes active state for a username of a supergroup or channel, requires owner
     * privileges in the supergroup or channel. The editable username can't be disabled.
     * May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum
     * number of active usernames has been reached
     */
    +_: 'toggleSupergroupUsernameIsActive',
    /** Identifier of the supergroup or channel */
    +supergroup_id?: number,
    /** The username to change */
    +username?: string,
    /** Pass true to activate the username; pass false to disable it */
    +is_active?: boolean,
  |}

  declare export type disableAllSupergroupUsernames = {|
    /**
     * Disables all active non-editable usernames of a supergroup or channel, requires
     * owner privileges in the supergroup or channel
     */
    +_: 'disableAllSupergroupUsernames',
    /** Identifier of the supergroup or channel */
    +supergroup_id?: number,
  |}

  declare export type reorderSupergroupActiveUsernames = {|
    /**
     * Changes order of active usernames of a supergroup or channel, requires owner
     * privileges in the supergroup or channel
     */
    +_: 'reorderSupergroupActiveUsernames',
    /** Identifier of the supergroup or channel */
    +supergroup_id?: number,
    /** The new order of active usernames. All currently active usernames must be specified */
    +usernames?: $ReadOnlyArray<string>,
  |}

  declare export type setSupergroupStickerSet = {|
    /**
     * Changes the sticker set of a supergroup; requires can_change_info administrator
     * right
     */
    +_: 'setSupergroupStickerSet',
    /** Identifier of the supergroup */
    +supergroup_id?: number,
    /**
     * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup
     * sticker set
     */
    +sticker_set_id?: number | string,
  |}

  declare export type setSupergroupCustomEmojiStickerSet = {|
    /**
     * Changes the custom emoji sticker set of a supergroup; requires can_change_info
     * administrator right. The chat must have at least chatBoostFeatures.min_custom_emoji_sticker_set_boost_level
     * boost level to pass the corresponding color
     */
    +_: 'setSupergroupCustomEmojiStickerSet',
    /** Identifier of the supergroup */
    +supergroup_id?: number,
    /**
     * New value of the custom emoji sticker set identifier for the supergroup. Use
     * 0 to remove the custom emoji sticker set in the supergroup
     */
    +custom_emoji_sticker_set_id?: number | string,
  |}

  declare export type setSupergroupUnrestrictBoostCount = {|
    /**
     * Changes the number of times the supergroup must be boosted by a user to ignore
     * slow mode and chat permission restrictions; requires can_restrict_members administrator
     * right
     */
    +_: 'setSupergroupUnrestrictBoostCount',
    /** Identifier of the supergroup */
    +supergroup_id?: number,
    /**
     * New value of the unrestrict_boost_count supergroup setting; 0-8. Use 0 to remove
     * the setting
     */
    +unrestrict_boost_count?: number,
  |}

  declare export type toggleSupergroupSignMessages = {|
    /**
     * Toggles whether sender signature or link to the account is added to sent messages
     * in a channel; requires can_change_info member right
     */
    +_: 'toggleSupergroupSignMessages',
    /** Identifier of the channel */
    +supergroup_id?: number,
    /** New value of sign_messages */
    +sign_messages?: boolean,
    /** New value of show_message_sender */
    +show_message_sender?: boolean,
  |}

  declare export type toggleSupergroupJoinToSendMessages = {|
    /**
     * Toggles whether joining is mandatory to send messages to a discussion supergroup;
     * requires can_restrict_members administrator right
     */
    +_: 'toggleSupergroupJoinToSendMessages',
    /** Identifier of the supergroup that isn't a broadcast group */
    +supergroup_id?: number,
    /** New value of join_to_send_messages */
    +join_to_send_messages?: boolean,
  |}

  declare export type toggleSupergroupJoinByRequest = {|
    /**
     * Toggles whether all users directly joining the supergroup need to be approved
     * by supergroup administrators; requires can_restrict_members administrator right
     */
    +_: 'toggleSupergroupJoinByRequest',
    /** Identifier of the supergroup that isn't a broadcast group */
    +supergroup_id?: number,
    /** New value of join_by_request */
    +join_by_request?: boolean,
  |}

  declare export type toggleSupergroupIsAllHistoryAvailable = {|
    /**
     * Toggles whether the message history of a supergroup is available to new members;
     * requires can_change_info member right
     */
    +_: 'toggleSupergroupIsAllHistoryAvailable',
    /** The identifier of the supergroup */
    +supergroup_id?: number,
    /** The new value of is_all_history_available */
    +is_all_history_available?: boolean,
  |}

  declare export type toggleSupergroupCanHaveSponsoredMessages = {|
    /**
     * Toggles whether sponsored messages are shown in the channel chat; requires owner
     * privileges in the channel. The chat must have at least chatBoostFeatures.min_sponsored_message_disable_boost_level
     * boost level to disable sponsored messages
     */
    +_: 'toggleSupergroupCanHaveSponsoredMessages',
    /** The identifier of the channel */
    +supergroup_id?: number,
    /** The new value of can_have_sponsored_messages */
    +can_have_sponsored_messages?: boolean,
  |}

  declare export type toggleSupergroupHasHiddenMembers = {|
    /**
     * Toggles whether non-administrators can receive only administrators and bots
     * using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members
     * == true
     */
    +_: 'toggleSupergroupHasHiddenMembers',
    /** Identifier of the supergroup */
    +supergroup_id?: number,
    /** New value of has_hidden_members */
    +has_hidden_members?: boolean,
  |}

  declare export type toggleSupergroupHasAggressiveAntiSpamEnabled = {|
    /**
     * Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can
     * be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
     */
    +_: 'toggleSupergroupHasAggressiveAntiSpamEnabled',
    /** The identifier of the supergroup, which isn't a broadcast group */
    +supergroup_id?: number,
    /** The new value of has_aggressive_anti_spam_enabled */
    +has_aggressive_anti_spam_enabled?: boolean,
  |}

  declare export type toggleSupergroupIsForum = {|
    /**
     * Toggles whether the supergroup is a forum; requires owner privileges in the
     * supergroup. Discussion supergroups can't be converted to forums
     */
    +_: 'toggleSupergroupIsForum',
    /** Identifier of the supergroup */
    +supergroup_id?: number,
    /** New value of is_forum */
    +is_forum?: boolean,
  |}

  declare export type toggleSupergroupIsBroadcastGroup = {|
    /** Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup */
    +_: 'toggleSupergroupIsBroadcastGroup',
    /** Identifier of the supergroup */
    +supergroup_id?: number,
  |}

  declare export type reportSupergroupSpam = {|
    /**
     * Reports messages in a supergroup as spam; requires administrator rights in the
     * supergroup
     */
    +_: 'reportSupergroupSpam',
    /** Supergroup identifier */
    +supergroup_id?: number,
    /**
     * Identifiers of messages to report. Use messageProperties.can_report_supergroup_spam
     * to check whether the message can be reported
     */
    +message_ids?: $ReadOnlyArray<number>,
  |}

  declare export type reportSupergroupAntiSpamFalsePositive = {|
    /**
     * Reports a false deletion of a message by aggressive anti-spam checks; requires
     * administrator rights in the supergroup. Can be called only for messages from
     * chatEventMessageDeleted with can_report_anti_spam_false_positive == true
     */
    +_: 'reportSupergroupAntiSpamFalsePositive',
    /** Supergroup identifier */
    +supergroup_id?: number,
    /** Identifier of the erroneously deleted message from chatEventMessageDeleted */
    +message_id?: number,
  |}

  declare export type getSupergroupMembers = {|
    /**
     * Returns information about members or banned users in a supergroup or channel.
     * Can be used only if supergroupFullInfo.can_get_members == true; additionally,
     * administrator privileges may be required for some filters
     */
    +_: 'getSupergroupMembers',
    /** Identifier of the supergroup or channel */
    +supergroup_id?: number,
    /** The type of users to return; pass null to use supergroupMembersFilterRecent */
    +filter?: SupergroupMembersFilter$Input,
    /** Number of users to skip */
    +offset?: number,
    /** The maximum number of users to be returned; up to 200 */
    +limit?: number,
  |}

  declare export type closeSecretChat = {|
    /** Closes a secret chat, effectively transferring its state to secretChatStateClosed */
    +_: 'closeSecretChat',
    /** Secret chat identifier */
    +secret_chat_id?: number,
  |}

  declare export type getChatEventLog = {|
    /**
     * Returns a list of service actions taken by chat members and administrators in
     * the last 48 hours. Available only for supergroups and channels. Requires administrator
     * rights. Returns results in reverse chronological order (i.e., in order of decreasing
     * event_id)
     */
    +_: 'getChatEventLog',
    /** Chat identifier */
    +chat_id?: number,
    /** Search query by which to filter events */
    +query?: string,
    /**
     * Identifier of an event from which to return results. Use 0 to get results from
     * the latest events
     */
    +from_event_id?: number | string,
    /** The maximum number of events to return; up to 100 */
    +limit?: number,
    /** The types of events to return; pass null to get chat events of all types */
    +filters?: chatEventLogFilters$Input,
    /**
     * User identifiers by which to filter events. By default, events relating to all
     * users will be returned
     */
    +user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type getTimeZones = {|
    /** Returns the list of supported time zones */
    +_: 'getTimeZones',
  |}

  declare export type getPaymentForm = {|
    /**
     * Returns an invoice payment form. This method must be called when the user presses
     * inline button of the type inlineKeyboardButtonTypeBuy, or wants to buy access
     * to media in a messagePaidMedia message
     */
    +_: 'getPaymentForm',
    /** The invoice */
    +input_invoice?: InputInvoice$Input,
    /** Preferred payment form theme; pass null to use the default theme */
    +theme?: themeParameters$Input,
  |}

  declare export type validateOrderInfo = {|
    /**
     * Validates the order information provided by a user and returns the available
     * shipping options for a flexible invoice
     */
    +_: 'validateOrderInfo',
    /** The invoice */
    +input_invoice?: InputInvoice$Input,
    /** The order information, provided by the user; pass null if empty */
    +order_info?: orderInfo$Input,
    /** Pass true to save the order information */
    +allow_save?: boolean,
  |}

  declare export type sendPaymentForm = {|
    /** Sends a filled-out payment form to the bot for final verification */
    +_: 'sendPaymentForm',
    /** The invoice */
    +input_invoice?: InputInvoice$Input,
    /** Payment form identifier returned by getPaymentForm */
    +payment_form_id?: number | string,
    /** Identifier returned by validateOrderInfo, or an empty string */
    +order_info_id?: string,
    /** Identifier of a chosen shipping option, if applicable */
    +shipping_option_id?: string,
    /**
     * The credentials chosen by user for payment; pass null for a payment in Telegram
     * Stars
     */
    +credentials?: InputCredentials$Input,
    /** Chosen by the user amount of tip in the smallest units of the currency */
    +tip_amount?: number,
  |}

  declare export type getPaymentReceipt = {|
    /** Returns information about a successful payment */
    +_: 'getPaymentReceipt',
    /** Chat identifier of the messagePaymentSuccessful message */
    +chat_id?: number,
    /** Message identifier */
    +message_id?: number,
  |}

  declare export type getSavedOrderInfo = {|
    /**
     * Returns saved order information. Returns a 404 error if there is no saved order
     * information
     */
    +_: 'getSavedOrderInfo',
  |}

  declare export type deleteSavedOrderInfo = {|
    /** Deletes saved order information */
    +_: 'deleteSavedOrderInfo',
  |}

  declare export type deleteSavedCredentials = {|
    /** Deletes saved credentials for all payment provider bots */
    +_: 'deleteSavedCredentials',
  |}

  declare export type getAvailableGifts = {|
    /** Returns gifts that can be sent to other users and channel chats */
    +_: 'getAvailableGifts',
  |}

  declare export type sendGift = {|
    /**
     * Sends a gift to another user or channel chat. May return an error with a message
     * "STARGIFT_USAGE_LIMITED" if the gift was sold out
     */
    +_: 'sendGift',
    /** Identifier of the gift to send */
    +gift_id?: number | string,
    /** Identifier of the user or the channel chat that will receive the gift */
    +owner_id?: MessageSender$Input,
    /**
     * Text to show along with the gift; 0-getOption("gift_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities
     * are allowed. Must be empty if the receiver enabled paid messages
     */
    +text?: formattedText$Input,
    /**
     * Pass true to show gift text and sender only to the gift receiver; otherwise,
     * everyone will be able to see them
     */
    +is_private?: boolean,
    /**
     * Pass true to additionally pay for the gift upgrade and allow the receiver to
     * upgrade it for free
     */
    +pay_for_upgrade?: boolean,
  |}

  declare export type sellGift = {|
    /** Sells a gift for Telegram Stars */
    +_: 'sellGift',
    /** Identifier of the gift */
    +received_gift_id?: string,
  |}

  declare export type toggleGiftIsSaved = {|
    /**
     * Toggles whether a gift is shown on the current user's or the channel's profile
     * page; requires can_post_messages administrator right in the channel chat
     */
    +_: 'toggleGiftIsSaved',
    /** Identifier of the gift */
    +received_gift_id?: string,
    /**
     * Pass true to display the gift on the user's or the channel's profile page; pass
     * false to remove it from the profile page
     */
    +is_saved?: boolean,
  |}

  declare export type setPinnedGifts = {|
    /**
     * Changes the list of pinned gifts on the current user's or the channel's profile
     * page; requires can_post_messages administrator right in the channel chat
     */
    +_: 'setPinnedGifts',
    /** Identifier of the user or the channel chat that received the gifts */
    +owner_id?: MessageSender$Input,
    /**
     * New list of pinned gifts. All gifts must be upgraded and saved on the profile
     * page first. There can be up to getOption("pinned_gift_count_max") pinned gifts
     */
    +received_gift_ids?: $ReadOnlyArray<string>,
  |}

  declare export type toggleChatGiftNotifications = {|
    /**
     * Toggles whether notifications for new gifts received by a channel chat are sent
     * to the current user; requires can_post_messages administrator right in the chat
     */
    +_: 'toggleChatGiftNotifications',
    /** Identifier of the channel chat */
    +chat_id?: number,
    /**
     * Pass true to enable notifications about new gifts owned by the channel chat;
     * pass false to disable the notifications
     */
    +are_enabled?: boolean,
  |}

  declare export type getGiftUpgradePreview = {|
    /** Returns examples of possible upgraded gifts for a regular gift */
    +_: 'getGiftUpgradePreview',
    /** Identifier of the gift */
    +gift_id?: number | string,
  |}

  declare export type upgradeGift = {|
    /** Upgrades a regular gift */
    +_: 'upgradeGift',
    /** Identifier of the gift */
    +received_gift_id?: string,
    /**
     * Pass true to keep the original gift text, sender and receiver in the upgraded
     * gift
     */
    +keep_original_details?: boolean,
    /**
     * The amount of Telegram Stars required to pay for the upgrade. It the gift has
     * prepaid_upgrade_star_count > 0, then pass 0, otherwise, pass gift.upgrade_star_count
     */
    +star_count?: number,
  |}

  declare export type transferGift = {|
    /** Sends an upgraded gift to another user or a channel chat */
    +_: 'transferGift',
    /** Identifier of the gift */
    +received_gift_id?: string,
    /** Identifier of the user or the channel chat that will receive the gift */
    +new_owner_id?: MessageSender$Input,
    /** The amount of Telegram Stars required to pay for the transfer */
    +star_count?: number,
  |}

  declare export type getReceivedGifts = {|
    /** Returns gifts received by the given user or chat */
    +_: 'getReceivedGifts',
    /** Identifier of the gift receiver */
    +owner_id?: MessageSender$Input,
    /**
     * Pass true to exclude gifts that aren't saved to the chat's profile page. Always
     * true for gifts received by other users and channel chats without can_post_messages
     * administrator right
     */
    +exclude_unsaved?: boolean,
    /**
     * Pass true to exclude gifts that are saved to the chat's profile page. Always
     * false for gifts received by other users and channel chats without can_post_messages
     * administrator right
     */
    +exclude_saved?: boolean,
    /** Pass true to exclude gifts that can be purchased unlimited number of times */
    +exclude_unlimited?: boolean,
    /** Pass true to exclude gifts that can be purchased limited number of times */
    +exclude_limited?: boolean,
    /** Pass true to exclude upgraded gifts */
    +exclude_upgraded?: boolean,
    /** Pass true to sort results by gift price instead of send date */
    +sort_by_price?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of gifts to be returned; must be positive and can't be greater
     * than 100. For optimal performance, the number of returned objects is chosen
     * by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type getReceivedGift = {|
    /** Returns information about a received gift */
    +_: 'getReceivedGift',
    /** Identifier of the gift */
    +received_gift_id?: string,
  |}

  declare export type getUpgradedGift = {|
    /** Returns information about an upgraded gift by its name */
    +_: 'getUpgradedGift',
    /** Unique name of the upgraded gift */
    +name?: string,
  |}

  declare export type getUpgradedGiftWithdrawalUrl = {|
    /**
     * Returns a URL for upgraded gift withdrawal in the TON blockchain as an NFT;
     * requires owner privileges for gifts owned by a chat
     */
    +_: 'getUpgradedGiftWithdrawalUrl',
    /** Identifier of the gift */
    +received_gift_id?: string,
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type createInvoiceLink = {|
    /** Creates a link for the given invoice; for bots only */
    +_: 'createInvoiceLink',
    /** Unique identifier of business connection on behalf of which to send the request */
    +business_connection_id?: string,
    /** Information about the invoice of the type inputMessageInvoice */
    +invoice?: InputMessageContent$Input,
  |}

  declare export type refundStarPayment = {|
    /** Refunds a previously done payment in Telegram Stars; for bots only */
    +_: 'refundStarPayment',
    /** Identifier of the user that did the payment */
    +user_id?: number,
    /** Telegram payment identifier */
    +telegram_payment_charge_id?: string,
  |}

  declare export type getSupportUser = {|
    /** Returns a user that can be contacted to get support */
    +_: 'getSupportUser',
  |}

  declare export type getBackgroundUrl = {|
    /** Constructs a persistent HTTP URL for a background */
    +_: 'getBackgroundUrl',
    /** Background name */
    +name?: string,
    /** Background type; backgroundTypeChatTheme isn't supported */
    +type?: BackgroundType$Input,
  |}

  declare export type searchBackground = {|
    /** Searches for a background by its name */
    +_: 'searchBackground',
    /** The name of the background */
    +name?: string,
  |}

  declare export type setDefaultBackground = {|
    /**
     * Sets default background for chats; adds the background to the list of installed
     * backgrounds
     */
    +_: 'setDefaultBackground',
    /** The input background to use; pass null to create a new filled background */
    +background?: InputBackground$Input,
    /**
     * Background type; pass null to use the default type of the remote background;
     * backgroundTypeChatTheme isn't supported
     */
    +type?: BackgroundType$Input,
    /** Pass true if the background is set for a dark theme */
    +for_dark_theme?: boolean,
  |}

  declare export type deleteDefaultBackground = {|
    /** Deletes default background for chats */
    +_: 'deleteDefaultBackground',
    /** Pass true if the background is deleted for a dark theme */
    +for_dark_theme?: boolean,
  |}

  declare export type getInstalledBackgrounds = {|
    /** Returns backgrounds installed by the user */
    +_: 'getInstalledBackgrounds',
    /** Pass true to order returned backgrounds for a dark theme */
    +for_dark_theme?: boolean,
  |}

  declare export type removeInstalledBackground = {|
    /** Removes background from the list of installed backgrounds */
    +_: 'removeInstalledBackground',
    /** The background identifier */
    +background_id?: number | string,
  |}

  declare export type resetInstalledBackgrounds = {|
    /** Resets list of installed backgrounds to its default value */
    +_: 'resetInstalledBackgrounds',
  |}

  declare export type getLocalizationTargetInfo = {|
    /**
     * Returns information about the current localization target. This is an offline
     * request if only_local is true. Can be called before authorization
     */
    +_: 'getLocalizationTargetInfo',
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    +only_local?: boolean,
  |}

  declare export type getLanguagePackInfo = {|
    /**
     * Returns information about a language pack. Returned language pack identifier
     * may be different from a provided one. Can be called before authorization
     */
    +_: 'getLanguagePackInfo',
    /** Language pack identifier */
    +language_pack_id?: string,
  |}

  declare export type getLanguagePackStrings = {|
    /**
     * Returns strings from a language pack in the current localization target by their
     * keys. Can be called before authorization
     */
    +_: 'getLanguagePackStrings',
    /** Language pack identifier of the strings to be returned */
    +language_pack_id?: string,
    /**
     * Language pack keys of the strings to be returned; leave empty to request all
     * available strings
     */
    +keys?: $ReadOnlyArray<string>,
  |}

  declare export type synchronizeLanguagePack = {|
    /**
     * Fetches the latest versions of all strings from a language pack in the current
     * localization target from the server. This method doesn't need to be called explicitly
     * for the current used/base language packs. Can be called before authorization
     */
    +_: 'synchronizeLanguagePack',
    /** Language pack identifier */
    +language_pack_id?: string,
  |}

  declare export type addCustomServerLanguagePack = {|
    /**
     * Adds a custom server language pack to the list of installed language packs in
     * current localization target. Can be called before authorization
     */
    +_: 'addCustomServerLanguagePack',
    /** Identifier of a language pack to be added */
    +language_pack_id?: string,
  |}

  declare export type setCustomLanguagePack = {|
    /** Adds or changes a custom local language pack to the current localization target */
    +_: 'setCustomLanguagePack',
    /**
     * Information about the language pack. Language pack identifier must start with
     * 'X', consist only of English letters, digits and hyphens, and must not exceed
     * 64 characters. Can be called before authorization
     */
    +info?: languagePackInfo$Input,
    /** Strings of the new language pack */
    +strings?: $ReadOnlyArray<languagePackString$Input>,
  |}

  declare export type editCustomLanguagePackInfo = {|
    /**
     * Edits information about a custom local language pack in the current localization
     * target. Can be called before authorization
     */
    +_: 'editCustomLanguagePackInfo',
    /** New information about the custom local language pack */
    +info?: languagePackInfo$Input,
  |}

  declare export type setCustomLanguagePackString = {|
    /**
     * Adds, edits or deletes a string in a custom local language pack. Can be called
     * before authorization
     */
    +_: 'setCustomLanguagePackString',
    /**
     * Identifier of a previously added custom local language pack in the current localization
     * target
     */
    +language_pack_id?: string,
    /** New language pack string */
    +new_string?: languagePackString$Input,
  |}

  declare export type deleteLanguagePack = {|
    /**
     * Deletes all information about a language pack in the current localization target.
     * The language pack which is currently in use (including base language pack) or
     * is being synchronized can't be deleted. Can be called before authorization
     */
    +_: 'deleteLanguagePack',
    /** Identifier of the language pack to delete */
    +language_pack_id?: string,
  |}

  declare export type registerDevice = {|
    /**
     * Registers the currently used device for receiving push notifications. Returns
     * a globally unique identifier of the push notification subscription
     */
    +_: 'registerDevice',
    /** Device token */
    +device_token?: DeviceToken$Input,
    /** List of user identifiers of other users currently using the application */
    +other_user_ids?: $ReadOnlyArray<number>,
  |}

  declare export type processPushNotification = {|
    /**
     * Handles a push notification. Returns error with code 406 if the push notification
     * is not supported and connection to the server is required to fetch new data.
     * Can be called before authorization
     */
    +_: 'processPushNotification',
    /**
     * JSON-encoded push notification payload with all fields sent by the server, and
     * "google.sent_time" and "google.notification.sound" fields added
     */
    +payload?: string,
  |}

  declare export type getPushReceiverId = {|
    /**
     * Returns a globally unique push notification subscription identifier for identification
     * of an account, which has received a push notification. Can be called synchronously
     */
    +_: 'getPushReceiverId',
    /** JSON-encoded push notification payload */
    +payload?: string,
  |}

  declare export type getRecentlyVisitedTMeUrls = {|
    /** Returns t.me URLs recently visited by a newly registered user */
    +_: 'getRecentlyVisitedTMeUrls',
    /** Google Play referrer to identify the user */
    +referrer?: string,
  |}

  declare export type setUserPrivacySettingRules = {|
    /** Changes user privacy settings */
    +_: 'setUserPrivacySettingRules',
    /** The privacy setting */
    +setting?: UserPrivacySetting$Input,
    /** The new privacy rules */
    +rules?: userPrivacySettingRules$Input,
  |}

  declare export type getUserPrivacySettingRules = {|
    /** Returns the current privacy settings */
    +_: 'getUserPrivacySettingRules',
    /** The privacy setting */
    +setting?: UserPrivacySetting$Input,
  |}

  declare export type setReadDatePrivacySettings = {|
    /** Changes privacy settings for message read date */
    +_: 'setReadDatePrivacySettings',
    /** New settings */
    +settings?: readDatePrivacySettings$Input,
  |}

  declare export type getReadDatePrivacySettings = {|
    /** Returns privacy settings for message read date */
    +_: 'getReadDatePrivacySettings',
  |}

  declare export type setNewChatPrivacySettings = {|
    /** Changes privacy settings for new chat creation; can be used only if getOption("can_set_new_chat_privacy_settings") */
    +_: 'setNewChatPrivacySettings',
    /** New settings */
    +settings?: newChatPrivacySettings$Input,
  |}

  declare export type getNewChatPrivacySettings = {|
    /** Returns privacy settings for new chat creation */
    +_: 'getNewChatPrivacySettings',
  |}

  declare export type getPaidMessageRevenue = {|
    /**
     * Returns the total number of Telegram Stars received by the current user for
     * paid messages from the given user
     */
    +_: 'getPaidMessageRevenue',
    /** Identifier of the user */
    +user_id?: number,
  |}

  declare export type allowUnpaidMessagesFromUser = {|
    /**
     * Allows the specified user to send unpaid private messages to the current user
     * by adding a rule to userPrivacySettingAllowUnpaidMessages
     */
    +_: 'allowUnpaidMessagesFromUser',
    /** Identifier of the user */
    +user_id?: number,
    /** Pass true to refund the user previously paid messages */
    +refund_payments?: boolean,
  |}

  declare export type setChatPaidMessageStarCount = {|
    /**
     * Changes the amount of Telegram Stars that must be paid to send a message to
     * a supergroup chat; requires can_restrict_members administrator right and supergroupFullInfo.can_enable_paid_messages
     */
    +_: 'setChatPaidMessageStarCount',
    /** Identifier of the supergroup chat */
    +chat_id?: number,
    /**
     * The new number of Telegram Stars that must be paid for each message that is
     * sent to the supergroup chat unless the sender is an administrator of the chat;
     * 0-getOption("paid_message_star_count_max"). The supergroup will receive getOption("paid_message_earnings_per_mille")
     * Telegram Stars for each 1000 Telegram Stars paid for message sending
     */
    +paid_message_star_count?: number,
  |}

  declare export type canSendMessageToUser = {|
    /**
     * Check whether the current user can message another user or try to create a chat
     * with them
     */
    +_: 'canSendMessageToUser',
    /** Identifier of the other user */
    +user_id?: number,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    +only_local?: boolean,
  |}

  declare export type getOption = {|
    /**
     * Returns the value of an option by its name. (Check the list of available options
     * on https://core.telegram.org/tdlib/options.) Can be called before authorization.
     * Can be called synchronously for options "version" and "commit_hash"
     */
    +_: 'getOption',
    /** The name of the option */
    +name?: string,
  |}

  declare export type setOption = {|
    /**
     * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.)
     * Only writable options can be set. Can be called before authorization
     */
    +_: 'setOption',
    /** The name of the option */
    +name?: string,
    /** The new value of the option; pass null to reset option value to a default value */
    +value?: OptionValue$Input,
  |}

  declare export type setAccountTtl = {|
    /**
     * Changes the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    +_: 'setAccountTtl',
    /** New account TTL */
    +ttl?: accountTtl$Input,
  |}

  declare export type getAccountTtl = {|
    /**
     * Returns the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    +_: 'getAccountTtl',
  |}

  declare export type deleteAccount = {|
    /**
     * Deletes the account of the current user, deleting all information associated
     * with the user from the server. The phone number of the account can be used to
     * create a new account. Can be called before authorization when the current authorization
     * state is authorizationStateWaitPassword
     */
    +_: 'deleteAccount',
    /** The reason why the account was deleted; optional */
    +reason?: string,
    /**
     * The 2-step verification password of the current user. If the current user isn't
     * authorized, then an empty string can be passed and account deletion can be canceled
     * within one week
     */
    +password?: string,
  |}

  declare export type setDefaultMessageAutoDeleteTime = {|
    /** Changes the default message auto-delete time for new chats */
    +_: 'setDefaultMessageAutoDeleteTime',
    /**
     * New default message auto-delete time; must be from 0 up to 365 * 86400 and be
     * divisible by 86400. If 0, then messages aren't deleted automatically
     */
    +message_auto_delete_time?: messageAutoDeleteTime$Input,
  |}

  declare export type getDefaultMessageAutoDeleteTime = {|
    /** Returns default message auto-delete time setting for new chats */
    +_: 'getDefaultMessageAutoDeleteTime',
  |}

  declare export type removeChatActionBar = {|
    /** Removes a chat action bar without any other action */
    +_: 'removeChatActionBar',
    /** Chat identifier */
    +chat_id?: number,
  |}

  declare export type reportChat = {|
    /**
     * Reports a chat to the Telegram moderators. A chat can be reported only from
     * the chat action bar, or if chat.can_be_reported
     */
    +_: 'reportChat',
    /** Chat identifier */
    +chat_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    +option_id?: string /* base64 */,
    /**
     * Identifiers of reported messages. Use messageProperties.can_report_chat to check
     * whether the message can be reported
     */
    +message_ids?: $ReadOnlyArray<number>,
    /**
     * Additional report details if asked by the server; 0-1024 characters; leave empty
     * for the initial request
     */
    +text?: string,
  |}

  declare export type reportChatPhoto = {|
    /**
     * Reports a chat photo to the Telegram moderators. A chat photo can be reported
     * only if chat.can_be_reported
     */
    +_: 'reportChatPhoto',
    /** Chat identifier */
    +chat_id?: number,
    /** Identifier of the photo to report. Only full photos from chatPhoto can be reported */
    +file_id?: number,
    /** The reason for reporting the chat photo */
    +reason?: ReportReason$Input,
    /** Additional report details; 0-1024 characters */
    +text?: string,
  |}

  declare export type reportMessageReactions = {|
    /**
     * Reports reactions set on a message to the Telegram moderators. Reactions on
     * a message can be reported only if messageProperties.can_report_reactions
     */
    +_: 'reportMessageReactions',
    /** Chat identifier */
    +chat_id?: number,
    /** Message identifier */
    +message_id?: number,
    /** Identifier of the sender, which added the reaction */
    +sender_id?: MessageSender$Input,
  |}

  declare export type getChatRevenueStatistics = {|
    /**
     * Returns detailed revenue statistics about a chat. Currently, this method can
     * be used only for channels if supergroupFullInfo.can_get_revenue_statistics ==
     * true or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     */
    +_: 'getChatRevenueStatistics',
    /** Chat identifier */
    +chat_id?: number,
    /** Pass true if a dark theme is used by the application */
    +is_dark?: boolean,
  |}

  declare export type getChatRevenueWithdrawalUrl = {|
    /**
     * Returns a URL for chat revenue withdrawal; requires owner privileges in the
     * channel chat or the bot. Currently, this method can be used only if getOption("can_withdraw_chat_revenue")
     * for channels with supergroupFullInfo.can_get_revenue_statistics == true or bots
     * with userFullInfo.bot_info.can_get_revenue_statistics == true
     */
    +_: 'getChatRevenueWithdrawalUrl',
    /** Chat identifier */
    +chat_id?: number,
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type getChatRevenueTransactions = {|
    /**
     * Returns the list of revenue transactions for a chat. Currently, this method
     * can be used only for channels if supergroupFullInfo.can_get_revenue_statistics
     * == true or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     */
    +_: 'getChatRevenueTransactions',
    /** Chat identifier */
    +chat_id?: number,
    /** Number of transactions to skip */
    +offset?: number,
    /** The maximum number of transactions to be returned; up to 200 */
    +limit?: number,
  |}

  declare export type getStarRevenueStatistics = {|
    /** Returns detailed Telegram Star revenue statistics */
    +_: 'getStarRevenueStatistics',
    /**
     * Identifier of the owner of the Telegram Stars; can be identifier of the current
     * user, an owned bot, or a supergroup or a channel chat with supergroupFullInfo.can_get_star_revenue_statistics
     * == true
     */
    +owner_id?: MessageSender$Input,
    /** Pass true if a dark theme is used by the application */
    +is_dark?: boolean,
  |}

  declare export type getStarWithdrawalUrl = {|
    /** Returns a URL for Telegram Star withdrawal */
    +_: 'getStarWithdrawalUrl',
    /**
     * Identifier of the owner of the Telegram Stars; can be identifier of the current
     * user, an owned bot, or an owned supergroup or channel chat
     */
    +owner_id?: MessageSender$Input,
    /** The number of Telegram Stars to withdraw. Must be at least getOption("star_withdrawal_count_min") */
    +star_count?: number,
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type getStarAdAccountUrl = {|
    /**
     * Returns a URL for a Telegram Ad platform account that can be used to set up
     * advertisements for the chat paid in the owned Telegram Stars
     */
    +_: 'getStarAdAccountUrl',
    /**
     * Identifier of the owner of the Telegram Stars; can be identifier of an owned
     * bot, or identifier of an owned channel chat
     */
    +owner_id?: MessageSender$Input,
  |}

  declare export type getChatStatistics = {|
    /**
     * Returns detailed statistics about a chat. Currently, this method can be used
     * only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics
     * == true
     */
    +_: 'getChatStatistics',
    /** Chat identifier */
    +chat_id?: number,
    /** Pass true if a dark theme is used by the application */
    +is_dark?: boolean,
  |}

  declare export type getMessageStatistics = {|
    /**
     * Returns detailed statistics about a message. Can be used only if messageProperties.can_get_statistics
     * == true
     */
    +_: 'getMessageStatistics',
    /** Chat identifier */
    +chat_id?: number,
    /** Message identifier */
    +message_id?: number,
    /** Pass true if a dark theme is used by the application */
    +is_dark?: boolean,
  |}

  declare export type getMessagePublicForwards = {|
    /**
     * Returns forwarded copies of a channel message to different public channels and
     * public reposts as a story. Can be used only if messageProperties.can_get_statistics
     * == true. For optimal performance, the number of returned messages and stories
     * is chosen by TDLib
     */
    +_: 'getMessagePublicForwards',
    /** Chat identifier of the message */
    +chat_id?: number,
    /** Message identifier */
    +message_id?: number,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    +offset?: string,
    /**
     * The maximum number of messages and stories to be returned; must be positive
     * and can't be greater than 100. For optimal performance, the number of returned
     * objects is chosen by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type getStoryStatistics = {|
    /**
     * Returns detailed statistics about a story. Can be used only if story.can_get_statistics
     * == true
     */
    +_: 'getStoryStatistics',
    /** Chat identifier */
    +chat_id?: number,
    /** Story identifier */
    +story_id?: number,
    /** Pass true if a dark theme is used by the application */
    +is_dark?: boolean,
  |}

  declare export type getStatisticalGraph = {|
    /** Loads an asynchronous or a zoomed in statistical graph */
    +_: 'getStatisticalGraph',
    /** Chat identifier */
    +chat_id?: number,
    /** The token for graph loading */
    +token?: string,
    /** X-value for zoomed in graph or 0 otherwise */
    +x?: number,
  |}

  declare export type getStorageStatistics = {|
    /** Returns storage usage statistics. Can be called before authorization */
    +_: 'getStorageStatistics',
    /**
     * The maximum number of chats with the largest storage usage for which separate
     * statistics need to be returned. All other chats will be grouped in entries with
     * chat_id == 0. If the chat info database is not used, the chat_limit is ignored
     * and is always set to 0
     */
    +chat_limit?: number,
  |}

  declare export type getStorageStatisticsFast = {|
    /** Quickly returns approximate storage usage statistics. Can be called before authorization */
    +_: 'getStorageStatisticsFast',
  |}

  declare export type getDatabaseStatistics = {|
    /** Returns database statistics */
    +_: 'getDatabaseStatistics',
  |}

  declare export type optimizeStorage = {|
    /**
     * Optimizes storage usage, i.e. deletes some files and returns new storage usage
     * statistics. Secret thumbnails can't be deleted
     */
    +_: 'optimizeStorage',
    /**
     * Limit on the total size of files after deletion, in bytes. Pass -1 to use the
     * default limit
     */
    +size?: number,
    /**
     * Limit on the time that has passed since the last time a file was accessed (or
     * creation time for some filesystems). Pass -1 to use the default limit
     */
    +ttl?: number,
    /**
     * Limit on the total number of files after deletion. Pass -1 to use the default
     * limit
     */
    +count?: number,
    /**
     * The amount of time after the creation of a file during which it can't be deleted,
     * in seconds. Pass -1 to use the default value
     */
    +immunity_delay?: number,
    /**
     * If non-empty, only files with the given types are considered. By default, all
     * types except thumbnails, profile photos, stickers and wallpapers are deleted
     */
    +file_types?: $ReadOnlyArray<FileType$Input>,
    /**
     * If non-empty, only files from the given chats are considered. Use 0 as chat
     * identifier to delete files not belonging to any chat (e.g., profile photos)
     */
    +chat_ids?: $ReadOnlyArray<number>,
    /**
     * If non-empty, files from the given chats are excluded. Use 0 as chat identifier
     * to exclude all files not belonging to any chat (e.g., profile photos)
     */
    +exclude_chat_ids?: $ReadOnlyArray<number>,
    /**
     * Pass true if statistics about the files that were deleted must be returned instead
     * of the whole storage usage statistics. Affects only returned statistics
     */
    +return_deleted_file_statistics?: boolean,
    /** Same as in getStorageStatistics. Affects only returned statistics */
    +chat_limit?: number,
  |}

  declare export type setNetworkType = {|
    /**
     * Sets the current network type. Can be called before authorization. Calling this
     * method forces all network connections to reopen, mitigating the delay in switching
     * between different networks, so it must be called whenever the network is changed,
     * even if the network type remains the same. Network type is used to check whether
     * the library can use the network at all and also for collecting detailed network
     * data usage statistics
     */
    +_: 'setNetworkType',
    /** The new network type; pass null to set network type to networkTypeOther */
    +type?: NetworkType$Input,
  |}

  declare export type getNetworkStatistics = {|
    /** Returns network data usage statistics. Can be called before authorization */
    +_: 'getNetworkStatistics',
    /** Pass true to get statistics only for the current library launch */
    +only_current?: boolean,
  |}

  declare export type addNetworkStatistics = {|
    /** Adds the specified data to data usage statistics. Can be called before authorization */
    +_: 'addNetworkStatistics',
    /** The network statistics entry with the data to be added to statistics */
    +entry?: NetworkStatisticsEntry$Input,
  |}

  declare export type resetNetworkStatistics = {|
    /** Resets all network data usage statistics to zero. Can be called before authorization */
    +_: 'resetNetworkStatistics',
  |}

  declare export type getAutoDownloadSettingsPresets = {|
    /** Returns auto-download settings presets for the current user */
    +_: 'getAutoDownloadSettingsPresets',
  |}

  declare export type setAutoDownloadSettings = {|
    /** Sets auto-download settings */
    +_: 'setAutoDownloadSettings',
    /** New user auto-download settings */
    +settings?: autoDownloadSettings$Input,
    /** Type of the network for which the new settings are relevant */
    +type?: NetworkType$Input,
  |}

  declare export type getAutosaveSettings = {|
    /** Returns autosave settings for the current user */
    +_: 'getAutosaveSettings',
  |}

  declare export type setAutosaveSettings = {|
    /**
     * Sets autosave settings for the given scope. The method is guaranteed to work
     * only after at least one call to getAutosaveSettings
     */
    +_: 'setAutosaveSettings',
    /** Autosave settings scope */
    +scope?: AutosaveSettingsScope$Input,
    /** New autosave settings for the scope; pass null to set autosave settings to default */
    +settings?: scopeAutosaveSettings$Input,
  |}

  declare export type clearAutosaveSettingsExceptions = {|
    /**
     * Clears the list of all autosave settings exceptions. The method is guaranteed
     * to work only after at least one call to getAutosaveSettings
     */
    +_: 'clearAutosaveSettingsExceptions',
  |}

  declare export type getBankCardInfo = {|
    /** Returns information about a bank card */
    +_: 'getBankCardInfo',
    /** The bank card number */
    +bank_card_number?: string,
  |}

  declare export type getPassportElement = {|
    /** Returns one of the available Telegram Passport elements */
    +_: 'getPassportElement',
    /** Telegram Passport element type */
    +type?: PassportElementType$Input,
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type getAllPassportElements = {|
    /** Returns all available Telegram Passport elements */
    +_: 'getAllPassportElements',
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type setPassportElement = {|
    /**
     * Adds an element to the user's Telegram Passport. May return an error with a
     * message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen
     * phone number or the chosen email address must be verified first
     */
    +_: 'setPassportElement',
    /** Input Telegram Passport element */
    +element?: InputPassportElement$Input,
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type deletePassportElement = {|
    /** Deletes a Telegram Passport element */
    +_: 'deletePassportElement',
    /** Element type */
    +type?: PassportElementType$Input,
  |}

  declare export type setPassportElementErrors = {|
    /**
     * Informs the user that some of the elements in their Telegram Passport contain
     * errors; for bots only. The user will not be able to resend the elements, until
     * the errors are fixed
     */
    +_: 'setPassportElementErrors',
    /** User identifier */
    +user_id?: number,
    /** The errors */
    +errors?: $ReadOnlyArray<inputPassportElementError$Input>,
  |}

  declare export type getPreferredCountryLanguage = {|
    /**
     * Returns an IETF language tag of the language preferred in the country, which
     * must be used to fill native fields in Telegram Passport personal details. Returns
     * a 404 error if unknown
     */
    +_: 'getPreferredCountryLanguage',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    +country_code?: string,
  |}

  declare export type sendEmailAddressVerificationCode = {|
    /** Sends a code to verify an email address to be added to a user's Telegram Passport */
    +_: 'sendEmailAddressVerificationCode',
    /** Email address */
    +email_address?: string,
  |}

  declare export type resendEmailAddressVerificationCode = {|
    /**
     * Resends the code to verify an email address to be added to a user's Telegram
     * Passport
     */
    +_: 'resendEmailAddressVerificationCode',
  |}

  declare export type checkEmailAddressVerificationCode = {|
    /** Checks the email address verification code for Telegram Passport */
    +_: 'checkEmailAddressVerificationCode',
    /** Verification code to check */
    +code?: string,
  |}

  declare export type getPassportAuthorizationForm = {|
    /** Returns a Telegram Passport authorization form for sharing data with a service */
    +_: 'getPassportAuthorizationForm',
    /** User identifier of the service's bot */
    +bot_user_id?: number,
    /** Telegram Passport element types requested by the service */
    +scope?: string,
    /** Service's public key */
    +public_key?: string,
    /** Unique request identifier provided by the service */
    +nonce?: string,
  |}

  declare export type getPassportAuthorizationFormAvailableElements = {|
    /**
     * Returns already available Telegram Passport elements suitable for completing
     * a Telegram Passport authorization form. Result can be received only once for
     * each authorization form
     */
    +_: 'getPassportAuthorizationFormAvailableElements',
    /** Authorization form identifier */
    +authorization_form_id?: number,
    /** The 2-step verification password of the current user */
    +password?: string,
  |}

  declare export type sendPassportAuthorizationForm = {|
    /**
     * Sends a Telegram Passport authorization form, effectively sharing data with
     * the service. This method must be called after getPassportAuthorizationFormAvailableElements
     * if some previously available elements are going to be reused
     */
    +_: 'sendPassportAuthorizationForm',
    /** Authorization form identifier */
    +authorization_form_id?: number,
    /**
     * Types of Telegram Passport elements chosen by user to complete the authorization
     * form
     */
    +types?: $ReadOnlyArray<PassportElementType$Input>,
  |}

  declare export type setBotUpdatesStatus = {|
    /**
     * Informs the server about the number of pending bot updates if they haven't been
     * processed for a long time; for bots only
     */
    +_: 'setBotUpdatesStatus',
    /** The number of pending updates */
    +pending_update_count?: number,
    /** The last error message */
    +error_message?: string,
  |}

  declare export type uploadStickerFile = {|
    /** Uploads a file with a sticker; returns the uploaded file */
    +_: 'uploadStickerFile',
    /** Sticker file owner; ignored for regular users */
    +user_id?: number,
    /** Sticker format */
    +sticker_format?: StickerFormat$Input,
    /**
     * File file to upload; must fit in a 512x512 square. For WEBP stickers the file
     * must be in WEBP or PNG format, which will be converted to WEBP server-side.
     * See https://core.telegram.org/animated_stickers#technical-requirements for technical
     * requirements
     */
    +sticker?: InputFile$Input,
  |}

  declare export type getSuggestedStickerSetName = {|
    /** Returns a suggested name for a new sticker set with a given title */
    +_: 'getSuggestedStickerSetName',
    /** Sticker set title; 1-64 characters */
    +title?: string,
  |}

  declare export type checkStickerSetName = {|
    /** Checks whether a name can be used for a new sticker set */
    +_: 'checkStickerSetName',
    /** Name to be checked */
    +name?: string,
  |}

  declare export type createNewStickerSet = {|
    /** Creates a new sticker set. Returns the newly created sticker set */
    +_: 'createNewStickerSet',
    /** Sticker set owner; ignored for regular users */
    +user_id?: number,
    /** Sticker set title; 1-64 characters */
    +title?: string,
    /**
     * Sticker set name. Can contain only English letters, digits and underscores.
     * Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive)
     * for bots; 0-64 characters. If empty, then the name returned by getSuggestedStickerSetName
     * will be used automatically
     */
    +name?: string,
    /** Type of the stickers in the set */
    +sticker_type?: StickerType$Input,
    /**
     * Pass true if stickers in the sticker set must be repainted; for custom emoji
     * sticker sets only
     */
    +needs_repainting?: boolean,
    /**
     * List of stickers to be added to the set; 1-200 stickers for custom emoji sticker
     * sets, and 1-120 stickers otherwise. For TGS stickers, uploadStickerFile must
     * be used before the sticker is shown
     */
    +stickers?: $ReadOnlyArray<inputSticker$Input>,
    /** Source of the sticker set; may be empty if unknown */
    +source?: string,
  |}

  declare export type addStickerToSet = {|
    /** Adds a new sticker to a set */
    +_: 'addStickerToSet',
    /** Sticker set owner; ignored for regular users */
    +user_id?: number,
    /**
     * Sticker set name. The sticker set must be owned by the current user, and contain
     * less than 200 stickers for custom emoji sticker sets and less than 120 otherwise
     */
    +name?: string,
    /** Sticker to add to the set */
    +sticker?: inputSticker$Input,
  |}

  declare export type replaceStickerInSet = {|
    /**
     * Replaces existing sticker in a set. The function is equivalent to removeStickerFromSet,
     * then addStickerToSet, then setStickerPositionInSet
     */
    +_: 'replaceStickerInSet',
    /** Sticker set owner; ignored for regular users */
    +user_id?: number,
    /** Sticker set name. The sticker set must be owned by the current user */
    +name?: string,
    /** Sticker to remove from the set */
    +old_sticker?: InputFile$Input,
    /** Sticker to add to the set */
    +new_sticker?: inputSticker$Input,
  |}

  declare export type setStickerSetThumbnail = {|
    /** Sets a sticker set thumbnail */
    +_: 'setStickerSetThumbnail',
    /** Sticker set owner; ignored for regular users */
    +user_id?: number,
    /** Sticker set name. The sticker set must be owned by the current user */
    +name?: string,
    /** Thumbnail to set; pass null to remove the sticker set thumbnail */
    +thumbnail?: InputFile$Input,
    /** Format of the thumbnail; pass null if thumbnail is removed */
    +format?: StickerFormat$Input,
  |}

  declare export type setCustomEmojiStickerSetThumbnail = {|
    /** Sets a custom emoji sticker set thumbnail */
    +_: 'setCustomEmojiStickerSetThumbnail',
    /** Sticker set name. The sticker set must be owned by the current user */
    +name?: string,
    /**
     * Identifier of the custom emoji from the sticker set, which will be set as sticker
     * set thumbnail; pass 0 to remove the sticker set thumbnail
     */
    +custom_emoji_id?: number | string,
  |}

  declare export type setStickerSetTitle = {|
    /** Sets a sticker set title */
    +_: 'setStickerSetTitle',
    /** Sticker set name. The sticker set must be owned by the current user */
    +name?: string,
    /** New sticker set title */
    +title?: string,
  |}

  declare export type deleteStickerSet = {|
    /** Completely deletes a sticker set */
    +_: 'deleteStickerSet',
    /** Sticker set name. The sticker set must be owned by the current user */
    +name?: string,
  |}

  declare export type setStickerPositionInSet = {|
    /**
     * Changes the position of a sticker in the set to which it belongs. The sticker
     * set must be owned by the current user
     */
    +_: 'setStickerPositionInSet',
    /** Sticker */
    +sticker?: InputFile$Input,
    /** New position of the sticker in the set, 0-based */
    +position?: number,
  |}

  declare export type removeStickerFromSet = {|
    /**
     * Removes a sticker from the set to which it belongs. The sticker set must be
     * owned by the current user
     */
    +_: 'removeStickerFromSet',
    /** Sticker to remove from the set */
    +sticker?: InputFile$Input,
  |}

  declare export type setStickerEmojis = {|
    /**
     * Changes the list of emojis corresponding to a sticker. The sticker must belong
     * to a regular or custom emoji sticker set that is owned by the current user
     */
    +_: 'setStickerEmojis',
    /** Sticker */
    +sticker?: InputFile$Input,
    /** New string with 1-20 emoji corresponding to the sticker */
    +emojis?: string,
  |}

  declare export type setStickerKeywords = {|
    /**
     * Changes the list of keywords of a sticker. The sticker must belong to a regular
     * or custom emoji sticker set that is owned by the current user
     */
    +_: 'setStickerKeywords',
    /** Sticker */
    +sticker?: InputFile$Input,
    /**
     * List of up to 20 keywords with total length up to 64 characters, which can be
     * used to find the sticker
     */
    +keywords?: $ReadOnlyArray<string>,
  |}

  declare export type setStickerMaskPosition = {|
    /**
     * Changes the mask position of a mask sticker. The sticker must belong to a mask
     * sticker set that is owned by the current user
     */
    +_: 'setStickerMaskPosition',
    /** Sticker */
    +sticker?: InputFile$Input,
    /** Position where the mask is placed; pass null to remove mask position */
    +mask_position?: maskPosition$Input,
  |}

  declare export type getOwnedStickerSets = {|
    /** Returns sticker sets owned by the current user */
    +_: 'getOwnedStickerSets',
    /**
     * Identifier of the sticker set from which to return owned sticker sets; use 0
     * to get results from the beginning
     */
    +offset_sticker_set_id?: number | string,
    /**
     * The maximum number of sticker sets to be returned; must be positive and can't
     * be greater than 100. For optimal performance, the number of returned objects
     * is chosen by TDLib and can be smaller than the specified limit
     */
    +limit?: number,
  |}

  declare export type getMapThumbnailFile = {|
    /**
     * Returns information about a file with a map thumbnail in PNG format. Only map
     * thumbnail files with size less than 1MB can be downloaded
     */
    +_: 'getMapThumbnailFile',
    /** Location of the map center */
    +location?: location$Input,
    /** Map zoom level; 13-20 */
    +zoom?: number,
    /** Map width in pixels before applying scale; 16-1024 */
    +width?: number,
    /** Map height in pixels before applying scale; 16-1024 */
    +height?: number,
    /** Map scale; 1-3 */
    +scale?: number,
    /** Identifier of a chat in which the thumbnail will be shown. Use 0 if unknown */
    +chat_id?: number,
  |}

  declare export type getPremiumLimit = {|
    /**
     * Returns information about a limit, increased for Premium users. Returns a 404
     * error if the limit is unknown
     */
    +_: 'getPremiumLimit',
    /** Type of the limit */
    +limit_type?: PremiumLimitType$Input,
  |}

  declare export type getPremiumFeatures = {|
    /** Returns information about features, available to Premium users */
    +_: 'getPremiumFeatures',
    /**
     * Source of the request; pass null if the method is called from some non-standard
     * source
     */
    +source?: PremiumSource$Input,
  |}

  declare export type getPremiumStickerExamples = {|
    /** Returns examples of premium stickers for demonstration purposes */
    +_: 'getPremiumStickerExamples',
  |}

  declare export type getPremiumInfoSticker = {|
    /** Returns the sticker to be used as representation of the Telegram Premium subscription */
    +_: 'getPremiumInfoSticker',
    /** Number of months the Telegram Premium subscription will be active */
    +month_count?: number,
  |}

  declare export type viewPremiumFeature = {|
    /**
     * Informs TDLib that the user viewed detailed information about a Premium feature
     * on the Premium features screen
     */
    +_: 'viewPremiumFeature',
    /** The viewed premium feature */
    +feature?: PremiumFeature$Input,
  |}

  declare export type clickPremiumSubscriptionButton = {|
    /**
     * Informs TDLib that the user clicked Premium subscription button on the Premium
     * features screen
     */
    +_: 'clickPremiumSubscriptionButton',
  |}

  declare export type getPremiumState = {|
    /**
     * Returns state of Telegram Premium subscription and promotion videos for Premium
     * features
     */
    +_: 'getPremiumState',
  |}

  declare export type getPremiumGiftPaymentOptions = {|
    /** Returns available options for gifting Telegram Premium to a user */
    +_: 'getPremiumGiftPaymentOptions',
  |}

  declare export type getPremiumGiveawayPaymentOptions = {|
    /**
     * Returns available options for creating of Telegram Premium giveaway or manual
     * distribution of Telegram Premium among chat members
     */
    +_: 'getPremiumGiveawayPaymentOptions',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by receivers of the gift codes and which is administered by the user
     */
    +boosted_chat_id?: number,
  |}

  declare export type checkPremiumGiftCode = {|
    /** Return information about a Telegram Premium gift code */
    +_: 'checkPremiumGiftCode',
    /** The code to check */
    +code?: string,
  |}

  declare export type applyPremiumGiftCode = {|
    /** Applies a Telegram Premium gift code */
    +_: 'applyPremiumGiftCode',
    /** The code to apply */
    +code?: string,
  |}

  declare export type launchPrepaidGiveaway = {|
    /** Launches a prepaid giveaway */
    +_: 'launchPrepaidGiveaway',
    /** Unique identifier of the prepaid giveaway */
    +giveaway_id?: number | string,
    /** Giveaway parameters */
    +parameters?: giveawayParameters$Input,
    /** The number of users to receive giveaway prize */
    +winner_count?: number,
    /**
     * The number of Telegram Stars to be distributed through the giveaway; pass 0
     * for Telegram Premium giveaways
     */
    +star_count?: number,
  |}

  declare export type getGiveawayInfo = {|
    /** Returns information about a giveaway */
    +_: 'getGiveawayInfo',
    /** Identifier of the channel chat which started the giveaway */
    +chat_id?: number,
    /** Identifier of the giveaway or a giveaway winners message in the chat */
    +message_id?: number,
  |}

  declare export type getStarPaymentOptions = {|
    /** Returns available options for Telegram Stars purchase */
    +_: 'getStarPaymentOptions',
  |}

  declare export type getStarGiftPaymentOptions = {|
    /** Returns available options for Telegram Stars gifting */
    +_: 'getStarGiftPaymentOptions',
    /**
     * Identifier of the user that will receive Telegram Stars; pass 0 to get options
     * for an unspecified user
     */
    +user_id?: number,
  |}

  declare export type getStarGiveawayPaymentOptions = {|
    /** Returns available options for Telegram Star giveaway creation */
    +_: 'getStarGiveawayPaymentOptions',
  |}

  declare export type getStarTransactions = {|
    /** Returns the list of Telegram Star transactions for the specified owner */
    +_: 'getStarTransactions',
    /**
     * Identifier of the owner of the Telegram Stars; can be the identifier of the
     * current user, identifier of an owned bot, or identifier of a supergroup or a
     * channel chat with supergroupFullInfo.can_get_star_revenue_statistics == true
     */
    +owner_id?: MessageSender$Input,
    /** If non-empty, only transactions related to the Star Subscription will be returned */
    +subscription_id?: string,
    /** Direction of the transactions to receive; pass null to get all transactions */
    +direction?: StarTransactionDirection$Input,
    /**
     * Offset of the first transaction to return as received from the previous request;
     * use empty string to get the first chunk of results
     */
    +offset?: string,
    /** The maximum number of transactions to return */
    +limit?: number,
  |}

  declare export type getStarSubscriptions = {|
    /** Returns the list of Telegram Star subscriptions for the current user */
    +_: 'getStarSubscriptions',
    /**
     * Pass true to receive only expiring subscriptions for which there are no enough
     * Telegram Stars to extend
     */
    +only_expiring?: boolean,
    /**
     * Offset of the first subscription to return as received from the previous request;
     * use empty string to get the first chunk of results
     */
    +offset?: string,
  |}

  declare export type canPurchaseFromStore = {|
    /**
     * Checks whether an in-store purchase is possible. Must be called before any in-store
     * purchase
     */
    +_: 'canPurchaseFromStore',
    /** Transaction purpose */
    +purpose?: StorePaymentPurpose$Input,
  |}

  declare export type assignAppStoreTransaction = {|
    /**
     * Informs server about a purchase through App Store. For official applications
     * only
     */
    +_: 'assignAppStoreTransaction',
    /** App Store receipt */
    +receipt?: string /* base64 */,
    /** Transaction purpose */
    +purpose?: StorePaymentPurpose$Input,
  |}

  declare export type assignGooglePlayTransaction = {|
    /**
     * Informs server about a purchase through Google Play. For official applications
     * only
     */
    +_: 'assignGooglePlayTransaction',
    /** Application package name */
    +package_name?: string,
    /** Identifier of the purchased store product */
    +store_product_id?: string,
    /** Google Play purchase token */
    +purchase_token?: string,
    /** Transaction purpose */
    +purpose?: StorePaymentPurpose$Input,
  |}

  declare export type editStarSubscription = {|
    /** Cancels or re-enables Telegram Star subscription */
    +_: 'editStarSubscription',
    /** Identifier of the subscription to change */
    +subscription_id?: string,
    /** New value of is_canceled */
    +is_canceled?: boolean,
  |}

  declare export type editUserStarSubscription = {|
    /** Cancels or re-enables Telegram Star subscription for a user; for bots only */
    +_: 'editUserStarSubscription',
    /** User identifier */
    +user_id?: number,
    /** Telegram payment identifier of the subscription */
    +telegram_payment_charge_id?: string,
    /**
     * Pass true to cancel the subscription; pass false to allow the user to enable
     * it
     */
    +is_canceled?: boolean,
  |}

  declare export type reuseStarSubscription = {|
    /**
     * Reuses an active Telegram Star subscription to a channel chat and joins the
     * chat again
     */
    +_: 'reuseStarSubscription',
    /** Identifier of the subscription */
    +subscription_id?: string,
  |}

  declare export type setChatAffiliateProgram = {|
    /** Changes affiliate program for a bot */
    +_: 'setChatAffiliateProgram',
    /** Identifier of the chat with an owned bot for which affiliate program is changed */
    +chat_id?: number,
    /**
     * Parameters of the affiliate program; pass null to close the currently active
     * program. If there is an active program, then commission and program duration
     * can only be increased. If the active program is scheduled to be closed, then
     * it can't be changed anymore
     */
    +parameters?: affiliateProgramParameters$Input,
  |}

  declare export type searchChatAffiliateProgram = {|
    /**
     * Searches a chat with an affiliate program. Returns the chat if found and the
     * program is active
     */
    +_: 'searchChatAffiliateProgram',
    /** Username of the chat */
    +username?: string,
    /** The referrer from an internalLinkTypeChatAffiliateProgram link */
    +referrer?: string,
  |}

  declare export type searchAffiliatePrograms = {|
    /** Searches affiliate programs that can be connected to the given affiliate */
    +_: 'searchAffiliatePrograms',
    /** The affiliate for which affiliate programs are searched for */
    +affiliate?: AffiliateType$Input,
    /** Sort order for the results */
    +sort_order?: AffiliateProgramSortOrder$Input,
    /**
     * Offset of the first affiliate program to return as received from the previous
     * request; use empty string to get the first chunk of results
     */
    +offset?: string,
    /** The maximum number of affiliate programs to return */
    +limit?: number,
  |}

  declare export type connectAffiliateProgram = {|
    /**
     * Connects an affiliate program to the given affiliate. Returns information about
     * the connected affiliate program
     */
    +_: 'connectAffiliateProgram',
    /** The affiliate to which the affiliate program will be connected */
    +affiliate?: AffiliateType$Input,
    /** Identifier of the bot, which affiliate program is connected */
    +bot_user_id?: number,
  |}

  declare export type disconnectAffiliateProgram = {|
    /**
     * Disconnects an affiliate program from the given affiliate and immediately deactivates
     * its referral link. Returns updated information about the disconnected affiliate
     * program
     */
    +_: 'disconnectAffiliateProgram',
    /** The affiliate to which the affiliate program is connected */
    +affiliate?: AffiliateType$Input,
    /** The referral link of the affiliate program */
    +url?: string,
  |}

  declare export type getConnectedAffiliateProgram = {|
    /**
     * Returns an affiliate program that were connected to the given affiliate by identifier
     * of the bot that created the program
     */
    +_: 'getConnectedAffiliateProgram',
    /** The affiliate to which the affiliate program will be connected */
    +affiliate?: AffiliateType$Input,
    /** Identifier of the bot that created the program */
    +bot_user_id?: number,
  |}

  declare export type getConnectedAffiliatePrograms = {|
    /** Returns affiliate programs that were connected to the given affiliate */
    +_: 'getConnectedAffiliatePrograms',
    /** The affiliate to which the affiliate program were connected */
    +affiliate?: AffiliateType$Input,
    /**
     * Offset of the first affiliate program to return as received from the previous
     * request; use empty string to get the first chunk of results
     */
    +offset?: string,
    /** The maximum number of affiliate programs to return */
    +limit?: number,
  |}

  declare export type getBusinessFeatures = {|
    /** Returns information about features, available to Business users */
    +_: 'getBusinessFeatures',
    /**
     * Source of the request; pass null if the method is called from settings or some
     * non-standard source
     */
    +source?: BusinessFeature$Input,
  |}

  declare export type acceptTermsOfService = {|
    /** Accepts Telegram terms of services */
    +_: 'acceptTermsOfService',
    /** Terms of service identifier */
    +terms_of_service_id?: string,
  |}

  declare export type searchStringsByPrefix = {|
    /**
     * Searches specified query by word prefixes in the provided strings. Returns 0-based
     * positions of strings that matched. Can be called synchronously
     */
    +_: 'searchStringsByPrefix',
    /** The strings to search in for the query */
    +strings?: $ReadOnlyArray<string>,
    /** Query to search for */
    +query?: string,
    /** The maximum number of objects to return */
    +limit?: number,
    /** Pass true to receive no results for an empty query */
    +return_none_for_empty_query?: boolean,
  |}

  declare export type sendCustomRequest = {|
    /** Sends a custom request; for bots only */
    +_: 'sendCustomRequest',
    /** The method name */
    +method?: string,
    /** JSON-serialized method parameters */
    +parameters?: string,
  |}

  declare export type answerCustomQuery = {|
    /** Answers a custom query; for bots only */
    +_: 'answerCustomQuery',
    /** Identifier of a custom query */
    +custom_query_id?: number | string,
    /** JSON-serialized answer to the query */
    +data?: string,
  |}

  declare export type setAlarm = {|
    /** Succeeds after a specified amount of time has passed. Can be called before initialization */
    +_: 'setAlarm',
    /** Number of seconds before the function returns */
    +seconds?: number,
  |}

  declare export type getCountries = {|
    /** Returns information about existing countries. Can be called before authorization */
    +_: 'getCountries',
  |}

  declare export type getCountryCode = {|
    /**
     * Uses the current IP address to find the current country. Returns two-letter
     * ISO 3166-1 alpha-2 country code. Can be called before authorization
     */
    +_: 'getCountryCode',
  |}

  declare export type getPhoneNumberInfo = {|
    /**
     * Returns information about a phone number by its prefix. Can be called before
     * authorization
     */
    +_: 'getPhoneNumberInfo',
    /** The phone number prefix */
    +phone_number_prefix?: string,
  |}

  declare export type getPhoneNumberInfoSync = {|
    /**
     * Returns information about a phone number by its prefix synchronously. getCountries
     * must be called at least once after changing localization to the specified language
     * if properly localized country information is expected. Can be called synchronously
     */
    +_: 'getPhoneNumberInfoSync',
    /** A two-letter ISO 639-1 language code for country information localization */
    +language_code?: string,
    /** The phone number prefix */
    +phone_number_prefix?: string,
  |}

  declare export type getCollectibleItemInfo = {|
    /** Returns information about a given collectible item that was purchased at https://fragment.com */
    +_: 'getCollectibleItemInfo',
    /**
     * Type of the collectible item. The item must be used by a user and must be visible
     * to the current user
     */
    +type?: CollectibleItemType$Input,
  |}

  declare export type getDeepLinkInfo = {|
    /**
     * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature"
     * or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown
     * links. Can be called before authorization
     */
    +_: 'getDeepLinkInfo',
    /** The link */
    +link?: string,
  |}

  declare export type getApplicationConfig = {|
    /** Returns application config, provided by the server. Can be called before authorization */
    +_: 'getApplicationConfig',
  |}

  declare export type saveApplicationLogEvent = {|
    /** Saves application log event on the server. Can be called before authorization */
    +_: 'saveApplicationLogEvent',
    /** Event type */
    +type?: string,
    /** Optional chat identifier, associated with the event */
    +chat_id?: number,
    /** The log event data */
    +data?: JsonValue$Input,
  |}

  declare export type getApplicationDownloadLink = {|
    /**
     * Returns the link for downloading official Telegram application to be used when
     * the current user invites friends to Telegram
     */
    +_: 'getApplicationDownloadLink',
  |}

  declare export type addProxy = {|
    /** Adds a proxy server for network requests. Can be called before authorization */
    +_: 'addProxy',
    /** Proxy server domain or IP address */
    +server?: string,
    /** Proxy server port */
    +port?: number,
    /** Pass true to immediately enable the proxy */
    +enable?: boolean,
    /** Proxy type */
    +type?: ProxyType$Input,
  |}

  declare export type editProxy = {|
    /** Edits an existing proxy server for network requests. Can be called before authorization */
    +_: 'editProxy',
    /** Proxy identifier */
    +proxy_id?: number,
    /** Proxy server domain or IP address */
    +server?: string,
    /** Proxy server port */
    +port?: number,
    /** Pass true to immediately enable the proxy */
    +enable?: boolean,
    /** Proxy type */
    +type?: ProxyType$Input,
  |}

  declare export type enableProxy = {|
    /**
     * Enables a proxy. Only one proxy can be enabled at a time. Can be called before
     * authorization
     */
    +_: 'enableProxy',
    /** Proxy identifier */
    +proxy_id?: number,
  |}

  declare export type disableProxy = {|
    /** Disables the currently enabled proxy. Can be called before authorization */
    +_: 'disableProxy',
  |}

  declare export type removeProxy = {|
    /** Removes a proxy server. Can be called before authorization */
    +_: 'removeProxy',
    /** Proxy identifier */
    +proxy_id?: number,
  |}

  declare export type getProxies = {|
    /**
     * Returns the list of proxies that are currently set up. Can be called before
     * authorization
     */
    +_: 'getProxies',
  |}

  declare export type getProxyLink = {|
    /**
     * Returns an HTTPS link, which can be used to add a proxy. Available only for
     * SOCKS5 and MTProto proxies. Can be called before authorization
     */
    +_: 'getProxyLink',
    /** Proxy identifier */
    +proxy_id?: number,
  |}

  declare export type pingProxy = {|
    /**
     * Computes time needed to receive a response from a Telegram server through a
     * proxy. Can be called before authorization
     */
    +_: 'pingProxy',
    /** Proxy identifier. Use 0 to ping a Telegram server without a proxy */
    +proxy_id?: number,
  |}

  declare export type setLogStream = {|
    /** Sets new log stream for internal logging of TDLib. Can be called synchronously */
    +_: 'setLogStream',
    /** New log stream */
    +log_stream?: LogStream$Input,
  |}

  declare export type getLogStream = {|
    /**
     * Returns information about currently used log stream for internal logging of
     * TDLib. Can be called synchronously
     */
    +_: 'getLogStream',
  |}

  declare export type setLogVerbosityLevel = {|
    /** Sets the verbosity level of the internal logging of TDLib. Can be called synchronously */
    +_: 'setLogVerbosityLevel',
    /**
     * New value of the verbosity level for logging. Value 0 corresponds to fatal errors,
     * value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,
     * value 3 corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can be used
     * to enable even more logging
     */
    +new_verbosity_level?: number,
  |}

  declare export type getLogVerbosityLevel = {|
    /**
     * Returns current verbosity level of the internal logging of TDLib. Can be called
     * synchronously
     */
    +_: 'getLogVerbosityLevel',
  |}

  declare export type getLogTags = {|
    /**
     * Returns the list of available TDLib internal log tags, for example, ["actor",
     * "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
     */
    +_: 'getLogTags',
  |}

  declare export type setLogTagVerbosityLevel = {|
    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can be called
     * synchronously
     */
    +_: 'setLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    +tag?: string,
    /** New verbosity level; 1-1024 */
    +new_verbosity_level?: number,
  |}

  declare export type getLogTagVerbosityLevel = {|
    /**
     * Returns current verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     */
    +_: 'getLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    +tag?: string,
  |}

  declare export type addLogMessage = {|
    /** Adds a message to TDLib internal log. Can be called synchronously */
    +_: 'addLogMessage',
    /** The minimum verbosity level needed for the message to be logged; 0-1023 */
    +verbosity_level?: number,
    /** Text of a message to log */
    +text?: string,
  |}

  declare export type getUserSupportInfo = {|
    /** Returns support information for the given user; for Telegram support only */
    +_: 'getUserSupportInfo',
    /** User identifier */
    +user_id?: number,
  |}

  declare export type setUserSupportInfo = {|
    /** Sets support information for the given user; for Telegram support only */
    +_: 'setUserSupportInfo',
    /** User identifier */
    +user_id?: number,
    /** New information message */
    +message?: formattedText$Input,
  |}

  declare export type getSupportName = {|
    /** Returns localized name of the Telegram support user; for Telegram support only */
    +_: 'getSupportName',
  |}

  declare export type testCallEmpty = {|
    /**
     * Does nothing; for testing only. This is an offline method. Can be called before
     * authorization
     */
    +_: 'testCallEmpty',
  |}

  declare export type testCallString = {|
    /**
     * Returns the received string; for testing only. This is an offline method. Can
     * be called before authorization
     */
    +_: 'testCallString',
    /** String to return */
    +x?: string,
  |}

  declare export type testCallBytes = {|
    /**
     * Returns the received bytes; for testing only. This is an offline method. Can
     * be called before authorization
     */
    +_: 'testCallBytes',
    /** Bytes to return */
    +x?: string /* base64 */,
  |}

  declare export type testCallVectorInt = {|
    /**
     * Returns the received vector of numbers; for testing only. This is an offline
     * method. Can be called before authorization
     */
    +_: 'testCallVectorInt',
    /** Vector of numbers to return */
    +x?: $ReadOnlyArray<number>,
  |}

  declare export type testCallVectorIntObject = {|
    /**
     * Returns the received vector of objects containing a number; for testing only.
     * This is an offline method. Can be called before authorization
     */
    +_: 'testCallVectorIntObject',
    /** Vector of objects to return */
    +x?: $ReadOnlyArray<testInt$Input>,
  |}

  declare export type testCallVectorString = {|
    /**
     * Returns the received vector of strings; for testing only. This is an offline
     * method. Can be called before authorization
     */
    +_: 'testCallVectorString',
    /** Vector of strings to return */
    +x?: $ReadOnlyArray<string>,
  |}

  declare export type testCallVectorStringObject = {|
    /**
     * Returns the received vector of objects containing a string; for testing only.
     * This is an offline method. Can be called before authorization
     */
    +_: 'testCallVectorStringObject',
    /** Vector of objects to return */
    +x?: $ReadOnlyArray<testString$Input>,
  |}

  declare export type testSquareInt = {|
    /**
     * Returns the squared received number; for testing only. This is an offline method.
     * Can be called before authorization
     */
    +_: 'testSquareInt',
    /** Number to square */
    +x?: number,
  |}

  declare export type testNetwork = {|
    /**
     * Sends a simple network request to the Telegram servers; for testing only. Can
     * be called before authorization
     */
    +_: 'testNetwork',
  |}

  declare export type testProxy = {|
    /**
     * Sends a simple network request to the Telegram servers via proxy; for testing
     * only. Can be called before authorization
     */
    +_: 'testProxy',
    /** Proxy server domain or IP address */
    +server?: string,
    /** Proxy server port */
    +port?: number,
    /** Proxy type */
    +type?: ProxyType$Input,
    /** Identifier of a datacenter with which to test connection */
    +dc_id?: number,
    /** The maximum overall timeout for the request */
    +timeout?: number,
  |}

  declare export type testGetDifference = {|
    /** Forces an updates.getDifference call to the Telegram servers; for testing only */
    +_: 'testGetDifference',
  |}

  declare export type testUseUpdate = {|
    /**
     * Does nothing and ensures that the Update object is used; for testing only. This
     * is an offline method. Can be called before authorization
     */
    +_: 'testUseUpdate',
  |}

  declare export type testReturnError = {|
    /**
     * Returns the specified error and ensures that the Error object is used; for testing
     * only. Can be called synchronously
     */
    +_: 'testReturnError',
    /** The error to be returned */
    +error?: error$Input,
  |}

  // --- ---

  declare export type Error = error

  declare export type Ok = ok

  /**
   * Provides information about the method by which an authentication code is delivered
   * to the user
   */
  declare export type AuthenticationCodeType =
    | authenticationCodeTypeTelegramMessage
    | authenticationCodeTypeSms
    | authenticationCodeTypeSmsWord
    | authenticationCodeTypeSmsPhrase
    | authenticationCodeTypeCall
    | authenticationCodeTypeFlashCall
    | authenticationCodeTypeMissedCall
    | authenticationCodeTypeFragment
    | authenticationCodeTypeFirebaseAndroid
    | authenticationCodeTypeFirebaseIos

  declare export type AuthenticationCodeInfo = authenticationCodeInfo

  declare export type EmailAddressAuthenticationCodeInfo = emailAddressAuthenticationCodeInfo

  /** Contains authentication data for an email address */
  declare export type EmailAddressAuthentication$Input =
    | emailAddressAuthenticationCode$Input
    | emailAddressAuthenticationAppleId$Input
    | emailAddressAuthenticationGoogleId$Input

  /** Describes reset state of an email address */
  declare export type EmailAddressResetState =
    | emailAddressResetStateAvailable
    | emailAddressResetStatePending

  declare export type TextEntities = textEntities

  declare export type FormattedText = formattedText

  /** Represents the current authorization state of the TDLib client */
  declare export type AuthorizationState =
    | authorizationStateWaitTdlibParameters
    | authorizationStateWaitPhoneNumber
    | authorizationStateWaitEmailAddress
    | authorizationStateWaitEmailCode
    | authorizationStateWaitCode
    | authorizationStateWaitOtherDeviceConfirmation
    | authorizationStateWaitRegistration
    | authorizationStateWaitPassword
    | authorizationStateReady
    | authorizationStateLoggingOut
    | authorizationStateClosing
    | authorizationStateClosed

  /** Describes parameters to be used for device verification */
  declare export type FirebaseDeviceVerificationParameters =
    | firebaseDeviceVerificationParametersSafetyNet
    | firebaseDeviceVerificationParametersPlayIntegrity

  declare export type PasswordState = passwordState

  declare export type RecoveryEmailAddress = recoveryEmailAddress

  declare export type TemporaryPasswordState = temporaryPasswordState

  declare export type File = file

  /** Points to a file */
  declare export type InputFile =
    | inputFileId
    | inputFileRemote
    | inputFileLocal
    | inputFileGenerated

  /** Points to a file */
  declare export type InputFile$Input =
    | inputFileId$Input
    | inputFileRemote$Input
    | inputFileLocal$Input
    | inputFileGenerated$Input

  /** Describes format of a thumbnail */
  declare export type ThumbnailFormat =
    | thumbnailFormatJpeg
    | thumbnailFormatGif
    | thumbnailFormatMpeg4
    | thumbnailFormatPng
    | thumbnailFormatTgs
    | thumbnailFormatWebm
    | thumbnailFormatWebp

  /** Part of the face, relative to which a mask is placed */
  declare export type MaskPoint =
    | maskPointForehead
    | maskPointEyes
    | maskPointMouth
    | maskPointChin

  /** Part of the face, relative to which a mask is placed */
  declare export type MaskPoint$Input =
    | maskPointForehead$Input
    | maskPointEyes$Input
    | maskPointMouth$Input
    | maskPointChin$Input

  /** Describes format of a sticker */
  declare export type StickerFormat =
    | stickerFormatWebp
    | stickerFormatTgs
    | stickerFormatWebm

  /** Describes format of a sticker */
  declare export type StickerFormat$Input =
    | stickerFormatWebp$Input
    | stickerFormatTgs$Input
    | stickerFormatWebm$Input

  /** Describes type of sticker */
  declare export type StickerType =
    | stickerTypeRegular
    | stickerTypeMask
    | stickerTypeCustomEmoji

  /** Describes type of sticker */
  declare export type StickerType$Input =
    | stickerTypeRegular$Input
    | stickerTypeMask$Input
    | stickerTypeCustomEmoji$Input

  /** Contains full information about sticker type */
  declare export type StickerFullType =
    | stickerFullTypeRegular
    | stickerFullTypeMask
    | stickerFullTypeCustomEmoji

  declare export type Outline = outline

  /** Describes the type of poll */
  declare export type PollType =
    | pollTypeRegular
    | pollTypeQuiz

  /** Describes the type of poll */
  declare export type PollType$Input =
    | pollTypeRegular$Input
    | pollTypeQuiz$Input

  declare export type Sticker = sticker

  declare export type AnimatedEmoji = animatedEmoji

  declare export type Background = background

  declare export type Backgrounds = backgrounds

  /**
   * Represents the type of user. The following types are possible: regular users,
   * deleted users and bots
   */
  declare export type UserType =
    | userTypeRegular
    | userTypeDeleted
    | userTypeBot
    | userTypeUnknown

  declare export type BotCommands = botCommands

  declare export type BotMenuButton = botMenuButton

  /** Describes conditions for sending of away messages by a Telegram Business account */
  declare export type BusinessAwayMessageSchedule =
    | businessAwayMessageScheduleAlways
    | businessAwayMessageScheduleOutsideOfOpeningHours
    | businessAwayMessageScheduleCustom

  /** Describes conditions for sending of away messages by a Telegram Business account */
  declare export type BusinessAwayMessageSchedule$Input =
    | businessAwayMessageScheduleAlways$Input
    | businessAwayMessageScheduleOutsideOfOpeningHours$Input
    | businessAwayMessageScheduleCustom$Input

  declare export type BusinessConnectedBot = businessConnectedBot

  declare export type BusinessChatLink = businessChatLink

  declare export type BusinessChatLinks = businessChatLinks

  declare export type BusinessChatLinkInfo = businessChatLinkInfo

  /** Describes type of sticker, which was used to create a chat photo */
  declare export type ChatPhotoStickerType =
    | chatPhotoStickerTypeRegularOrMask
    | chatPhotoStickerTypeCustomEmoji

  /** Describes type of sticker, which was used to create a chat photo */
  declare export type ChatPhotoStickerType$Input =
    | chatPhotoStickerTypeRegularOrMask$Input
    | chatPhotoStickerTypeCustomEmoji$Input

  declare export type ChatPhotos = chatPhotos

  /** Describes a photo to be set as a user profile or chat photo */
  declare export type InputChatPhoto$Input =
    | inputChatPhotoPrevious$Input
    | inputChatPhotoStatic$Input
    | inputChatPhotoAnimation$Input
    | inputChatPhotoSticker$Input

  /** Describes type of subscription paid in Telegram Stars */
  declare export type StarSubscriptionType =
    | starSubscriptionTypeChannel
    | starSubscriptionTypeBot

  declare export type StarSubscriptions = starSubscriptions

  /** Describes type of affiliate for an affiliate program */
  declare export type AffiliateType$Input =
    | affiliateTypeCurrentUser$Input
    | affiliateTypeBot$Input
    | affiliateTypeChannel$Input

  /** Describes the order of the found affiliate programs */
  declare export type AffiliateProgramSortOrder$Input =
    | affiliateProgramSortOrderProfitability$Input
    | affiliateProgramSortOrderCreationDate$Input
    | affiliateProgramSortOrderRevenue$Input

  declare export type FoundAffiliatePrograms = foundAffiliatePrograms

  declare export type ConnectedAffiliateProgram = connectedAffiliateProgram

  declare export type ConnectedAffiliatePrograms = connectedAffiliatePrograms

  declare export type PremiumGiftPaymentOptions = premiumGiftPaymentOptions

  declare export type PremiumGiveawayPaymentOptions = premiumGiveawayPaymentOptions

  declare export type PremiumGiftCodeInfo = premiumGiftCodeInfo

  declare export type StarPaymentOptions = starPaymentOptions

  declare export type StarGiveawayPaymentOptions = starGiveawayPaymentOptions

  declare export type Gifts = gifts

  declare export type UpgradedGift = upgradedGift

  declare export type UpgradeGiftResult = upgradeGiftResult

  /** Represents content of a gift received by a user or a channel chat */
  declare export type SentGift =
    | sentGiftRegular
    | sentGiftUpgraded

  declare export type ReceivedGift = receivedGift

  declare export type ReceivedGifts = receivedGifts

  declare export type GiftUpgradePreview = giftUpgradePreview

  /** Describes direction of a transaction with Telegram Stars */
  declare export type StarTransactionDirection$Input =
    | starTransactionDirectionIncoming$Input
    | starTransactionDirectionOutgoing$Input

  /** Describes type of transaction with Telegram Stars */
  declare export type StarTransactionType =
    | starTransactionTypePremiumBotDeposit
    | starTransactionTypeAppStoreDeposit
    | starTransactionTypeGooglePlayDeposit
    | starTransactionTypeFragmentDeposit
    | starTransactionTypeUserDeposit
    | starTransactionTypeGiveawayDeposit
    | starTransactionTypeFragmentWithdrawal
    | starTransactionTypeTelegramAdsWithdrawal
    | starTransactionTypeTelegramApiUsage
    | starTransactionTypeBotPaidMediaPurchase
    | starTransactionTypeBotPaidMediaSale
    | starTransactionTypeChannelPaidMediaPurchase
    | starTransactionTypeChannelPaidMediaSale
    | starTransactionTypeBotInvoicePurchase
    | starTransactionTypeBotInvoiceSale
    | starTransactionTypeBotSubscriptionPurchase
    | starTransactionTypeBotSubscriptionSale
    | starTransactionTypeChannelSubscriptionPurchase
    | starTransactionTypeChannelSubscriptionSale
    | starTransactionTypeGiftPurchase
    | starTransactionTypeGiftTransfer
    | starTransactionTypeGiftSale
    | starTransactionTypeGiftUpgrade
    | starTransactionTypeChannelPaidReactionSend
    | starTransactionTypeChannelPaidReactionReceive
    | starTransactionTypeAffiliateProgramCommission
    | starTransactionTypePaidMessageSend
    | starTransactionTypePaidMessageReceive
    | starTransactionTypePremiumPurchase
    | starTransactionTypeUnsupported

  declare export type StarTransactions = starTransactions

  /** Contains information about status of a user in a giveaway */
  declare export type GiveawayParticipantStatus =
    | giveawayParticipantStatusEligible
    | giveawayParticipantStatusParticipating
    | giveawayParticipantStatusAlreadyWasMember
    | giveawayParticipantStatusAdministrator
    | giveawayParticipantStatusDisallowedCountry

  /** Contains information about a giveaway */
  declare export type GiveawayInfo =
    | giveawayInfoOngoing
    | giveawayInfoCompleted

  /** Contains information about a giveaway prize */
  declare export type GiveawayPrize =
    | giveawayPrizePremium
    | giveawayPrizeStars

  /** Describes type of emoji status */
  declare export type EmojiStatusType =
    | emojiStatusTypeCustomEmoji
    | emojiStatusTypeUpgradedGift

  /** Describes type of emoji status */
  declare export type EmojiStatusType$Input =
    | emojiStatusTypeCustomEmoji$Input
    | emojiStatusTypeUpgradedGift$Input

  declare export type EmojiStatuses = emojiStatuses

  declare export type EmojiStatusCustomEmojis = emojiStatusCustomEmojis

  declare export type User = user

  declare export type UserFullInfo = userFullInfo

  declare export type Users = users

  declare export type FoundUsers = foundUsers

  declare export type ChatAdministrators = chatAdministrators

  /** Provides information about the status of a member in a chat */
  declare export type ChatMemberStatus =
    | chatMemberStatusCreator
    | chatMemberStatusAdministrator
    | chatMemberStatusMember
    | chatMemberStatusRestricted
    | chatMemberStatusLeft
    | chatMemberStatusBanned

  /** Provides information about the status of a member in a chat */
  declare export type ChatMemberStatus$Input =
    | chatMemberStatusCreator$Input
    | chatMemberStatusAdministrator$Input
    | chatMemberStatusMember$Input
    | chatMemberStatusRestricted$Input
    | chatMemberStatusLeft$Input
    | chatMemberStatusBanned$Input

  declare export type ChatMember = chatMember

  declare export type ChatMembers = chatMembers

  /** Specifies the kind of chat members to return in searchChatMembers */
  declare export type ChatMembersFilter$Input =
    | chatMembersFilterContacts$Input
    | chatMembersFilterAdministrators$Input
    | chatMembersFilterMembers$Input
    | chatMembersFilterMention$Input
    | chatMembersFilterRestricted$Input
    | chatMembersFilterBanned$Input
    | chatMembersFilterBots$Input

  /** Specifies the kind of chat members to return in getSupergroupMembers */
  declare export type SupergroupMembersFilter$Input =
    | supergroupMembersFilterRecent$Input
    | supergroupMembersFilterContacts$Input
    | supergroupMembersFilterAdministrators$Input
    | supergroupMembersFilterSearch$Input
    | supergroupMembersFilterRestricted$Input
    | supergroupMembersFilterBanned$Input
    | supergroupMembersFilterMention$Input
    | supergroupMembersFilterBots$Input

  declare export type ChatInviteLink = chatInviteLink

  declare export type ChatInviteLinks = chatInviteLinks

  declare export type ChatInviteLinkCounts = chatInviteLinkCounts

  declare export type ChatInviteLinkMembers = chatInviteLinkMembers

  /** Describes the type of chat to which points an invite link */
  declare export type InviteLinkChatType =
    | inviteLinkChatTypeBasicGroup
    | inviteLinkChatTypeSupergroup
    | inviteLinkChatTypeChannel

  declare export type ChatInviteLinkInfo = chatInviteLinkInfo

  declare export type ChatJoinRequests = chatJoinRequests

  declare export type BasicGroup = basicGroup

  declare export type BasicGroupFullInfo = basicGroupFullInfo

  declare export type Supergroup = supergroup

  declare export type SupergroupFullInfo = supergroupFullInfo

  /** Describes the current secret chat state */
  declare export type SecretChatState =
    | secretChatStatePending
    | secretChatStateReady
    | secretChatStateClosed

  declare export type SecretChat = secretChat

  /** Contains information about the sender of a message */
  declare export type MessageSender =
    | messageSenderUser
    | messageSenderChat

  /** Contains information about the sender of a message */
  declare export type MessageSender$Input =
    | messageSenderUser$Input
    | messageSenderChat$Input

  declare export type MessageSenders = messageSenders

  declare export type ChatMessageSenders = chatMessageSenders

  /** Describes read date of a recent outgoing message in a private chat */
  declare export type MessageReadDate =
    | messageReadDateRead
    | messageReadDateUnread
    | messageReadDateTooOld
    | messageReadDateUserPrivacyRestricted
    | messageReadDateMyPrivacyRestricted

  declare export type MessageViewers = messageViewers

  /** Contains information about the origin of a message */
  declare export type MessageOrigin =
    | messageOriginUser
    | messageOriginHiddenUser
    | messageOriginChat
    | messageOriginChannel

  /** Describes type of message reaction */
  declare export type ReactionType =
    | reactionTypeEmoji
    | reactionTypeCustomEmoji
    | reactionTypePaid

  /** Describes type of message reaction */
  declare export type ReactionType$Input =
    | reactionTypeEmoji$Input
    | reactionTypeCustomEmoji$Input
    | reactionTypePaid$Input

  /** Describes type of paid message reaction */
  declare export type PaidReactionType =
    | paidReactionTypeRegular
    | paidReactionTypeAnonymous
    | paidReactionTypeChat

  /** Describes type of paid message reaction */
  declare export type PaidReactionType$Input =
    | paidReactionTypeRegular$Input
    | paidReactionTypeAnonymous$Input
    | paidReactionTypeChat$Input

  /** Describes type of emoji effect */
  declare export type MessageEffectType =
    | messageEffectTypeEmojiReaction
    | messageEffectTypePremiumSticker

  declare export type MessageEffect = messageEffect

  /** Contains information about the sending state of the message */
  declare export type MessageSendingState =
    | messageSendingStatePending
    | messageSendingStateFailed

  /** Contains information about the message or the story a message is replying to */
  declare export type MessageReplyTo =
    | messageReplyToMessage
    | messageReplyToStory

  /** Contains information about the message or the story to be replied */
  declare export type InputMessageReplyTo =
    | inputMessageReplyToMessage
    | inputMessageReplyToExternalMessage
    | inputMessageReplyToStory

  /** Contains information about the message or the story to be replied */
  declare export type InputMessageReplyTo$Input =
    | inputMessageReplyToMessage$Input
    | inputMessageReplyToExternalMessage$Input
    | inputMessageReplyToStory$Input

  declare export type Message = message

  declare export type Messages = messages

  declare export type FoundMessages = foundMessages

  declare export type FoundChatMessages = foundChatMessages

  declare export type MessagePositions = messagePositions

  declare export type MessageCalendar = messageCalendar

  declare export type BusinessMessage = businessMessage

  declare export type BusinessMessages = businessMessages

  /** Describes source of a message */
  declare export type MessageSource$Input =
    | messageSourceChatHistory$Input
    | messageSourceMessageThreadHistory$Input
    | messageSourceForumTopicHistory$Input
    | messageSourceHistoryPreview$Input
    | messageSourceChatList$Input
    | messageSourceSearch$Input
    | messageSourceChatEventLog$Input
    | messageSourceNotification$Input
    | messageSourceScreenshot$Input
    | messageSourceOther$Input

  declare export type SponsoredMessages = sponsoredMessages

  /** Describes result of sponsored message report */
  declare export type ReportChatSponsoredMessageResult =
    | reportChatSponsoredMessageResultOk
    | reportChatSponsoredMessageResultFailed
    | reportChatSponsoredMessageResultOptionRequired
    | reportChatSponsoredMessageResultAdsHidden
    | reportChatSponsoredMessageResultPremiumRequired

  declare export type FoundFileDownloads = foundFileDownloads

  /** Describes the types of chats to which notification settings are relevant */
  declare export type NotificationSettingsScope =
    | notificationSettingsScopePrivateChats
    | notificationSettingsScopeGroupChats
    | notificationSettingsScopeChannelChats

  /** Describes the types of chats to which notification settings are relevant */
  declare export type NotificationSettingsScope$Input =
    | notificationSettingsScopePrivateChats$Input
    | notificationSettingsScopeGroupChats$Input
    | notificationSettingsScopeChannelChats$Input

  declare export type ScopeNotificationSettings = scopeNotificationSettings

  /** Describes sources of reactions for which notifications will be shown */
  declare export type ReactionNotificationSource =
    | reactionNotificationSourceNone
    | reactionNotificationSourceContacts
    | reactionNotificationSourceAll

  /** Describes sources of reactions for which notifications will be shown */
  declare export type ReactionNotificationSource$Input =
    | reactionNotificationSourceNone$Input
    | reactionNotificationSourceContacts$Input
    | reactionNotificationSourceAll$Input

  /** Describes the type of chat */
  declare export type ChatType =
    | chatTypePrivate
    | chatTypeBasicGroup
    | chatTypeSupergroup
    | chatTypeSecret

  declare export type ChatFolderIcon = chatFolderIcon

  declare export type ChatFolder = chatFolder

  declare export type ChatFolderInfo = chatFolderInfo

  declare export type ChatFolderInviteLink = chatFolderInviteLink

  declare export type ChatFolderInviteLinks = chatFolderInviteLinks

  declare export type ChatFolderInviteLinkInfo = chatFolderInviteLinkInfo

  declare export type RecommendedChatFolders = recommendedChatFolders

  declare export type ArchiveChatListSettings = archiveChatListSettings

  /** Describes a list of chats */
  declare export type ChatList =
    | chatListMain
    | chatListArchive
    | chatListFolder

  /** Describes a list of chats */
  declare export type ChatList$Input =
    | chatListMain$Input
    | chatListArchive$Input
    | chatListFolder$Input

  declare export type ChatLists = chatLists

  /** Describes a reason why an external chat is shown in a chat list */
  declare export type ChatSource =
    | chatSourceMtprotoProxy
    | chatSourcePublicServiceAnnouncement

  /** Describes reactions available in the chat */
  declare export type ChatAvailableReactions =
    | chatAvailableReactionsAll
    | chatAvailableReactionsSome

  /** Describes reactions available in the chat */
  declare export type ChatAvailableReactions$Input =
    | chatAvailableReactionsAll$Input
    | chatAvailableReactionsSome$Input

  declare export type SavedMessagesTags = savedMessagesTags

  declare export type Chat = chat

  declare export type Chats = chats

  declare export type FailedToAddMembers = failedToAddMembers

  declare export type CreatedBasicGroupChat = createdBasicGroupChat

  /** Describes type of public chat */
  declare export type PublicChatType$Input =
    | publicChatTypeHasUsername$Input
    | publicChatTypeIsLocationBased$Input

  /** Describes actions which must be possible to do through a chat action bar */
  declare export type ChatActionBar =
    | chatActionBarReportSpam
    | chatActionBarInviteMembers
    | chatActionBarReportAddBlock
    | chatActionBarAddContact
    | chatActionBarSharePhoneNumber
    | chatActionBarJoinRequest

  /** Describes a keyboard button type */
  declare export type KeyboardButtonType =
    | keyboardButtonTypeText
    | keyboardButtonTypeRequestPhoneNumber
    | keyboardButtonTypeRequestLocation
    | keyboardButtonTypeRequestPoll
    | keyboardButtonTypeRequestUsers
    | keyboardButtonTypeRequestChat
    | keyboardButtonTypeWebApp

  /** Describes a keyboard button type */
  declare export type KeyboardButtonType$Input =
    | keyboardButtonTypeText$Input
    | keyboardButtonTypeRequestPhoneNumber$Input
    | keyboardButtonTypeRequestLocation$Input
    | keyboardButtonTypeRequestPoll$Input
    | keyboardButtonTypeRequestUsers$Input
    | keyboardButtonTypeRequestChat$Input
    | keyboardButtonTypeWebApp$Input

  /** Describes the type of inline keyboard button */
  declare export type InlineKeyboardButtonType =
    | inlineKeyboardButtonTypeUrl
    | inlineKeyboardButtonTypeLoginUrl
    | inlineKeyboardButtonTypeWebApp
    | inlineKeyboardButtonTypeCallback
    | inlineKeyboardButtonTypeCallbackWithPassword
    | inlineKeyboardButtonTypeCallbackGame
    | inlineKeyboardButtonTypeSwitchInline
    | inlineKeyboardButtonTypeBuy
    | inlineKeyboardButtonTypeUser
    | inlineKeyboardButtonTypeCopyText

  /** Describes the type of inline keyboard button */
  declare export type InlineKeyboardButtonType$Input =
    | inlineKeyboardButtonTypeUrl$Input
    | inlineKeyboardButtonTypeLoginUrl$Input
    | inlineKeyboardButtonTypeWebApp$Input
    | inlineKeyboardButtonTypeCallback$Input
    | inlineKeyboardButtonTypeCallbackWithPassword$Input
    | inlineKeyboardButtonTypeCallbackGame$Input
    | inlineKeyboardButtonTypeSwitchInline$Input
    | inlineKeyboardButtonTypeBuy$Input
    | inlineKeyboardButtonTypeUser$Input
    | inlineKeyboardButtonTypeCopyText$Input

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  declare export type ReplyMarkup =
    | replyMarkupRemoveKeyboard
    | replyMarkupForceReply
    | replyMarkupShowKeyboard
    | replyMarkupInlineKeyboard

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  declare export type ReplyMarkup$Input =
    | replyMarkupRemoveKeyboard$Input
    | replyMarkupForceReply$Input
    | replyMarkupShowKeyboard$Input
    | replyMarkupInlineKeyboard$Input

  /** Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl */
  declare export type LoginUrlInfo =
    | loginUrlInfoOpen
    | loginUrlInfoRequestConfirmation

  /** Describes mode in which a Web App is opened */
  declare export type WebAppOpenMode =
    | webAppOpenModeCompact
    | webAppOpenModeFullSize
    | webAppOpenModeFullScreen

  /** Describes mode in which a Web App is opened */
  declare export type WebAppOpenMode$Input =
    | webAppOpenModeCompact$Input
    | webAppOpenModeFullSize$Input
    | webAppOpenModeFullScreen$Input

  declare export type FoundWebApp = foundWebApp

  declare export type WebAppInfo = webAppInfo

  declare export type MainWebApp = mainWebApp

  declare export type MessageThreadInfo = messageThreadInfo

  /** Describes type of Saved Messages topic */
  declare export type SavedMessagesTopicType =
    | savedMessagesTopicTypeMyNotes
    | savedMessagesTopicTypeAuthorHidden
    | savedMessagesTopicTypeSavedFromChat

  declare export type ForumTopicInfo = forumTopicInfo

  declare export type ForumTopic = forumTopic

  declare export type ForumTopics = forumTopics

  /** Describes a formatted text object */
  declare export type RichText =
    | richTextPlain
    | richTextBold
    | richTextItalic
    | richTextUnderline
    | richTextStrikethrough
    | richTextFixed
    | richTextUrl
    | richTextEmailAddress
    | richTextSubscript
    | richTextSuperscript
    | richTextMarked
    | richTextPhoneNumber
    | richTextIcon
    | richTextReference
    | richTextAnchor
    | richTextAnchorLink
    | richTexts

  /** Describes a horizontal alignment of a table cell content */
  declare export type PageBlockHorizontalAlignment =
    | pageBlockHorizontalAlignmentLeft
    | pageBlockHorizontalAlignmentCenter
    | pageBlockHorizontalAlignmentRight

  /** Describes a Vertical alignment of a table cell content */
  declare export type PageBlockVerticalAlignment =
    | pageBlockVerticalAlignmentTop
    | pageBlockVerticalAlignmentMiddle
    | pageBlockVerticalAlignmentBottom

  /** Describes a block of an instant view for a web page */
  declare export type PageBlock =
    | pageBlockTitle
    | pageBlockSubtitle
    | pageBlockAuthorDate
    | pageBlockHeader
    | pageBlockSubheader
    | pageBlockKicker
    | pageBlockParagraph
    | pageBlockPreformatted
    | pageBlockFooter
    | pageBlockDivider
    | pageBlockAnchor
    | pageBlockList
    | pageBlockBlockQuote
    | pageBlockPullQuote
    | pageBlockAnimation
    | pageBlockAudio
    | pageBlockPhoto
    | pageBlockVideo
    | pageBlockVoiceNote
    | pageBlockCover
    | pageBlockEmbedded
    | pageBlockEmbeddedPost
    | pageBlockCollage
    | pageBlockSlideshow
    | pageBlockChatLink
    | pageBlockTable
    | pageBlockDetails
    | pageBlockRelatedArticles
    | pageBlockMap

  declare export type WebPageInstantView = webPageInstantView

  /** Describes a media from a link preview album */
  declare export type LinkPreviewAlbumMedia =
    | linkPreviewAlbumMediaPhoto
    | linkPreviewAlbumMediaVideo

  /** Describes type of link preview */
  declare export type LinkPreviewType =
    | linkPreviewTypeAlbum
    | linkPreviewTypeAnimation
    | linkPreviewTypeApp
    | linkPreviewTypeArticle
    | linkPreviewTypeAudio
    | linkPreviewTypeBackground
    | linkPreviewTypeChannelBoost
    | linkPreviewTypeChat
    | linkPreviewTypeDocument
    | linkPreviewTypeEmbeddedAnimationPlayer
    | linkPreviewTypeEmbeddedAudioPlayer
    | linkPreviewTypeEmbeddedVideoPlayer
    | linkPreviewTypeExternalAudio
    | linkPreviewTypeExternalVideo
    | linkPreviewTypeInvoice
    | linkPreviewTypeMessage
    | linkPreviewTypePhoto
    | linkPreviewTypePremiumGiftCode
    | linkPreviewTypeShareableChatFolder
    | linkPreviewTypeSticker
    | linkPreviewTypeStickerSet
    | linkPreviewTypeStory
    | linkPreviewTypeSupergroupBoost
    | linkPreviewTypeTheme
    | linkPreviewTypeUnsupported
    | linkPreviewTypeUpgradedGift
    | linkPreviewTypeUser
    | linkPreviewTypeVideo
    | linkPreviewTypeVideoChat
    | linkPreviewTypeVideoNote
    | linkPreviewTypeVoiceNote
    | linkPreviewTypeWebApp

  declare export type LinkPreview = linkPreview

  declare export type Countries = countries

  declare export type PhoneNumberInfo = phoneNumberInfo

  /** Describes a collectible item that can be purchased at https://fragment.com */
  declare export type CollectibleItemType$Input =
    | collectibleItemTypeUsername$Input
    | collectibleItemTypePhoneNumber$Input

  declare export type CollectibleItemInfo = collectibleItemInfo

  declare export type BankCardInfo = bankCardInfo

  declare export type OrderInfo = orderInfo

  /** Contains information about the payment method chosen by the user */
  declare export type InputCredentials$Input =
    | inputCredentialsSaved$Input
    | inputCredentialsNew$Input
    | inputCredentialsApplePay$Input
    | inputCredentialsGooglePay$Input

  /** Contains information about a payment provider */
  declare export type PaymentProvider =
    | paymentProviderSmartGlocal
    | paymentProviderStripe
    | paymentProviderOther

  /** Describes type of payment form */
  declare export type PaymentFormType =
    | paymentFormTypeRegular
    | paymentFormTypeStars
    | paymentFormTypeStarSubscription

  declare export type PaymentForm = paymentForm

  declare export type ValidatedOrderInfo = validatedOrderInfo

  declare export type PaymentResult = paymentResult

  /** Describes type of successful payment */
  declare export type PaymentReceiptType =
    | paymentReceiptTypeRegular
    | paymentReceiptTypeStars

  declare export type PaymentReceipt = paymentReceipt

  /** Describes an invoice to process */
  declare export type InputInvoice$Input =
    | inputInvoiceMessage$Input
    | inputInvoiceName$Input
    | inputInvoiceTelegram$Input

  /** Describes a paid media */
  declare export type PaidMedia =
    | paidMediaPreview
    | paidMediaPhoto
    | paidMediaVideo
    | paidMediaUnsupported

  /** Contains the type of Telegram Passport element */
  declare export type PassportElementType =
    | passportElementTypePersonalDetails
    | passportElementTypePassport
    | passportElementTypeDriverLicense
    | passportElementTypeIdentityCard
    | passportElementTypeInternalPassport
    | passportElementTypeAddress
    | passportElementTypeUtilityBill
    | passportElementTypeBankStatement
    | passportElementTypeRentalAgreement
    | passportElementTypePassportRegistration
    | passportElementTypeTemporaryRegistration
    | passportElementTypePhoneNumber
    | passportElementTypeEmailAddress

  /** Contains the type of Telegram Passport element */
  declare export type PassportElementType$Input =
    | passportElementTypePersonalDetails$Input
    | passportElementTypePassport$Input
    | passportElementTypeDriverLicense$Input
    | passportElementTypeIdentityCard$Input
    | passportElementTypeInternalPassport$Input
    | passportElementTypeAddress$Input
    | passportElementTypeUtilityBill$Input
    | passportElementTypeBankStatement$Input
    | passportElementTypeRentalAgreement$Input
    | passportElementTypePassportRegistration$Input
    | passportElementTypeTemporaryRegistration$Input
    | passportElementTypePhoneNumber$Input
    | passportElementTypeEmailAddress$Input

  /** Contains information about a Telegram Passport element */
  declare export type PassportElement =
    | passportElementPersonalDetails
    | passportElementPassport
    | passportElementDriverLicense
    | passportElementIdentityCard
    | passportElementInternalPassport
    | passportElementAddress
    | passportElementUtilityBill
    | passportElementBankStatement
    | passportElementRentalAgreement
    | passportElementPassportRegistration
    | passportElementTemporaryRegistration
    | passportElementPhoneNumber
    | passportElementEmailAddress

  /** Contains information about a Telegram Passport element to be saved */
  declare export type InputPassportElement$Input =
    | inputPassportElementPersonalDetails$Input
    | inputPassportElementPassport$Input
    | inputPassportElementDriverLicense$Input
    | inputPassportElementIdentityCard$Input
    | inputPassportElementInternalPassport$Input
    | inputPassportElementAddress$Input
    | inputPassportElementUtilityBill$Input
    | inputPassportElementBankStatement$Input
    | inputPassportElementRentalAgreement$Input
    | inputPassportElementPassportRegistration$Input
    | inputPassportElementTemporaryRegistration$Input
    | inputPassportElementPhoneNumber$Input
    | inputPassportElementEmailAddress$Input

  declare export type PassportElements = passportElements

  /** Contains the description of an error in a Telegram Passport element */
  declare export type PassportElementErrorSource =
    | passportElementErrorSourceUnspecified
    | passportElementErrorSourceDataField
    | passportElementErrorSourceFrontSide
    | passportElementErrorSourceReverseSide
    | passportElementErrorSourceSelfie
    | passportElementErrorSourceTranslationFile
    | passportElementErrorSourceTranslationFiles
    | passportElementErrorSourceFile
    | passportElementErrorSourceFiles

  declare export type PassportAuthorizationForm = passportAuthorizationForm

  declare export type PassportElementsWithErrors = passportElementsWithErrors

  /**
   * Contains the description of an error in a Telegram Passport element; for bots
   * only
   */
  declare export type InputPassportElementErrorSource$Input =
    | inputPassportElementErrorSourceUnspecified$Input
    | inputPassportElementErrorSourceDataField$Input
    | inputPassportElementErrorSourceFrontSide$Input
    | inputPassportElementErrorSourceReverseSide$Input
    | inputPassportElementErrorSourceSelfie$Input
    | inputPassportElementErrorSourceTranslationFile$Input
    | inputPassportElementErrorSourceTranslationFiles$Input
    | inputPassportElementErrorSourceFile$Input
    | inputPassportElementErrorSourceFiles$Input

  /** Contains the content of a message */
  declare export type MessageContent =
    | messageText
    | messageAnimation
    | messageAudio
    | messageDocument
    | messagePaidMedia
    | messagePhoto
    | messageSticker
    | messageVideo
    | messageVideoNote
    | messageVoiceNote
    | messageExpiredPhoto
    | messageExpiredVideo
    | messageExpiredVideoNote
    | messageExpiredVoiceNote
    | messageLocation
    | messageVenue
    | messageContact
    | messageAnimatedEmoji
    | messageDice
    | messageGame
    | messagePoll
    | messageStory
    | messageInvoice
    | messageCall
    | messageVideoChatScheduled
    | messageVideoChatStarted
    | messageVideoChatEnded
    | messageInviteVideoChatParticipants
    | messageBasicGroupChatCreate
    | messageSupergroupChatCreate
    | messageChatChangeTitle
    | messageChatChangePhoto
    | messageChatDeletePhoto
    | messageChatAddMembers
    | messageChatJoinByLink
    | messageChatJoinByRequest
    | messageChatDeleteMember
    | messageChatUpgradeTo
    | messageChatUpgradeFrom
    | messagePinMessage
    | messageScreenshotTaken
    | messageChatSetBackground
    | messageChatSetTheme
    | messageChatSetMessageAutoDeleteTime
    | messageChatBoost
    | messageForumTopicCreated
    | messageForumTopicEdited
    | messageForumTopicIsClosedToggled
    | messageForumTopicIsHiddenToggled
    | messageSuggestProfilePhoto
    | messageCustomServiceAction
    | messageGameScore
    | messagePaymentSuccessful
    | messagePaymentSuccessfulBot
    | messagePaymentRefunded
    | messageGiftedPremium
    | messagePremiumGiftCode
    | messageGiveawayCreated
    | messageGiveaway
    | messageGiveawayCompleted
    | messageGiveawayWinners
    | messageGiftedStars
    | messageGiveawayPrizeStars
    | messageGift
    | messageUpgradedGift
    | messageRefundedUpgradedGift
    | messageContactRegistered
    | messageUsersShared
    | messageChatShared
    | messageBotWriteAccessAllowed
    | messageWebAppDataSent
    | messageWebAppDataReceived
    | messagePassportDataSent
    | messagePassportDataReceived
    | messageProximityAlertTriggered
    | messageUnsupported

  /** Represents a part of the text which must be formatted differently */
  declare export type TextEntityType =
    | textEntityTypeMention
    | textEntityTypeHashtag
    | textEntityTypeCashtag
    | textEntityTypeBotCommand
    | textEntityTypeUrl
    | textEntityTypeEmailAddress
    | textEntityTypePhoneNumber
    | textEntityTypeBankCardNumber
    | textEntityTypeBold
    | textEntityTypeItalic
    | textEntityTypeUnderline
    | textEntityTypeStrikethrough
    | textEntityTypeSpoiler
    | textEntityTypeCode
    | textEntityTypePre
    | textEntityTypePreCode
    | textEntityTypeBlockQuote
    | textEntityTypeExpandableBlockQuote
    | textEntityTypeTextUrl
    | textEntityTypeMentionName
    | textEntityTypeCustomEmoji
    | textEntityTypeMediaTimestamp

  /** Represents a part of the text which must be formatted differently */
  declare export type TextEntityType$Input =
    | textEntityTypeMention$Input
    | textEntityTypeHashtag$Input
    | textEntityTypeCashtag$Input
    | textEntityTypeBotCommand$Input
    | textEntityTypeUrl$Input
    | textEntityTypeEmailAddress$Input
    | textEntityTypePhoneNumber$Input
    | textEntityTypeBankCardNumber$Input
    | textEntityTypeBold$Input
    | textEntityTypeItalic$Input
    | textEntityTypeUnderline$Input
    | textEntityTypeStrikethrough$Input
    | textEntityTypeSpoiler$Input
    | textEntityTypeCode$Input
    | textEntityTypePre$Input
    | textEntityTypePreCode$Input
    | textEntityTypeBlockQuote$Input
    | textEntityTypeExpandableBlockQuote$Input
    | textEntityTypeTextUrl$Input
    | textEntityTypeMentionName$Input
    | textEntityTypeCustomEmoji$Input
    | textEntityTypeMediaTimestamp$Input

  /** Describes type of paid media to sent */
  declare export type InputPaidMediaType =
    | inputPaidMediaTypePhoto
    | inputPaidMediaTypeVideo

  /** Describes type of paid media to sent */
  declare export type InputPaidMediaType$Input =
    | inputPaidMediaTypePhoto$Input
    | inputPaidMediaTypeVideo$Input

  /** Contains information about the time when a scheduled message will be sent */
  declare export type MessageSchedulingState =
    | messageSchedulingStateSendAtDate
    | messageSchedulingStateSendWhenOnline
    | messageSchedulingStateSendWhenVideoProcessed

  /** Contains information about the time when a scheduled message will be sent */
  declare export type MessageSchedulingState$Input =
    | messageSchedulingStateSendAtDate$Input
    | messageSchedulingStateSendWhenOnline$Input
    | messageSchedulingStateSendWhenVideoProcessed$Input

  /** Describes when a message will be self-destructed */
  declare export type MessageSelfDestructType =
    | messageSelfDestructTypeTimer
    | messageSelfDestructTypeImmediately

  /** Describes when a message will be self-destructed */
  declare export type MessageSelfDestructType$Input =
    | messageSelfDestructTypeTimer$Input
    | messageSelfDestructTypeImmediately$Input

  /** The content of a message to send */
  declare export type InputMessageContent =
    | inputMessageText
    | inputMessageAnimation
    | inputMessageAudio
    | inputMessageDocument
    | inputMessagePaidMedia
    | inputMessagePhoto
    | inputMessageSticker
    | inputMessageVideo
    | inputMessageVideoNote
    | inputMessageVoiceNote
    | inputMessageLocation
    | inputMessageVenue
    | inputMessageContact
    | inputMessageDice
    | inputMessageGame
    | inputMessageInvoice
    | inputMessagePoll
    | inputMessageStory
    | inputMessageForwarded

  /** The content of a message to send */
  declare export type InputMessageContent$Input =
    | inputMessageText$Input
    | inputMessageAnimation$Input
    | inputMessageAudio$Input
    | inputMessageDocument$Input
    | inputMessagePaidMedia$Input
    | inputMessagePhoto$Input
    | inputMessageSticker$Input
    | inputMessageVideo$Input
    | inputMessageVideoNote$Input
    | inputMessageVoiceNote$Input
    | inputMessageLocation$Input
    | inputMessageVenue$Input
    | inputMessageContact$Input
    | inputMessageDice$Input
    | inputMessageGame$Input
    | inputMessageInvoice$Input
    | inputMessagePoll$Input
    | inputMessageStory$Input
    | inputMessageForwarded$Input

  declare export type MessageProperties = messageProperties

  /** Represents a filter for message search results */
  declare export type SearchMessagesFilter$Input =
    | searchMessagesFilterEmpty$Input
    | searchMessagesFilterAnimation$Input
    | searchMessagesFilterAudio$Input
    | searchMessagesFilterDocument$Input
    | searchMessagesFilterPhoto$Input
    | searchMessagesFilterVideo$Input
    | searchMessagesFilterVoiceNote$Input
    | searchMessagesFilterPhotoAndVideo$Input
    | searchMessagesFilterUrl$Input
    | searchMessagesFilterChatPhoto$Input
    | searchMessagesFilterVideoNote$Input
    | searchMessagesFilterVoiceAndVideoNote$Input
    | searchMessagesFilterMention$Input
    | searchMessagesFilterUnreadMention$Input
    | searchMessagesFilterUnreadReaction$Input
    | searchMessagesFilterFailedToSend$Input
    | searchMessagesFilterPinned$Input

  /** Represents a filter for type of the chats in which to search messages */
  declare export type SearchMessagesChatTypeFilter$Input =
    | searchMessagesChatTypeFilterPrivate$Input
    | searchMessagesChatTypeFilterGroup$Input
    | searchMessagesChatTypeFilterChannel$Input

  /** Describes the different types of activity in a chat */
  declare export type ChatAction =
    | chatActionTyping
    | chatActionRecordingVideo
    | chatActionUploadingVideo
    | chatActionRecordingVoiceNote
    | chatActionUploadingVoiceNote
    | chatActionUploadingPhoto
    | chatActionUploadingDocument
    | chatActionChoosingSticker
    | chatActionChoosingLocation
    | chatActionChoosingContact
    | chatActionStartPlayingGame
    | chatActionRecordingVideoNote
    | chatActionUploadingVideoNote
    | chatActionWatchingAnimations
    | chatActionCancel

  /** Describes the different types of activity in a chat */
  declare export type ChatAction$Input =
    | chatActionTyping$Input
    | chatActionRecordingVideo$Input
    | chatActionUploadingVideo$Input
    | chatActionRecordingVoiceNote$Input
    | chatActionUploadingVoiceNote$Input
    | chatActionUploadingPhoto$Input
    | chatActionUploadingDocument$Input
    | chatActionChoosingSticker$Input
    | chatActionChoosingLocation$Input
    | chatActionChoosingContact$Input
    | chatActionStartPlayingGame$Input
    | chatActionRecordingVideoNote$Input
    | chatActionUploadingVideoNote$Input
    | chatActionWatchingAnimations$Input
    | chatActionCancel$Input

  /** Describes the last time the user was online */
  declare export type UserStatus =
    | userStatusEmpty
    | userStatusOnline
    | userStatusOffline
    | userStatusRecently
    | userStatusLastWeek
    | userStatusLastMonth

  declare export type EmojiKeywords = emojiKeywords

  declare export type Stickers = stickers

  declare export type Emojis = emojis

  declare export type StickerSet = stickerSet

  declare export type StickerSets = stickerSets

  declare export type TrendingStickerSets = trendingStickerSets

  /** Describes source of stickers for an emoji category */
  declare export type EmojiCategorySource =
    | emojiCategorySourceSearch
    | emojiCategorySourcePremium

  declare export type EmojiCategories = emojiCategories

  /** Describes type of emoji category */
  declare export type EmojiCategoryType$Input =
    | emojiCategoryTypeDefault$Input
    | emojiCategoryTypeRegularStickers$Input
    | emojiCategoryTypeEmojiStatus$Input
    | emojiCategoryTypeChatPhoto$Input

  declare export type CurrentWeather = currentWeather

  /** Describes type of clickable area on a story media */
  declare export type StoryAreaType =
    | storyAreaTypeLocation
    | storyAreaTypeVenue
    | storyAreaTypeSuggestedReaction
    | storyAreaTypeMessage
    | storyAreaTypeLink
    | storyAreaTypeWeather
    | storyAreaTypeUpgradedGift

  /** Describes type of clickable area on a story media to be added */
  declare export type InputStoryAreaType$Input =
    | inputStoryAreaTypeLocation$Input
    | inputStoryAreaTypeFoundVenue$Input
    | inputStoryAreaTypePreviousVenue$Input
    | inputStoryAreaTypeSuggestedReaction$Input
    | inputStoryAreaTypeMessage$Input
    | inputStoryAreaTypeLink$Input
    | inputStoryAreaTypeWeather$Input
    | inputStoryAreaTypeUpgradedGift$Input

  /** Contains the content of a story */
  declare export type StoryContent =
    | storyContentPhoto
    | storyContentVideo
    | storyContentUnsupported

  /** The content of a story to send */
  declare export type InputStoryContent$Input =
    | inputStoryContentPhoto$Input
    | inputStoryContentVideo$Input

  /** Describes a list of stories */
  declare export type StoryList =
    | storyListMain
    | storyListArchive

  /** Describes a list of stories */
  declare export type StoryList$Input =
    | storyListMain$Input
    | storyListArchive$Input

  /** Contains information about the origin of a story that was reposted */
  declare export type StoryOrigin =
    | storyOriginPublicStory
    | storyOriginHiddenUser

  declare export type Story = story

  declare export type Stories = stories

  declare export type FoundStories = foundStories

  declare export type ChatActiveStories = chatActiveStories

  /** Describes type of interaction with a story */
  declare export type StoryInteractionType =
    | storyInteractionTypeView
    | storyInteractionTypeForward
    | storyInteractionTypeRepost

  declare export type StoryInteractions = storyInteractions

  declare export type QuickReplyMessage = quickReplyMessage

  declare export type QuickReplyMessages = quickReplyMessages

  /** Describes a public forward or repost of a story */
  declare export type PublicForward =
    | publicForwardMessage
    | publicForwardStory

  declare export type PublicForwards = publicForwards

  declare export type BotMediaPreview = botMediaPreview

  declare export type BotMediaPreviews = botMediaPreviews

  declare export type BotMediaPreviewInfo = botMediaPreviewInfo

  declare export type ChatBoostLevelFeatures = chatBoostLevelFeatures

  declare export type ChatBoostFeatures = chatBoostFeatures

  /** Describes source of a chat boost */
  declare export type ChatBoostSource =
    | chatBoostSourceGiftCode
    | chatBoostSourceGiveaway
    | chatBoostSourcePremium

  declare export type ChatBoostStatus = chatBoostStatus

  declare export type FoundChatBoosts = foundChatBoosts

  declare export type ChatBoostSlots = chatBoostSlots

  /** Describes the reason why a code needs to be re-sent */
  declare export type ResendCodeReason$Input =
    | resendCodeReasonUserRequest$Input
    | resendCodeReasonVerificationFailed$Input

  /** Describes the reason why a call was discarded */
  declare export type CallDiscardReason =
    | callDiscardReasonEmpty
    | callDiscardReasonMissed
    | callDiscardReasonDeclined
    | callDiscardReasonDisconnected
    | callDiscardReasonHungUp
    | callDiscardReasonAllowGroupCall

  /** Describes the type of call server */
  declare export type CallServerType =
    | callServerTypeTelegramReflector
    | callServerTypeWebrtc

  declare export type CallId = callId

  declare export type GroupCallId = groupCallId

  /** Describes the current call state */
  declare export type CallState =
    | callStatePending
    | callStateExchangingKeys
    | callStateReady
    | callStateHangingUp
    | callStateDiscarded
    | callStateError

  /** Describes the quality of a group call video */
  declare export type GroupCallVideoQuality$Input =
    | groupCallVideoQualityThumbnail$Input
    | groupCallVideoQualityMedium$Input
    | groupCallVideoQualityFull$Input

  declare export type GroupCallStreams = groupCallStreams

  declare export type RtmpUrl = rtmpUrl

  declare export type GroupCall = groupCall

  /** Describes the exact type of problem with a call */
  declare export type CallProblem$Input =
    | callProblemEcho$Input
    | callProblemNoise$Input
    | callProblemInterruptions$Input
    | callProblemDistortedSpeech$Input
    | callProblemSilentLocal$Input
    | callProblemSilentRemote$Input
    | callProblemDropped$Input
    | callProblemDistortedVideo$Input
    | callProblemPixelatedVideo$Input

  /** Contains settings for Firebase Authentication in the official applications */
  declare export type FirebaseAuthenticationSettings$Input =
    | firebaseAuthenticationSettingsAndroid$Input
    | firebaseAuthenticationSettingsIos$Input

  declare export type AddedReactions = addedReactions

  declare export type AvailableReactions = availableReactions

  declare export type EmojiReaction = emojiReaction

  /**
   * Describes why the current user can't add reactions to the message, despite some
   * other users can
   */
  declare export type ReactionUnavailabilityReason =
    | reactionUnavailabilityReasonAnonymousAdministrator
    | reactionUnavailabilityReasonGuest

  declare export type Animations = animations

  /** Contains animated stickers which must be used for dice animation rendering */
  declare export type DiceStickers =
    | diceStickersRegular
    | diceStickersSlotMachine

  declare export type ImportedContacts = importedContacts

  /** Describes result of speech recognition in a voice note */
  declare export type SpeechRecognitionResult =
    | speechRecognitionResultPending
    | speechRecognitionResultText
    | speechRecognitionResultError

  declare export type BusinessConnection = businessConnection

  declare export type AttachmentMenuBot = attachmentMenuBot

  declare export type SentWebAppMessage = sentWebAppMessage

  /** Describes a reason why a bot was allowed to write messages to the current user */
  declare export type BotWriteAccessAllowReason =
    | botWriteAccessAllowReasonConnectedWebsite
    | botWriteAccessAllowReasonAddedToAttachmentMenu
    | botWriteAccessAllowReasonLaunchedWebApp
    | botWriteAccessAllowReasonAcceptedRequest

  declare export type HttpUrl = httpUrl

  declare export type UserLink = userLink

  /** Describes the target chat to be opened */
  declare export type TargetChat =
    | targetChatCurrent
    | targetChatChosen
    | targetChatInternalLink

  /** Describes the target chat to be opened */
  declare export type TargetChat$Input =
    | targetChatCurrent$Input
    | targetChatChosen$Input
    | targetChatInternalLink$Input

  /** Represents a single result of an inline query; for bots only */
  declare export type InputInlineQueryResult$Input =
    | inputInlineQueryResultAnimation$Input
    | inputInlineQueryResultArticle$Input
    | inputInlineQueryResultAudio$Input
    | inputInlineQueryResultContact$Input
    | inputInlineQueryResultDocument$Input
    | inputInlineQueryResultGame$Input
    | inputInlineQueryResultLocation$Input
    | inputInlineQueryResultPhoto$Input
    | inputInlineQueryResultSticker$Input
    | inputInlineQueryResultVenue$Input
    | inputInlineQueryResultVideo$Input
    | inputInlineQueryResultVoiceNote$Input

  /** Represents a single result of an inline query */
  declare export type InlineQueryResult =
    | inlineQueryResultArticle
    | inlineQueryResultContact
    | inlineQueryResultLocation
    | inlineQueryResultVenue
    | inlineQueryResultGame
    | inlineQueryResultAnimation
    | inlineQueryResultAudio
    | inlineQueryResultDocument
    | inlineQueryResultPhoto
    | inlineQueryResultSticker
    | inlineQueryResultVideo
    | inlineQueryResultVoiceNote

  /** Represents type of button in results of inline query */
  declare export type InlineQueryResultsButtonType =
    | inlineQueryResultsButtonTypeStartBot
    | inlineQueryResultsButtonTypeWebApp

  /** Represents type of button in results of inline query */
  declare export type InlineQueryResultsButtonType$Input =
    | inlineQueryResultsButtonTypeStartBot$Input
    | inlineQueryResultsButtonTypeWebApp$Input

  declare export type InlineQueryResults = inlineQueryResults

  declare export type PreparedInlineMessageId = preparedInlineMessageId

  declare export type PreparedInlineMessage = preparedInlineMessage

  /** Represents a payload of a callback query */
  declare export type CallbackQueryPayload =
    | callbackQueryPayloadData
    | callbackQueryPayloadDataWithPassword
    | callbackQueryPayloadGame

  /** Represents a payload of a callback query */
  declare export type CallbackQueryPayload$Input =
    | callbackQueryPayloadData$Input
    | callbackQueryPayloadDataWithPassword$Input
    | callbackQueryPayloadGame$Input

  declare export type CallbackQueryAnswer = callbackQueryAnswer

  declare export type CustomRequestResult = customRequestResult

  declare export type GameHighScores = gameHighScores

  /** Represents a chat event */
  declare export type ChatEventAction =
    | chatEventMessageEdited
    | chatEventMessageDeleted
    | chatEventMessagePinned
    | chatEventMessageUnpinned
    | chatEventPollStopped
    | chatEventMemberJoined
    | chatEventMemberJoinedByInviteLink
    | chatEventMemberJoinedByRequest
    | chatEventMemberInvited
    | chatEventMemberLeft
    | chatEventMemberPromoted
    | chatEventMemberRestricted
    | chatEventMemberSubscriptionExtended
    | chatEventAvailableReactionsChanged
    | chatEventBackgroundChanged
    | chatEventDescriptionChanged
    | chatEventEmojiStatusChanged
    | chatEventLinkedChatChanged
    | chatEventLocationChanged
    | chatEventMessageAutoDeleteTimeChanged
    | chatEventPermissionsChanged
    | chatEventPhotoChanged
    | chatEventSlowModeDelayChanged
    | chatEventStickerSetChanged
    | chatEventCustomEmojiStickerSetChanged
    | chatEventTitleChanged
    | chatEventUsernameChanged
    | chatEventActiveUsernamesChanged
    | chatEventAccentColorChanged
    | chatEventProfileAccentColorChanged
    | chatEventHasProtectedContentToggled
    | chatEventInvitesToggled
    | chatEventIsAllHistoryAvailableToggled
    | chatEventHasAggressiveAntiSpamEnabledToggled
    | chatEventSignMessagesToggled
    | chatEventShowMessageSenderToggled
    | chatEventInviteLinkEdited
    | chatEventInviteLinkRevoked
    | chatEventInviteLinkDeleted
    | chatEventVideoChatCreated
    | chatEventVideoChatEnded
    | chatEventVideoChatMuteNewParticipantsToggled
    | chatEventVideoChatParticipantIsMutedToggled
    | chatEventVideoChatParticipantVolumeLevelChanged
    | chatEventIsForumToggled
    | chatEventForumTopicCreated
    | chatEventForumTopicEdited
    | chatEventForumTopicToggleIsClosed
    | chatEventForumTopicToggleIsHidden
    | chatEventForumTopicDeleted
    | chatEventForumTopicPinned

  declare export type ChatEvents = chatEvents

  /** Represents the value of a string in a language pack */
  declare export type LanguagePackStringValue =
    | languagePackStringValueOrdinary
    | languagePackStringValuePluralized
    | languagePackStringValueDeleted

  /** Represents the value of a string in a language pack */
  declare export type LanguagePackStringValue$Input =
    | languagePackStringValueOrdinary$Input
    | languagePackStringValuePluralized$Input
    | languagePackStringValueDeleted$Input

  declare export type LanguagePackStrings = languagePackStrings

  declare export type LanguagePackInfo = languagePackInfo

  declare export type LocalizationTargetInfo = localizationTargetInfo

  /** Describes type of limit, increased for Premium users */
  declare export type PremiumLimitType =
    | premiumLimitTypeSupergroupCount
    | premiumLimitTypePinnedChatCount
    | premiumLimitTypeCreatedPublicChatCount
    | premiumLimitTypeSavedAnimationCount
    | premiumLimitTypeFavoriteStickerCount
    | premiumLimitTypeChatFolderCount
    | premiumLimitTypeChatFolderChosenChatCount
    | premiumLimitTypePinnedArchivedChatCount
    | premiumLimitTypePinnedSavedMessagesTopicCount
    | premiumLimitTypeCaptionLength
    | premiumLimitTypeBioLength
    | premiumLimitTypeChatFolderInviteLinkCount
    | premiumLimitTypeShareableChatFolderCount
    | premiumLimitTypeActiveStoryCount
    | premiumLimitTypeWeeklySentStoryCount
    | premiumLimitTypeMonthlySentStoryCount
    | premiumLimitTypeStoryCaptionLength
    | premiumLimitTypeStorySuggestedReactionAreaCount
    | premiumLimitTypeSimilarChatCount

  /** Describes type of limit, increased for Premium users */
  declare export type PremiumLimitType$Input =
    | premiumLimitTypeSupergroupCount$Input
    | premiumLimitTypePinnedChatCount$Input
    | premiumLimitTypeCreatedPublicChatCount$Input
    | premiumLimitTypeSavedAnimationCount$Input
    | premiumLimitTypeFavoriteStickerCount$Input
    | premiumLimitTypeChatFolderCount$Input
    | premiumLimitTypeChatFolderChosenChatCount$Input
    | premiumLimitTypePinnedArchivedChatCount$Input
    | premiumLimitTypePinnedSavedMessagesTopicCount$Input
    | premiumLimitTypeCaptionLength$Input
    | premiumLimitTypeBioLength$Input
    | premiumLimitTypeChatFolderInviteLinkCount$Input
    | premiumLimitTypeShareableChatFolderCount$Input
    | premiumLimitTypeActiveStoryCount$Input
    | premiumLimitTypeWeeklySentStoryCount$Input
    | premiumLimitTypeMonthlySentStoryCount$Input
    | premiumLimitTypeStoryCaptionLength$Input
    | premiumLimitTypeStorySuggestedReactionAreaCount$Input
    | premiumLimitTypeSimilarChatCount$Input

  /** Describes a feature available to Premium users */
  declare export type PremiumFeature =
    | premiumFeatureIncreasedLimits
    | premiumFeatureIncreasedUploadFileSize
    | premiumFeatureImprovedDownloadSpeed
    | premiumFeatureVoiceRecognition
    | premiumFeatureDisabledAds
    | premiumFeatureUniqueReactions
    | premiumFeatureUniqueStickers
    | premiumFeatureCustomEmoji
    | premiumFeatureAdvancedChatManagement
    | premiumFeatureProfileBadge
    | premiumFeatureEmojiStatus
    | premiumFeatureAnimatedProfilePhoto
    | premiumFeatureForumTopicIcon
    | premiumFeatureAppIcons
    | premiumFeatureRealTimeChatTranslation
    | premiumFeatureUpgradedStories
    | premiumFeatureChatBoost
    | premiumFeatureAccentColor
    | premiumFeatureBackgroundForBoth
    | premiumFeatureSavedMessagesTags
    | premiumFeatureMessagePrivacy
    | premiumFeatureLastSeenTimes
    | premiumFeatureBusiness
    | premiumFeatureMessageEffects

  /** Describes a feature available to Premium users */
  declare export type PremiumFeature$Input =
    | premiumFeatureIncreasedLimits$Input
    | premiumFeatureIncreasedUploadFileSize$Input
    | premiumFeatureImprovedDownloadSpeed$Input
    | premiumFeatureVoiceRecognition$Input
    | premiumFeatureDisabledAds$Input
    | premiumFeatureUniqueReactions$Input
    | premiumFeatureUniqueStickers$Input
    | premiumFeatureCustomEmoji$Input
    | premiumFeatureAdvancedChatManagement$Input
    | premiumFeatureProfileBadge$Input
    | premiumFeatureEmojiStatus$Input
    | premiumFeatureAnimatedProfilePhoto$Input
    | premiumFeatureForumTopicIcon$Input
    | premiumFeatureAppIcons$Input
    | premiumFeatureRealTimeChatTranslation$Input
    | premiumFeatureUpgradedStories$Input
    | premiumFeatureChatBoost$Input
    | premiumFeatureAccentColor$Input
    | premiumFeatureBackgroundForBoth$Input
    | premiumFeatureSavedMessagesTags$Input
    | premiumFeatureMessagePrivacy$Input
    | premiumFeatureLastSeenTimes$Input
    | premiumFeatureBusiness$Input
    | premiumFeatureMessageEffects$Input

  /** Describes a feature available to Business user accounts */
  declare export type BusinessFeature =
    | businessFeatureLocation
    | businessFeatureOpeningHours
    | businessFeatureQuickReplies
    | businessFeatureGreetingMessage
    | businessFeatureAwayMessage
    | businessFeatureAccountLinks
    | businessFeatureStartPage
    | businessFeatureBots
    | businessFeatureEmojiStatus
    | businessFeatureChatFolderTags
    | businessFeatureUpgradedStories

  /** Describes a feature available to Business user accounts */
  declare export type BusinessFeature$Input =
    | businessFeatureLocation$Input
    | businessFeatureOpeningHours$Input
    | businessFeatureQuickReplies$Input
    | businessFeatureGreetingMessage$Input
    | businessFeatureAwayMessage$Input
    | businessFeatureAccountLinks$Input
    | businessFeatureStartPage$Input
    | businessFeatureBots$Input
    | businessFeatureEmojiStatus$Input
    | businessFeatureChatFolderTags$Input
    | businessFeatureUpgradedStories$Input

  /** Describes a story feature available to Premium users */
  declare export type PremiumStoryFeature$Input =
    | premiumStoryFeaturePriorityOrder$Input
    | premiumStoryFeatureStealthMode$Input
    | premiumStoryFeaturePermanentViewsHistory$Input
    | premiumStoryFeatureCustomExpirationDuration$Input
    | premiumStoryFeatureSaveStories$Input
    | premiumStoryFeatureLinksAndFormatting$Input
    | premiumStoryFeatureVideoQuality$Input

  declare export type PremiumLimit = premiumLimit

  declare export type PremiumFeatures = premiumFeatures

  declare export type BusinessFeatures = businessFeatures

  /** Describes a source from which the Premium features screen is opened */
  declare export type PremiumSource$Input =
    | premiumSourceLimitExceeded$Input
    | premiumSourceFeature$Input
    | premiumSourceBusinessFeature$Input
    | premiumSourceStoryFeature$Input
    | premiumSourceLink$Input
    | premiumSourceSettings$Input

  declare export type PremiumState = premiumState

  /** Describes a purpose of an in-store payment */
  declare export type StorePaymentPurpose$Input =
    | storePaymentPurposePremiumSubscription$Input
    | storePaymentPurposePremiumGift$Input
    | storePaymentPurposePremiumGiftCodes$Input
    | storePaymentPurposePremiumGiveaway$Input
    | storePaymentPurposeStarGiveaway$Input
    | storePaymentPurposeStars$Input
    | storePaymentPurposeGiftedStars$Input

  /** Describes a purpose of a payment toward Telegram */
  declare export type TelegramPaymentPurpose$Input =
    | telegramPaymentPurposePremiumGift$Input
    | telegramPaymentPurposePremiumGiftCodes$Input
    | telegramPaymentPurposePremiumGiveaway$Input
    | telegramPaymentPurposeStars$Input
    | telegramPaymentPurposeGiftedStars$Input
    | telegramPaymentPurposeStarGiveaway$Input
    | telegramPaymentPurposeJoinChat$Input

  /**
   * Represents a data needed to subscribe for push notifications through registerDevice
   * method. To use specific push notification service, the correct application platform
   * must be specified and a valid server authentication data must be uploaded at
   * https://my.telegram.org
   */
  declare export type DeviceToken$Input =
    | deviceTokenFirebaseCloudMessaging$Input
    | deviceTokenApplePush$Input
    | deviceTokenApplePushVoIP$Input
    | deviceTokenWindowsPush$Input
    | deviceTokenMicrosoftPush$Input
    | deviceTokenMicrosoftPushVoIP$Input
    | deviceTokenWebPush$Input
    | deviceTokenSimplePush$Input
    | deviceTokenUbuntuPush$Input
    | deviceTokenBlackBerryPush$Input
    | deviceTokenTizenPush$Input
    | deviceTokenHuaweiPush$Input

  declare export type PushReceiverId = pushReceiverId

  /** Describes a fill of a background */
  declare export type BackgroundFill =
    | backgroundFillSolid
    | backgroundFillGradient
    | backgroundFillFreeformGradient

  /** Describes a fill of a background */
  declare export type BackgroundFill$Input =
    | backgroundFillSolid$Input
    | backgroundFillGradient$Input
    | backgroundFillFreeformGradient$Input

  /** Describes the type of background */
  declare export type BackgroundType =
    | backgroundTypeWallpaper
    | backgroundTypePattern
    | backgroundTypeFill
    | backgroundTypeChatTheme

  /** Describes the type of background */
  declare export type BackgroundType$Input =
    | backgroundTypeWallpaper$Input
    | backgroundTypePattern$Input
    | backgroundTypeFill$Input
    | backgroundTypeChatTheme$Input

  /** Contains information about background to set */
  declare export type InputBackground$Input =
    | inputBackgroundLocal$Input
    | inputBackgroundRemote$Input
    | inputBackgroundPrevious$Input

  declare export type TimeZones = timeZones

  declare export type Hashtags = hashtags

  /**
   * Represents result of checking whether the current user can send a story in the
   * specific chat
   */
  declare export type CanSendStoryResult =
    | canSendStoryResultOk
    | canSendStoryResultPremiumNeeded
    | canSendStoryResultBoostNeeded
    | canSendStoryResultActiveStoryLimitExceeded
    | canSendStoryResultWeeklyLimitExceeded
    | canSendStoryResultMonthlyLimitExceeded

  /**
   * Represents result of checking whether the current session can be used to transfer
   * a chat ownership to another user
   */
  declare export type CanTransferOwnershipResult =
    | canTransferOwnershipResultOk
    | canTransferOwnershipResultPasswordNeeded
    | canTransferOwnershipResultPasswordTooFresh
    | canTransferOwnershipResultSessionTooFresh

  /** Represents result of checking whether a username can be set for a chat */
  declare export type CheckChatUsernameResult =
    | checkChatUsernameResultOk
    | checkChatUsernameResultUsernameInvalid
    | checkChatUsernameResultUsernameOccupied
    | checkChatUsernameResultUsernamePurchasable
    | checkChatUsernameResultPublicChatsTooMany
    | checkChatUsernameResultPublicGroupsUnavailable

  /** Represents result of checking whether a name can be used for a new sticker set */
  declare export type CheckStickerSetNameResult =
    | checkStickerSetNameResultOk
    | checkStickerSetNameResultNameInvalid
    | checkStickerSetNameResultNameOccupied

  /** Represents result of 2-step verification password reset */
  declare export type ResetPasswordResult =
    | resetPasswordResultOk
    | resetPasswordResultPending
    | resetPasswordResultDeclined

  /** Contains information about a file with messages exported from another app */
  declare export type MessageFileType =
    | messageFileTypePrivate
    | messageFileTypeGroup
    | messageFileTypeUnknown

  /** Contains content of a push message notification */
  declare export type PushMessageContent =
    | pushMessageContentHidden
    | pushMessageContentAnimation
    | pushMessageContentAudio
    | pushMessageContentContact
    | pushMessageContentContactRegistered
    | pushMessageContentDocument
    | pushMessageContentGame
    | pushMessageContentGameScore
    | pushMessageContentInvoice
    | pushMessageContentLocation
    | pushMessageContentPaidMedia
    | pushMessageContentPhoto
    | pushMessageContentPoll
    | pushMessageContentPremiumGiftCode
    | pushMessageContentGiveaway
    | pushMessageContentGift
    | pushMessageContentUpgradedGift
    | pushMessageContentScreenshotTaken
    | pushMessageContentSticker
    | pushMessageContentStory
    | pushMessageContentText
    | pushMessageContentVideo
    | pushMessageContentVideoNote
    | pushMessageContentVoiceNote
    | pushMessageContentBasicGroupChatCreate
    | pushMessageContentVideoChatStarted
    | pushMessageContentVideoChatEnded
    | pushMessageContentInviteVideoChatParticipants
    | pushMessageContentChatAddMembers
    | pushMessageContentChatChangePhoto
    | pushMessageContentChatChangeTitle
    | pushMessageContentChatSetBackground
    | pushMessageContentChatSetTheme
    | pushMessageContentChatDeleteMember
    | pushMessageContentChatJoinByLink
    | pushMessageContentChatJoinByRequest
    | pushMessageContentRecurringPayment
    | pushMessageContentSuggestProfilePhoto
    | pushMessageContentProximityAlertTriggered
    | pushMessageContentMessageForwards
    | pushMessageContentMediaAlbum

  /** Contains detailed information about a notification */
  declare export type NotificationType =
    | notificationTypeNewMessage
    | notificationTypeNewSecretChat
    | notificationTypeNewCall
    | notificationTypeNewPushMessage

  /** Describes the type of notifications in a notification group */
  declare export type NotificationGroupType =
    | notificationGroupTypeMessages
    | notificationGroupTypeMentions
    | notificationGroupTypeSecretChat
    | notificationGroupTypeCalls

  declare export type NotificationSound = notificationSound

  declare export type NotificationSounds = notificationSounds

  /** Represents the value of an option */
  declare export type OptionValue =
    | optionValueBoolean
    | optionValueEmpty
    | optionValueInteger
    | optionValueString

  /** Represents the value of an option */
  declare export type OptionValue$Input =
    | optionValueBoolean$Input
    | optionValueEmpty$Input
    | optionValueInteger$Input
    | optionValueString$Input

  /** Represents a JSON value */
  declare export type JsonValue =
    | jsonValueNull
    | jsonValueBoolean
    | jsonValueNumber
    | jsonValueString
    | jsonValueArray
    | jsonValueObject

  /** Represents a JSON value */
  declare export type JsonValue$Input =
    | jsonValueNull$Input
    | jsonValueBoolean$Input
    | jsonValueNumber$Input
    | jsonValueString$Input
    | jsonValueArray$Input
    | jsonValueObject$Input

  /** Describes privacy settings of a story */
  declare export type StoryPrivacySettings =
    | storyPrivacySettingsEveryone
    | storyPrivacySettingsContacts
    | storyPrivacySettingsCloseFriends
    | storyPrivacySettingsSelectedUsers

  /** Describes privacy settings of a story */
  declare export type StoryPrivacySettings$Input =
    | storyPrivacySettingsEveryone$Input
    | storyPrivacySettingsContacts$Input
    | storyPrivacySettingsCloseFriends$Input
    | storyPrivacySettingsSelectedUsers$Input

  /** Represents a single rule for managing user privacy settings */
  declare export type UserPrivacySettingRule =
    | userPrivacySettingRuleAllowAll
    | userPrivacySettingRuleAllowContacts
    | userPrivacySettingRuleAllowBots
    | userPrivacySettingRuleAllowPremiumUsers
    | userPrivacySettingRuleAllowUsers
    | userPrivacySettingRuleAllowChatMembers
    | userPrivacySettingRuleRestrictAll
    | userPrivacySettingRuleRestrictContacts
    | userPrivacySettingRuleRestrictBots
    | userPrivacySettingRuleRestrictUsers
    | userPrivacySettingRuleRestrictChatMembers

  /** Represents a single rule for managing user privacy settings */
  declare export type UserPrivacySettingRule$Input =
    | userPrivacySettingRuleAllowAll$Input
    | userPrivacySettingRuleAllowContacts$Input
    | userPrivacySettingRuleAllowBots$Input
    | userPrivacySettingRuleAllowPremiumUsers$Input
    | userPrivacySettingRuleAllowUsers$Input
    | userPrivacySettingRuleAllowChatMembers$Input
    | userPrivacySettingRuleRestrictAll$Input
    | userPrivacySettingRuleRestrictContacts$Input
    | userPrivacySettingRuleRestrictBots$Input
    | userPrivacySettingRuleRestrictUsers$Input
    | userPrivacySettingRuleRestrictChatMembers$Input

  declare export type UserPrivacySettingRules = userPrivacySettingRules

  /** Describes available user privacy settings */
  declare export type UserPrivacySetting =
    | userPrivacySettingShowStatus
    | userPrivacySettingShowProfilePhoto
    | userPrivacySettingShowLinkInForwardedMessages
    | userPrivacySettingShowPhoneNumber
    | userPrivacySettingShowBio
    | userPrivacySettingShowBirthdate
    | userPrivacySettingAllowChatInvites
    | userPrivacySettingAllowCalls
    | userPrivacySettingAllowPeerToPeerCalls
    | userPrivacySettingAllowFindingByPhoneNumber
    | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
    | userPrivacySettingAutosaveGifts
    | userPrivacySettingAllowUnpaidMessages

  /** Describes available user privacy settings */
  declare export type UserPrivacySetting$Input =
    | userPrivacySettingShowStatus$Input
    | userPrivacySettingShowProfilePhoto$Input
    | userPrivacySettingShowLinkInForwardedMessages$Input
    | userPrivacySettingShowPhoneNumber$Input
    | userPrivacySettingShowBio$Input
    | userPrivacySettingShowBirthdate$Input
    | userPrivacySettingAllowChatInvites$Input
    | userPrivacySettingAllowCalls$Input
    | userPrivacySettingAllowPeerToPeerCalls$Input
    | userPrivacySettingAllowFindingByPhoneNumber$Input
    | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input
    | userPrivacySettingAutosaveGifts$Input
    | userPrivacySettingAllowUnpaidMessages$Input

  declare export type ReadDatePrivacySettings = readDatePrivacySettings

  declare export type NewChatPrivacySettings = newChatPrivacySettings

  /** Describes result of canSendMessageToUser */
  declare export type CanSendMessageToUserResult =
    | canSendMessageToUserResultOk
    | canSendMessageToUserResultUserHasPaidMessages
    | canSendMessageToUserResultUserIsDeleted
    | canSendMessageToUserResultUserRestrictsNewChats

  declare export type AccountTtl = accountTtl

  declare export type MessageAutoDeleteTime = messageAutoDeleteTime

  /** Represents the type of session */
  declare export type SessionType =
    | sessionTypeAndroid
    | sessionTypeApple
    | sessionTypeBrave
    | sessionTypeChrome
    | sessionTypeEdge
    | sessionTypeFirefox
    | sessionTypeIpad
    | sessionTypeIphone
    | sessionTypeLinux
    | sessionTypeMac
    | sessionTypeOpera
    | sessionTypeSafari
    | sessionTypeUbuntu
    | sessionTypeUnknown
    | sessionTypeVivaldi
    | sessionTypeWindows
    | sessionTypeXbox

  declare export type Session = session

  declare export type Sessions = sessions

  declare export type ConnectedWebsites = connectedWebsites

  /** Describes the reason why a chat is reported */
  declare export type ReportReason$Input =
    | reportReasonSpam$Input
    | reportReasonViolence$Input
    | reportReasonPornography$Input
    | reportReasonChildAbuse$Input
    | reportReasonCopyright$Input
    | reportReasonUnrelatedLocation$Input
    | reportReasonFake$Input
    | reportReasonIllegalDrugs$Input
    | reportReasonPersonalDetails$Input
    | reportReasonCustom$Input

  /** Describes result of chat report */
  declare export type ReportChatResult =
    | reportChatResultOk
    | reportChatResultOptionRequired
    | reportChatResultTextRequired
    | reportChatResultMessagesRequired

  /** Describes result of story report */
  declare export type ReportStoryResult =
    | reportStoryResultOk
    | reportStoryResultOptionRequired
    | reportStoryResultTextRequired

  /**
   * Describes an internal https://t.me or tg: link, which must be processed by the
   * application in a special way
   */
  declare export type InternalLinkType =
    | internalLinkTypeActiveSessions
    | internalLinkTypeAttachmentMenuBot
    | internalLinkTypeAuthenticationCode
    | internalLinkTypeBackground
    | internalLinkTypeBotAddToChannel
    | internalLinkTypeBotStart
    | internalLinkTypeBotStartInGroup
    | internalLinkTypeBusinessChat
    | internalLinkTypeBuyStars
    | internalLinkTypeChangePhoneNumber
    | internalLinkTypeChatAffiliateProgram
    | internalLinkTypeChatBoost
    | internalLinkTypeChatFolderInvite
    | internalLinkTypeChatFolderSettings
    | internalLinkTypeChatInvite
    | internalLinkTypeDefaultMessageAutoDeleteTimerSettings
    | internalLinkTypeEditProfileSettings
    | internalLinkTypeGame
    | internalLinkTypeInstantView
    | internalLinkTypeInvoice
    | internalLinkTypeLanguagePack
    | internalLinkTypeLanguageSettings
    | internalLinkTypeMainWebApp
    | internalLinkTypeMessage
    | internalLinkTypeMessageDraft
    | internalLinkTypePassportDataRequest
    | internalLinkTypePhoneNumberConfirmation
    | internalLinkTypePremiumFeatures
    | internalLinkTypePremiumGift
    | internalLinkTypePremiumGiftCode
    | internalLinkTypePrivacyAndSecuritySettings
    | internalLinkTypeProxy
    | internalLinkTypePublicChat
    | internalLinkTypeQrCodeAuthentication
    | internalLinkTypeRestorePurchases
    | internalLinkTypeSettings
    | internalLinkTypeStickerSet
    | internalLinkTypeStory
    | internalLinkTypeTheme
    | internalLinkTypeThemeSettings
    | internalLinkTypeUnknownDeepLink
    | internalLinkTypeUnsupportedProxy
    | internalLinkTypeUpgradedGift
    | internalLinkTypeUserPhoneNumber
    | internalLinkTypeUserToken
    | internalLinkTypeVideoChat
    | internalLinkTypeWebApp

  /**
   * Describes an internal https://t.me or tg: link, which must be processed by the
   * application in a special way
   */
  declare export type InternalLinkType$Input =
    | internalLinkTypeActiveSessions$Input
    | internalLinkTypeAttachmentMenuBot$Input
    | internalLinkTypeAuthenticationCode$Input
    | internalLinkTypeBackground$Input
    | internalLinkTypeBotAddToChannel$Input
    | internalLinkTypeBotStart$Input
    | internalLinkTypeBotStartInGroup$Input
    | internalLinkTypeBusinessChat$Input
    | internalLinkTypeBuyStars$Input
    | internalLinkTypeChangePhoneNumber$Input
    | internalLinkTypeChatAffiliateProgram$Input
    | internalLinkTypeChatBoost$Input
    | internalLinkTypeChatFolderInvite$Input
    | internalLinkTypeChatFolderSettings$Input
    | internalLinkTypeChatInvite$Input
    | internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input
    | internalLinkTypeEditProfileSettings$Input
    | internalLinkTypeGame$Input
    | internalLinkTypeInstantView$Input
    | internalLinkTypeInvoice$Input
    | internalLinkTypeLanguagePack$Input
    | internalLinkTypeLanguageSettings$Input
    | internalLinkTypeMainWebApp$Input
    | internalLinkTypeMessage$Input
    | internalLinkTypeMessageDraft$Input
    | internalLinkTypePassportDataRequest$Input
    | internalLinkTypePhoneNumberConfirmation$Input
    | internalLinkTypePremiumFeatures$Input
    | internalLinkTypePremiumGift$Input
    | internalLinkTypePremiumGiftCode$Input
    | internalLinkTypePrivacyAndSecuritySettings$Input
    | internalLinkTypeProxy$Input
    | internalLinkTypePublicChat$Input
    | internalLinkTypeQrCodeAuthentication$Input
    | internalLinkTypeRestorePurchases$Input
    | internalLinkTypeSettings$Input
    | internalLinkTypeStickerSet$Input
    | internalLinkTypeStory$Input
    | internalLinkTypeTheme$Input
    | internalLinkTypeThemeSettings$Input
    | internalLinkTypeUnknownDeepLink$Input
    | internalLinkTypeUnsupportedProxy$Input
    | internalLinkTypeUpgradedGift$Input
    | internalLinkTypeUserPhoneNumber$Input
    | internalLinkTypeUserToken$Input
    | internalLinkTypeVideoChat$Input
    | internalLinkTypeWebApp$Input

  declare export type MessageLink = messageLink

  declare export type MessageLinkInfo = messageLinkInfo

  declare export type ChatBoostLink = chatBoostLink

  declare export type ChatBoostLinkInfo = chatBoostLinkInfo

  /** Describes type of block list */
  declare export type BlockList =
    | blockListMain
    | blockListStories

  /** Describes type of block list */
  declare export type BlockList$Input =
    | blockListMain$Input
    | blockListStories$Input

  declare export type FilePart = filePart

  /** Represents the type of file */
  declare export type FileType =
    | fileTypeNone
    | fileTypeAnimation
    | fileTypeAudio
    | fileTypeDocument
    | fileTypeNotificationSound
    | fileTypePhoto
    | fileTypePhotoStory
    | fileTypeProfilePhoto
    | fileTypeSecret
    | fileTypeSecretThumbnail
    | fileTypeSecure
    | fileTypeSelfDestructingPhoto
    | fileTypeSelfDestructingVideo
    | fileTypeSelfDestructingVideoNote
    | fileTypeSelfDestructingVoiceNote
    | fileTypeSticker
    | fileTypeThumbnail
    | fileTypeUnknown
    | fileTypeVideo
    | fileTypeVideoNote
    | fileTypeVideoStory
    | fileTypeVoiceNote
    | fileTypeWallpaper

  /** Represents the type of file */
  declare export type FileType$Input =
    | fileTypeNone$Input
    | fileTypeAnimation$Input
    | fileTypeAudio$Input
    | fileTypeDocument$Input
    | fileTypeNotificationSound$Input
    | fileTypePhoto$Input
    | fileTypePhotoStory$Input
    | fileTypeProfilePhoto$Input
    | fileTypeSecret$Input
    | fileTypeSecretThumbnail$Input
    | fileTypeSecure$Input
    | fileTypeSelfDestructingPhoto$Input
    | fileTypeSelfDestructingVideo$Input
    | fileTypeSelfDestructingVideoNote$Input
    | fileTypeSelfDestructingVoiceNote$Input
    | fileTypeSticker$Input
    | fileTypeThumbnail$Input
    | fileTypeUnknown$Input
    | fileTypeVideo$Input
    | fileTypeVideoNote$Input
    | fileTypeVideoStory$Input
    | fileTypeVoiceNote$Input
    | fileTypeWallpaper$Input

  declare export type StorageStatistics = storageStatistics

  declare export type StorageStatisticsFast = storageStatisticsFast

  declare export type DatabaseStatistics = databaseStatistics

  /** Represents the type of network */
  declare export type NetworkType =
    | networkTypeNone
    | networkTypeMobile
    | networkTypeMobileRoaming
    | networkTypeWiFi
    | networkTypeOther

  /** Represents the type of network */
  declare export type NetworkType$Input =
    | networkTypeNone$Input
    | networkTypeMobile$Input
    | networkTypeMobileRoaming$Input
    | networkTypeWiFi$Input
    | networkTypeOther$Input

  /** Contains statistics about network usage */
  declare export type NetworkStatisticsEntry =
    | networkStatisticsEntryFile
    | networkStatisticsEntryCall

  /** Contains statistics about network usage */
  declare export type NetworkStatisticsEntry$Input =
    | networkStatisticsEntryFile$Input
    | networkStatisticsEntryCall$Input

  declare export type NetworkStatistics = networkStatistics

  declare export type AutoDownloadSettingsPresets = autoDownloadSettingsPresets

  /** Describes scope of autosave settings */
  declare export type AutosaveSettingsScope =
    | autosaveSettingsScopePrivateChats
    | autosaveSettingsScopeGroupChats
    | autosaveSettingsScopeChannelChats
    | autosaveSettingsScopeChat

  /** Describes scope of autosave settings */
  declare export type AutosaveSettingsScope$Input =
    | autosaveSettingsScopePrivateChats$Input
    | autosaveSettingsScopeGroupChats$Input
    | autosaveSettingsScopeChannelChats$Input
    | autosaveSettingsScopeChat$Input

  declare export type AutosaveSettings = autosaveSettings

  /** Describes the current state of the connection to Telegram servers */
  declare export type ConnectionState =
    | connectionStateWaitingForNetwork
    | connectionStateConnectingToProxy
    | connectionStateConnecting
    | connectionStateUpdating
    | connectionStateReady

  /**
   * Represents the categories of chats for which a list of frequently used chats
   * can be retrieved
   */
  declare export type TopChatCategory$Input =
    | topChatCategoryUsers$Input
    | topChatCategoryBots$Input
    | topChatCategoryGroups$Input
    | topChatCategoryChannels$Input
    | topChatCategoryInlineBots$Input
    | topChatCategoryWebAppBots$Input
    | topChatCategoryCalls$Input
    | topChatCategoryForwardChats$Input

  declare export type FoundPosition = foundPosition

  declare export type FoundPositions = foundPositions

  /** Describes the type of URL linking to an internal Telegram entity */
  declare export type TMeUrlType =
    | tMeUrlTypeUser
    | tMeUrlTypeSupergroup
    | tMeUrlTypeChatInvite
    | tMeUrlTypeStickerSet

  declare export type TMeUrls = tMeUrls

  /** Describes an action suggested to the current user */
  declare export type SuggestedAction =
    | suggestedActionEnableArchiveAndMuteNewChats
    | suggestedActionCheckPassword
    | suggestedActionCheckPhoneNumber
    | suggestedActionViewChecksHint
    | suggestedActionConvertToBroadcastGroup
    | suggestedActionSetPassword
    | suggestedActionUpgradePremium
    | suggestedActionRestorePremium
    | suggestedActionSubscribeToAnnualPremium
    | suggestedActionGiftPremiumForChristmas
    | suggestedActionSetBirthdate
    | suggestedActionSetProfilePhoto
    | suggestedActionExtendPremium
    | suggestedActionExtendStarSubscriptions

  /** Describes an action suggested to the current user */
  declare export type SuggestedAction$Input =
    | suggestedActionEnableArchiveAndMuteNewChats$Input
    | suggestedActionCheckPassword$Input
    | suggestedActionCheckPhoneNumber$Input
    | suggestedActionViewChecksHint$Input
    | suggestedActionConvertToBroadcastGroup$Input
    | suggestedActionSetPassword$Input
    | suggestedActionUpgradePremium$Input
    | suggestedActionRestorePremium$Input
    | suggestedActionSubscribeToAnnualPremium$Input
    | suggestedActionGiftPremiumForChristmas$Input
    | suggestedActionSetBirthdate$Input
    | suggestedActionSetProfilePhoto$Input
    | suggestedActionExtendPremium$Input
    | suggestedActionExtendStarSubscriptions$Input

  declare export type Count = count

  declare export type Text = text

  declare export type Seconds = seconds

  declare export type FileDownloadedPrefixSize = fileDownloadedPrefixSize

  declare export type StarCount = starCount

  declare export type DeepLinkInfo = deepLinkInfo

  /** Describes the way the text needs to be parsed for text entities */
  declare export type TextParseMode$Input =
    | textParseModeMarkdown$Input
    | textParseModeHTML$Input

  /** Describes the type of proxy server */
  declare export type ProxyType =
    | proxyTypeSocks5
    | proxyTypeHttp
    | proxyTypeMtproto

  /** Describes the type of proxy server */
  declare export type ProxyType$Input =
    | proxyTypeSocks5$Input
    | proxyTypeHttp$Input
    | proxyTypeMtproto$Input

  declare export type Proxy = proxy

  declare export type Proxies = proxies

  /** Describes a statistical graph */
  declare export type StatisticalGraph =
    | statisticalGraphData
    | statisticalGraphAsync
    | statisticalGraphError

  /** Describes type of object, for which statistics are provided */
  declare export type ChatStatisticsObjectType =
    | chatStatisticsObjectTypeMessage
    | chatStatisticsObjectTypeStory

  /** Contains a detailed statistics about a chat */
  declare export type ChatStatistics =
    | chatStatisticsSupergroup
    | chatStatisticsChannel

  declare export type ChatRevenueStatistics = chatRevenueStatistics

  declare export type MessageStatistics = messageStatistics

  declare export type StoryStatistics = storyStatistics

  /** Describes state of a revenue withdrawal */
  declare export type RevenueWithdrawalState =
    | revenueWithdrawalStatePending
    | revenueWithdrawalStateSucceeded
    | revenueWithdrawalStateFailed

  /**
   * Describes type of transaction for revenue earned from sponsored messages in
   * a chat
   */
  declare export type ChatRevenueTransactionType =
    | chatRevenueTransactionTypeEarnings
    | chatRevenueTransactionTypeWithdrawal
    | chatRevenueTransactionTypeRefund

  declare export type ChatRevenueTransactions = chatRevenueTransactions

  declare export type StarRevenueStatistics = starRevenueStatistics

  /** Represents a vector path command */
  declare export type VectorPathCommand =
    | vectorPathCommandLine
    | vectorPathCommandCubicBezierCurve

  /** Represents the scope to which bot commands are relevant */
  declare export type BotCommandScope$Input =
    | botCommandScopeDefault$Input
    | botCommandScopeAllPrivateChats$Input
    | botCommandScopeAllGroupChats$Input
    | botCommandScopeAllChatAdministrators$Input
    | botCommandScopeChat$Input
    | botCommandScopeChatAdministrators$Input
    | botCommandScopeChatMember$Input

  /** Describes type of the request for which a code is sent to a phone number */
  declare export type PhoneNumberCodeType$Input =
    | phoneNumberCodeTypeChange$Input
    | phoneNumberCodeTypeVerify$Input
    | phoneNumberCodeTypeConfirmOwnership$Input

  /** Contains notifications about data changes */
  declare export type Update =
    | updateAuthorizationState
    | updateNewMessage
    | updateMessageSendAcknowledged
    | updateMessageSendSucceeded
    | updateMessageSendFailed
    | updateMessageContent
    | updateMessageEdited
    | updateMessageIsPinned
    | updateMessageInteractionInfo
    | updateMessageContentOpened
    | updateMessageMentionRead
    | updateMessageUnreadReactions
    | updateMessageFactCheck
    | updateMessageLiveLocationViewed
    | updateVideoPublished
    | updateNewChat
    | updateChatTitle
    | updateChatPhoto
    | updateChatAccentColors
    | updateChatPermissions
    | updateChatLastMessage
    | updateChatPosition
    | updateChatAddedToList
    | updateChatRemovedFromList
    | updateChatReadInbox
    | updateChatReadOutbox
    | updateChatActionBar
    | updateChatBusinessBotManageBar
    | updateChatAvailableReactions
    | updateChatDraftMessage
    | updateChatEmojiStatus
    | updateChatMessageSender
    | updateChatMessageAutoDeleteTime
    | updateChatNotificationSettings
    | updateChatPendingJoinRequests
    | updateChatReplyMarkup
    | updateChatBackground
    | updateChatTheme
    | updateChatUnreadMentionCount
    | updateChatUnreadReactionCount
    | updateChatVideoChat
    | updateChatDefaultDisableNotification
    | updateChatHasProtectedContent
    | updateChatIsTranslatable
    | updateChatIsMarkedAsUnread
    | updateChatViewAsTopics
    | updateChatBlockList
    | updateChatHasScheduledMessages
    | updateChatFolders
    | updateChatOnlineMemberCount
    | updateSavedMessagesTopic
    | updateSavedMessagesTopicCount
    | updateQuickReplyShortcut
    | updateQuickReplyShortcutDeleted
    | updateQuickReplyShortcuts
    | updateQuickReplyShortcutMessages
    | updateForumTopicInfo
    | updateScopeNotificationSettings
    | updateReactionNotificationSettings
    | updateNotification
    | updateNotificationGroup
    | updateActiveNotifications
    | updateHavePendingNotifications
    | updateDeleteMessages
    | updateChatAction
    | updateUserStatus
    | updateUser
    | updateBasicGroup
    | updateSupergroup
    | updateSecretChat
    | updateUserFullInfo
    | updateBasicGroupFullInfo
    | updateSupergroupFullInfo
    | updateServiceNotification
    | updateFile
    | updateFileGenerationStart
    | updateFileGenerationStop
    | updateFileDownloads
    | updateFileAddedToDownloads
    | updateFileDownload
    | updateFileRemovedFromDownloads
    | updateApplicationVerificationRequired
    | updateApplicationRecaptchaVerificationRequired
    | updateCall
    | updateGroupCall
    | updateGroupCallParticipant
    | updateNewCallSignalingData
    | updateUserPrivacySettingRules
    | updateUnreadMessageCount
    | updateUnreadChatCount
    | updateStory
    | updateStoryDeleted
    | updateStorySendSucceeded
    | updateStorySendFailed
    | updateChatActiveStories
    | updateStoryListChatCount
    | updateStoryStealthMode
    | updateOption
    | updateStickerSet
    | updateInstalledStickerSets
    | updateTrendingStickerSets
    | updateRecentStickers
    | updateFavoriteStickers
    | updateSavedAnimations
    | updateSavedNotificationSounds
    | updateDefaultBackground
    | updateChatThemes
    | updateAccentColors
    | updateProfileAccentColors
    | updateLanguagePackStrings
    | updateConnectionState
    | updateTermsOfService
    | updateUnconfirmedSession
    | updateAttachmentMenuBots
    | updateWebAppMessageSent
    | updateActiveEmojiReactions
    | updateAvailableMessageEffects
    | updateDefaultReactionType
    | updateDefaultPaidReactionType
    | updateSavedMessagesTags
    | updateActiveLiveLocationMessages
    | updateOwnedStarCount
    | updateChatRevenueAmount
    | updateStarRevenueStatus
    | updateSpeechRecognitionTrial
    | updateDiceEmojis
    | updateAnimatedEmojiMessageClicked
    | updateAnimationSearchParameters
    | updateSuggestedActions
    | updateSpeedLimitNotification
    | updateContactCloseBirthdays
    | updateAutosaveSettings
    | updateBusinessConnection
    | updateNewBusinessMessage
    | updateBusinessMessageEdited
    | updateBusinessMessagesDeleted
    | updateNewInlineQuery
    | updateNewChosenInlineResult
    | updateNewCallbackQuery
    | updateNewInlineCallbackQuery
    | updateNewBusinessCallbackQuery
    | updateNewShippingQuery
    | updateNewPreCheckoutQuery
    | updateNewCustomEvent
    | updateNewCustomQuery
    | updatePoll
    | updatePollAnswer
    | updateChatMember
    | updateNewChatJoinRequest
    | updateChatBoost
    | updateMessageReaction
    | updateMessageReactions
    | updatePaidMediaPurchased

  declare export type Updates = updates

  /** Describes a stream to which TDLib internal log is written */
  declare export type LogStream =
    | logStreamDefault
    | logStreamFile
    | logStreamEmpty

  /** Describes a stream to which TDLib internal log is written */
  declare export type LogStream$Input =
    | logStreamDefault$Input
    | logStreamFile$Input
    | logStreamEmpty$Input

  declare export type LogVerbosityLevel = logVerbosityLevel

  declare export type LogTags = logTags

  declare export type UserSupportInfo = userSupportInfo

  declare export type TestInt = testInt

  declare export type TestString = testString

  declare export type TestBytes = testBytes

  declare export type TestVectorInt = testVectorInt

  declare export type TestVectorIntObject = testVectorIntObject

  declare export type TestVectorString = testVectorString

  declare export type TestVectorStringObject = testVectorStringObject

  // --- Special types ---

  declare export type $Function =
    | getAuthorizationState
    | setTdlibParameters
    | setAuthenticationPhoneNumber
    | setAuthenticationEmailAddress
    | resendAuthenticationCode
    | checkAuthenticationEmailCode
    | checkAuthenticationCode
    | requestQrCodeAuthentication
    | registerUser
    | resetAuthenticationEmailAddress
    | checkAuthenticationPassword
    | requestAuthenticationPasswordRecovery
    | checkAuthenticationPasswordRecoveryCode
    | recoverAuthenticationPassword
    | sendAuthenticationFirebaseSms
    | reportAuthenticationCodeMissing
    | checkAuthenticationBotToken
    | logOut
    | close
    | destroy
    | confirmQrCodeAuthentication
    | getCurrentState
    | setDatabaseEncryptionKey
    | getPasswordState
    | setPassword
    | setLoginEmailAddress
    | resendLoginEmailAddressCode
    | checkLoginEmailAddressCode
    | getRecoveryEmailAddress
    | setRecoveryEmailAddress
    | checkRecoveryEmailAddressCode
    | resendRecoveryEmailAddressCode
    | cancelRecoveryEmailAddressVerification
    | requestPasswordRecovery
    | checkPasswordRecoveryCode
    | recoverPassword
    | resetPassword
    | cancelPasswordReset
    | createTemporaryPassword
    | getTemporaryPasswordState
    | getMe
    | getUser
    | getUserFullInfo
    | getBasicGroup
    | getBasicGroupFullInfo
    | getSupergroup
    | getSupergroupFullInfo
    | getSecretChat
    | getChat
    | getMessage
    | getMessageLocally
    | getRepliedMessage
    | getChatPinnedMessage
    | getCallbackQueryMessage
    | getMessages
    | getMessageProperties
    | getMessageThread
    | getMessageReadDate
    | getMessageViewers
    | getFile
    | getRemoteFile
    | loadChats
    | getChats
    | searchPublicChat
    | searchPublicChats
    | searchChats
    | searchChatsOnServer
    | getRecommendedChats
    | getChatSimilarChats
    | getChatSimilarChatCount
    | openChatSimilarChat
    | getBotSimilarBots
    | getBotSimilarBotCount
    | openBotSimilarBot
    | getTopChats
    | removeTopChat
    | searchRecentlyFoundChats
    | addRecentlyFoundChat
    | removeRecentlyFoundChat
    | clearRecentlyFoundChats
    | getRecentlyOpenedChats
    | checkChatUsername
    | getCreatedPublicChats
    | checkCreatedPublicChatsLimit
    | getSuitableDiscussionChats
    | getInactiveSupergroupChats
    | getSuitablePersonalChats
    | loadSavedMessagesTopics
    | getSavedMessagesTopicHistory
    | getSavedMessagesTopicMessageByDate
    | deleteSavedMessagesTopicHistory
    | deleteSavedMessagesTopicMessagesByDate
    | toggleSavedMessagesTopicIsPinned
    | setPinnedSavedMessagesTopics
    | getGroupsInCommon
    | getChatHistory
    | getMessageThreadHistory
    | deleteChatHistory
    | deleteChat
    | searchChatMessages
    | searchMessages
    | searchSecretMessages
    | searchSavedMessages
    | searchCallMessages
    | searchOutgoingDocumentMessages
    | searchPublicMessagesByTag
    | searchPublicStoriesByTag
    | searchPublicStoriesByLocation
    | searchPublicStoriesByVenue
    | getSearchedForTags
    | removeSearchedForTag
    | clearSearchedForTags
    | deleteAllCallMessages
    | searchChatRecentLocationMessages
    | getChatMessageByDate
    | getChatSparseMessagePositions
    | getChatMessageCalendar
    | getChatMessageCount
    | getChatMessagePosition
    | getChatScheduledMessages
    | getChatSponsoredMessages
    | clickChatSponsoredMessage
    | reportChatSponsoredMessage
    | removeNotification
    | removeNotificationGroup
    | getMessageLink
    | getMessageEmbeddingCode
    | getMessageLinkInfo
    | translateText
    | translateMessageText
    | recognizeSpeech
    | rateSpeechRecognition
    | getChatAvailableMessageSenders
    | setChatMessageSender
    | sendMessage
    | sendMessageAlbum
    | sendBotStartMessage
    | sendInlineQueryResultMessage
    | forwardMessages
    | sendQuickReplyShortcutMessages
    | resendMessages
    | addLocalMessage
    | deleteMessages
    | deleteChatMessagesBySender
    | deleteChatMessagesByDate
    | editMessageText
    | editMessageLiveLocation
    | editMessageMedia
    | editMessageCaption
    | editMessageReplyMarkup
    | editInlineMessageText
    | editInlineMessageLiveLocation
    | editInlineMessageMedia
    | editInlineMessageCaption
    | editInlineMessageReplyMarkup
    | editMessageSchedulingState
    | setMessageFactCheck
    | sendBusinessMessage
    | sendBusinessMessageAlbum
    | editBusinessMessageText
    | editBusinessMessageLiveLocation
    | editBusinessMessageMedia
    | editBusinessMessageCaption
    | editBusinessMessageReplyMarkup
    | stopBusinessPoll
    | setBusinessMessageIsPinned
    | checkQuickReplyShortcutName
    | loadQuickReplyShortcuts
    | setQuickReplyShortcutName
    | deleteQuickReplyShortcut
    | reorderQuickReplyShortcuts
    | loadQuickReplyShortcutMessages
    | deleteQuickReplyShortcutMessages
    | addQuickReplyShortcutMessage
    | addQuickReplyShortcutInlineQueryResultMessage
    | addQuickReplyShortcutMessageAlbum
    | readdQuickReplyShortcutMessages
    | editQuickReplyMessage
    | getForumTopicDefaultIcons
    | createForumTopic
    | editForumTopic
    | getForumTopic
    | getForumTopicLink
    | getForumTopics
    | setForumTopicNotificationSettings
    | toggleForumTopicIsClosed
    | toggleGeneralForumTopicIsHidden
    | toggleForumTopicIsPinned
    | setPinnedForumTopics
    | deleteForumTopic
    | getEmojiReaction
    | getCustomEmojiReactionAnimations
    | getMessageAvailableReactions
    | clearRecentReactions
    | addMessageReaction
    | removeMessageReaction
    | getChatAvailablePaidMessageReactionSenders
    | addPendingPaidMessageReaction
    | commitPendingPaidMessageReactions
    | removePendingPaidMessageReactions
    | setPaidMessageReactionType
    | setMessageReactions
    | getMessageAddedReactions
    | setDefaultReactionType
    | getSavedMessagesTags
    | setSavedMessagesTagLabel
    | getMessageEffect
    | searchQuote
    | getTextEntities
    | parseTextEntities
    | parseMarkdown
    | getMarkdownText
    | getCountryFlagEmoji
    | getFileMimeType
    | getFileExtension
    | cleanFileName
    | getLanguagePackString
    | getJsonValue
    | getJsonString
    | getThemeParametersJsonString
    | setPollAnswer
    | getPollVoters
    | stopPoll
    | hideSuggestedAction
    | hideContactCloseBirthdays
    | getBusinessConnection
    | getLoginUrlInfo
    | getLoginUrl
    | shareUsersWithBot
    | shareChatWithBot
    | getInlineQueryResults
    | answerInlineQuery
    | savePreparedInlineMessage
    | getPreparedInlineMessage
    | getGrossingWebAppBots
    | searchWebApp
    | getWebAppPlaceholder
    | getWebAppLinkUrl
    | getMainWebApp
    | getWebAppUrl
    | sendWebAppData
    | openWebApp
    | closeWebApp
    | answerWebAppQuery
    | checkWebAppFileDownload
    | getCallbackQueryAnswer
    | answerCallbackQuery
    | answerShippingQuery
    | answerPreCheckoutQuery
    | setGameScore
    | setInlineGameScore
    | getGameHighScores
    | getInlineGameHighScores
    | deleteChatReplyMarkup
    | sendChatAction
    | openChat
    | closeChat
    | viewMessages
    | openMessageContent
    | clickAnimatedEmojiMessage
    | getInternalLink
    | getInternalLinkType
    | getExternalLinkInfo
    | getExternalLink
    | readAllChatMentions
    | readAllMessageThreadMentions
    | readAllChatReactions
    | readAllMessageThreadReactions
    | createPrivateChat
    | createBasicGroupChat
    | createSupergroupChat
    | createSecretChat
    | createNewBasicGroupChat
    | createNewSupergroupChat
    | createNewSecretChat
    | upgradeBasicGroupChatToSupergroupChat
    | getChatListsToAddChat
    | addChatToList
    | getChatFolder
    | createChatFolder
    | editChatFolder
    | deleteChatFolder
    | getChatFolderChatsToLeave
    | getChatFolderChatCount
    | reorderChatFolders
    | toggleChatFolderTags
    | getRecommendedChatFolders
    | getChatFolderDefaultIconName
    | getChatsForChatFolderInviteLink
    | createChatFolderInviteLink
    | getChatFolderInviteLinks
    | editChatFolderInviteLink
    | deleteChatFolderInviteLink
    | checkChatFolderInviteLink
    | addChatFolderByInviteLink
    | getChatFolderNewChats
    | processChatFolderNewChats
    | getArchiveChatListSettings
    | setArchiveChatListSettings
    | setChatTitle
    | setChatPhoto
    | setChatAccentColor
    | setChatProfileAccentColor
    | setChatMessageAutoDeleteTime
    | setChatEmojiStatus
    | setChatPermissions
    | setChatBackground
    | deleteChatBackground
    | setChatTheme
    | setChatDraftMessage
    | setChatNotificationSettings
    | toggleChatHasProtectedContent
    | toggleChatViewAsTopics
    | toggleChatIsTranslatable
    | toggleChatIsMarkedAsUnread
    | toggleChatDefaultDisableNotification
    | setChatAvailableReactions
    | setChatClientData
    | setChatDescription
    | setChatDiscussionGroup
    | setChatLocation
    | setChatSlowModeDelay
    | pinChatMessage
    | unpinChatMessage
    | unpinAllChatMessages
    | unpinAllMessageThreadMessages
    | joinChat
    | leaveChat
    | addChatMember
    | addChatMembers
    | setChatMemberStatus
    | banChatMember
    | canTransferOwnership
    | transferChatOwnership
    | getChatMember
    | searchChatMembers
    | getChatAdministrators
    | clearAllDraftMessages
    | getSavedNotificationSound
    | getSavedNotificationSounds
    | addSavedNotificationSound
    | removeSavedNotificationSound
    | getChatNotificationSettingsExceptions
    | getScopeNotificationSettings
    | setScopeNotificationSettings
    | setReactionNotificationSettings
    | resetAllNotificationSettings
    | toggleChatIsPinned
    | setPinnedChats
    | readChatList
    | getCurrentWeather
    | getStory
    | getChatsToSendStories
    | canSendStory
    | sendStory
    | editStory
    | editStoryCover
    | setStoryPrivacySettings
    | toggleStoryIsPostedToChatPage
    | deleteStory
    | getStoryNotificationSettingsExceptions
    | loadActiveStories
    | setChatActiveStoriesList
    | getChatActiveStories
    | getChatPostedToChatPageStories
    | getChatArchivedStories
    | setChatPinnedStories
    | openStory
    | closeStory
    | getStoryAvailableReactions
    | setStoryReaction
    | getStoryInteractions
    | getChatStoryInteractions
    | reportStory
    | activateStoryStealthMode
    | getStoryPublicForwards
    | getChatBoostLevelFeatures
    | getChatBoostFeatures
    | getAvailableChatBoostSlots
    | getChatBoostStatus
    | boostChat
    | getChatBoostLink
    | getChatBoostLinkInfo
    | getChatBoosts
    | getUserChatBoosts
    | getAttachmentMenuBot
    | toggleBotIsAddedToAttachmentMenu
    | getThemedEmojiStatuses
    | getRecentEmojiStatuses
    | getUpgradedGiftEmojiStatuses
    | getDefaultEmojiStatuses
    | clearRecentEmojiStatuses
    | getThemedChatEmojiStatuses
    | getDefaultChatEmojiStatuses
    | getDisallowedChatEmojiStatuses
    | downloadFile
    | getFileDownloadedPrefixSize
    | cancelDownloadFile
    | getSuggestedFileName
    | preliminaryUploadFile
    | cancelPreliminaryUploadFile
    | writeGeneratedFilePart
    | setFileGenerationProgress
    | finishFileGeneration
    | readFilePart
    | deleteFile
    | addFileToDownloads
    | toggleDownloadIsPaused
    | toggleAllDownloadsArePaused
    | removeFileFromDownloads
    | removeAllFilesFromDownloads
    | searchFileDownloads
    | setApplicationVerificationToken
    | getMessageFileType
    | getMessageImportConfirmationText
    | importMessages
    | replacePrimaryChatInviteLink
    | createChatInviteLink
    | createChatSubscriptionInviteLink
    | editChatInviteLink
    | editChatSubscriptionInviteLink
    | getChatInviteLink
    | getChatInviteLinkCounts
    | getChatInviteLinks
    | getChatInviteLinkMembers
    | revokeChatInviteLink
    | deleteRevokedChatInviteLink
    | deleteAllRevokedChatInviteLinks
    | checkChatInviteLink
    | joinChatByInviteLink
    | getChatJoinRequests
    | processChatJoinRequest
    | processChatJoinRequests
    | createCall
    | acceptCall
    | sendCallSignalingData
    | discardCall
    | sendCallRating
    | sendCallDebugInformation
    | sendCallLog
    | getVideoChatAvailableParticipants
    | setVideoChatDefaultParticipant
    | createVideoChat
    | createGroupCall
    | getVideoChatRtmpUrl
    | replaceVideoChatRtmpUrl
    | getGroupCall
    | startScheduledGroupCall
    | toggleGroupCallEnabledStartNotification
    | joinGroupCall
    | startGroupCallScreenSharing
    | toggleGroupCallScreenSharingIsPaused
    | endGroupCallScreenSharing
    | setGroupCallTitle
    | toggleGroupCallMuteNewParticipants
    | inviteGroupCallParticipants
    | getGroupCallInviteLink
    | revokeGroupCallInviteLink
    | startGroupCallRecording
    | endGroupCallRecording
    | toggleGroupCallIsMyVideoPaused
    | toggleGroupCallIsMyVideoEnabled
    | setGroupCallParticipantIsSpeaking
    | toggleGroupCallParticipantIsMuted
    | setGroupCallParticipantVolumeLevel
    | toggleGroupCallParticipantIsHandRaised
    | loadGroupCallParticipants
    | leaveGroupCall
    | endGroupCall
    | getGroupCallStreams
    | getGroupCallStreamSegment
    | setMessageSenderBlockList
    | blockMessageSenderFromReplies
    | getBlockedMessageSenders
    | addContact
    | importContacts
    | getContacts
    | searchContacts
    | removeContacts
    | getImportedContactCount
    | changeImportedContacts
    | clearImportedContacts
    | setCloseFriends
    | getCloseFriends
    | setUserPersonalProfilePhoto
    | suggestUserProfilePhoto
    | toggleBotCanManageEmojiStatus
    | setUserEmojiStatus
    | searchUserByPhoneNumber
    | sharePhoneNumber
    | getUserProfilePhotos
    | getStickerOutline
    | getStickers
    | getAllStickerEmojis
    | searchStickers
    | getGreetingStickers
    | getPremiumStickers
    | getInstalledStickerSets
    | getArchivedStickerSets
    | getTrendingStickerSets
    | getAttachedStickerSets
    | getStickerSet
    | getStickerSetName
    | searchStickerSet
    | searchInstalledStickerSets
    | searchStickerSets
    | changeStickerSet
    | viewTrendingStickerSets
    | reorderInstalledStickerSets
    | getRecentStickers
    | addRecentSticker
    | removeRecentSticker
    | clearRecentStickers
    | getFavoriteStickers
    | addFavoriteSticker
    | removeFavoriteSticker
    | getStickerEmojis
    | searchEmojis
    | getKeywordEmojis
    | getEmojiCategories
    | getAnimatedEmoji
    | getEmojiSuggestionsUrl
    | getCustomEmojiStickers
    | getDefaultChatPhotoCustomEmojiStickers
    | getDefaultProfilePhotoCustomEmojiStickers
    | getDefaultBackgroundCustomEmojiStickers
    | getSavedAnimations
    | addSavedAnimation
    | removeSavedAnimation
    | getRecentInlineBots
    | getOwnedBots
    | searchHashtags
    | removeRecentHashtag
    | getLinkPreview
    | getWebPageInstantView
    | setProfilePhoto
    | deleteProfilePhoto
    | setAccentColor
    | setProfileAccentColor
    | setName
    | setBio
    | setUsername
    | toggleUsernameIsActive
    | reorderActiveUsernames
    | setBirthdate
    | setPersonalChat
    | setEmojiStatus
    | toggleHasSponsoredMessagesEnabled
    | setBusinessLocation
    | setBusinessOpeningHours
    | setBusinessGreetingMessageSettings
    | setBusinessAwayMessageSettings
    | setBusinessStartPage
    | sendPhoneNumberCode
    | sendPhoneNumberFirebaseSms
    | reportPhoneNumberCodeMissing
    | resendPhoneNumberCode
    | checkPhoneNumberCode
    | getBusinessConnectedBot
    | setBusinessConnectedBot
    | deleteBusinessConnectedBot
    | toggleBusinessConnectedBotChatIsPaused
    | removeBusinessConnectedBotFromChat
    | getBusinessChatLinks
    | createBusinessChatLink
    | editBusinessChatLink
    | deleteBusinessChatLink
    | getBusinessChatLinkInfo
    | getUserLink
    | searchUserByToken
    | setCommands
    | deleteCommands
    | getCommands
    | setMenuButton
    | getMenuButton
    | setDefaultGroupAdministratorRights
    | setDefaultChannelAdministratorRights
    | canBotSendMessages
    | allowBotToSendMessages
    | sendWebAppCustomRequest
    | getBotMediaPreviews
    | getBotMediaPreviewInfo
    | addBotMediaPreview
    | editBotMediaPreview
    | reorderBotMediaPreviews
    | deleteBotMediaPreviews
    | setBotName
    | getBotName
    | setBotProfilePhoto
    | toggleBotUsernameIsActive
    | reorderBotActiveUsernames
    | setBotInfoDescription
    | getBotInfoDescription
    | setBotInfoShortDescription
    | getBotInfoShortDescription
    | setMessageSenderBotVerification
    | removeMessageSenderBotVerification
    | getActiveSessions
    | terminateSession
    | terminateAllOtherSessions
    | confirmSession
    | toggleSessionCanAcceptCalls
    | toggleSessionCanAcceptSecretChats
    | setInactiveSessionTtl
    | getConnectedWebsites
    | disconnectWebsite
    | disconnectAllWebsites
    | setSupergroupUsername
    | toggleSupergroupUsernameIsActive
    | disableAllSupergroupUsernames
    | reorderSupergroupActiveUsernames
    | setSupergroupStickerSet
    | setSupergroupCustomEmojiStickerSet
    | setSupergroupUnrestrictBoostCount
    | toggleSupergroupSignMessages
    | toggleSupergroupJoinToSendMessages
    | toggleSupergroupJoinByRequest
    | toggleSupergroupIsAllHistoryAvailable
    | toggleSupergroupCanHaveSponsoredMessages
    | toggleSupergroupHasHiddenMembers
    | toggleSupergroupHasAggressiveAntiSpamEnabled
    | toggleSupergroupIsForum
    | toggleSupergroupIsBroadcastGroup
    | reportSupergroupSpam
    | reportSupergroupAntiSpamFalsePositive
    | getSupergroupMembers
    | closeSecretChat
    | getChatEventLog
    | getTimeZones
    | getPaymentForm
    | validateOrderInfo
    | sendPaymentForm
    | getPaymentReceipt
    | getSavedOrderInfo
    | deleteSavedOrderInfo
    | deleteSavedCredentials
    | getAvailableGifts
    | sendGift
    | sellGift
    | toggleGiftIsSaved
    | setPinnedGifts
    | toggleChatGiftNotifications
    | getGiftUpgradePreview
    | upgradeGift
    | transferGift
    | getReceivedGifts
    | getReceivedGift
    | getUpgradedGift
    | getUpgradedGiftWithdrawalUrl
    | createInvoiceLink
    | refundStarPayment
    | getSupportUser
    | getBackgroundUrl
    | searchBackground
    | setDefaultBackground
    | deleteDefaultBackground
    | getInstalledBackgrounds
    | removeInstalledBackground
    | resetInstalledBackgrounds
    | getLocalizationTargetInfo
    | getLanguagePackInfo
    | getLanguagePackStrings
    | synchronizeLanguagePack
    | addCustomServerLanguagePack
    | setCustomLanguagePack
    | editCustomLanguagePackInfo
    | setCustomLanguagePackString
    | deleteLanguagePack
    | registerDevice
    | processPushNotification
    | getPushReceiverId
    | getRecentlyVisitedTMeUrls
    | setUserPrivacySettingRules
    | getUserPrivacySettingRules
    | setReadDatePrivacySettings
    | getReadDatePrivacySettings
    | setNewChatPrivacySettings
    | getNewChatPrivacySettings
    | getPaidMessageRevenue
    | allowUnpaidMessagesFromUser
    | setChatPaidMessageStarCount
    | canSendMessageToUser
    | getOption
    | setOption
    | setAccountTtl
    | getAccountTtl
    | deleteAccount
    | setDefaultMessageAutoDeleteTime
    | getDefaultMessageAutoDeleteTime
    | removeChatActionBar
    | reportChat
    | reportChatPhoto
    | reportMessageReactions
    | getChatRevenueStatistics
    | getChatRevenueWithdrawalUrl
    | getChatRevenueTransactions
    | getStarRevenueStatistics
    | getStarWithdrawalUrl
    | getStarAdAccountUrl
    | getChatStatistics
    | getMessageStatistics
    | getMessagePublicForwards
    | getStoryStatistics
    | getStatisticalGraph
    | getStorageStatistics
    | getStorageStatisticsFast
    | getDatabaseStatistics
    | optimizeStorage
    | setNetworkType
    | getNetworkStatistics
    | addNetworkStatistics
    | resetNetworkStatistics
    | getAutoDownloadSettingsPresets
    | setAutoDownloadSettings
    | getAutosaveSettings
    | setAutosaveSettings
    | clearAutosaveSettingsExceptions
    | getBankCardInfo
    | getPassportElement
    | getAllPassportElements
    | setPassportElement
    | deletePassportElement
    | setPassportElementErrors
    | getPreferredCountryLanguage
    | sendEmailAddressVerificationCode
    | resendEmailAddressVerificationCode
    | checkEmailAddressVerificationCode
    | getPassportAuthorizationForm
    | getPassportAuthorizationFormAvailableElements
    | sendPassportAuthorizationForm
    | setBotUpdatesStatus
    | uploadStickerFile
    | getSuggestedStickerSetName
    | checkStickerSetName
    | createNewStickerSet
    | addStickerToSet
    | replaceStickerInSet
    | setStickerSetThumbnail
    | setCustomEmojiStickerSetThumbnail
    | setStickerSetTitle
    | deleteStickerSet
    | setStickerPositionInSet
    | removeStickerFromSet
    | setStickerEmojis
    | setStickerKeywords
    | setStickerMaskPosition
    | getOwnedStickerSets
    | getMapThumbnailFile
    | getPremiumLimit
    | getPremiumFeatures
    | getPremiumStickerExamples
    | getPremiumInfoSticker
    | viewPremiumFeature
    | clickPremiumSubscriptionButton
    | getPremiumState
    | getPremiumGiftPaymentOptions
    | getPremiumGiveawayPaymentOptions
    | checkPremiumGiftCode
    | applyPremiumGiftCode
    | launchPrepaidGiveaway
    | getGiveawayInfo
    | getStarPaymentOptions
    | getStarGiftPaymentOptions
    | getStarGiveawayPaymentOptions
    | getStarTransactions
    | getStarSubscriptions
    | canPurchaseFromStore
    | assignAppStoreTransaction
    | assignGooglePlayTransaction
    | editStarSubscription
    | editUserStarSubscription
    | reuseStarSubscription
    | setChatAffiliateProgram
    | searchChatAffiliateProgram
    | searchAffiliatePrograms
    | connectAffiliateProgram
    | disconnectAffiliateProgram
    | getConnectedAffiliateProgram
    | getConnectedAffiliatePrograms
    | getBusinessFeatures
    | acceptTermsOfService
    | searchStringsByPrefix
    | sendCustomRequest
    | answerCustomQuery
    | setAlarm
    | getCountries
    | getCountryCode
    | getPhoneNumberInfo
    | getPhoneNumberInfoSync
    | getCollectibleItemInfo
    | getDeepLinkInfo
    | getApplicationConfig
    | saveApplicationLogEvent
    | getApplicationDownloadLink
    | addProxy
    | editProxy
    | enableProxy
    | disableProxy
    | removeProxy
    | getProxies
    | getProxyLink
    | pingProxy
    | setLogStream
    | getLogStream
    | setLogVerbosityLevel
    | getLogVerbosityLevel
    | getLogTags
    | setLogTagVerbosityLevel
    | getLogTagVerbosityLevel
    | addLogMessage
    | getUserSupportInfo
    | setUserSupportInfo
    | getSupportName
    | testCallEmpty
    | testCallString
    | testCallBytes
    | testCallVectorInt
    | testCallVectorIntObject
    | testCallVectorString
    | testCallVectorStringObject
    | testSquareInt
    | testNetwork
    | testProxy
    | testGetDifference
    | testUseUpdate
    | testReturnError

  declare export type $FunctionResultByName = {
    getAuthorizationState: AuthorizationState,
    setTdlibParameters: Ok,
    setAuthenticationPhoneNumber: Ok,
    setAuthenticationEmailAddress: Ok,
    resendAuthenticationCode: Ok,
    checkAuthenticationEmailCode: Ok,
    checkAuthenticationCode: Ok,
    requestQrCodeAuthentication: Ok,
    registerUser: Ok,
    resetAuthenticationEmailAddress: Ok,
    checkAuthenticationPassword: Ok,
    requestAuthenticationPasswordRecovery: Ok,
    checkAuthenticationPasswordRecoveryCode: Ok,
    recoverAuthenticationPassword: Ok,
    sendAuthenticationFirebaseSms: Ok,
    reportAuthenticationCodeMissing: Ok,
    checkAuthenticationBotToken: Ok,
    logOut: Ok,
    close: Ok,
    destroy: Ok,
    confirmQrCodeAuthentication: Session,
    getCurrentState: Updates,
    setDatabaseEncryptionKey: Ok,
    getPasswordState: PasswordState,
    setPassword: PasswordState,
    setLoginEmailAddress: EmailAddressAuthenticationCodeInfo,
    resendLoginEmailAddressCode: EmailAddressAuthenticationCodeInfo,
    checkLoginEmailAddressCode: Ok,
    getRecoveryEmailAddress: RecoveryEmailAddress,
    setRecoveryEmailAddress: PasswordState,
    checkRecoveryEmailAddressCode: PasswordState,
    resendRecoveryEmailAddressCode: PasswordState,
    cancelRecoveryEmailAddressVerification: PasswordState,
    requestPasswordRecovery: EmailAddressAuthenticationCodeInfo,
    checkPasswordRecoveryCode: Ok,
    recoverPassword: PasswordState,
    resetPassword: ResetPasswordResult,
    cancelPasswordReset: Ok,
    createTemporaryPassword: TemporaryPasswordState,
    getTemporaryPasswordState: TemporaryPasswordState,
    getMe: User,
    getUser: User,
    getUserFullInfo: UserFullInfo,
    getBasicGroup: BasicGroup,
    getBasicGroupFullInfo: BasicGroupFullInfo,
    getSupergroup: Supergroup,
    getSupergroupFullInfo: SupergroupFullInfo,
    getSecretChat: SecretChat,
    getChat: Chat,
    getMessage: Message,
    getMessageLocally: Message,
    getRepliedMessage: Message,
    getChatPinnedMessage: Message,
    getCallbackQueryMessage: Message,
    getMessages: Messages,
    getMessageProperties: MessageProperties,
    getMessageThread: MessageThreadInfo,
    getMessageReadDate: MessageReadDate,
    getMessageViewers: MessageViewers,
    getFile: File,
    getRemoteFile: File,
    loadChats: Ok,
    getChats: Chats,
    searchPublicChat: Chat,
    searchPublicChats: Chats,
    searchChats: Chats,
    searchChatsOnServer: Chats,
    getRecommendedChats: Chats,
    getChatSimilarChats: Chats,
    getChatSimilarChatCount: Count,
    openChatSimilarChat: Ok,
    getBotSimilarBots: Users,
    getBotSimilarBotCount: Count,
    openBotSimilarBot: Ok,
    getTopChats: Chats,
    removeTopChat: Ok,
    searchRecentlyFoundChats: Chats,
    addRecentlyFoundChat: Ok,
    removeRecentlyFoundChat: Ok,
    clearRecentlyFoundChats: Ok,
    getRecentlyOpenedChats: Chats,
    checkChatUsername: CheckChatUsernameResult,
    getCreatedPublicChats: Chats,
    checkCreatedPublicChatsLimit: Ok,
    getSuitableDiscussionChats: Chats,
    getInactiveSupergroupChats: Chats,
    getSuitablePersonalChats: Chats,
    loadSavedMessagesTopics: Ok,
    getSavedMessagesTopicHistory: Messages,
    getSavedMessagesTopicMessageByDate: Message,
    deleteSavedMessagesTopicHistory: Ok,
    deleteSavedMessagesTopicMessagesByDate: Ok,
    toggleSavedMessagesTopicIsPinned: Ok,
    setPinnedSavedMessagesTopics: Ok,
    getGroupsInCommon: Chats,
    getChatHistory: Messages,
    getMessageThreadHistory: Messages,
    deleteChatHistory: Ok,
    deleteChat: Ok,
    searchChatMessages: FoundChatMessages,
    searchMessages: FoundMessages,
    searchSecretMessages: FoundMessages,
    searchSavedMessages: FoundChatMessages,
    searchCallMessages: FoundMessages,
    searchOutgoingDocumentMessages: FoundMessages,
    searchPublicMessagesByTag: FoundMessages,
    searchPublicStoriesByTag: FoundStories,
    searchPublicStoriesByLocation: FoundStories,
    searchPublicStoriesByVenue: FoundStories,
    getSearchedForTags: Hashtags,
    removeSearchedForTag: Ok,
    clearSearchedForTags: Ok,
    deleteAllCallMessages: Ok,
    searchChatRecentLocationMessages: Messages,
    getChatMessageByDate: Message,
    getChatSparseMessagePositions: MessagePositions,
    getChatMessageCalendar: MessageCalendar,
    getChatMessageCount: Count,
    getChatMessagePosition: Count,
    getChatScheduledMessages: Messages,
    getChatSponsoredMessages: SponsoredMessages,
    clickChatSponsoredMessage: Ok,
    reportChatSponsoredMessage: ReportChatSponsoredMessageResult,
    removeNotification: Ok,
    removeNotificationGroup: Ok,
    getMessageLink: MessageLink,
    getMessageEmbeddingCode: Text,
    getMessageLinkInfo: MessageLinkInfo,
    translateText: FormattedText,
    translateMessageText: FormattedText,
    recognizeSpeech: Ok,
    rateSpeechRecognition: Ok,
    getChatAvailableMessageSenders: ChatMessageSenders,
    setChatMessageSender: Ok,
    sendMessage: Message,
    sendMessageAlbum: Messages,
    sendBotStartMessage: Message,
    sendInlineQueryResultMessage: Message,
    forwardMessages: Messages,
    sendQuickReplyShortcutMessages: Messages,
    resendMessages: Messages,
    addLocalMessage: Message,
    deleteMessages: Ok,
    deleteChatMessagesBySender: Ok,
    deleteChatMessagesByDate: Ok,
    editMessageText: Message,
    editMessageLiveLocation: Message,
    editMessageMedia: Message,
    editMessageCaption: Message,
    editMessageReplyMarkup: Message,
    editInlineMessageText: Ok,
    editInlineMessageLiveLocation: Ok,
    editInlineMessageMedia: Ok,
    editInlineMessageCaption: Ok,
    editInlineMessageReplyMarkup: Ok,
    editMessageSchedulingState: Ok,
    setMessageFactCheck: Ok,
    sendBusinessMessage: BusinessMessage,
    sendBusinessMessageAlbum: BusinessMessages,
    editBusinessMessageText: BusinessMessage,
    editBusinessMessageLiveLocation: BusinessMessage,
    editBusinessMessageMedia: BusinessMessage,
    editBusinessMessageCaption: BusinessMessage,
    editBusinessMessageReplyMarkup: BusinessMessage,
    stopBusinessPoll: BusinessMessage,
    setBusinessMessageIsPinned: Ok,
    checkQuickReplyShortcutName: Ok,
    loadQuickReplyShortcuts: Ok,
    setQuickReplyShortcutName: Ok,
    deleteQuickReplyShortcut: Ok,
    reorderQuickReplyShortcuts: Ok,
    loadQuickReplyShortcutMessages: Ok,
    deleteQuickReplyShortcutMessages: Ok,
    addQuickReplyShortcutMessage: QuickReplyMessage,
    addQuickReplyShortcutInlineQueryResultMessage: QuickReplyMessage,
    addQuickReplyShortcutMessageAlbum: QuickReplyMessages,
    readdQuickReplyShortcutMessages: QuickReplyMessages,
    editQuickReplyMessage: Ok,
    getForumTopicDefaultIcons: Stickers,
    createForumTopic: ForumTopicInfo,
    editForumTopic: Ok,
    getForumTopic: ForumTopic,
    getForumTopicLink: MessageLink,
    getForumTopics: ForumTopics,
    setForumTopicNotificationSettings: Ok,
    toggleForumTopicIsClosed: Ok,
    toggleGeneralForumTopicIsHidden: Ok,
    toggleForumTopicIsPinned: Ok,
    setPinnedForumTopics: Ok,
    deleteForumTopic: Ok,
    getEmojiReaction: EmojiReaction,
    getCustomEmojiReactionAnimations: Stickers,
    getMessageAvailableReactions: AvailableReactions,
    clearRecentReactions: Ok,
    addMessageReaction: Ok,
    removeMessageReaction: Ok,
    getChatAvailablePaidMessageReactionSenders: MessageSenders,
    addPendingPaidMessageReaction: Ok,
    commitPendingPaidMessageReactions: Ok,
    removePendingPaidMessageReactions: Ok,
    setPaidMessageReactionType: Ok,
    setMessageReactions: Ok,
    getMessageAddedReactions: AddedReactions,
    setDefaultReactionType: Ok,
    getSavedMessagesTags: SavedMessagesTags,
    setSavedMessagesTagLabel: Ok,
    getMessageEffect: MessageEffect,
    searchQuote: FoundPosition,
    getTextEntities: TextEntities,
    parseTextEntities: FormattedText,
    parseMarkdown: FormattedText,
    getMarkdownText: FormattedText,
    getCountryFlagEmoji: Text,
    getFileMimeType: Text,
    getFileExtension: Text,
    cleanFileName: Text,
    getLanguagePackString: LanguagePackStringValue,
    getJsonValue: JsonValue,
    getJsonString: Text,
    getThemeParametersJsonString: Text,
    setPollAnswer: Ok,
    getPollVoters: MessageSenders,
    stopPoll: Ok,
    hideSuggestedAction: Ok,
    hideContactCloseBirthdays: Ok,
    getBusinessConnection: BusinessConnection,
    getLoginUrlInfo: LoginUrlInfo,
    getLoginUrl: HttpUrl,
    shareUsersWithBot: Ok,
    shareChatWithBot: Ok,
    getInlineQueryResults: InlineQueryResults,
    answerInlineQuery: Ok,
    savePreparedInlineMessage: PreparedInlineMessageId,
    getPreparedInlineMessage: PreparedInlineMessage,
    getGrossingWebAppBots: FoundUsers,
    searchWebApp: FoundWebApp,
    getWebAppPlaceholder: Outline,
    getWebAppLinkUrl: HttpUrl,
    getMainWebApp: MainWebApp,
    getWebAppUrl: HttpUrl,
    sendWebAppData: Ok,
    openWebApp: WebAppInfo,
    closeWebApp: Ok,
    answerWebAppQuery: SentWebAppMessage,
    checkWebAppFileDownload: Ok,
    getCallbackQueryAnswer: CallbackQueryAnswer,
    answerCallbackQuery: Ok,
    answerShippingQuery: Ok,
    answerPreCheckoutQuery: Ok,
    setGameScore: Message,
    setInlineGameScore: Ok,
    getGameHighScores: GameHighScores,
    getInlineGameHighScores: GameHighScores,
    deleteChatReplyMarkup: Ok,
    sendChatAction: Ok,
    openChat: Ok,
    closeChat: Ok,
    viewMessages: Ok,
    openMessageContent: Ok,
    clickAnimatedEmojiMessage: Sticker,
    getInternalLink: HttpUrl,
    getInternalLinkType: InternalLinkType,
    getExternalLinkInfo: LoginUrlInfo,
    getExternalLink: HttpUrl,
    readAllChatMentions: Ok,
    readAllMessageThreadMentions: Ok,
    readAllChatReactions: Ok,
    readAllMessageThreadReactions: Ok,
    createPrivateChat: Chat,
    createBasicGroupChat: Chat,
    createSupergroupChat: Chat,
    createSecretChat: Chat,
    createNewBasicGroupChat: CreatedBasicGroupChat,
    createNewSupergroupChat: Chat,
    createNewSecretChat: Chat,
    upgradeBasicGroupChatToSupergroupChat: Chat,
    getChatListsToAddChat: ChatLists,
    addChatToList: Ok,
    getChatFolder: ChatFolder,
    createChatFolder: ChatFolderInfo,
    editChatFolder: ChatFolderInfo,
    deleteChatFolder: Ok,
    getChatFolderChatsToLeave: Chats,
    getChatFolderChatCount: Count,
    reorderChatFolders: Ok,
    toggleChatFolderTags: Ok,
    getRecommendedChatFolders: RecommendedChatFolders,
    getChatFolderDefaultIconName: ChatFolderIcon,
    getChatsForChatFolderInviteLink: Chats,
    createChatFolderInviteLink: ChatFolderInviteLink,
    getChatFolderInviteLinks: ChatFolderInviteLinks,
    editChatFolderInviteLink: ChatFolderInviteLink,
    deleteChatFolderInviteLink: Ok,
    checkChatFolderInviteLink: ChatFolderInviteLinkInfo,
    addChatFolderByInviteLink: Ok,
    getChatFolderNewChats: Chats,
    processChatFolderNewChats: Ok,
    getArchiveChatListSettings: ArchiveChatListSettings,
    setArchiveChatListSettings: Ok,
    setChatTitle: Ok,
    setChatPhoto: Ok,
    setChatAccentColor: Ok,
    setChatProfileAccentColor: Ok,
    setChatMessageAutoDeleteTime: Ok,
    setChatEmojiStatus: Ok,
    setChatPermissions: Ok,
    setChatBackground: Ok,
    deleteChatBackground: Ok,
    setChatTheme: Ok,
    setChatDraftMessage: Ok,
    setChatNotificationSettings: Ok,
    toggleChatHasProtectedContent: Ok,
    toggleChatViewAsTopics: Ok,
    toggleChatIsTranslatable: Ok,
    toggleChatIsMarkedAsUnread: Ok,
    toggleChatDefaultDisableNotification: Ok,
    setChatAvailableReactions: Ok,
    setChatClientData: Ok,
    setChatDescription: Ok,
    setChatDiscussionGroup: Ok,
    setChatLocation: Ok,
    setChatSlowModeDelay: Ok,
    pinChatMessage: Ok,
    unpinChatMessage: Ok,
    unpinAllChatMessages: Ok,
    unpinAllMessageThreadMessages: Ok,
    joinChat: Ok,
    leaveChat: Ok,
    addChatMember: FailedToAddMembers,
    addChatMembers: FailedToAddMembers,
    setChatMemberStatus: Ok,
    banChatMember: Ok,
    canTransferOwnership: CanTransferOwnershipResult,
    transferChatOwnership: Ok,
    getChatMember: ChatMember,
    searchChatMembers: ChatMembers,
    getChatAdministrators: ChatAdministrators,
    clearAllDraftMessages: Ok,
    getSavedNotificationSound: NotificationSounds,
    getSavedNotificationSounds: NotificationSounds,
    addSavedNotificationSound: NotificationSound,
    removeSavedNotificationSound: Ok,
    getChatNotificationSettingsExceptions: Chats,
    getScopeNotificationSettings: ScopeNotificationSettings,
    setScopeNotificationSettings: Ok,
    setReactionNotificationSettings: Ok,
    resetAllNotificationSettings: Ok,
    toggleChatIsPinned: Ok,
    setPinnedChats: Ok,
    readChatList: Ok,
    getCurrentWeather: CurrentWeather,
    getStory: Story,
    getChatsToSendStories: Chats,
    canSendStory: CanSendStoryResult,
    sendStory: Story,
    editStory: Ok,
    editStoryCover: Ok,
    setStoryPrivacySettings: Ok,
    toggleStoryIsPostedToChatPage: Ok,
    deleteStory: Ok,
    getStoryNotificationSettingsExceptions: Chats,
    loadActiveStories: Ok,
    setChatActiveStoriesList: Ok,
    getChatActiveStories: ChatActiveStories,
    getChatPostedToChatPageStories: Stories,
    getChatArchivedStories: Stories,
    setChatPinnedStories: Ok,
    openStory: Ok,
    closeStory: Ok,
    getStoryAvailableReactions: AvailableReactions,
    setStoryReaction: Ok,
    getStoryInteractions: StoryInteractions,
    getChatStoryInteractions: StoryInteractions,
    reportStory: ReportStoryResult,
    activateStoryStealthMode: Ok,
    getStoryPublicForwards: PublicForwards,
    getChatBoostLevelFeatures: ChatBoostLevelFeatures,
    getChatBoostFeatures: ChatBoostFeatures,
    getAvailableChatBoostSlots: ChatBoostSlots,
    getChatBoostStatus: ChatBoostStatus,
    boostChat: ChatBoostSlots,
    getChatBoostLink: ChatBoostLink,
    getChatBoostLinkInfo: ChatBoostLinkInfo,
    getChatBoosts: FoundChatBoosts,
    getUserChatBoosts: FoundChatBoosts,
    getAttachmentMenuBot: AttachmentMenuBot,
    toggleBotIsAddedToAttachmentMenu: Ok,
    getThemedEmojiStatuses: EmojiStatusCustomEmojis,
    getRecentEmojiStatuses: EmojiStatuses,
    getUpgradedGiftEmojiStatuses: EmojiStatuses,
    getDefaultEmojiStatuses: EmojiStatusCustomEmojis,
    clearRecentEmojiStatuses: Ok,
    getThemedChatEmojiStatuses: EmojiStatusCustomEmojis,
    getDefaultChatEmojiStatuses: EmojiStatusCustomEmojis,
    getDisallowedChatEmojiStatuses: EmojiStatusCustomEmojis,
    downloadFile: File,
    getFileDownloadedPrefixSize: FileDownloadedPrefixSize,
    cancelDownloadFile: Ok,
    getSuggestedFileName: Text,
    preliminaryUploadFile: File,
    cancelPreliminaryUploadFile: Ok,
    writeGeneratedFilePart: Ok,
    setFileGenerationProgress: Ok,
    finishFileGeneration: Ok,
    readFilePart: FilePart,
    deleteFile: Ok,
    addFileToDownloads: File,
    toggleDownloadIsPaused: Ok,
    toggleAllDownloadsArePaused: Ok,
    removeFileFromDownloads: Ok,
    removeAllFilesFromDownloads: Ok,
    searchFileDownloads: FoundFileDownloads,
    setApplicationVerificationToken: Ok,
    getMessageFileType: MessageFileType,
    getMessageImportConfirmationText: Text,
    importMessages: Ok,
    replacePrimaryChatInviteLink: ChatInviteLink,
    createChatInviteLink: ChatInviteLink,
    createChatSubscriptionInviteLink: ChatInviteLink,
    editChatInviteLink: ChatInviteLink,
    editChatSubscriptionInviteLink: ChatInviteLink,
    getChatInviteLink: ChatInviteLink,
    getChatInviteLinkCounts: ChatInviteLinkCounts,
    getChatInviteLinks: ChatInviteLinks,
    getChatInviteLinkMembers: ChatInviteLinkMembers,
    revokeChatInviteLink: ChatInviteLinks,
    deleteRevokedChatInviteLink: Ok,
    deleteAllRevokedChatInviteLinks: Ok,
    checkChatInviteLink: ChatInviteLinkInfo,
    joinChatByInviteLink: Chat,
    getChatJoinRequests: ChatJoinRequests,
    processChatJoinRequest: Ok,
    processChatJoinRequests: Ok,
    createCall: CallId,
    acceptCall: Ok,
    sendCallSignalingData: Ok,
    discardCall: Ok,
    sendCallRating: Ok,
    sendCallDebugInformation: Ok,
    sendCallLog: Ok,
    getVideoChatAvailableParticipants: MessageSenders,
    setVideoChatDefaultParticipant: Ok,
    createVideoChat: GroupCallId,
    createGroupCall: Ok,
    getVideoChatRtmpUrl: RtmpUrl,
    replaceVideoChatRtmpUrl: RtmpUrl,
    getGroupCall: GroupCall,
    startScheduledGroupCall: Ok,
    toggleGroupCallEnabledStartNotification: Ok,
    joinGroupCall: Text,
    startGroupCallScreenSharing: Text,
    toggleGroupCallScreenSharingIsPaused: Ok,
    endGroupCallScreenSharing: Ok,
    setGroupCallTitle: Ok,
    toggleGroupCallMuteNewParticipants: Ok,
    inviteGroupCallParticipants: Ok,
    getGroupCallInviteLink: HttpUrl,
    revokeGroupCallInviteLink: Ok,
    startGroupCallRecording: Ok,
    endGroupCallRecording: Ok,
    toggleGroupCallIsMyVideoPaused: Ok,
    toggleGroupCallIsMyVideoEnabled: Ok,
    setGroupCallParticipantIsSpeaking: Ok,
    toggleGroupCallParticipantIsMuted: Ok,
    setGroupCallParticipantVolumeLevel: Ok,
    toggleGroupCallParticipantIsHandRaised: Ok,
    loadGroupCallParticipants: Ok,
    leaveGroupCall: Ok,
    endGroupCall: Ok,
    getGroupCallStreams: GroupCallStreams,
    getGroupCallStreamSegment: FilePart,
    setMessageSenderBlockList: Ok,
    blockMessageSenderFromReplies: Ok,
    getBlockedMessageSenders: MessageSenders,
    addContact: Ok,
    importContacts: ImportedContacts,
    getContacts: Users,
    searchContacts: Users,
    removeContacts: Ok,
    getImportedContactCount: Count,
    changeImportedContacts: ImportedContacts,
    clearImportedContacts: Ok,
    setCloseFriends: Ok,
    getCloseFriends: Users,
    setUserPersonalProfilePhoto: Ok,
    suggestUserProfilePhoto: Ok,
    toggleBotCanManageEmojiStatus: Ok,
    setUserEmojiStatus: Ok,
    searchUserByPhoneNumber: User,
    sharePhoneNumber: Ok,
    getUserProfilePhotos: ChatPhotos,
    getStickerOutline: Outline,
    getStickers: Stickers,
    getAllStickerEmojis: Emojis,
    searchStickers: Stickers,
    getGreetingStickers: Stickers,
    getPremiumStickers: Stickers,
    getInstalledStickerSets: StickerSets,
    getArchivedStickerSets: StickerSets,
    getTrendingStickerSets: TrendingStickerSets,
    getAttachedStickerSets: StickerSets,
    getStickerSet: StickerSet,
    getStickerSetName: Text,
    searchStickerSet: StickerSet,
    searchInstalledStickerSets: StickerSets,
    searchStickerSets: StickerSets,
    changeStickerSet: Ok,
    viewTrendingStickerSets: Ok,
    reorderInstalledStickerSets: Ok,
    getRecentStickers: Stickers,
    addRecentSticker: Stickers,
    removeRecentSticker: Ok,
    clearRecentStickers: Ok,
    getFavoriteStickers: Stickers,
    addFavoriteSticker: Ok,
    removeFavoriteSticker: Ok,
    getStickerEmojis: Emojis,
    searchEmojis: EmojiKeywords,
    getKeywordEmojis: Emojis,
    getEmojiCategories: EmojiCategories,
    getAnimatedEmoji: AnimatedEmoji,
    getEmojiSuggestionsUrl: HttpUrl,
    getCustomEmojiStickers: Stickers,
    getDefaultChatPhotoCustomEmojiStickers: Stickers,
    getDefaultProfilePhotoCustomEmojiStickers: Stickers,
    getDefaultBackgroundCustomEmojiStickers: Stickers,
    getSavedAnimations: Animations,
    addSavedAnimation: Ok,
    removeSavedAnimation: Ok,
    getRecentInlineBots: Users,
    getOwnedBots: Users,
    searchHashtags: Hashtags,
    removeRecentHashtag: Ok,
    getLinkPreview: LinkPreview,
    getWebPageInstantView: WebPageInstantView,
    setProfilePhoto: Ok,
    deleteProfilePhoto: Ok,
    setAccentColor: Ok,
    setProfileAccentColor: Ok,
    setName: Ok,
    setBio: Ok,
    setUsername: Ok,
    toggleUsernameIsActive: Ok,
    reorderActiveUsernames: Ok,
    setBirthdate: Ok,
    setPersonalChat: Ok,
    setEmojiStatus: Ok,
    toggleHasSponsoredMessagesEnabled: Ok,
    setBusinessLocation: Ok,
    setBusinessOpeningHours: Ok,
    setBusinessGreetingMessageSettings: Ok,
    setBusinessAwayMessageSettings: Ok,
    setBusinessStartPage: Ok,
    sendPhoneNumberCode: AuthenticationCodeInfo,
    sendPhoneNumberFirebaseSms: Ok,
    reportPhoneNumberCodeMissing: Ok,
    resendPhoneNumberCode: AuthenticationCodeInfo,
    checkPhoneNumberCode: Ok,
    getBusinessConnectedBot: BusinessConnectedBot,
    setBusinessConnectedBot: Ok,
    deleteBusinessConnectedBot: Ok,
    toggleBusinessConnectedBotChatIsPaused: Ok,
    removeBusinessConnectedBotFromChat: Ok,
    getBusinessChatLinks: BusinessChatLinks,
    createBusinessChatLink: BusinessChatLink,
    editBusinessChatLink: BusinessChatLink,
    deleteBusinessChatLink: Ok,
    getBusinessChatLinkInfo: BusinessChatLinkInfo,
    getUserLink: UserLink,
    searchUserByToken: User,
    setCommands: Ok,
    deleteCommands: Ok,
    getCommands: BotCommands,
    setMenuButton: Ok,
    getMenuButton: BotMenuButton,
    setDefaultGroupAdministratorRights: Ok,
    setDefaultChannelAdministratorRights: Ok,
    canBotSendMessages: Ok,
    allowBotToSendMessages: Ok,
    sendWebAppCustomRequest: CustomRequestResult,
    getBotMediaPreviews: BotMediaPreviews,
    getBotMediaPreviewInfo: BotMediaPreviewInfo,
    addBotMediaPreview: BotMediaPreview,
    editBotMediaPreview: BotMediaPreview,
    reorderBotMediaPreviews: Ok,
    deleteBotMediaPreviews: Ok,
    setBotName: Ok,
    getBotName: Text,
    setBotProfilePhoto: Ok,
    toggleBotUsernameIsActive: Ok,
    reorderBotActiveUsernames: Ok,
    setBotInfoDescription: Ok,
    getBotInfoDescription: Text,
    setBotInfoShortDescription: Ok,
    getBotInfoShortDescription: Text,
    setMessageSenderBotVerification: Ok,
    removeMessageSenderBotVerification: Ok,
    getActiveSessions: Sessions,
    terminateSession: Ok,
    terminateAllOtherSessions: Ok,
    confirmSession: Ok,
    toggleSessionCanAcceptCalls: Ok,
    toggleSessionCanAcceptSecretChats: Ok,
    setInactiveSessionTtl: Ok,
    getConnectedWebsites: ConnectedWebsites,
    disconnectWebsite: Ok,
    disconnectAllWebsites: Ok,
    setSupergroupUsername: Ok,
    toggleSupergroupUsernameIsActive: Ok,
    disableAllSupergroupUsernames: Ok,
    reorderSupergroupActiveUsernames: Ok,
    setSupergroupStickerSet: Ok,
    setSupergroupCustomEmojiStickerSet: Ok,
    setSupergroupUnrestrictBoostCount: Ok,
    toggleSupergroupSignMessages: Ok,
    toggleSupergroupJoinToSendMessages: Ok,
    toggleSupergroupJoinByRequest: Ok,
    toggleSupergroupIsAllHistoryAvailable: Ok,
    toggleSupergroupCanHaveSponsoredMessages: Ok,
    toggleSupergroupHasHiddenMembers: Ok,
    toggleSupergroupHasAggressiveAntiSpamEnabled: Ok,
    toggleSupergroupIsForum: Ok,
    toggleSupergroupIsBroadcastGroup: Ok,
    reportSupergroupSpam: Ok,
    reportSupergroupAntiSpamFalsePositive: Ok,
    getSupergroupMembers: ChatMembers,
    closeSecretChat: Ok,
    getChatEventLog: ChatEvents,
    getTimeZones: TimeZones,
    getPaymentForm: PaymentForm,
    validateOrderInfo: ValidatedOrderInfo,
    sendPaymentForm: PaymentResult,
    getPaymentReceipt: PaymentReceipt,
    getSavedOrderInfo: OrderInfo,
    deleteSavedOrderInfo: Ok,
    deleteSavedCredentials: Ok,
    getAvailableGifts: Gifts,
    sendGift: Ok,
    sellGift: Ok,
    toggleGiftIsSaved: Ok,
    setPinnedGifts: Ok,
    toggleChatGiftNotifications: Ok,
    getGiftUpgradePreview: GiftUpgradePreview,
    upgradeGift: UpgradeGiftResult,
    transferGift: Ok,
    getReceivedGifts: ReceivedGifts,
    getReceivedGift: ReceivedGift,
    getUpgradedGift: UpgradedGift,
    getUpgradedGiftWithdrawalUrl: HttpUrl,
    createInvoiceLink: HttpUrl,
    refundStarPayment: Ok,
    getSupportUser: User,
    getBackgroundUrl: HttpUrl,
    searchBackground: Background,
    setDefaultBackground: Background,
    deleteDefaultBackground: Ok,
    getInstalledBackgrounds: Backgrounds,
    removeInstalledBackground: Ok,
    resetInstalledBackgrounds: Ok,
    getLocalizationTargetInfo: LocalizationTargetInfo,
    getLanguagePackInfo: LanguagePackInfo,
    getLanguagePackStrings: LanguagePackStrings,
    synchronizeLanguagePack: Ok,
    addCustomServerLanguagePack: Ok,
    setCustomLanguagePack: Ok,
    editCustomLanguagePackInfo: Ok,
    setCustomLanguagePackString: Ok,
    deleteLanguagePack: Ok,
    registerDevice: PushReceiverId,
    processPushNotification: Ok,
    getPushReceiverId: PushReceiverId,
    getRecentlyVisitedTMeUrls: TMeUrls,
    setUserPrivacySettingRules: Ok,
    getUserPrivacySettingRules: UserPrivacySettingRules,
    setReadDatePrivacySettings: Ok,
    getReadDatePrivacySettings: ReadDatePrivacySettings,
    setNewChatPrivacySettings: Ok,
    getNewChatPrivacySettings: NewChatPrivacySettings,
    getPaidMessageRevenue: StarCount,
    allowUnpaidMessagesFromUser: Ok,
    setChatPaidMessageStarCount: Ok,
    canSendMessageToUser: CanSendMessageToUserResult,
    getOption: OptionValue,
    setOption: Ok,
    setAccountTtl: Ok,
    getAccountTtl: AccountTtl,
    deleteAccount: Ok,
    setDefaultMessageAutoDeleteTime: Ok,
    getDefaultMessageAutoDeleteTime: MessageAutoDeleteTime,
    removeChatActionBar: Ok,
    reportChat: ReportChatResult,
    reportChatPhoto: Ok,
    reportMessageReactions: Ok,
    getChatRevenueStatistics: ChatRevenueStatistics,
    getChatRevenueWithdrawalUrl: HttpUrl,
    getChatRevenueTransactions: ChatRevenueTransactions,
    getStarRevenueStatistics: StarRevenueStatistics,
    getStarWithdrawalUrl: HttpUrl,
    getStarAdAccountUrl: HttpUrl,
    getChatStatistics: ChatStatistics,
    getMessageStatistics: MessageStatistics,
    getMessagePublicForwards: PublicForwards,
    getStoryStatistics: StoryStatistics,
    getStatisticalGraph: StatisticalGraph,
    getStorageStatistics: StorageStatistics,
    getStorageStatisticsFast: StorageStatisticsFast,
    getDatabaseStatistics: DatabaseStatistics,
    optimizeStorage: StorageStatistics,
    setNetworkType: Ok,
    getNetworkStatistics: NetworkStatistics,
    addNetworkStatistics: Ok,
    resetNetworkStatistics: Ok,
    getAutoDownloadSettingsPresets: AutoDownloadSettingsPresets,
    setAutoDownloadSettings: Ok,
    getAutosaveSettings: AutosaveSettings,
    setAutosaveSettings: Ok,
    clearAutosaveSettingsExceptions: Ok,
    getBankCardInfo: BankCardInfo,
    getPassportElement: PassportElement,
    getAllPassportElements: PassportElements,
    setPassportElement: PassportElement,
    deletePassportElement: Ok,
    setPassportElementErrors: Ok,
    getPreferredCountryLanguage: Text,
    sendEmailAddressVerificationCode: EmailAddressAuthenticationCodeInfo,
    resendEmailAddressVerificationCode: EmailAddressAuthenticationCodeInfo,
    checkEmailAddressVerificationCode: Ok,
    getPassportAuthorizationForm: PassportAuthorizationForm,
    getPassportAuthorizationFormAvailableElements: PassportElementsWithErrors,
    sendPassportAuthorizationForm: Ok,
    setBotUpdatesStatus: Ok,
    uploadStickerFile: File,
    getSuggestedStickerSetName: Text,
    checkStickerSetName: CheckStickerSetNameResult,
    createNewStickerSet: StickerSet,
    addStickerToSet: Ok,
    replaceStickerInSet: Ok,
    setStickerSetThumbnail: Ok,
    setCustomEmojiStickerSetThumbnail: Ok,
    setStickerSetTitle: Ok,
    deleteStickerSet: Ok,
    setStickerPositionInSet: Ok,
    removeStickerFromSet: Ok,
    setStickerEmojis: Ok,
    setStickerKeywords: Ok,
    setStickerMaskPosition: Ok,
    getOwnedStickerSets: StickerSets,
    getMapThumbnailFile: File,
    getPremiumLimit: PremiumLimit,
    getPremiumFeatures: PremiumFeatures,
    getPremiumStickerExamples: Stickers,
    getPremiumInfoSticker: Sticker,
    viewPremiumFeature: Ok,
    clickPremiumSubscriptionButton: Ok,
    getPremiumState: PremiumState,
    getPremiumGiftPaymentOptions: PremiumGiftPaymentOptions,
    getPremiumGiveawayPaymentOptions: PremiumGiveawayPaymentOptions,
    checkPremiumGiftCode: PremiumGiftCodeInfo,
    applyPremiumGiftCode: Ok,
    launchPrepaidGiveaway: Ok,
    getGiveawayInfo: GiveawayInfo,
    getStarPaymentOptions: StarPaymentOptions,
    getStarGiftPaymentOptions: StarPaymentOptions,
    getStarGiveawayPaymentOptions: StarGiveawayPaymentOptions,
    getStarTransactions: StarTransactions,
    getStarSubscriptions: StarSubscriptions,
    canPurchaseFromStore: Ok,
    assignAppStoreTransaction: Ok,
    assignGooglePlayTransaction: Ok,
    editStarSubscription: Ok,
    editUserStarSubscription: Ok,
    reuseStarSubscription: Ok,
    setChatAffiliateProgram: Ok,
    searchChatAffiliateProgram: Chat,
    searchAffiliatePrograms: FoundAffiliatePrograms,
    connectAffiliateProgram: ConnectedAffiliateProgram,
    disconnectAffiliateProgram: ConnectedAffiliateProgram,
    getConnectedAffiliateProgram: ConnectedAffiliateProgram,
    getConnectedAffiliatePrograms: ConnectedAffiliatePrograms,
    getBusinessFeatures: BusinessFeatures,
    acceptTermsOfService: Ok,
    searchStringsByPrefix: FoundPositions,
    sendCustomRequest: CustomRequestResult,
    answerCustomQuery: Ok,
    setAlarm: Ok,
    getCountries: Countries,
    getCountryCode: Text,
    getPhoneNumberInfo: PhoneNumberInfo,
    getPhoneNumberInfoSync: PhoneNumberInfo,
    getCollectibleItemInfo: CollectibleItemInfo,
    getDeepLinkInfo: DeepLinkInfo,
    getApplicationConfig: JsonValue,
    saveApplicationLogEvent: Ok,
    getApplicationDownloadLink: HttpUrl,
    addProxy: Proxy,
    editProxy: Proxy,
    enableProxy: Ok,
    disableProxy: Ok,
    removeProxy: Ok,
    getProxies: Proxies,
    getProxyLink: HttpUrl,
    pingProxy: Seconds,
    setLogStream: Ok,
    getLogStream: LogStream,
    setLogVerbosityLevel: Ok,
    getLogVerbosityLevel: LogVerbosityLevel,
    getLogTags: LogTags,
    setLogTagVerbosityLevel: Ok,
    getLogTagVerbosityLevel: LogVerbosityLevel,
    addLogMessage: Ok,
    getUserSupportInfo: UserSupportInfo,
    setUserSupportInfo: UserSupportInfo,
    getSupportName: Text,
    testCallEmpty: Ok,
    testCallString: TestString,
    testCallBytes: TestBytes,
    testCallVectorInt: TestVectorInt,
    testCallVectorIntObject: TestVectorIntObject,
    testCallVectorString: TestVectorString,
    testCallVectorStringObject: TestVectorStringObject,
    testSquareInt: TestInt,
    testNetwork: Ok,
    testProxy: Ok,
    testGetDifference: Ok,
    testUseUpdate: Update,
    testReturnError: Error,
  }

  declare export type $FunctionInputByName = {
    getAuthorizationState: getAuthorizationState,
    setTdlibParameters: setTdlibParameters,
    setAuthenticationPhoneNumber: setAuthenticationPhoneNumber,
    setAuthenticationEmailAddress: setAuthenticationEmailAddress,
    resendAuthenticationCode: resendAuthenticationCode,
    checkAuthenticationEmailCode: checkAuthenticationEmailCode,
    checkAuthenticationCode: checkAuthenticationCode,
    requestQrCodeAuthentication: requestQrCodeAuthentication,
    registerUser: registerUser,
    resetAuthenticationEmailAddress: resetAuthenticationEmailAddress,
    checkAuthenticationPassword: checkAuthenticationPassword,
    requestAuthenticationPasswordRecovery: requestAuthenticationPasswordRecovery,
    checkAuthenticationPasswordRecoveryCode: checkAuthenticationPasswordRecoveryCode,
    recoverAuthenticationPassword: recoverAuthenticationPassword,
    sendAuthenticationFirebaseSms: sendAuthenticationFirebaseSms,
    reportAuthenticationCodeMissing: reportAuthenticationCodeMissing,
    checkAuthenticationBotToken: checkAuthenticationBotToken,
    logOut: logOut,
    close: close,
    destroy: destroy,
    confirmQrCodeAuthentication: confirmQrCodeAuthentication,
    getCurrentState: getCurrentState,
    setDatabaseEncryptionKey: setDatabaseEncryptionKey,
    getPasswordState: getPasswordState,
    setPassword: setPassword,
    setLoginEmailAddress: setLoginEmailAddress,
    resendLoginEmailAddressCode: resendLoginEmailAddressCode,
    checkLoginEmailAddressCode: checkLoginEmailAddressCode,
    getRecoveryEmailAddress: getRecoveryEmailAddress,
    setRecoveryEmailAddress: setRecoveryEmailAddress,
    checkRecoveryEmailAddressCode: checkRecoveryEmailAddressCode,
    resendRecoveryEmailAddressCode: resendRecoveryEmailAddressCode,
    cancelRecoveryEmailAddressVerification: cancelRecoveryEmailAddressVerification,
    requestPasswordRecovery: requestPasswordRecovery,
    checkPasswordRecoveryCode: checkPasswordRecoveryCode,
    recoverPassword: recoverPassword,
    resetPassword: resetPassword,
    cancelPasswordReset: cancelPasswordReset,
    createTemporaryPassword: createTemporaryPassword,
    getTemporaryPasswordState: getTemporaryPasswordState,
    getMe: getMe,
    getUser: getUser,
    getUserFullInfo: getUserFullInfo,
    getBasicGroup: getBasicGroup,
    getBasicGroupFullInfo: getBasicGroupFullInfo,
    getSupergroup: getSupergroup,
    getSupergroupFullInfo: getSupergroupFullInfo,
    getSecretChat: getSecretChat,
    getChat: getChat,
    getMessage: getMessage,
    getMessageLocally: getMessageLocally,
    getRepliedMessage: getRepliedMessage,
    getChatPinnedMessage: getChatPinnedMessage,
    getCallbackQueryMessage: getCallbackQueryMessage,
    getMessages: getMessages,
    getMessageProperties: getMessageProperties,
    getMessageThread: getMessageThread,
    getMessageReadDate: getMessageReadDate,
    getMessageViewers: getMessageViewers,
    getFile: getFile,
    getRemoteFile: getRemoteFile,
    loadChats: loadChats,
    getChats: getChats,
    searchPublicChat: searchPublicChat,
    searchPublicChats: searchPublicChats,
    searchChats: searchChats,
    searchChatsOnServer: searchChatsOnServer,
    getRecommendedChats: getRecommendedChats,
    getChatSimilarChats: getChatSimilarChats,
    getChatSimilarChatCount: getChatSimilarChatCount,
    openChatSimilarChat: openChatSimilarChat,
    getBotSimilarBots: getBotSimilarBots,
    getBotSimilarBotCount: getBotSimilarBotCount,
    openBotSimilarBot: openBotSimilarBot,
    getTopChats: getTopChats,
    removeTopChat: removeTopChat,
    searchRecentlyFoundChats: searchRecentlyFoundChats,
    addRecentlyFoundChat: addRecentlyFoundChat,
    removeRecentlyFoundChat: removeRecentlyFoundChat,
    clearRecentlyFoundChats: clearRecentlyFoundChats,
    getRecentlyOpenedChats: getRecentlyOpenedChats,
    checkChatUsername: checkChatUsername,
    getCreatedPublicChats: getCreatedPublicChats,
    checkCreatedPublicChatsLimit: checkCreatedPublicChatsLimit,
    getSuitableDiscussionChats: getSuitableDiscussionChats,
    getInactiveSupergroupChats: getInactiveSupergroupChats,
    getSuitablePersonalChats: getSuitablePersonalChats,
    loadSavedMessagesTopics: loadSavedMessagesTopics,
    getSavedMessagesTopicHistory: getSavedMessagesTopicHistory,
    getSavedMessagesTopicMessageByDate: getSavedMessagesTopicMessageByDate,
    deleteSavedMessagesTopicHistory: deleteSavedMessagesTopicHistory,
    deleteSavedMessagesTopicMessagesByDate: deleteSavedMessagesTopicMessagesByDate,
    toggleSavedMessagesTopicIsPinned: toggleSavedMessagesTopicIsPinned,
    setPinnedSavedMessagesTopics: setPinnedSavedMessagesTopics,
    getGroupsInCommon: getGroupsInCommon,
    getChatHistory: getChatHistory,
    getMessageThreadHistory: getMessageThreadHistory,
    deleteChatHistory: deleteChatHistory,
    deleteChat: deleteChat,
    searchChatMessages: searchChatMessages,
    searchMessages: searchMessages,
    searchSecretMessages: searchSecretMessages,
    searchSavedMessages: searchSavedMessages,
    searchCallMessages: searchCallMessages,
    searchOutgoingDocumentMessages: searchOutgoingDocumentMessages,
    searchPublicMessagesByTag: searchPublicMessagesByTag,
    searchPublicStoriesByTag: searchPublicStoriesByTag,
    searchPublicStoriesByLocation: searchPublicStoriesByLocation,
    searchPublicStoriesByVenue: searchPublicStoriesByVenue,
    getSearchedForTags: getSearchedForTags,
    removeSearchedForTag: removeSearchedForTag,
    clearSearchedForTags: clearSearchedForTags,
    deleteAllCallMessages: deleteAllCallMessages,
    searchChatRecentLocationMessages: searchChatRecentLocationMessages,
    getChatMessageByDate: getChatMessageByDate,
    getChatSparseMessagePositions: getChatSparseMessagePositions,
    getChatMessageCalendar: getChatMessageCalendar,
    getChatMessageCount: getChatMessageCount,
    getChatMessagePosition: getChatMessagePosition,
    getChatScheduledMessages: getChatScheduledMessages,
    getChatSponsoredMessages: getChatSponsoredMessages,
    clickChatSponsoredMessage: clickChatSponsoredMessage,
    reportChatSponsoredMessage: reportChatSponsoredMessage,
    removeNotification: removeNotification,
    removeNotificationGroup: removeNotificationGroup,
    getMessageLink: getMessageLink,
    getMessageEmbeddingCode: getMessageEmbeddingCode,
    getMessageLinkInfo: getMessageLinkInfo,
    translateText: translateText,
    translateMessageText: translateMessageText,
    recognizeSpeech: recognizeSpeech,
    rateSpeechRecognition: rateSpeechRecognition,
    getChatAvailableMessageSenders: getChatAvailableMessageSenders,
    setChatMessageSender: setChatMessageSender,
    sendMessage: sendMessage,
    sendMessageAlbum: sendMessageAlbum,
    sendBotStartMessage: sendBotStartMessage,
    sendInlineQueryResultMessage: sendInlineQueryResultMessage,
    forwardMessages: forwardMessages,
    sendQuickReplyShortcutMessages: sendQuickReplyShortcutMessages,
    resendMessages: resendMessages,
    addLocalMessage: addLocalMessage,
    deleteMessages: deleteMessages,
    deleteChatMessagesBySender: deleteChatMessagesBySender,
    deleteChatMessagesByDate: deleteChatMessagesByDate,
    editMessageText: editMessageText,
    editMessageLiveLocation: editMessageLiveLocation,
    editMessageMedia: editMessageMedia,
    editMessageCaption: editMessageCaption,
    editMessageReplyMarkup: editMessageReplyMarkup,
    editInlineMessageText: editInlineMessageText,
    editInlineMessageLiveLocation: editInlineMessageLiveLocation,
    editInlineMessageMedia: editInlineMessageMedia,
    editInlineMessageCaption: editInlineMessageCaption,
    editInlineMessageReplyMarkup: editInlineMessageReplyMarkup,
    editMessageSchedulingState: editMessageSchedulingState,
    setMessageFactCheck: setMessageFactCheck,
    sendBusinessMessage: sendBusinessMessage,
    sendBusinessMessageAlbum: sendBusinessMessageAlbum,
    editBusinessMessageText: editBusinessMessageText,
    editBusinessMessageLiveLocation: editBusinessMessageLiveLocation,
    editBusinessMessageMedia: editBusinessMessageMedia,
    editBusinessMessageCaption: editBusinessMessageCaption,
    editBusinessMessageReplyMarkup: editBusinessMessageReplyMarkup,
    stopBusinessPoll: stopBusinessPoll,
    setBusinessMessageIsPinned: setBusinessMessageIsPinned,
    checkQuickReplyShortcutName: checkQuickReplyShortcutName,
    loadQuickReplyShortcuts: loadQuickReplyShortcuts,
    setQuickReplyShortcutName: setQuickReplyShortcutName,
    deleteQuickReplyShortcut: deleteQuickReplyShortcut,
    reorderQuickReplyShortcuts: reorderQuickReplyShortcuts,
    loadQuickReplyShortcutMessages: loadQuickReplyShortcutMessages,
    deleteQuickReplyShortcutMessages: deleteQuickReplyShortcutMessages,
    addQuickReplyShortcutMessage: addQuickReplyShortcutMessage,
    addQuickReplyShortcutInlineQueryResultMessage: addQuickReplyShortcutInlineQueryResultMessage,
    addQuickReplyShortcutMessageAlbum: addQuickReplyShortcutMessageAlbum,
    readdQuickReplyShortcutMessages: readdQuickReplyShortcutMessages,
    editQuickReplyMessage: editQuickReplyMessage,
    getForumTopicDefaultIcons: getForumTopicDefaultIcons,
    createForumTopic: createForumTopic,
    editForumTopic: editForumTopic,
    getForumTopic: getForumTopic,
    getForumTopicLink: getForumTopicLink,
    getForumTopics: getForumTopics,
    setForumTopicNotificationSettings: setForumTopicNotificationSettings,
    toggleForumTopicIsClosed: toggleForumTopicIsClosed,
    toggleGeneralForumTopicIsHidden: toggleGeneralForumTopicIsHidden,
    toggleForumTopicIsPinned: toggleForumTopicIsPinned,
    setPinnedForumTopics: setPinnedForumTopics,
    deleteForumTopic: deleteForumTopic,
    getEmojiReaction: getEmojiReaction,
    getCustomEmojiReactionAnimations: getCustomEmojiReactionAnimations,
    getMessageAvailableReactions: getMessageAvailableReactions,
    clearRecentReactions: clearRecentReactions,
    addMessageReaction: addMessageReaction,
    removeMessageReaction: removeMessageReaction,
    getChatAvailablePaidMessageReactionSenders: getChatAvailablePaidMessageReactionSenders,
    addPendingPaidMessageReaction: addPendingPaidMessageReaction,
    commitPendingPaidMessageReactions: commitPendingPaidMessageReactions,
    removePendingPaidMessageReactions: removePendingPaidMessageReactions,
    setPaidMessageReactionType: setPaidMessageReactionType,
    setMessageReactions: setMessageReactions,
    getMessageAddedReactions: getMessageAddedReactions,
    setDefaultReactionType: setDefaultReactionType,
    getSavedMessagesTags: getSavedMessagesTags,
    setSavedMessagesTagLabel: setSavedMessagesTagLabel,
    getMessageEffect: getMessageEffect,
    searchQuote: searchQuote,
    getTextEntities: getTextEntities,
    parseTextEntities: parseTextEntities,
    parseMarkdown: parseMarkdown,
    getMarkdownText: getMarkdownText,
    getCountryFlagEmoji: getCountryFlagEmoji,
    getFileMimeType: getFileMimeType,
    getFileExtension: getFileExtension,
    cleanFileName: cleanFileName,
    getLanguagePackString: getLanguagePackString,
    getJsonValue: getJsonValue,
    getJsonString: getJsonString,
    getThemeParametersJsonString: getThemeParametersJsonString,
    setPollAnswer: setPollAnswer,
    getPollVoters: getPollVoters,
    stopPoll: stopPoll,
    hideSuggestedAction: hideSuggestedAction,
    hideContactCloseBirthdays: hideContactCloseBirthdays,
    getBusinessConnection: getBusinessConnection,
    getLoginUrlInfo: getLoginUrlInfo,
    getLoginUrl: getLoginUrl,
    shareUsersWithBot: shareUsersWithBot,
    shareChatWithBot: shareChatWithBot,
    getInlineQueryResults: getInlineQueryResults,
    answerInlineQuery: answerInlineQuery,
    savePreparedInlineMessage: savePreparedInlineMessage,
    getPreparedInlineMessage: getPreparedInlineMessage,
    getGrossingWebAppBots: getGrossingWebAppBots,
    searchWebApp: searchWebApp,
    getWebAppPlaceholder: getWebAppPlaceholder,
    getWebAppLinkUrl: getWebAppLinkUrl,
    getMainWebApp: getMainWebApp,
    getWebAppUrl: getWebAppUrl,
    sendWebAppData: sendWebAppData,
    openWebApp: openWebApp,
    closeWebApp: closeWebApp,
    answerWebAppQuery: answerWebAppQuery,
    checkWebAppFileDownload: checkWebAppFileDownload,
    getCallbackQueryAnswer: getCallbackQueryAnswer,
    answerCallbackQuery: answerCallbackQuery,
    answerShippingQuery: answerShippingQuery,
    answerPreCheckoutQuery: answerPreCheckoutQuery,
    setGameScore: setGameScore,
    setInlineGameScore: setInlineGameScore,
    getGameHighScores: getGameHighScores,
    getInlineGameHighScores: getInlineGameHighScores,
    deleteChatReplyMarkup: deleteChatReplyMarkup,
    sendChatAction: sendChatAction,
    openChat: openChat,
    closeChat: closeChat,
    viewMessages: viewMessages,
    openMessageContent: openMessageContent,
    clickAnimatedEmojiMessage: clickAnimatedEmojiMessage,
    getInternalLink: getInternalLink,
    getInternalLinkType: getInternalLinkType,
    getExternalLinkInfo: getExternalLinkInfo,
    getExternalLink: getExternalLink,
    readAllChatMentions: readAllChatMentions,
    readAllMessageThreadMentions: readAllMessageThreadMentions,
    readAllChatReactions: readAllChatReactions,
    readAllMessageThreadReactions: readAllMessageThreadReactions,
    createPrivateChat: createPrivateChat,
    createBasicGroupChat: createBasicGroupChat,
    createSupergroupChat: createSupergroupChat,
    createSecretChat: createSecretChat,
    createNewBasicGroupChat: createNewBasicGroupChat,
    createNewSupergroupChat: createNewSupergroupChat,
    createNewSecretChat: createNewSecretChat,
    upgradeBasicGroupChatToSupergroupChat: upgradeBasicGroupChatToSupergroupChat,
    getChatListsToAddChat: getChatListsToAddChat,
    addChatToList: addChatToList,
    getChatFolder: getChatFolder,
    createChatFolder: createChatFolder,
    editChatFolder: editChatFolder,
    deleteChatFolder: deleteChatFolder,
    getChatFolderChatsToLeave: getChatFolderChatsToLeave,
    getChatFolderChatCount: getChatFolderChatCount,
    reorderChatFolders: reorderChatFolders,
    toggleChatFolderTags: toggleChatFolderTags,
    getRecommendedChatFolders: getRecommendedChatFolders,
    getChatFolderDefaultIconName: getChatFolderDefaultIconName,
    getChatsForChatFolderInviteLink: getChatsForChatFolderInviteLink,
    createChatFolderInviteLink: createChatFolderInviteLink,
    getChatFolderInviteLinks: getChatFolderInviteLinks,
    editChatFolderInviteLink: editChatFolderInviteLink,
    deleteChatFolderInviteLink: deleteChatFolderInviteLink,
    checkChatFolderInviteLink: checkChatFolderInviteLink,
    addChatFolderByInviteLink: addChatFolderByInviteLink,
    getChatFolderNewChats: getChatFolderNewChats,
    processChatFolderNewChats: processChatFolderNewChats,
    getArchiveChatListSettings: getArchiveChatListSettings,
    setArchiveChatListSettings: setArchiveChatListSettings,
    setChatTitle: setChatTitle,
    setChatPhoto: setChatPhoto,
    setChatAccentColor: setChatAccentColor,
    setChatProfileAccentColor: setChatProfileAccentColor,
    setChatMessageAutoDeleteTime: setChatMessageAutoDeleteTime,
    setChatEmojiStatus: setChatEmojiStatus,
    setChatPermissions: setChatPermissions,
    setChatBackground: setChatBackground,
    deleteChatBackground: deleteChatBackground,
    setChatTheme: setChatTheme,
    setChatDraftMessage: setChatDraftMessage,
    setChatNotificationSettings: setChatNotificationSettings,
    toggleChatHasProtectedContent: toggleChatHasProtectedContent,
    toggleChatViewAsTopics: toggleChatViewAsTopics,
    toggleChatIsTranslatable: toggleChatIsTranslatable,
    toggleChatIsMarkedAsUnread: toggleChatIsMarkedAsUnread,
    toggleChatDefaultDisableNotification: toggleChatDefaultDisableNotification,
    setChatAvailableReactions: setChatAvailableReactions,
    setChatClientData: setChatClientData,
    setChatDescription: setChatDescription,
    setChatDiscussionGroup: setChatDiscussionGroup,
    setChatLocation: setChatLocation,
    setChatSlowModeDelay: setChatSlowModeDelay,
    pinChatMessage: pinChatMessage,
    unpinChatMessage: unpinChatMessage,
    unpinAllChatMessages: unpinAllChatMessages,
    unpinAllMessageThreadMessages: unpinAllMessageThreadMessages,
    joinChat: joinChat,
    leaveChat: leaveChat,
    addChatMember: addChatMember,
    addChatMembers: addChatMembers,
    setChatMemberStatus: setChatMemberStatus,
    banChatMember: banChatMember,
    canTransferOwnership: canTransferOwnership,
    transferChatOwnership: transferChatOwnership,
    getChatMember: getChatMember,
    searchChatMembers: searchChatMembers,
    getChatAdministrators: getChatAdministrators,
    clearAllDraftMessages: clearAllDraftMessages,
    getSavedNotificationSound: getSavedNotificationSound,
    getSavedNotificationSounds: getSavedNotificationSounds,
    addSavedNotificationSound: addSavedNotificationSound,
    removeSavedNotificationSound: removeSavedNotificationSound,
    getChatNotificationSettingsExceptions: getChatNotificationSettingsExceptions,
    getScopeNotificationSettings: getScopeNotificationSettings,
    setScopeNotificationSettings: setScopeNotificationSettings,
    setReactionNotificationSettings: setReactionNotificationSettings,
    resetAllNotificationSettings: resetAllNotificationSettings,
    toggleChatIsPinned: toggleChatIsPinned,
    setPinnedChats: setPinnedChats,
    readChatList: readChatList,
    getCurrentWeather: getCurrentWeather,
    getStory: getStory,
    getChatsToSendStories: getChatsToSendStories,
    canSendStory: canSendStory,
    sendStory: sendStory,
    editStory: editStory,
    editStoryCover: editStoryCover,
    setStoryPrivacySettings: setStoryPrivacySettings,
    toggleStoryIsPostedToChatPage: toggleStoryIsPostedToChatPage,
    deleteStory: deleteStory,
    getStoryNotificationSettingsExceptions: getStoryNotificationSettingsExceptions,
    loadActiveStories: loadActiveStories,
    setChatActiveStoriesList: setChatActiveStoriesList,
    getChatActiveStories: getChatActiveStories,
    getChatPostedToChatPageStories: getChatPostedToChatPageStories,
    getChatArchivedStories: getChatArchivedStories,
    setChatPinnedStories: setChatPinnedStories,
    openStory: openStory,
    closeStory: closeStory,
    getStoryAvailableReactions: getStoryAvailableReactions,
    setStoryReaction: setStoryReaction,
    getStoryInteractions: getStoryInteractions,
    getChatStoryInteractions: getChatStoryInteractions,
    reportStory: reportStory,
    activateStoryStealthMode: activateStoryStealthMode,
    getStoryPublicForwards: getStoryPublicForwards,
    getChatBoostLevelFeatures: getChatBoostLevelFeatures,
    getChatBoostFeatures: getChatBoostFeatures,
    getAvailableChatBoostSlots: getAvailableChatBoostSlots,
    getChatBoostStatus: getChatBoostStatus,
    boostChat: boostChat,
    getChatBoostLink: getChatBoostLink,
    getChatBoostLinkInfo: getChatBoostLinkInfo,
    getChatBoosts: getChatBoosts,
    getUserChatBoosts: getUserChatBoosts,
    getAttachmentMenuBot: getAttachmentMenuBot,
    toggleBotIsAddedToAttachmentMenu: toggleBotIsAddedToAttachmentMenu,
    getThemedEmojiStatuses: getThemedEmojiStatuses,
    getRecentEmojiStatuses: getRecentEmojiStatuses,
    getUpgradedGiftEmojiStatuses: getUpgradedGiftEmojiStatuses,
    getDefaultEmojiStatuses: getDefaultEmojiStatuses,
    clearRecentEmojiStatuses: clearRecentEmojiStatuses,
    getThemedChatEmojiStatuses: getThemedChatEmojiStatuses,
    getDefaultChatEmojiStatuses: getDefaultChatEmojiStatuses,
    getDisallowedChatEmojiStatuses: getDisallowedChatEmojiStatuses,
    downloadFile: downloadFile,
    getFileDownloadedPrefixSize: getFileDownloadedPrefixSize,
    cancelDownloadFile: cancelDownloadFile,
    getSuggestedFileName: getSuggestedFileName,
    preliminaryUploadFile: preliminaryUploadFile,
    cancelPreliminaryUploadFile: cancelPreliminaryUploadFile,
    writeGeneratedFilePart: writeGeneratedFilePart,
    setFileGenerationProgress: setFileGenerationProgress,
    finishFileGeneration: finishFileGeneration,
    readFilePart: readFilePart,
    deleteFile: deleteFile,
    addFileToDownloads: addFileToDownloads,
    toggleDownloadIsPaused: toggleDownloadIsPaused,
    toggleAllDownloadsArePaused: toggleAllDownloadsArePaused,
    removeFileFromDownloads: removeFileFromDownloads,
    removeAllFilesFromDownloads: removeAllFilesFromDownloads,
    searchFileDownloads: searchFileDownloads,
    setApplicationVerificationToken: setApplicationVerificationToken,
    getMessageFileType: getMessageFileType,
    getMessageImportConfirmationText: getMessageImportConfirmationText,
    importMessages: importMessages,
    replacePrimaryChatInviteLink: replacePrimaryChatInviteLink,
    createChatInviteLink: createChatInviteLink,
    createChatSubscriptionInviteLink: createChatSubscriptionInviteLink,
    editChatInviteLink: editChatInviteLink,
    editChatSubscriptionInviteLink: editChatSubscriptionInviteLink,
    getChatInviteLink: getChatInviteLink,
    getChatInviteLinkCounts: getChatInviteLinkCounts,
    getChatInviteLinks: getChatInviteLinks,
    getChatInviteLinkMembers: getChatInviteLinkMembers,
    revokeChatInviteLink: revokeChatInviteLink,
    deleteRevokedChatInviteLink: deleteRevokedChatInviteLink,
    deleteAllRevokedChatInviteLinks: deleteAllRevokedChatInviteLinks,
    checkChatInviteLink: checkChatInviteLink,
    joinChatByInviteLink: joinChatByInviteLink,
    getChatJoinRequests: getChatJoinRequests,
    processChatJoinRequest: processChatJoinRequest,
    processChatJoinRequests: processChatJoinRequests,
    createCall: createCall,
    acceptCall: acceptCall,
    sendCallSignalingData: sendCallSignalingData,
    discardCall: discardCall,
    sendCallRating: sendCallRating,
    sendCallDebugInformation: sendCallDebugInformation,
    sendCallLog: sendCallLog,
    getVideoChatAvailableParticipants: getVideoChatAvailableParticipants,
    setVideoChatDefaultParticipant: setVideoChatDefaultParticipant,
    createVideoChat: createVideoChat,
    createGroupCall: createGroupCall,
    getVideoChatRtmpUrl: getVideoChatRtmpUrl,
    replaceVideoChatRtmpUrl: replaceVideoChatRtmpUrl,
    getGroupCall: getGroupCall,
    startScheduledGroupCall: startScheduledGroupCall,
    toggleGroupCallEnabledStartNotification: toggleGroupCallEnabledStartNotification,
    joinGroupCall: joinGroupCall,
    startGroupCallScreenSharing: startGroupCallScreenSharing,
    toggleGroupCallScreenSharingIsPaused: toggleGroupCallScreenSharingIsPaused,
    endGroupCallScreenSharing: endGroupCallScreenSharing,
    setGroupCallTitle: setGroupCallTitle,
    toggleGroupCallMuteNewParticipants: toggleGroupCallMuteNewParticipants,
    inviteGroupCallParticipants: inviteGroupCallParticipants,
    getGroupCallInviteLink: getGroupCallInviteLink,
    revokeGroupCallInviteLink: revokeGroupCallInviteLink,
    startGroupCallRecording: startGroupCallRecording,
    endGroupCallRecording: endGroupCallRecording,
    toggleGroupCallIsMyVideoPaused: toggleGroupCallIsMyVideoPaused,
    toggleGroupCallIsMyVideoEnabled: toggleGroupCallIsMyVideoEnabled,
    setGroupCallParticipantIsSpeaking: setGroupCallParticipantIsSpeaking,
    toggleGroupCallParticipantIsMuted: toggleGroupCallParticipantIsMuted,
    setGroupCallParticipantVolumeLevel: setGroupCallParticipantVolumeLevel,
    toggleGroupCallParticipantIsHandRaised: toggleGroupCallParticipantIsHandRaised,
    loadGroupCallParticipants: loadGroupCallParticipants,
    leaveGroupCall: leaveGroupCall,
    endGroupCall: endGroupCall,
    getGroupCallStreams: getGroupCallStreams,
    getGroupCallStreamSegment: getGroupCallStreamSegment,
    setMessageSenderBlockList: setMessageSenderBlockList,
    blockMessageSenderFromReplies: blockMessageSenderFromReplies,
    getBlockedMessageSenders: getBlockedMessageSenders,
    addContact: addContact,
    importContacts: importContacts,
    getContacts: getContacts,
    searchContacts: searchContacts,
    removeContacts: removeContacts,
    getImportedContactCount: getImportedContactCount,
    changeImportedContacts: changeImportedContacts,
    clearImportedContacts: clearImportedContacts,
    setCloseFriends: setCloseFriends,
    getCloseFriends: getCloseFriends,
    setUserPersonalProfilePhoto: setUserPersonalProfilePhoto,
    suggestUserProfilePhoto: suggestUserProfilePhoto,
    toggleBotCanManageEmojiStatus: toggleBotCanManageEmojiStatus,
    setUserEmojiStatus: setUserEmojiStatus,
    searchUserByPhoneNumber: searchUserByPhoneNumber,
    sharePhoneNumber: sharePhoneNumber,
    getUserProfilePhotos: getUserProfilePhotos,
    getStickerOutline: getStickerOutline,
    getStickers: getStickers,
    getAllStickerEmojis: getAllStickerEmojis,
    searchStickers: searchStickers,
    getGreetingStickers: getGreetingStickers,
    getPremiumStickers: getPremiumStickers,
    getInstalledStickerSets: getInstalledStickerSets,
    getArchivedStickerSets: getArchivedStickerSets,
    getTrendingStickerSets: getTrendingStickerSets,
    getAttachedStickerSets: getAttachedStickerSets,
    getStickerSet: getStickerSet,
    getStickerSetName: getStickerSetName,
    searchStickerSet: searchStickerSet,
    searchInstalledStickerSets: searchInstalledStickerSets,
    searchStickerSets: searchStickerSets,
    changeStickerSet: changeStickerSet,
    viewTrendingStickerSets: viewTrendingStickerSets,
    reorderInstalledStickerSets: reorderInstalledStickerSets,
    getRecentStickers: getRecentStickers,
    addRecentSticker: addRecentSticker,
    removeRecentSticker: removeRecentSticker,
    clearRecentStickers: clearRecentStickers,
    getFavoriteStickers: getFavoriteStickers,
    addFavoriteSticker: addFavoriteSticker,
    removeFavoriteSticker: removeFavoriteSticker,
    getStickerEmojis: getStickerEmojis,
    searchEmojis: searchEmojis,
    getKeywordEmojis: getKeywordEmojis,
    getEmojiCategories: getEmojiCategories,
    getAnimatedEmoji: getAnimatedEmoji,
    getEmojiSuggestionsUrl: getEmojiSuggestionsUrl,
    getCustomEmojiStickers: getCustomEmojiStickers,
    getDefaultChatPhotoCustomEmojiStickers: getDefaultChatPhotoCustomEmojiStickers,
    getDefaultProfilePhotoCustomEmojiStickers: getDefaultProfilePhotoCustomEmojiStickers,
    getDefaultBackgroundCustomEmojiStickers: getDefaultBackgroundCustomEmojiStickers,
    getSavedAnimations: getSavedAnimations,
    addSavedAnimation: addSavedAnimation,
    removeSavedAnimation: removeSavedAnimation,
    getRecentInlineBots: getRecentInlineBots,
    getOwnedBots: getOwnedBots,
    searchHashtags: searchHashtags,
    removeRecentHashtag: removeRecentHashtag,
    getLinkPreview: getLinkPreview,
    getWebPageInstantView: getWebPageInstantView,
    setProfilePhoto: setProfilePhoto,
    deleteProfilePhoto: deleteProfilePhoto,
    setAccentColor: setAccentColor,
    setProfileAccentColor: setProfileAccentColor,
    setName: setName,
    setBio: setBio,
    setUsername: setUsername,
    toggleUsernameIsActive: toggleUsernameIsActive,
    reorderActiveUsernames: reorderActiveUsernames,
    setBirthdate: setBirthdate,
    setPersonalChat: setPersonalChat,
    setEmojiStatus: setEmojiStatus,
    toggleHasSponsoredMessagesEnabled: toggleHasSponsoredMessagesEnabled,
    setBusinessLocation: setBusinessLocation,
    setBusinessOpeningHours: setBusinessOpeningHours,
    setBusinessGreetingMessageSettings: setBusinessGreetingMessageSettings,
    setBusinessAwayMessageSettings: setBusinessAwayMessageSettings,
    setBusinessStartPage: setBusinessStartPage,
    sendPhoneNumberCode: sendPhoneNumberCode,
    sendPhoneNumberFirebaseSms: sendPhoneNumberFirebaseSms,
    reportPhoneNumberCodeMissing: reportPhoneNumberCodeMissing,
    resendPhoneNumberCode: resendPhoneNumberCode,
    checkPhoneNumberCode: checkPhoneNumberCode,
    getBusinessConnectedBot: getBusinessConnectedBot,
    setBusinessConnectedBot: setBusinessConnectedBot,
    deleteBusinessConnectedBot: deleteBusinessConnectedBot,
    toggleBusinessConnectedBotChatIsPaused: toggleBusinessConnectedBotChatIsPaused,
    removeBusinessConnectedBotFromChat: removeBusinessConnectedBotFromChat,
    getBusinessChatLinks: getBusinessChatLinks,
    createBusinessChatLink: createBusinessChatLink,
    editBusinessChatLink: editBusinessChatLink,
    deleteBusinessChatLink: deleteBusinessChatLink,
    getBusinessChatLinkInfo: getBusinessChatLinkInfo,
    getUserLink: getUserLink,
    searchUserByToken: searchUserByToken,
    setCommands: setCommands,
    deleteCommands: deleteCommands,
    getCommands: getCommands,
    setMenuButton: setMenuButton,
    getMenuButton: getMenuButton,
    setDefaultGroupAdministratorRights: setDefaultGroupAdministratorRights,
    setDefaultChannelAdministratorRights: setDefaultChannelAdministratorRights,
    canBotSendMessages: canBotSendMessages,
    allowBotToSendMessages: allowBotToSendMessages,
    sendWebAppCustomRequest: sendWebAppCustomRequest,
    getBotMediaPreviews: getBotMediaPreviews,
    getBotMediaPreviewInfo: getBotMediaPreviewInfo,
    addBotMediaPreview: addBotMediaPreview,
    editBotMediaPreview: editBotMediaPreview,
    reorderBotMediaPreviews: reorderBotMediaPreviews,
    deleteBotMediaPreviews: deleteBotMediaPreviews,
    setBotName: setBotName,
    getBotName: getBotName,
    setBotProfilePhoto: setBotProfilePhoto,
    toggleBotUsernameIsActive: toggleBotUsernameIsActive,
    reorderBotActiveUsernames: reorderBotActiveUsernames,
    setBotInfoDescription: setBotInfoDescription,
    getBotInfoDescription: getBotInfoDescription,
    setBotInfoShortDescription: setBotInfoShortDescription,
    getBotInfoShortDescription: getBotInfoShortDescription,
    setMessageSenderBotVerification: setMessageSenderBotVerification,
    removeMessageSenderBotVerification: removeMessageSenderBotVerification,
    getActiveSessions: getActiveSessions,
    terminateSession: terminateSession,
    terminateAllOtherSessions: terminateAllOtherSessions,
    confirmSession: confirmSession,
    toggleSessionCanAcceptCalls: toggleSessionCanAcceptCalls,
    toggleSessionCanAcceptSecretChats: toggleSessionCanAcceptSecretChats,
    setInactiveSessionTtl: setInactiveSessionTtl,
    getConnectedWebsites: getConnectedWebsites,
    disconnectWebsite: disconnectWebsite,
    disconnectAllWebsites: disconnectAllWebsites,
    setSupergroupUsername: setSupergroupUsername,
    toggleSupergroupUsernameIsActive: toggleSupergroupUsernameIsActive,
    disableAllSupergroupUsernames: disableAllSupergroupUsernames,
    reorderSupergroupActiveUsernames: reorderSupergroupActiveUsernames,
    setSupergroupStickerSet: setSupergroupStickerSet,
    setSupergroupCustomEmojiStickerSet: setSupergroupCustomEmojiStickerSet,
    setSupergroupUnrestrictBoostCount: setSupergroupUnrestrictBoostCount,
    toggleSupergroupSignMessages: toggleSupergroupSignMessages,
    toggleSupergroupJoinToSendMessages: toggleSupergroupJoinToSendMessages,
    toggleSupergroupJoinByRequest: toggleSupergroupJoinByRequest,
    toggleSupergroupIsAllHistoryAvailable: toggleSupergroupIsAllHistoryAvailable,
    toggleSupergroupCanHaveSponsoredMessages: toggleSupergroupCanHaveSponsoredMessages,
    toggleSupergroupHasHiddenMembers: toggleSupergroupHasHiddenMembers,
    toggleSupergroupHasAggressiveAntiSpamEnabled: toggleSupergroupHasAggressiveAntiSpamEnabled,
    toggleSupergroupIsForum: toggleSupergroupIsForum,
    toggleSupergroupIsBroadcastGroup: toggleSupergroupIsBroadcastGroup,
    reportSupergroupSpam: reportSupergroupSpam,
    reportSupergroupAntiSpamFalsePositive: reportSupergroupAntiSpamFalsePositive,
    getSupergroupMembers: getSupergroupMembers,
    closeSecretChat: closeSecretChat,
    getChatEventLog: getChatEventLog,
    getTimeZones: getTimeZones,
    getPaymentForm: getPaymentForm,
    validateOrderInfo: validateOrderInfo,
    sendPaymentForm: sendPaymentForm,
    getPaymentReceipt: getPaymentReceipt,
    getSavedOrderInfo: getSavedOrderInfo,
    deleteSavedOrderInfo: deleteSavedOrderInfo,
    deleteSavedCredentials: deleteSavedCredentials,
    getAvailableGifts: getAvailableGifts,
    sendGift: sendGift,
    sellGift: sellGift,
    toggleGiftIsSaved: toggleGiftIsSaved,
    setPinnedGifts: setPinnedGifts,
    toggleChatGiftNotifications: toggleChatGiftNotifications,
    getGiftUpgradePreview: getGiftUpgradePreview,
    upgradeGift: upgradeGift,
    transferGift: transferGift,
    getReceivedGifts: getReceivedGifts,
    getReceivedGift: getReceivedGift,
    getUpgradedGift: getUpgradedGift,
    getUpgradedGiftWithdrawalUrl: getUpgradedGiftWithdrawalUrl,
    createInvoiceLink: createInvoiceLink,
    refundStarPayment: refundStarPayment,
    getSupportUser: getSupportUser,
    getBackgroundUrl: getBackgroundUrl,
    searchBackground: searchBackground,
    setDefaultBackground: setDefaultBackground,
    deleteDefaultBackground: deleteDefaultBackground,
    getInstalledBackgrounds: getInstalledBackgrounds,
    removeInstalledBackground: removeInstalledBackground,
    resetInstalledBackgrounds: resetInstalledBackgrounds,
    getLocalizationTargetInfo: getLocalizationTargetInfo,
    getLanguagePackInfo: getLanguagePackInfo,
    getLanguagePackStrings: getLanguagePackStrings,
    synchronizeLanguagePack: synchronizeLanguagePack,
    addCustomServerLanguagePack: addCustomServerLanguagePack,
    setCustomLanguagePack: setCustomLanguagePack,
    editCustomLanguagePackInfo: editCustomLanguagePackInfo,
    setCustomLanguagePackString: setCustomLanguagePackString,
    deleteLanguagePack: deleteLanguagePack,
    registerDevice: registerDevice,
    processPushNotification: processPushNotification,
    getPushReceiverId: getPushReceiverId,
    getRecentlyVisitedTMeUrls: getRecentlyVisitedTMeUrls,
    setUserPrivacySettingRules: setUserPrivacySettingRules,
    getUserPrivacySettingRules: getUserPrivacySettingRules,
    setReadDatePrivacySettings: setReadDatePrivacySettings,
    getReadDatePrivacySettings: getReadDatePrivacySettings,
    setNewChatPrivacySettings: setNewChatPrivacySettings,
    getNewChatPrivacySettings: getNewChatPrivacySettings,
    getPaidMessageRevenue: getPaidMessageRevenue,
    allowUnpaidMessagesFromUser: allowUnpaidMessagesFromUser,
    setChatPaidMessageStarCount: setChatPaidMessageStarCount,
    canSendMessageToUser: canSendMessageToUser,
    getOption: getOption,
    setOption: setOption,
    setAccountTtl: setAccountTtl,
    getAccountTtl: getAccountTtl,
    deleteAccount: deleteAccount,
    setDefaultMessageAutoDeleteTime: setDefaultMessageAutoDeleteTime,
    getDefaultMessageAutoDeleteTime: getDefaultMessageAutoDeleteTime,
    removeChatActionBar: removeChatActionBar,
    reportChat: reportChat,
    reportChatPhoto: reportChatPhoto,
    reportMessageReactions: reportMessageReactions,
    getChatRevenueStatistics: getChatRevenueStatistics,
    getChatRevenueWithdrawalUrl: getChatRevenueWithdrawalUrl,
    getChatRevenueTransactions: getChatRevenueTransactions,
    getStarRevenueStatistics: getStarRevenueStatistics,
    getStarWithdrawalUrl: getStarWithdrawalUrl,
    getStarAdAccountUrl: getStarAdAccountUrl,
    getChatStatistics: getChatStatistics,
    getMessageStatistics: getMessageStatistics,
    getMessagePublicForwards: getMessagePublicForwards,
    getStoryStatistics: getStoryStatistics,
    getStatisticalGraph: getStatisticalGraph,
    getStorageStatistics: getStorageStatistics,
    getStorageStatisticsFast: getStorageStatisticsFast,
    getDatabaseStatistics: getDatabaseStatistics,
    optimizeStorage: optimizeStorage,
    setNetworkType: setNetworkType,
    getNetworkStatistics: getNetworkStatistics,
    addNetworkStatistics: addNetworkStatistics,
    resetNetworkStatistics: resetNetworkStatistics,
    getAutoDownloadSettingsPresets: getAutoDownloadSettingsPresets,
    setAutoDownloadSettings: setAutoDownloadSettings,
    getAutosaveSettings: getAutosaveSettings,
    setAutosaveSettings: setAutosaveSettings,
    clearAutosaveSettingsExceptions: clearAutosaveSettingsExceptions,
    getBankCardInfo: getBankCardInfo,
    getPassportElement: getPassportElement,
    getAllPassportElements: getAllPassportElements,
    setPassportElement: setPassportElement,
    deletePassportElement: deletePassportElement,
    setPassportElementErrors: setPassportElementErrors,
    getPreferredCountryLanguage: getPreferredCountryLanguage,
    sendEmailAddressVerificationCode: sendEmailAddressVerificationCode,
    resendEmailAddressVerificationCode: resendEmailAddressVerificationCode,
    checkEmailAddressVerificationCode: checkEmailAddressVerificationCode,
    getPassportAuthorizationForm: getPassportAuthorizationForm,
    getPassportAuthorizationFormAvailableElements: getPassportAuthorizationFormAvailableElements,
    sendPassportAuthorizationForm: sendPassportAuthorizationForm,
    setBotUpdatesStatus: setBotUpdatesStatus,
    uploadStickerFile: uploadStickerFile,
    getSuggestedStickerSetName: getSuggestedStickerSetName,
    checkStickerSetName: checkStickerSetName,
    createNewStickerSet: createNewStickerSet,
    addStickerToSet: addStickerToSet,
    replaceStickerInSet: replaceStickerInSet,
    setStickerSetThumbnail: setStickerSetThumbnail,
    setCustomEmojiStickerSetThumbnail: setCustomEmojiStickerSetThumbnail,
    setStickerSetTitle: setStickerSetTitle,
    deleteStickerSet: deleteStickerSet,
    setStickerPositionInSet: setStickerPositionInSet,
    removeStickerFromSet: removeStickerFromSet,
    setStickerEmojis: setStickerEmojis,
    setStickerKeywords: setStickerKeywords,
    setStickerMaskPosition: setStickerMaskPosition,
    getOwnedStickerSets: getOwnedStickerSets,
    getMapThumbnailFile: getMapThumbnailFile,
    getPremiumLimit: getPremiumLimit,
    getPremiumFeatures: getPremiumFeatures,
    getPremiumStickerExamples: getPremiumStickerExamples,
    getPremiumInfoSticker: getPremiumInfoSticker,
    viewPremiumFeature: viewPremiumFeature,
    clickPremiumSubscriptionButton: clickPremiumSubscriptionButton,
    getPremiumState: getPremiumState,
    getPremiumGiftPaymentOptions: getPremiumGiftPaymentOptions,
    getPremiumGiveawayPaymentOptions: getPremiumGiveawayPaymentOptions,
    checkPremiumGiftCode: checkPremiumGiftCode,
    applyPremiumGiftCode: applyPremiumGiftCode,
    launchPrepaidGiveaway: launchPrepaidGiveaway,
    getGiveawayInfo: getGiveawayInfo,
    getStarPaymentOptions: getStarPaymentOptions,
    getStarGiftPaymentOptions: getStarGiftPaymentOptions,
    getStarGiveawayPaymentOptions: getStarGiveawayPaymentOptions,
    getStarTransactions: getStarTransactions,
    getStarSubscriptions: getStarSubscriptions,
    canPurchaseFromStore: canPurchaseFromStore,
    assignAppStoreTransaction: assignAppStoreTransaction,
    assignGooglePlayTransaction: assignGooglePlayTransaction,
    editStarSubscription: editStarSubscription,
    editUserStarSubscription: editUserStarSubscription,
    reuseStarSubscription: reuseStarSubscription,
    setChatAffiliateProgram: setChatAffiliateProgram,
    searchChatAffiliateProgram: searchChatAffiliateProgram,
    searchAffiliatePrograms: searchAffiliatePrograms,
    connectAffiliateProgram: connectAffiliateProgram,
    disconnectAffiliateProgram: disconnectAffiliateProgram,
    getConnectedAffiliateProgram: getConnectedAffiliateProgram,
    getConnectedAffiliatePrograms: getConnectedAffiliatePrograms,
    getBusinessFeatures: getBusinessFeatures,
    acceptTermsOfService: acceptTermsOfService,
    searchStringsByPrefix: searchStringsByPrefix,
    sendCustomRequest: sendCustomRequest,
    answerCustomQuery: answerCustomQuery,
    setAlarm: setAlarm,
    getCountries: getCountries,
    getCountryCode: getCountryCode,
    getPhoneNumberInfo: getPhoneNumberInfo,
    getPhoneNumberInfoSync: getPhoneNumberInfoSync,
    getCollectibleItemInfo: getCollectibleItemInfo,
    getDeepLinkInfo: getDeepLinkInfo,
    getApplicationConfig: getApplicationConfig,
    saveApplicationLogEvent: saveApplicationLogEvent,
    getApplicationDownloadLink: getApplicationDownloadLink,
    addProxy: addProxy,
    editProxy: editProxy,
    enableProxy: enableProxy,
    disableProxy: disableProxy,
    removeProxy: removeProxy,
    getProxies: getProxies,
    getProxyLink: getProxyLink,
    pingProxy: pingProxy,
    setLogStream: setLogStream,
    getLogStream: getLogStream,
    setLogVerbosityLevel: setLogVerbosityLevel,
    getLogVerbosityLevel: getLogVerbosityLevel,
    getLogTags: getLogTags,
    setLogTagVerbosityLevel: setLogTagVerbosityLevel,
    getLogTagVerbosityLevel: getLogTagVerbosityLevel,
    addLogMessage: addLogMessage,
    getUserSupportInfo: getUserSupportInfo,
    setUserSupportInfo: setUserSupportInfo,
    getSupportName: getSupportName,
    testCallEmpty: testCallEmpty,
    testCallString: testCallString,
    testCallBytes: testCallBytes,
    testCallVectorInt: testCallVectorInt,
    testCallVectorIntObject: testCallVectorIntObject,
    testCallVectorString: testCallVectorString,
    testCallVectorStringObject: testCallVectorStringObject,
    testSquareInt: testSquareInt,
    testNetwork: testNetwork,
    testProxy: testProxy,
    testGetDifference: testGetDifference,
    testUseUpdate: testUseUpdate,
    testReturnError: testReturnError,
  }

  declare export type $FunctionName = $Keys<$FunctionResultByName>

  declare export type $SyncFunctionName =
    | 'checkQuickReplyShortcutName'
    | 'searchQuote'
    | 'getTextEntities'
    | 'parseTextEntities'
    | 'parseMarkdown'
    | 'getMarkdownText'
    | 'getCountryFlagEmoji'
    | 'getFileMimeType'
    | 'getFileExtension'
    | 'cleanFileName'
    | 'getLanguagePackString'
    | 'getJsonValue'
    | 'getJsonString'
    | 'getThemeParametersJsonString'
    | 'getChatFolderDefaultIconName'
    | 'getPushReceiverId'
    | 'getOption'
    | 'searchStringsByPrefix'
    | 'getPhoneNumberInfoSync'
    | 'setLogStream'
    | 'getLogStream'
    | 'setLogVerbosityLevel'
    | 'getLogVerbosityLevel'
    | 'getLogTags'
    | 'setLogTagVerbosityLevel'
    | 'getLogTagVerbosityLevel'
    | 'addLogMessage'
    | 'testReturnError'

  declare export type Invoke = <T: $FunctionName>(
    query: { +_: T, ... } & $FunctionInputByName[T]
  ) => Promise<$FunctionResultByName[T]>

  declare export type Execute = <T: $SyncFunctionName>(
    query: { +_: T, ... } & $FunctionInputByName[T]
  ) => error | $FunctionResultByName[T]
}
