// Types for TDLib v1.8.51 (bb474a201baa798784d696d2d9d762a9d2807f96)
// Generated using tdl-install-types v0.3.0
declare module 'tdlib-types' {
  export type error = {
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    _: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    code: number,
    /** Error message; subject to future changes */
    message: string,
  }

  export type error$Input = {
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    readonly _: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    readonly code?: number,
    /** Error message; subject to future changes */
    readonly message?: string,
  }

  export type ok = {
    /**
     * An object of this type is returned on a successful function call for certain
     * functions
     */
    _: 'ok',
  }

  export type authenticationCodeTypeTelegramMessage = {
    /**
     * A digit-only authentication code is delivered via a private Telegram message,
     * which can be viewed from another active session
     */
    _: 'authenticationCodeTypeTelegramMessage',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeSms = {
    /**
     * A digit-only authentication code is delivered via an SMS message to the specified
     * phone number; non-official applications may not receive this type of code
     */
    _: 'authenticationCodeTypeSms',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeSmsWord = {
    /**
     * An authentication code is a word delivered via an SMS message to the specified
     * phone number; non-official applications may not receive this type of code
     */
    _: 'authenticationCodeTypeSmsWord',
    /** The first letters of the word if known */
    first_letter: string,
  }

  export type authenticationCodeTypeSmsPhrase = {
    /**
     * An authentication code is a phrase from multiple words delivered via an SMS
     * message to the specified phone number; non-official applications may not receive
     * this type of code
     */
    _: 'authenticationCodeTypeSmsPhrase',
    /** The first word of the phrase if known */
    first_word: string,
  }

  export type authenticationCodeTypeCall = {
    /**
     * A digit-only authentication code is delivered via a phone call to the specified
     * phone number
     */
    _: 'authenticationCodeTypeCall',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeFlashCall = {
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The phone number that calls is the code that must be entered automatically
     */
    _: 'authenticationCodeTypeFlashCall',
    /** Pattern of the phone number from which the call will be made */
    pattern: string,
  }

  export type authenticationCodeTypeMissedCall = {
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The last digits of the phone number that calls are the code that
     * must be entered manually by the user
     */
    _: 'authenticationCodeTypeMissedCall',
    /** Prefix of the phone number from which the call will be made */
    phone_number_prefix: string,
    /** Number of digits in the code, excluding the prefix */
    length: number,
  }

  export type authenticationCodeTypeFragment = {
    /**
     * A digit-only authentication code is delivered to https://fragment.com. The user
     * must be logged in there via a wallet owning the phone number's NFT
     */
    _: 'authenticationCodeTypeFragment',
    /** URL to open to receive the code */
    url: string,
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeFirebaseAndroid = {
    /**
     * A digit-only authentication code is delivered via Firebase Authentication to
     * the official Android application
     */
    _: 'authenticationCodeTypeFirebaseAndroid',
    /** Parameters to be used for device verification */
    device_verification_parameters: FirebaseDeviceVerificationParameters,
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeFirebaseIos = {
    /**
     * A digit-only authentication code is delivered via Firebase Authentication to
     * the official iOS application
     */
    _: 'authenticationCodeTypeFirebaseIos',
    /**
     * Receipt of successful application token validation to compare with receipt from
     * push notification
     */
    receipt: string,
    /**
     * Time after the next authentication method is expected to be used if verification
     * push notification isn't received, in seconds
     */
    push_timeout: number,
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeInfo = {
    /** Information about the authentication code that was sent */
    _: 'authenticationCodeInfo',
    /** A phone number that is being authenticated */
    phone_number: string,
    /** The way the code was sent to the user */
    type: AuthenticationCodeType,
    /** The way the next code will be sent to the user; may be null */
    next_type?: AuthenticationCodeType,
    /** Timeout before the code can be re-sent, in seconds */
    timeout: number,
  }

  export type emailAddressAuthenticationCodeInfo = {
    /** Information about the email address authentication code that was sent */
    _: 'emailAddressAuthenticationCodeInfo',
    /** Pattern of the email address to which an authentication code was sent */
    email_address_pattern: string,
    /** Length of the code; 0 if unknown */
    length: number,
  }

  export type emailAddressAuthenticationCode$Input = {
    /** An authentication code delivered to a user's email address */
    readonly _: 'emailAddressAuthenticationCode',
    /** The code */
    readonly code?: string,
  }

  export type emailAddressAuthenticationAppleId$Input = {
    /** An authentication token received through Apple ID */
    readonly _: 'emailAddressAuthenticationAppleId',
    /** The token */
    readonly token?: string,
  }

  export type emailAddressAuthenticationGoogleId$Input = {
    /** An authentication token received through Google ID */
    readonly _: 'emailAddressAuthenticationGoogleId',
    /** The token */
    readonly token?: string,
  }

  export type emailAddressResetStateAvailable = {
    /**
     * Email address can be reset after the given period. Call resetAuthenticationEmailAddress
     * to reset it and allow the user to authorize with a code sent to the user's phone
     * number
     */
    _: 'emailAddressResetStateAvailable',
    /**
     * Time required to wait before the email address can be reset; 0 if the user is
     * subscribed to Telegram Premium
     */
    wait_period: number,
  }

  export type emailAddressResetStatePending = {
    /**
     * Email address reset has already been requested. Call resetAuthenticationEmailAddress
     * to check whether immediate reset is possible
     */
    _: 'emailAddressResetStatePending',
    /**
     * Left time before the email address will be reset, in seconds. updateAuthorizationState
     * is not sent when this field changes
     */
    reset_in: number,
  }

  export type textEntity = {
    /** Represents a part of the text that needs to be formatted in some unusual way */
    _: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    offset: number,
    /** Length of the entity, in UTF-16 code units */
    length: number,
    /** Type of the entity */
    type: TextEntityType,
  }

  export type textEntity$Input = {
    /** Represents a part of the text that needs to be formatted in some unusual way */
    readonly _: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    readonly offset?: number,
    /** Length of the entity, in UTF-16 code units */
    readonly length?: number,
    /** Type of the entity */
    readonly type?: TextEntityType$Input,
  }

  export type textEntities = {
    /** Contains a list of text entities */
    _: 'textEntities',
    /** List of text entities */
    entities: Array<textEntity>,
  }

  export type formattedText = {
    /** A text with some entities */
    _: 'formattedText',
    /** The text */
    text: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. BlockQuote entities can't contain other BlockQuote entities. Bold,
     * Italic, Underline, Strikethrough, and Spoiler entities can contain and can be
     * part of any other entities. All other entities can't contain each other
     */
    entities: Array<textEntity>,
  }

  export type formattedText$Input = {
    /** A text with some entities */
    readonly _: 'formattedText',
    /** The text */
    readonly text?: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. BlockQuote entities can't contain other BlockQuote entities. Bold,
     * Italic, Underline, Strikethrough, and Spoiler entities can contain and can be
     * part of any other entities. All other entities can't contain each other
     */
    readonly entities?: ReadonlyArray<textEntity$Input>,
  }

  export type termsOfService = {
    /** Contains Telegram terms of service */
    _: 'termsOfService',
    /** Text of the terms of service */
    text: formattedText,
    /** The minimum age of a user to be able to accept the terms; 0 if age isn't restricted */
    min_user_age: number,
    /** True, if a blocking popup with terms of service must be shown to the user */
    show_popup: boolean,
  }

  export type authorizationStateWaitTdlibParameters = {
    /** Initialization parameters are needed. Call setTdlibParameters to provide them */
    _: 'authorizationStateWaitTdlibParameters',
  }

  export type authorizationStateWaitPhoneNumber = {
    /**
     * TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber
     * to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken
     * for other authentication options
     */
    _: 'authorizationStateWaitPhoneNumber',
  }

  export type authorizationStateWaitPremiumPurchase = {
    /**
     * The user must buy Telegram Premium as an in-store purchase to log in. Call checkAuthenticationPremiumPurchase
     * and then setAuthenticationPremiumPurchaseTransaction
     */
    _: 'authorizationStateWaitPremiumPurchase',
    /** Identifier of the store product that must be bought */
    store_product_id: string,
  }

  export type authorizationStateWaitEmailAddress = {
    /**
     * TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress
     * to provide the email address, or directly call checkAuthenticationEmailCode
     * with Apple ID/Google ID token if allowed
     */
    _: 'authorizationStateWaitEmailAddress',
    /** True, if authorization through Apple ID is allowed */
    allow_apple_id: boolean,
    /** True, if authorization through Google ID is allowed */
    allow_google_id: boolean,
  }

  export type authorizationStateWaitEmailCode = {
    /**
     * TDLib needs the user's authentication code sent to an email address to authorize.
     * Call checkAuthenticationEmailCode to provide the code
     */
    _: 'authorizationStateWaitEmailCode',
    /** True, if authorization through Apple ID is allowed */
    allow_apple_id: boolean,
    /** True, if authorization through Google ID is allowed */
    allow_google_id: boolean,
    /** Information about the sent authentication code */
    code_info: emailAddressAuthenticationCodeInfo,
    /**
     * Reset state of the email address; may be null if the email address can't be
     * reset
     */
    email_address_reset_state?: EmailAddressResetState,
  }

  export type authorizationStateWaitCode = {
    /**
     * TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode
     * to check the code
     */
    _: 'authorizationStateWaitCode',
    /** Information about the authorization code that was sent */
    code_info: authenticationCodeInfo,
  }

  export type authorizationStateWaitOtherDeviceConfirmation = {
    /**
     * The user needs to confirm authorization on another logged in device by scanning
     * a QR code with the provided link
     */
    _: 'authorizationStateWaitOtherDeviceConfirmation',
    /** A tg:// URL for the QR code. The link will be updated frequently */
    link: string,
  }

  export type authorizationStateWaitRegistration = {
    /**
     * The user is unregistered and need to accept terms of service and enter their
     * first name and last name to finish registration. Call registerUser to accept
     * the terms of service and provide the data
     */
    _: 'authorizationStateWaitRegistration',
    /** Telegram terms of service */
    terms_of_service: termsOfService,
  }

  export type authorizationStateWaitPassword = {
    /**
     * The user has been authorized, but needs to enter a 2-step verification password
     * to start using the application. Call checkAuthenticationPassword to provide
     * the password, or requestAuthenticationPasswordRecovery to recover the password,
     * or deleteAccount to delete the account after a week
     */
    _: 'authorizationStateWaitPassword',
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email address has been set up */
    has_recovery_email_address: boolean,
    /** True, if some Telegram Passport elements were saved */
    has_passport_data: boolean,
    /**
     * Pattern of the email address to which the recovery email was sent; empty until
     * a recovery email has been sent
     */
    recovery_email_address_pattern: string,
  }

  export type authorizationStateReady = {
    /**
     * The user has been successfully authorized. TDLib is now ready to answer general
     * requests
     */
    _: 'authorizationStateReady',
  }

  export type authorizationStateLoggingOut = {
    /** The user is currently logging out */
    _: 'authorizationStateLoggingOut',
  }

  export type authorizationStateClosing = {
    /**
     * TDLib is closing, all subsequent queries will be answered with the error 500.
     * Note that closing TDLib can take a while. All resources will be freed only after
     * authorizationStateClosed has been received
     */
    _: 'authorizationStateClosing',
  }

  export type authorizationStateClosed = {
    /**
     * TDLib client is in its final state. All databases are closed and all resources
     * are released. No other updates will be received after this. All queries will
     * be responded to with error code 500. To continue working, one must create a
     * new instance of the TDLib client
     */
    _: 'authorizationStateClosed',
  }

  export type firebaseDeviceVerificationParametersSafetyNet = {
    /** Device verification must be performed with the SafetyNet Attestation API */
    _: 'firebaseDeviceVerificationParametersSafetyNet',
    /** Nonce to pass to the SafetyNet Attestation API */
    nonce: string /* base64 */,
  }

  export type firebaseDeviceVerificationParametersPlayIntegrity = {
    /**
     * Device verification must be performed with the classic Play Integrity verification
     * (https://developer.android.com/google/play/integrity/classic)
     */
    _: 'firebaseDeviceVerificationParametersPlayIntegrity',
    /** Base64url-encoded nonce to pass to the Play Integrity API */
    nonce: string,
    /** Cloud project number to pass to the Play Integrity API */
    cloud_project_number: string,
  }

  export type passwordState = {
    /** Represents the current state of 2-step verification */
    _: 'passwordState',
    /** True, if a 2-step verification password is set */
    has_password: boolean,
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email is set */
    has_recovery_email_address: boolean,
    /** True, if some Telegram Passport elements were saved */
    has_passport_data: boolean,
    /**
     * Information about the recovery email address to which the confirmation email
     * was sent; may be null
     */
    recovery_email_address_code_info?: emailAddressAuthenticationCodeInfo,
    /** Pattern of the email address set up for logging in */
    login_email_address_pattern: string,
    /**
     * If not 0, point in time (Unix timestamp) after which the 2-step verification
     * password can be reset immediately using resetPassword
     */
    pending_reset_date: number,
  }

  export type recoveryEmailAddress = {
    /** Contains information about the current recovery email address */
    _: 'recoveryEmailAddress',
    /** Recovery email address */
    recovery_email_address: string,
  }

  export type temporaryPasswordState = {
    /**
     * Returns information about the availability of a temporary password, which can
     * be used for payments
     */
    _: 'temporaryPasswordState',
    /** True, if a temporary password is available */
    has_password: boolean,
    /** Time left before the temporary password expires, in seconds */
    valid_for: number,
  }

  export type localFile = {
    /** Represents a local file */
    _: 'localFile',
    /** Local path to the locally available file part; may be empty */
    path: string,
    /** True, if it is possible to download or generate the file */
    can_be_downloaded: boolean,
    /** True, if the file can be deleted */
    can_be_deleted: boolean,
    /**
     * True, if the file is currently being downloaded (or a local copy is being generated
     * by some other means)
     */
    is_downloading_active: boolean,
    /** True, if the local copy is fully available */
    is_downloading_completed: boolean,
    /**
     * Download will be started from this offset. downloaded_prefix_size is calculated
     * from this offset
     */
    download_offset: number,
    /**
     * If is_downloading_completed is false, then only some prefix of the file starting
     * from download_offset is ready to be read. downloaded_prefix_size is the size
     * of that prefix in bytes
     */
    downloaded_prefix_size: number,
    /**
     * Total downloaded file size, in bytes. Can be used only for calculating download
     * progress. The actual file size may be bigger, and some parts of it may contain
     * garbage
     */
    downloaded_size: number,
  }

  export type remoteFile = {
    /** Represents a remote file */
    _: 'remoteFile',
    /**
     * Remote file identifier; may be empty. Can be used by the current user across
     * application restarts or even from other devices. Uniquely identifies a file,
     * but a file can have a lot of different valid identifiers. If the identifier
     * starts with "http://" or "https://", it represents the HTTP URL of the file.
     * TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads
     * is called on such a file or if it is sent to a secret chat, TDLib starts a file
     * generation process by sending updateFileGenerationStart to the application with
     * the HTTP URL in the original_path and "#url#" as the conversion string. Application
     * must generate the file by downloading it to the specified location
     */
    id: string,
    /**
     * Unique file identifier; may be empty if unknown. The unique file identifier
     * which is the same for the same file even for different users and is persistent
     * over time
     */
    unique_id: string,
    /**
     * True, if the file is currently being uploaded (or a remote copy is being generated
     * by some other means)
     */
    is_uploading_active: boolean,
    /** True, if a remote copy is fully available */
    is_uploading_completed: boolean,
    /** Size of the remote available part of the file, in bytes; 0 if unknown */
    uploaded_size: number,
  }

  export type file = {
    /** Represents a file */
    _: 'file',
    /** Unique file identifier */
    id: number,
    /** File size, in bytes; 0 if unknown */
    size: number,
    /**
     * Approximate file size in bytes in case the exact file size is unknown. Can be
     * used to show download/upload progress
     */
    expected_size: number,
    /** Information about the local copy of the file */
    local: localFile,
    /** Information about the remote copy of the file */
    remote: remoteFile,
  }

  export type inputFileId = {
    /** A file defined by its unique identifier */
    _: 'inputFileId',
    /** Unique file identifier */
    id: number,
  }

  export type inputFileId$Input = {
    /** A file defined by its unique identifier */
    readonly _: 'inputFileId',
    /** Unique file identifier */
    readonly id?: number,
  }

  export type inputFileRemote = {
    /**
     * A file defined by its remote identifier. The remote identifier is guaranteed
     * to be usable only if the corresponding file is still accessible to the user
     * and known to TDLib. For example, if the file is from a message, then the message
     * must be not deleted and accessible to the user. If the file database is disabled,
     * then the corresponding object with the file must be preloaded by the application
     */
    _: 'inputFileRemote',
    /** Remote file identifier */
    id: string,
  }

  export type inputFileRemote$Input = {
    /**
     * A file defined by its remote identifier. The remote identifier is guaranteed
     * to be usable only if the corresponding file is still accessible to the user
     * and known to TDLib. For example, if the file is from a message, then the message
     * must be not deleted and accessible to the user. If the file database is disabled,
     * then the corresponding object with the file must be preloaded by the application
     */
    readonly _: 'inputFileRemote',
    /** Remote file identifier */
    readonly id?: string,
  }

  export type inputFileLocal = {
    /** A file defined by a local path */
    _: 'inputFileLocal',
    /** Local path to the file */
    path: string,
  }

  export type inputFileLocal$Input = {
    /** A file defined by a local path */
    readonly _: 'inputFileLocal',
    /** Local path to the file */
    readonly path?: string,
  }

  export type inputFileGenerated = {
    /**
     * A file generated by the application. The application must handle updates updateFileGenerationStart
     * and updateFileGenerationStop to generate the file when asked by TDLib
     */
    _: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated. The path doesn't have
     * to be a valid path and is used by TDLib only to detect name and MIME type of
     * the generated file
     */
    original_path: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    conversion: string,
    /** Expected size of the generated file, in bytes; pass 0 if unknown */
    expected_size: number,
  }

  export type inputFileGenerated$Input = {
    /**
     * A file generated by the application. The application must handle updates updateFileGenerationStart
     * and updateFileGenerationStop to generate the file when asked by TDLib
     */
    readonly _: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated. The path doesn't have
     * to be a valid path and is used by TDLib only to detect name and MIME type of
     * the generated file
     */
    readonly original_path?: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    readonly conversion?: string,
    /** Expected size of the generated file, in bytes; pass 0 if unknown */
    readonly expected_size?: number,
  }

  export type photoSize = {
    /** Describes an image in JPEG format */
    _: 'photoSize',
    /** Image type (see https://core.telegram.org/constructor/photoSize) */
    type: string,
    /** Information about the image file */
    photo: file,
    /** Image width */
    width: number,
    /** Image height */
    height: number,
    /**
     * Sizes of progressive JPEG file prefixes, which can be used to preliminarily
     * show the image; in bytes
     */
    progressive_sizes: Array<number>,
  }

  export type minithumbnail = {
    /** Thumbnail image of a very poor quality and low resolution */
    _: 'minithumbnail',
    /** Thumbnail width, usually doesn't exceed 40 */
    width: number,
    /** Thumbnail height, usually doesn't exceed 40 */
    height: number,
    /** The thumbnail in JPEG format */
    data: string /* base64 */,
  }

  export type thumbnailFormatJpeg = {
    /** The thumbnail is in JPEG format */
    _: 'thumbnailFormatJpeg',
  }

  export type thumbnailFormatGif = {
    /**
     * The thumbnail is in static GIF format. It will be used only for some bot inline
     * query results
     */
    _: 'thumbnailFormatGif',
  }

  export type thumbnailFormatMpeg4 = {
    /**
     * The thumbnail is in MPEG4 format. It will be used only for some animations and
     * videos
     */
    _: 'thumbnailFormatMpeg4',
  }

  export type thumbnailFormatPng = {
    /** The thumbnail is in PNG format. It will be used only for background patterns */
    _: 'thumbnailFormatPng',
  }

  export type thumbnailFormatTgs = {
    /** The thumbnail is in TGS format. It will be used only for sticker sets */
    _: 'thumbnailFormatTgs',
  }

  export type thumbnailFormatWebm = {
    /** The thumbnail is in WEBM format. It will be used only for sticker sets */
    _: 'thumbnailFormatWebm',
  }

  export type thumbnailFormatWebp = {
    /**
     * The thumbnail is in WEBP format. It will be used only for some stickers and
     * sticker sets
     */
    _: 'thumbnailFormatWebp',
  }

  export type thumbnail = {
    /** Represents a thumbnail */
    _: 'thumbnail',
    /** Thumbnail format */
    format: ThumbnailFormat,
    /** Thumbnail width */
    width: number,
    /** Thumbnail height */
    height: number,
    /** The thumbnail */
    file: file,
  }

  export type maskPointForehead = {
    /** The mask is placed relatively to the forehead */
    _: 'maskPointForehead',
  }

  export type maskPointForehead$Input = {
    /** The mask is placed relatively to the forehead */
    readonly _: 'maskPointForehead',
  }

  export type maskPointEyes = {
    /** The mask is placed relatively to the eyes */
    _: 'maskPointEyes',
  }

  export type maskPointEyes$Input = {
    /** The mask is placed relatively to the eyes */
    readonly _: 'maskPointEyes',
  }

  export type maskPointMouth = {
    /** The mask is placed relatively to the mouth */
    _: 'maskPointMouth',
  }

  export type maskPointMouth$Input = {
    /** The mask is placed relatively to the mouth */
    readonly _: 'maskPointMouth',
  }

  export type maskPointChin = {
    /** The mask is placed relatively to the chin */
    _: 'maskPointChin',
  }

  export type maskPointChin$Input = {
    /** The mask is placed relatively to the chin */
    readonly _: 'maskPointChin',
  }

  export type maskPosition = {
    /** Position on a photo where a mask is placed */
    _: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    point: MaskPoint,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    x_shift: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    y_shift: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    scale: number,
  }

  export type maskPosition$Input = {
    /** Position on a photo where a mask is placed */
    readonly _: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    readonly point?: MaskPoint$Input,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    readonly x_shift?: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    readonly y_shift?: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    readonly scale?: number,
  }

  export type stickerFormatWebp = {
    /** The sticker is an image in WEBP format */
    _: 'stickerFormatWebp',
  }

  export type stickerFormatWebp$Input = {
    /** The sticker is an image in WEBP format */
    readonly _: 'stickerFormatWebp',
  }

  export type stickerFormatTgs = {
    /** The sticker is an animation in TGS format */
    _: 'stickerFormatTgs',
  }

  export type stickerFormatTgs$Input = {
    /** The sticker is an animation in TGS format */
    readonly _: 'stickerFormatTgs',
  }

  export type stickerFormatWebm = {
    /** The sticker is a video in WEBM format */
    _: 'stickerFormatWebm',
  }

  export type stickerFormatWebm$Input = {
    /** The sticker is a video in WEBM format */
    readonly _: 'stickerFormatWebm',
  }

  export type stickerTypeRegular = {
    /** The sticker is a regular sticker */
    _: 'stickerTypeRegular',
  }

  export type stickerTypeRegular$Input = {
    /** The sticker is a regular sticker */
    readonly _: 'stickerTypeRegular',
  }

  export type stickerTypeMask = {
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    _: 'stickerTypeMask',
  }

  export type stickerTypeMask$Input = {
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    readonly _: 'stickerTypeMask',
  }

  export type stickerTypeCustomEmoji = {
    /** The sticker is a custom emoji to be used inside message text and caption */
    _: 'stickerTypeCustomEmoji',
  }

  export type stickerTypeCustomEmoji$Input = {
    /** The sticker is a custom emoji to be used inside message text and caption */
    readonly _: 'stickerTypeCustomEmoji',
  }

  export type stickerFullTypeRegular = {
    /** The sticker is a regular sticker */
    _: 'stickerFullTypeRegular',
    /**
     * Premium animation of the sticker; may be null. If present, only Telegram Premium
     * users can use the sticker
     */
    premium_animation?: file,
  }

  export type stickerFullTypeMask = {
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    _: 'stickerFullTypeMask',
    /** Position where the mask is placed; may be null */
    mask_position?: maskPosition,
  }

  export type stickerFullTypeCustomEmoji = {
    /**
     * The sticker is a custom emoji to be used inside message text and caption. Currently,
     * only Telegram Premium users can use custom emoji
     */
    _: 'stickerFullTypeCustomEmoji',
    /** Identifier of the custom emoji */
    custom_emoji_id: string,
    /**
     * True, if the sticker must be repainted to a text color in messages, the color
     * of the Telegram Premium badge in emoji status, white color on chat photos, or
     * another appropriate color in other places
     */
    needs_repainting: boolean,
  }

  export type closedVectorPath = {
    /**
     * Represents a closed vector path. The path begins at the end point of the last
     * command. The coordinate system origin is in the upper-left corner
     */
    _: 'closedVectorPath',
    /** List of vector path commands */
    commands: Array<VectorPathCommand>,
  }

  export type outline = {
    /** Represents outline of an image */
    _: 'outline',
    /** The list of closed vector paths */
    paths: Array<closedVectorPath>,
  }

  export type pollOption = {
    /** Describes one answer option of a poll */
    _: 'pollOption',
    /** Option text; 1-100 characters. Only custom emoji entities are allowed */
    text: formattedText,
    /** Number of voters for this option, available only for closed or voted polls */
    voter_count: number,
    /** The percentage of votes for this option; 0-100 */
    vote_percentage: number,
    /** True, if the option was chosen by the user */
    is_chosen: boolean,
    /** True, if the option is being chosen by a pending setPollAnswer request */
    is_being_chosen: boolean,
  }

  export type pollTypeRegular = {
    /** A regular poll */
    _: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    allow_multiple_answers: boolean,
  }

  export type pollTypeRegular$Input = {
    /** A regular poll */
    readonly _: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    readonly allow_multiple_answers?: boolean,
  }

  export type pollTypeQuiz = {
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    _: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    correct_option_id: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    explanation: formattedText,
  }

  export type pollTypeQuiz$Input = {
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    readonly _: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    readonly correct_option_id?: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    readonly explanation?: formattedText$Input,
  }

  export type checklistTask = {
    /** Describes a task in a checklist */
    _: 'checklistTask',
    /** Unique identifier of the task */
    id: number,
    /**
     * Text of the task; may contain only Bold, Italic, Underline, Strikethrough, Spoiler,
     * CustomEmoji, Url, EmailAddress, Mention, Hashtag, Cashtag and PhoneNumber entities
     */
    text: formattedText,
    /** Identifier of the user that completed the task; 0 if the task isn't completed */
    completed_by_user_id: number,
    /**
     * Point in time (Unix timestamp) when the task was completed; 0 if the task isn't
     * completed
     */
    completion_date: number,
  }

  export type inputChecklistTask = {
    /** Describes a task in a checklist to be sent */
    _: 'inputChecklistTask',
    /** Unique identifier of the task; must be positive */
    id: number,
    /**
     * Text of the task; 1-getOption("checklist_task_text_length_max") characters without
     * line feeds. May contain only Bold, Italic, Underline, Strikethrough, Spoiler,
     * and CustomEmoji entities
     */
    text: formattedText,
  }

  export type inputChecklistTask$Input = {
    /** Describes a task in a checklist to be sent */
    readonly _: 'inputChecklistTask',
    /** Unique identifier of the task; must be positive */
    readonly id?: number,
    /**
     * Text of the task; 1-getOption("checklist_task_text_length_max") characters without
     * line feeds. May contain only Bold, Italic, Underline, Strikethrough, Spoiler,
     * and CustomEmoji entities
     */
    readonly text?: formattedText$Input,
  }

  export type checklist = {
    /** Describes a checklist */
    _: 'checklist',
    /**
     * Title of the checklist; may contain only Bold, Italic, Underline, Strikethrough,
     * Spoiler, and CustomEmoji entities
     */
    title: formattedText,
    /** List of tasks in the checklist */
    tasks: Array<checklistTask>,
    /** True, if users other than creator of the list can add tasks to the list */
    others_can_add_tasks: boolean,
    /**
     * True, if the current user can add tasks to the list if they have Telegram Premium
     * subscription
     */
    can_add_tasks: boolean,
    /**
     * True, if users other than creator of the list can mark tasks as done or not
     * done. If true, then the checklist is called "group checklist"
     */
    others_can_mark_tasks_as_done: boolean,
    /**
     * True, if the current user can mark tasks as done or not done if they have Telegram
     * Premium subscription
     */
    can_mark_tasks_as_done: boolean,
  }

  export type inputChecklist = {
    /** Describes a checklist to be sent */
    _: 'inputChecklist',
    /**
     * Title of the checklist; 1-getOption("checklist_title_length_max") characters.
     * May contain only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities
     */
    title: formattedText,
    /** List of tasks in the checklist; 1-getOption("checklist_task_count_max") tasks */
    tasks: Array<inputChecklistTask>,
    /** True, if other users can add tasks to the list */
    others_can_add_tasks: boolean,
    /** True, if other users can mark tasks as done or not done */
    others_can_mark_tasks_as_done: boolean,
  }

  export type inputChecklist$Input = {
    /** Describes a checklist to be sent */
    readonly _: 'inputChecklist',
    /**
     * Title of the checklist; 1-getOption("checklist_title_length_max") characters.
     * May contain only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities
     */
    readonly title?: formattedText$Input,
    /** List of tasks in the checklist; 1-getOption("checklist_task_count_max") tasks */
    readonly tasks?: ReadonlyArray<inputChecklistTask$Input>,
    /** True, if other users can add tasks to the list */
    readonly others_can_add_tasks?: boolean,
    /** True, if other users can mark tasks as done or not done */
    readonly others_can_mark_tasks_as_done?: boolean,
  }

  export type animation = {
    /** Describes an animation file. The animation must be encoded in GIF or MPEG4 format */
    _: 'animation',
    /** Duration of the animation, in seconds; as defined by the sender */
    duration: number,
    /** Width of the animation */
    width: number,
    /** Height of the animation */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file, usually "image/gif" or "video/mp4" */
    mime_type: string,
    /**
     * True, if stickers were added to the animation. The list of corresponding sticker
     * set can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Animation minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Animation thumbnail in JPEG or MPEG4 format; may be null */
    thumbnail?: thumbnail,
    /** File containing the animation */
    animation: file,
  }

  export type audio = {
    /** Describes an audio file. Audio is usually in MP3 or M4A format */
    _: 'audio',
    /** Duration of the audio, in seconds; as defined by the sender */
    duration: number,
    /** Title of the audio; as defined by the sender */
    title: string,
    /** Performer of the audio; as defined by the sender */
    performer: string,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** The MIME type of the file; as defined by the sender */
    mime_type: string,
    /** The minithumbnail of the album cover; may be null */
    album_cover_minithumbnail?: minithumbnail,
    /**
     * The thumbnail of the album cover in JPEG format; as defined by the sender. The
     * full size thumbnail is expected to be extracted from the downloaded audio file;
     * may be null
     */
    album_cover_thumbnail?: thumbnail,
    /**
     * Album cover variants to use if the downloaded audio file contains no album cover.
     * Provided thumbnail dimensions are approximate
     */
    external_album_covers: Array<thumbnail>,
    /** File containing the audio */
    audio: file,
  }

  export type document = {
    /** Describes a document of any type */
    _: 'document',
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /** Document minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /**
     * Document thumbnail in JPEG or PNG format (PNG will be used only for background
     * patterns); as defined by the sender; may be null
     */
    thumbnail?: thumbnail,
    /** File containing the document */
    document: file,
  }

  export type photo = {
    /** Describes a photo */
    _: 'photo',
    /**
     * True, if stickers were added to the photo. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo, in different sizes */
    sizes: Array<photoSize>,
  }

  export type sticker = {
    /** Describes a sticker */
    _: 'sticker',
    /** Unique sticker identifier within the set; 0 if none */
    id: string,
    /** Identifier of the sticker set to which the sticker belongs; 0 if none */
    set_id: string,
    /** Sticker width; as defined by the sender */
    width: number,
    /** Sticker height; as defined by the sender */
    height: number,
    /** Emoji corresponding to the sticker */
    emoji: string,
    /** Sticker format */
    format: StickerFormat,
    /** Sticker's full type */
    full_type: StickerFullType,
    /** Sticker thumbnail in WEBP or JPEG format; may be null */
    thumbnail?: thumbnail,
    /** File containing the sticker */
    sticker: file,
  }

  export type video = {
    /** Describes a video file */
    _: 'video',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /** Video width; as defined by the sender */
    width: number,
    /** Video height; as defined by the sender */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /**
     * True, if stickers were added to the video. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** True, if the video is expected to be streamed */
    supports_streaming: boolean,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** File containing the video */
    video: file,
  }

  export type videoNote = {
    /**
     * Describes a video note. The video must be equal in width and height, cropped
     * to a circle, and stored in MPEG4 format
     */
    _: 'videoNote',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /**
     * A waveform representation of the video note's audio in 5-bit format; may be
     * empty if unknown
     */
    waveform: string /* base64 */,
    /** Video width and height; as defined by the sender */
    length: number,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** Result of speech recognition in the video note; may be null */
    speech_recognition_result?: SpeechRecognitionResult,
    /** File containing the video */
    video: file,
  }

  export type voiceNote = {
    /** Describes a voice note */
    _: 'voiceNote',
    /** Duration of the voice note, in seconds; as defined by the sender */
    duration: number,
    /** A waveform representation of the voice note in 5-bit format */
    waveform: string /* base64 */,
    /**
     * MIME type of the file; as defined by the sender. Usually, one of "audio/ogg"
     * for Opus in an OGG container, "audio/mpeg" for an MP3 audio, or "audio/mp4"
     * for an M4A audio
     */
    mime_type: string,
    /** Result of speech recognition in the voice note; may be null */
    speech_recognition_result?: SpeechRecognitionResult,
    /** File containing the voice note */
    voice: file,
  }

  export type animatedEmoji = {
    /** Describes an animated or custom representation of an emoji */
    _: 'animatedEmoji',
    /**
     * Sticker for the emoji; may be null if yet unknown for a custom emoji. If the
     * sticker is a custom emoji, then it can have arbitrary format
     */
    sticker?: sticker,
    /** Expected width of the sticker, which can be used if the sticker is null */
    sticker_width: number,
    /** Expected height of the sticker, which can be used if the sticker is null */
    sticker_height: number,
    /** Emoji modifier fitzpatrick type; 0-6; 0 if none */
    fitzpatrick_type: number,
    /**
     * File containing the sound to be played when the sticker is clicked; may be null.
     * The sound is encoded with the Opus codec, and stored inside an OGG container
     */
    sound?: file,
  }

  export type contact = {
    /** Describes a user contact */
    _: 'contact',
    /** Phone number of the user */
    phone_number: string,
    /** First name of the user; 1-255 characters in length */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    vcard: string,
    /** Identifier of the user, if known; 0 otherwise */
    user_id: number,
  }

  export type contact$Input = {
    /** Describes a user contact */
    readonly _: 'contact',
    /** Phone number of the user */
    readonly phone_number?: string,
    /** First name of the user; 1-255 characters in length */
    readonly first_name?: string,
    /** Last name of the user */
    readonly last_name?: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    readonly vcard?: string,
    /** Identifier of the user, if known; 0 otherwise */
    readonly user_id?: number,
  }

  export type location = {
    /** Describes a location on planet Earth */
    _: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    latitude: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    longitude: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    horizontal_accuracy: number,
  }

  export type location$Input = {
    /** Describes a location on planet Earth */
    readonly _: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    readonly latitude?: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    readonly longitude?: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    readonly horizontal_accuracy?: number,
  }

  export type venue = {
    /** Describes a venue */
    _: 'venue',
    /** Venue location; as defined by the sender */
    location: location,
    /** Venue name; as defined by the sender */
    title: string,
    /** Venue address; as defined by the sender */
    address: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    provider: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    id: string,
    /** Type of the venue in the provider database; as defined by the sender */
    type: string,
  }

  export type venue$Input = {
    /** Describes a venue */
    readonly _: 'venue',
    /** Venue location; as defined by the sender */
    readonly location?: location$Input,
    /** Venue name; as defined by the sender */
    readonly title?: string,
    /** Venue address; as defined by the sender */
    readonly address?: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    readonly provider?: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    readonly id?: string,
    /** Type of the venue in the provider database; as defined by the sender */
    readonly type?: string,
  }

  export type game = {
    /**
     * Describes a game. Use getInternalLink with internalLinkTypeGame to share the
     * game
     */
    _: 'game',
    /** Unique game identifier */
    id: string,
    /** Game short name */
    short_name: string,
    /** Game title */
    title: string,
    /** Game text, usually containing scoreboards for a game */
    text: formattedText,
    /** Game description */
    description: string,
    /** Game photo */
    photo: photo,
    /** Game animation; may be null */
    animation?: animation,
  }

  export type webApp = {
    /**
     * Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share
     * the Web App
     */
    _: 'webApp',
    /** Web App short name */
    short_name: string,
    /** Web App title */
    title: string,
    /** Web App description */
    description: string,
    /** Web App photo */
    photo: photo,
    /** Web App animation; may be null */
    animation?: animation,
  }

  export type poll = {
    /** Describes a poll */
    _: 'poll',
    /** Unique poll identifier */
    id: string,
    /** Poll question; 1-300 characters. Only custom emoji entities are allowed */
    question: formattedText,
    /** List of poll answer options */
    options: Array<pollOption>,
    /** Total number of voters, participating in the poll */
    total_voter_count: number,
    /** Identifiers of recent voters, if the poll is non-anonymous */
    recent_voter_ids: Array<MessageSender>,
    /** True, if the poll is anonymous */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /** Amount of time the poll will be active after creation, in seconds */
    open_period: number,
    /** Point in time (Unix timestamp) when the poll will automatically be closed */
    close_date: number,
    /** True, if the poll is closed */
    is_closed: boolean,
  }

  export type alternativeVideo = {
    /** Describes an alternative re-encoded quality of a video file */
    _: 'alternativeVideo',
    /** Unique identifier of the alternative video, which is used in the HLS file */
    id: string,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /** Codec used for video file encoding, for example, "h264", "h265", or "av1" */
    codec: string,
    /** HLS file describing the video */
    hls_file: file,
    /** File containing the video */
    video: file,
  }

  export type videoStoryboard = {
    /** Describes a storyboard for a video */
    _: 'videoStoryboard',
    /** A JPEG file that contains tiled previews of video */
    storyboard_file: file,
    /** Width of a tile */
    width: number,
    /** Height of a tile */
    height: number,
    /** File that describes mapping of position in the video to a tile in the JPEG file */
    map_file: file,
  }

  export type background = {
    /** Describes a chat background */
    _: 'background',
    /** Unique background identifier */
    id: string,
    /** True, if this is one of default backgrounds */
    is_default: boolean,
    /** True, if the background is dark and is recommended to be used with dark theme */
    is_dark: boolean,
    /** Unique background name */
    name: string,
    /**
     * Document with the background; may be null. Null only for filled and chat theme
     * backgrounds
     */
    document?: document,
    /** Type of the background */
    type: BackgroundType,
  }

  export type backgrounds = {
    /** Contains a list of backgrounds */
    _: 'backgrounds',
    /** A list of backgrounds */
    backgrounds: Array<background>,
  }

  export type chatBackground = {
    /** Describes a background set for a specific chat */
    _: 'chatBackground',
    /** The background */
    background: background,
    /**
     * Dimming of the background in dark themes, as a percentage; 0-100. Applied only
     * to Wallpaper and Fill types of background
     */
    dark_theme_dimming: number,
  }

  export type profilePhoto = {
    /** Describes a user profile photo */
    _: 'profilePhoto',
    /**
     * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list
     * of user profile photos
     */
    id: string,
    /**
     * A small (160x160) user profile photo. The file can be downloaded only before
     * the photo is changed
     */
    small: file,
    /**
     * A big (640x640) user profile photo. The file can be downloaded only before the
     * photo is changed
     */
    big: file,
    /** User profile photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
    /** True, if the photo is visible only for the current user */
    is_personal: boolean,
  }

  export type chatPhotoInfo = {
    /** Contains basic information about the photo of a chat */
    _: 'chatPhotoInfo',
    /**
     * A small (160x160) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    small: file,
    /**
     * A big (640x640) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    big: file,
    /** Chat photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
    /** True, if the photo is visible only for the current user */
    is_personal: boolean,
  }

  export type userTypeRegular = {
    /** A regular user */
    _: 'userTypeRegular',
  }

  export type userTypeDeleted = {
    /**
     * A deleted user or deleted bot. No information on the user besides the user identifier
     * is available. It is not possible to perform any active actions on this type
     * of user
     */
    _: 'userTypeDeleted',
  }

  export type userTypeBot = {
    /** A bot (see https://core.telegram.org/bots) */
    _: 'userTypeBot',
    /**
     * True, if the bot is owned by the current user and can be edited using the methods
     * toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName,
     * setBotInfoDescription, and setBotInfoShortDescription
     */
    can_be_edited: boolean,
    /** True, if the bot can be invited to basic group and supergroup chats */
    can_join_groups: boolean,
    /**
     * True, if the bot can read all messages in basic group or supergroup chats and
     * not just those addressed to the bot. In private and channel chats a bot can
     * always read all messages
     */
    can_read_all_group_messages: boolean,
    /** True, if the bot has the main Web App */
    has_main_web_app: boolean,
    /** True, if the bot supports inline queries */
    is_inline: boolean,
    /** Placeholder for inline queries (displayed on the application input field) */
    inline_query_placeholder: string,
    /**
     * True, if the location of the user is expected to be sent with every inline query
     * to this bot
     */
    need_location: boolean,
    /** True, if the bot supports connection to Telegram Business accounts */
    can_connect_to_business: boolean,
    /** True, if the bot can be added to attachment or side menu */
    can_be_added_to_attachment_menu: boolean,
    /** The number of recently active users of the bot */
    active_user_count: number,
  }

  export type userTypeUnknown = {
    /**
     * No information on the user besides the user identifier is available, yet this
     * user has not been deleted. This object is extremely rare and must be handled
     * like a deleted user. It is not possible to perform any actions on users of this
     * type
     */
    _: 'userTypeUnknown',
  }

  export type botCommand = {
    /** Represents a command supported by a bot */
    _: 'botCommand',
    /** Text of the bot command */
    command: string,
    /** Description of the bot command */
    description: string,
  }

  export type botCommand$Input = {
    /** Represents a command supported by a bot */
    readonly _: 'botCommand',
    /** Text of the bot command */
    readonly command?: string,
    /** Description of the bot command */
    readonly description?: string,
  }

  export type botCommands = {
    /** Contains a list of bot commands */
    _: 'botCommands',
    /** Bot's user identifier */
    bot_user_id: number,
    /** List of bot commands */
    commands: Array<botCommand>,
  }

  export type botMenuButton = {
    /** Describes a button to be shown instead of bot commands menu button */
    _: 'botMenuButton',
    /** Text of the button */
    text: string,
    /**
     * URL of a Web App to open when the button is pressed. If the link is of the type
     * internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the
     * link must be passed to openWebApp
     */
    url: string,
  }

  export type botMenuButton$Input = {
    /** Describes a button to be shown instead of bot commands menu button */
    readonly _: 'botMenuButton',
    /** Text of the button */
    readonly text?: string,
    /**
     * URL of a Web App to open when the button is pressed. If the link is of the type
     * internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the
     * link must be passed to openWebApp
     */
    readonly url?: string,
  }

  export type botVerificationParameters = {
    /** Describes parameters of verification that is provided by a bot */
    _: 'botVerificationParameters',
    /** Identifier of the custom emoji that is used as the verification sign */
    icon_custom_emoji_id: string,
    /** Name of the organization that provides verification */
    organization_name: string,
    /**
     * Default custom description of verification reason to be used as placeholder
     * in setMessageSenderBotVerification; may be null if none
     */
    default_custom_description?: formattedText,
    /** True, if the bot is allowed to provide custom description for verified entities */
    can_set_custom_description: boolean,
  }

  export type botVerification = {
    /** Describes verification status provided by a bot */
    _: 'botVerification',
    /** Identifier of the bot that provided the verification */
    bot_user_id: number,
    /** Identifier of the custom emoji that is used as the verification sign */
    icon_custom_emoji_id: string,
    /**
     * Custom description of verification reason set by the bot. Can contain only Mention,
     * Hashtag, Cashtag, PhoneNumber, BankCardNumber, Url, and EmailAddress entities
     */
    custom_description: formattedText,
  }

  export type verificationStatus = {
    /** Contains information about verification status of a chat or a user */
    _: 'verificationStatus',
    /** True, if the chat or the user is verified by Telegram */
    is_verified: boolean,
    /** True, if the chat or the user is marked as scam by Telegram */
    is_scam: boolean,
    /** True, if the chat or the user is marked as fake by Telegram */
    is_fake: boolean,
    /**
     * Identifier of the custom emoji to be shown as verification sign provided by
     * a bot for the user; 0 if none
     */
    bot_verification_icon_custom_emoji_id: string,
  }

  export type chatLocation = {
    /** Represents a location to which a chat is connected */
    _: 'chatLocation',
    /** The location */
    location: location,
    /** Location address; 1-64 characters, as defined by the chat owner */
    address: string,
  }

  export type chatLocation$Input = {
    /** Represents a location to which a chat is connected */
    readonly _: 'chatLocation',
    /** The location */
    readonly location?: location$Input,
    /** Location address; 1-64 characters, as defined by the chat owner */
    readonly address?: string,
  }

  export type birthdate = {
    /** Represents a birthdate of a user */
    _: 'birthdate',
    /** Day of the month; 1-31 */
    day: number,
    /** Month of the year; 1-12 */
    month: number,
    /** Birth year; 0 if unknown */
    year: number,
  }

  export type birthdate$Input = {
    /** Represents a birthdate of a user */
    readonly _: 'birthdate',
    /** Day of the month; 1-31 */
    readonly day?: number,
    /** Month of the year; 1-12 */
    readonly month?: number,
    /** Birth year; 0 if unknown */
    readonly year?: number,
  }

  export type closeBirthdayUser = {
    /** Describes a user that had or will have a birthday soon */
    _: 'closeBirthdayUser',
    /** User identifier */
    user_id: number,
    /** Birthdate of the user */
    birthdate: birthdate,
  }

  export type businessAwayMessageScheduleAlways = {
    /** Send away messages always */
    _: 'businessAwayMessageScheduleAlways',
  }

  export type businessAwayMessageScheduleAlways$Input = {
    /** Send away messages always */
    readonly _: 'businessAwayMessageScheduleAlways',
  }

  export type businessAwayMessageScheduleOutsideOfOpeningHours = {
    /** Send away messages outside of the business opening hours */
    _: 'businessAwayMessageScheduleOutsideOfOpeningHours',
  }

  export type businessAwayMessageScheduleOutsideOfOpeningHours$Input = {
    /** Send away messages outside of the business opening hours */
    readonly _: 'businessAwayMessageScheduleOutsideOfOpeningHours',
  }

  export type businessAwayMessageScheduleCustom = {
    /** Send away messages only in the specified time span */
    _: 'businessAwayMessageScheduleCustom',
    /** Point in time (Unix timestamp) when the away messages will start to be sent */
    start_date: number,
    /** Point in time (Unix timestamp) when the away messages will stop to be sent */
    end_date: number,
  }

  export type businessAwayMessageScheduleCustom$Input = {
    /** Send away messages only in the specified time span */
    readonly _: 'businessAwayMessageScheduleCustom',
    /** Point in time (Unix timestamp) when the away messages will start to be sent */
    readonly start_date?: number,
    /** Point in time (Unix timestamp) when the away messages will stop to be sent */
    readonly end_date?: number,
  }

  export type businessLocation = {
    /** Represents a location of a business */
    _: 'businessLocation',
    /** The location; may be null if not specified */
    location?: location,
    /** Location address; 1-96 characters */
    address: string,
  }

  export type businessLocation$Input = {
    /** Represents a location of a business */
    readonly _: 'businessLocation',
    /** The location; may be null if not specified */
    readonly location?: location$Input,
    /** Location address; 1-96 characters */
    readonly address?: string,
  }

  export type businessRecipients = {
    /** Describes private chats chosen for automatic interaction with a business */
    _: 'businessRecipients',
    /** Identifiers of selected private chats */
    chat_ids: Array<number>,
    /**
     * Identifiers of private chats that are always excluded; for businessConnectedBot
     * only
     */
    excluded_chat_ids: Array<number>,
    /** True, if all existing private chats are selected */
    select_existing_chats: boolean,
    /** True, if all new private chats are selected */
    select_new_chats: boolean,
    /** True, if all private chats with contacts are selected */
    select_contacts: boolean,
    /** True, if all private chats with non-contacts are selected */
    select_non_contacts: boolean,
    /**
     * If true, then all private chats except the selected are chosen. Otherwise, only
     * the selected chats are chosen
     */
    exclude_selected: boolean,
  }

  export type businessRecipients$Input = {
    /** Describes private chats chosen for automatic interaction with a business */
    readonly _: 'businessRecipients',
    /** Identifiers of selected private chats */
    readonly chat_ids?: ReadonlyArray<number>,
    /**
     * Identifiers of private chats that are always excluded; for businessConnectedBot
     * only
     */
    readonly excluded_chat_ids?: ReadonlyArray<number>,
    /** True, if all existing private chats are selected */
    readonly select_existing_chats?: boolean,
    /** True, if all new private chats are selected */
    readonly select_new_chats?: boolean,
    /** True, if all private chats with contacts are selected */
    readonly select_contacts?: boolean,
    /** True, if all private chats with non-contacts are selected */
    readonly select_non_contacts?: boolean,
    /**
     * If true, then all private chats except the selected are chosen. Otherwise, only
     * the selected chats are chosen
     */
    readonly exclude_selected?: boolean,
  }

  export type businessAwayMessageSettings = {
    /**
     * Describes settings for messages that are automatically sent by a Telegram Business
     * account when it is away
     */
    _: 'businessAwayMessageSettings',
    /** Unique quick reply shortcut identifier for the away messages */
    shortcut_id: number,
    /** Chosen recipients of the away messages */
    recipients: businessRecipients,
    /** Settings used to check whether the current user is away */
    schedule: BusinessAwayMessageSchedule,
    /**
     * True, if the messages must not be sent if the account was online in the last
     * 10 minutes
     */
    offline_only: boolean,
  }

  export type businessAwayMessageSettings$Input = {
    /**
     * Describes settings for messages that are automatically sent by a Telegram Business
     * account when it is away
     */
    readonly _: 'businessAwayMessageSettings',
    /** Unique quick reply shortcut identifier for the away messages */
    readonly shortcut_id?: number,
    /** Chosen recipients of the away messages */
    readonly recipients?: businessRecipients$Input,
    /** Settings used to check whether the current user is away */
    readonly schedule?: BusinessAwayMessageSchedule$Input,
    /**
     * True, if the messages must not be sent if the account was online in the last
     * 10 minutes
     */
    readonly offline_only?: boolean,
  }

  export type businessGreetingMessageSettings = {
    /**
     * Describes settings for greeting messages that are automatically sent by a Telegram
     * Business account as response to incoming messages in an inactive private chat
     */
    _: 'businessGreetingMessageSettings',
    /** Unique quick reply shortcut identifier for the greeting messages */
    shortcut_id: number,
    /** Chosen recipients of the greeting messages */
    recipients: businessRecipients,
    /**
     * The number of days after which a chat will be considered as inactive; currently,
     * must be on of 7, 14, 21, or 28
     */
    inactivity_days: number,
  }

  export type businessGreetingMessageSettings$Input = {
    /**
     * Describes settings for greeting messages that are automatically sent by a Telegram
     * Business account as response to incoming messages in an inactive private chat
     */
    readonly _: 'businessGreetingMessageSettings',
    /** Unique quick reply shortcut identifier for the greeting messages */
    readonly shortcut_id?: number,
    /** Chosen recipients of the greeting messages */
    readonly recipients?: businessRecipients$Input,
    /**
     * The number of days after which a chat will be considered as inactive; currently,
     * must be on of 7, 14, 21, or 28
     */
    readonly inactivity_days?: number,
  }

  export type businessBotRights = {
    /** Describes rights of a business bot */
    _: 'businessBotRights',
    /**
     * True, if the bot can send and edit messages in the private chats that had incoming
     * messages in the last 24 hours
     */
    can_reply: boolean,
    /** True, if the bot can mark incoming private messages as read */
    can_read_messages: boolean,
    /** True, if the bot can delete sent messages */
    can_delete_sent_messages: boolean,
    /** True, if the bot can delete any message */
    can_delete_all_messages: boolean,
    /** True, if the bot can edit name of the business account */
    can_edit_name: boolean,
    /** True, if the bot can edit bio of the business account */
    can_edit_bio: boolean,
    /** True, if the bot can edit profile photo of the business account */
    can_edit_profile_photo: boolean,
    /** True, if the bot can edit username of the business account */
    can_edit_username: boolean,
    /**
     * True, if the bot can view gifts and amount of Telegram Stars owned by the business
     * account
     */
    can_view_gifts_and_stars: boolean,
    /** True, if the bot can sell regular gifts received by the business account */
    can_sell_gifts: boolean,
    /** True, if the bot can change gift receiving settings of the business account */
    can_change_gift_settings: boolean,
    /** True, if the bot can transfer and upgrade gifts received by the business account */
    can_transfer_and_upgrade_gifts: boolean,
    /**
     * True, if the bot can transfer Telegram Stars received by the business account
     * to account of the bot, or use them to upgrade and transfer gifts
     */
    can_transfer_stars: boolean,
    /** True, if the bot can post, edit and delete stories */
    can_manage_stories: boolean,
  }

  export type businessBotRights$Input = {
    /** Describes rights of a business bot */
    readonly _: 'businessBotRights',
    /**
     * True, if the bot can send and edit messages in the private chats that had incoming
     * messages in the last 24 hours
     */
    readonly can_reply?: boolean,
    /** True, if the bot can mark incoming private messages as read */
    readonly can_read_messages?: boolean,
    /** True, if the bot can delete sent messages */
    readonly can_delete_sent_messages?: boolean,
    /** True, if the bot can delete any message */
    readonly can_delete_all_messages?: boolean,
    /** True, if the bot can edit name of the business account */
    readonly can_edit_name?: boolean,
    /** True, if the bot can edit bio of the business account */
    readonly can_edit_bio?: boolean,
    /** True, if the bot can edit profile photo of the business account */
    readonly can_edit_profile_photo?: boolean,
    /** True, if the bot can edit username of the business account */
    readonly can_edit_username?: boolean,
    /**
     * True, if the bot can view gifts and amount of Telegram Stars owned by the business
     * account
     */
    readonly can_view_gifts_and_stars?: boolean,
    /** True, if the bot can sell regular gifts received by the business account */
    readonly can_sell_gifts?: boolean,
    /** True, if the bot can change gift receiving settings of the business account */
    readonly can_change_gift_settings?: boolean,
    /** True, if the bot can transfer and upgrade gifts received by the business account */
    readonly can_transfer_and_upgrade_gifts?: boolean,
    /**
     * True, if the bot can transfer Telegram Stars received by the business account
     * to account of the bot, or use them to upgrade and transfer gifts
     */
    readonly can_transfer_stars?: boolean,
    /** True, if the bot can post, edit and delete stories */
    readonly can_manage_stories?: boolean,
  }

  export type businessConnectedBot = {
    /** Describes a bot connected to a business account */
    _: 'businessConnectedBot',
    /** User identifier of the bot */
    bot_user_id: number,
    /** Private chats that will be accessible to the bot */
    recipients: businessRecipients,
    /** Rights of the bot */
    rights: businessBotRights,
  }

  export type businessConnectedBot$Input = {
    /** Describes a bot connected to a business account */
    readonly _: 'businessConnectedBot',
    /** User identifier of the bot */
    readonly bot_user_id?: number,
    /** Private chats that will be accessible to the bot */
    readonly recipients?: businessRecipients$Input,
    /** Rights of the bot */
    readonly rights?: businessBotRights$Input,
  }

  export type businessStartPage = {
    /** Describes settings for a business account start page */
    _: 'businessStartPage',
    /** Title text of the start page */
    title: string,
    /** Message text of the start page */
    message: string,
    /** Greeting sticker of the start page; may be null if none */
    sticker?: sticker,
  }

  export type inputBusinessStartPage$Input = {
    /** Describes settings for a business account start page to set */
    readonly _: 'inputBusinessStartPage',
    /**
     * Title text of the start page; 0-getOption("business_start_page_title_length_max")
     * characters
     */
    readonly title?: string,
    /**
     * Message text of the start page; 0-getOption("business_start_page_message_length_max")
     * characters
     */
    readonly message?: string,
    /**
     * Greeting sticker of the start page; pass null if none. The sticker must belong
     * to a sticker set and must not be a custom emoji
     */
    readonly sticker?: InputFile$Input,
  }

  export type businessOpeningHoursInterval = {
    /** Describes an interval of time when the business is open */
    _: 'businessOpeningHoursInterval',
    /**
     * The minute's sequence number in a week, starting on Monday, marking the start
     * of the time interval during which the business is open; 0-7*24*60
     */
    start_minute: number,
    /**
     * The minute's sequence number in a week, starting on Monday, marking the end
     * of the time interval during which the business is open; 1-8*24*60
     */
    end_minute: number,
  }

  export type businessOpeningHoursInterval$Input = {
    /** Describes an interval of time when the business is open */
    readonly _: 'businessOpeningHoursInterval',
    /**
     * The minute's sequence number in a week, starting on Monday, marking the start
     * of the time interval during which the business is open; 0-7*24*60
     */
    readonly start_minute?: number,
    /**
     * The minute's sequence number in a week, starting on Monday, marking the end
     * of the time interval during which the business is open; 1-8*24*60
     */
    readonly end_minute?: number,
  }

  export type businessOpeningHours = {
    /** Describes opening hours of a business */
    _: 'businessOpeningHours',
    /** Unique time zone identifier */
    time_zone_id: string,
    /** Intervals of the time when the business is open */
    opening_hours: Array<businessOpeningHoursInterval>,
  }

  export type businessOpeningHours$Input = {
    /** Describes opening hours of a business */
    readonly _: 'businessOpeningHours',
    /** Unique time zone identifier */
    readonly time_zone_id?: string,
    /** Intervals of the time when the business is open */
    readonly opening_hours?: ReadonlyArray<businessOpeningHoursInterval$Input>,
  }

  export type businessInfo = {
    /** Contains information about a Telegram Business account */
    _: 'businessInfo',
    /** Location of the business; may be null if none */
    location?: businessLocation,
    /**
     * Opening hours of the business; may be null if none. The hours are guaranteed
     * to be valid and has already been split by week days
     */
    opening_hours?: businessOpeningHours,
    /**
     * Opening hours of the business in the local time; may be null if none. The hours
     * are guaranteed to be valid and has already been split by week days. Local time
     * zone identifier will be empty. An updateUserFullInfo update is not triggered
     * when value of this field changes
     */
    local_opening_hours?: businessOpeningHours,
    /**
     * Time left before the business will open the next time, in seconds; 0 if unknown.
     * An updateUserFullInfo update is not triggered when value of this field changes
     */
    next_open_in: number,
    /**
     * Time left before the business will close the next time, in seconds; 0 if unknown.
     * An updateUserFullInfo update is not triggered when value of this field changes
     */
    next_close_in: number,
    /**
     * The greeting message; may be null if none or the Business account is not of
     * the current user
     */
    greeting_message_settings?: businessGreetingMessageSettings,
    /**
     * The away message; may be null if none or the Business account is not of the
     * current user
     */
    away_message_settings?: businessAwayMessageSettings,
    /** Information about start page of the account; may be null if none */
    start_page?: businessStartPage,
  }

  export type businessChatLink = {
    /** Contains information about a business chat link */
    _: 'businessChatLink',
    /** The HTTPS link */
    link: string,
    /** Message draft text that will be added to the input field */
    text: formattedText,
    /** Link title */
    title: string,
    /** Number of times the link was used */
    view_count: number,
  }

  export type businessChatLinks = {
    /** Contains a list of business chat links created by the user */
    _: 'businessChatLinks',
    /** List of links */
    links: Array<businessChatLink>,
  }

  export type inputBusinessChatLink$Input = {
    /** Describes a business chat link to create or edit */
    readonly _: 'inputBusinessChatLink',
    /** Message draft text that will be added to the input field */
    readonly text?: formattedText$Input,
    /** Link title */
    readonly title?: string,
  }

  export type businessChatLinkInfo = {
    /** Contains information about a business chat link */
    _: 'businessChatLinkInfo',
    /** Identifier of the private chat that created the link */
    chat_id: number,
    /** Message draft text that must be added to the input field */
    text: formattedText,
  }

  export type chatPhotoStickerTypeRegularOrMask = {
    /** Information about the sticker, which was used to create the chat photo */
    _: 'chatPhotoStickerTypeRegularOrMask',
    /** Sticker set identifier */
    sticker_set_id: string,
    /** Identifier of the sticker in the set */
    sticker_id: string,
  }

  export type chatPhotoStickerTypeRegularOrMask$Input = {
    /** Information about the sticker, which was used to create the chat photo */
    readonly _: 'chatPhotoStickerTypeRegularOrMask',
    /** Sticker set identifier */
    readonly sticker_set_id?: number | string,
    /** Identifier of the sticker in the set */
    readonly sticker_id?: number | string,
  }

  export type chatPhotoStickerTypeCustomEmoji = {
    /** Information about the custom emoji, which was used to create the chat photo */
    _: 'chatPhotoStickerTypeCustomEmoji',
    /** Identifier of the custom emoji */
    custom_emoji_id: string,
  }

  export type chatPhotoStickerTypeCustomEmoji$Input = {
    /** Information about the custom emoji, which was used to create the chat photo */
    readonly _: 'chatPhotoStickerTypeCustomEmoji',
    /** Identifier of the custom emoji */
    readonly custom_emoji_id?: number | string,
  }

  export type chatPhotoSticker = {
    /**
     * Information about the sticker, which was used to create the chat photo. The
     * sticker is shown at the center of the photo and occupies at most 67% of it
     */
    _: 'chatPhotoSticker',
    /** Type of the sticker */
    type: ChatPhotoStickerType,
    /**
     * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient
     * isn't supported
     */
    background_fill: BackgroundFill,
  }

  export type chatPhotoSticker$Input = {
    /**
     * Information about the sticker, which was used to create the chat photo. The
     * sticker is shown at the center of the photo and occupies at most 67% of it
     */
    readonly _: 'chatPhotoSticker',
    /** Type of the sticker */
    readonly type?: ChatPhotoStickerType$Input,
    /**
     * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient
     * isn't supported
     */
    readonly background_fill?: BackgroundFill$Input,
  }

  export type animatedChatPhoto = {
    /** Animated variant of a chat photo in MPEG4 format */
    _: 'animatedChatPhoto',
    /** Animation width and height */
    length: number,
    /** Information about the animation file */
    file: file,
    /** Timestamp of the frame, used as a static chat photo */
    main_frame_timestamp: number,
  }

  export type chatPhoto = {
    /** Describes a chat or user profile photo */
    _: 'chatPhoto',
    /** Unique photo identifier */
    id: string,
    /** Point in time (Unix timestamp) when the photo has been added */
    added_date: number,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo in JPEG format, in different size */
    sizes: Array<photoSize>,
    /**
     * A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be
     * null
     */
    animation?: animatedChatPhoto,
    /**
     * A small (160x160) animated variant of the photo in MPEG4 format; may be null
     * even the big animation is available
     */
    small_animation?: animatedChatPhoto,
    /** Sticker-based version of the chat photo; may be null */
    sticker?: chatPhotoSticker,
  }

  export type chatPhotos = {
    /** Contains a list of chat or user profile photos */
    _: 'chatPhotos',
    /** Total number of photos */
    total_count: number,
    /** List of photos */
    photos: Array<chatPhoto>,
  }

  export type inputChatPhotoPrevious$Input = {
    /** A previously used profile photo of the current user */
    readonly _: 'inputChatPhotoPrevious',
    /** Identifier of the current user's profile photo to reuse */
    readonly chat_photo_id?: number | string,
  }

  export type inputChatPhotoStatic$Input = {
    /** A static photo in JPEG format */
    readonly _: 'inputChatPhotoStatic',
    /**
     * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    readonly photo?: InputFile$Input,
  }

  export type inputChatPhotoAnimation$Input = {
    /**
     * An animation in MPEG4 format; must be square, at most 10 seconds long, have
     * width between 160 and 1280 and be at most 2MB in size
     */
    readonly _: 'inputChatPhotoAnimation',
    /**
     * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    readonly animation?: InputFile$Input,
    /** Timestamp of the frame, which will be used as static chat photo */
    readonly main_frame_timestamp?: number,
  }

  export type inputChatPhotoSticker$Input = {
    /** A sticker on a custom background */
    readonly _: 'inputChatPhotoSticker',
    /** Information about the sticker */
    readonly sticker?: chatPhotoSticker$Input,
  }

  export type chatPermissions = {
    /** Describes actions that a user is allowed to take in a chat */
    _: 'chatPermissions',
    /**
     * True, if the user can send text messages, contacts, giveaways, giveaway winners,
     * invoices, locations, and venues
     */
    can_send_basic_messages: boolean,
    /** True, if the user can send music files */
    can_send_audios: boolean,
    /** True, if the user can send documents */
    can_send_documents: boolean,
    /** True, if the user can send photos */
    can_send_photos: boolean,
    /** True, if the user can send videos */
    can_send_videos: boolean,
    /** True, if the user can send video notes */
    can_send_video_notes: boolean,
    /** True, if the user can send voice notes */
    can_send_voice_notes: boolean,
    /** True, if the user can send polls and checklists */
    can_send_polls: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots
     */
    can_send_other_messages: boolean,
    /** True, if the user may add a link preview to their messages */
    can_add_link_previews: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /** True, if the user can invite new users to the chat */
    can_invite_users: boolean,
    /** True, if the user can pin messages */
    can_pin_messages: boolean,
    /** True, if the user can create topics */
    can_create_topics: boolean,
  }

  export type chatPermissions$Input = {
    /** Describes actions that a user is allowed to take in a chat */
    readonly _: 'chatPermissions',
    /**
     * True, if the user can send text messages, contacts, giveaways, giveaway winners,
     * invoices, locations, and venues
     */
    readonly can_send_basic_messages?: boolean,
    /** True, if the user can send music files */
    readonly can_send_audios?: boolean,
    /** True, if the user can send documents */
    readonly can_send_documents?: boolean,
    /** True, if the user can send photos */
    readonly can_send_photos?: boolean,
    /** True, if the user can send videos */
    readonly can_send_videos?: boolean,
    /** True, if the user can send video notes */
    readonly can_send_video_notes?: boolean,
    /** True, if the user can send voice notes */
    readonly can_send_voice_notes?: boolean,
    /** True, if the user can send polls and checklists */
    readonly can_send_polls?: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots
     */
    readonly can_send_other_messages?: boolean,
    /** True, if the user may add a link preview to their messages */
    readonly can_add_link_previews?: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    readonly can_change_info?: boolean,
    /** True, if the user can invite new users to the chat */
    readonly can_invite_users?: boolean,
    /** True, if the user can pin messages */
    readonly can_pin_messages?: boolean,
    /** True, if the user can create topics */
    readonly can_create_topics?: boolean,
  }

  export type chatAdministratorRights = {
    /** Describes rights of the administrator */
    _: 'chatAdministratorRights',
    /**
     * True, if the administrator can access the chat event log, get boost list, see
     * hidden supergroup and channel members, report supergroup spam messages, ignore
     * slow mode, and send messages to the chat without paying Telegram Stars. Implied
     * by any other privilege; applicable to supergroups and channels only
     */
    can_manage_chat: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /**
     * True, if the administrator can create channel posts, answer to channel direct
     * messages, or view channel statistics; applicable to channels only
     */
    can_post_messages: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    can_edit_messages: boolean,
    /** True, if the administrator can delete messages of other users */
    can_delete_messages: boolean,
    /** True, if the administrator can invite new users to the chat */
    can_invite_users: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members or view
     * supergroup statistics; always true for channels
     */
    can_restrict_members: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    can_pin_messages: boolean,
    /**
     * True, if the administrator can create, rename, close, reopen, hide, and unhide
     * forum topics; applicable to forum supergroups only
     */
    can_manage_topics: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    can_promote_members: boolean,
    /** True, if the administrator can manage video chats */
    can_manage_video_chats: boolean,
    /**
     * True, if the administrator can create new chat stories, or edit and delete posted
     * stories; applicable to supergroups and channels only
     */
    can_post_stories: boolean,
    /**
     * True, if the administrator can edit stories posted by other users, post stories
     * to the chat page, pin chat stories, and access story archive; applicable to
     * supergroups and channels only
     */
    can_edit_stories: boolean,
    /**
     * True, if the administrator can delete stories posted by other users; applicable
     * to supergroups and channels only
     */
    can_delete_stories: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
  }

  export type chatAdministratorRights$Input = {
    /** Describes rights of the administrator */
    readonly _: 'chatAdministratorRights',
    /**
     * True, if the administrator can access the chat event log, get boost list, see
     * hidden supergroup and channel members, report supergroup spam messages, ignore
     * slow mode, and send messages to the chat without paying Telegram Stars. Implied
     * by any other privilege; applicable to supergroups and channels only
     */
    readonly can_manage_chat?: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    readonly can_change_info?: boolean,
    /**
     * True, if the administrator can create channel posts, answer to channel direct
     * messages, or view channel statistics; applicable to channels only
     */
    readonly can_post_messages?: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    readonly can_edit_messages?: boolean,
    /** True, if the administrator can delete messages of other users */
    readonly can_delete_messages?: boolean,
    /** True, if the administrator can invite new users to the chat */
    readonly can_invite_users?: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members or view
     * supergroup statistics; always true for channels
     */
    readonly can_restrict_members?: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    readonly can_pin_messages?: boolean,
    /**
     * True, if the administrator can create, rename, close, reopen, hide, and unhide
     * forum topics; applicable to forum supergroups only
     */
    readonly can_manage_topics?: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    readonly can_promote_members?: boolean,
    /** True, if the administrator can manage video chats */
    readonly can_manage_video_chats?: boolean,
    /**
     * True, if the administrator can create new chat stories, or edit and delete posted
     * stories; applicable to supergroups and channels only
     */
    readonly can_post_stories?: boolean,
    /**
     * True, if the administrator can edit stories posted by other users, post stories
     * to the chat page, pin chat stories, and access story archive; applicable to
     * supergroups and channels only
     */
    readonly can_edit_stories?: boolean,
    /**
     * True, if the administrator can delete stories posted by other users; applicable
     * to supergroups and channels only
     */
    readonly can_delete_stories?: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    readonly is_anonymous?: boolean,
  }

  export type starAmount = {
    /** Describes a possibly non-integer amount of Telegram Stars */
    _: 'starAmount',
    /** The integer amount of Telegram Stars rounded to 0 */
    star_count: number,
    /** The number of 1/1000000000 shares of Telegram Stars; from -999999999 to 999999999 */
    nanostar_count: number,
  }

  export type starSubscriptionTypeChannel = {
    /** Describes a subscription to a channel chat */
    _: 'starSubscriptionTypeChannel',
    /**
     * True, if the subscription is active and the user can use the method reuseStarSubscription
     * to join the subscribed chat again
     */
    can_reuse: boolean,
    /**
     * The invite link that can be used to renew the subscription if it has been expired;
     * may be empty, if the link isn't available anymore
     */
    invite_link: string,
  }

  export type starSubscriptionTypeBot = {
    /** Describes a subscription in a bot or a business account */
    _: 'starSubscriptionTypeBot',
    /** True, if the subscription was canceled by the bot and can't be extended */
    is_canceled_by_bot: boolean,
    /** Subscription invoice title */
    title: string,
    /** Subscription invoice photo */
    photo: photo,
    /** The link to the subscription invoice */
    invoice_link: string,
  }

  export type starSubscriptionPricing = {
    /** Describes subscription plan paid in Telegram Stars */
    _: 'starSubscriptionPricing',
    /** The number of seconds between consecutive Telegram Star debiting */
    period: number,
    /** The amount of Telegram Stars that must be paid for each period */
    star_count: number,
  }

  export type starSubscriptionPricing$Input = {
    /** Describes subscription plan paid in Telegram Stars */
    readonly _: 'starSubscriptionPricing',
    /** The number of seconds between consecutive Telegram Star debiting */
    readonly period?: number,
    /** The amount of Telegram Stars that must be paid for each period */
    readonly star_count?: number,
  }

  export type starSubscription = {
    /**
     * Contains information about subscription to a channel chat, a bot, or a business
     * account that was paid in Telegram Stars
     */
    _: 'starSubscription',
    /** Unique identifier of the subscription */
    id: string,
    /** Identifier of the chat that is subscribed */
    chat_id: number,
    /** Point in time (Unix timestamp) when the subscription will expire or expired */
    expiration_date: number,
    /** True, if the subscription was canceled */
    is_canceled: boolean,
    /**
     * True, if the subscription expires soon and there are no enough Telegram Stars
     * on the user's balance to extend it
     */
    is_expiring: boolean,
    /** The subscription plan */
    pricing: starSubscriptionPricing,
    /** Type of the subscription */
    type: StarSubscriptionType,
  }

  export type starSubscriptions = {
    /** Represents a list of Telegram Star subscriptions */
    _: 'starSubscriptions',
    /** The amount of owned Telegram Stars */
    star_amount: starAmount,
    /** List of subscriptions for Telegram Stars */
    subscriptions: Array<starSubscription>,
    /**
     * The number of Telegram Stars required to buy to extend subscriptions expiring
     * soon
     */
    required_star_count: number,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type affiliateTypeCurrentUser$Input = {
    /** The affiliate is the current user */
    readonly _: 'affiliateTypeCurrentUser',
  }

  export type affiliateTypeBot$Input = {
    /** The affiliate is a bot owned by the current user */
    readonly _: 'affiliateTypeBot',
    /** User identifier of the bot */
    readonly user_id?: number,
  }

  export type affiliateTypeChannel$Input = {
    /**
     * The affiliate is a channel chat where the current user has can_post_messages
     * administrator right
     */
    readonly _: 'affiliateTypeChannel',
    /** Identifier of the channel chat */
    readonly chat_id?: number,
  }

  export type affiliateProgramSortOrderProfitability$Input = {
    /** The affiliate programs must be sorted by the profitability */
    readonly _: 'affiliateProgramSortOrderProfitability',
  }

  export type affiliateProgramSortOrderCreationDate$Input = {
    /** The affiliate programs must be sorted by creation date */
    readonly _: 'affiliateProgramSortOrderCreationDate',
  }

  export type affiliateProgramSortOrderRevenue$Input = {
    /** The affiliate programs must be sorted by the expected revenue */
    readonly _: 'affiliateProgramSortOrderRevenue',
  }

  export type affiliateProgramParameters = {
    /** Describes parameters of an affiliate program */
    _: 'affiliateProgramParameters',
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner; getOption("affiliate_program_commission_per_mille_min")-getOption("affiliate_program_commission_per_mille_max")
     */
    commission_per_mille: number,
    /**
     * Number of months the program will be active; 0-36. If 0, then the program is
     * eternal
     */
    month_count: number,
  }

  export type affiliateProgramParameters$Input = {
    /** Describes parameters of an affiliate program */
    readonly _: 'affiliateProgramParameters',
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner; getOption("affiliate_program_commission_per_mille_min")-getOption("affiliate_program_commission_per_mille_max")
     */
    readonly commission_per_mille?: number,
    /**
     * Number of months the program will be active; 0-36. If 0, then the program is
     * eternal
     */
    readonly month_count?: number,
  }

  export type affiliateProgramInfo = {
    /** Contains information about an active affiliate program */
    _: 'affiliateProgramInfo',
    /** Parameters of the affiliate program */
    parameters: affiliateProgramParameters,
    /**
     * Point in time (Unix timestamp) when the affiliate program will be closed; 0
     * if the affiliate program isn't scheduled to be closed. If positive, then the
     * program can't be connected using connectAffiliateProgram, but active connections
     * will work until the date
     */
    end_date: number,
    /**
     * The amount of daily revenue per user in Telegram Stars of the bot that created
     * the affiliate program
     */
    daily_revenue_per_user_amount: starAmount,
  }

  export type affiliateInfo = {
    /**
     * Contains information about an affiliate that received commission from a Telegram
     * Star transaction
     */
    _: 'affiliateInfo',
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner
     */
    commission_per_mille: number,
    /** Identifier of the chat which received the commission */
    affiliate_chat_id: number,
    /**
     * The amount of Telegram Stars that were received by the affiliate; can be negative
     * for refunds
     */
    star_amount: starAmount,
  }

  export type foundAffiliateProgram = {
    /** Describes a found affiliate program */
    _: 'foundAffiliateProgram',
    /** User identifier of the bot created the program */
    bot_user_id: number,
    /** Information about the affiliate program */
    info: affiliateProgramInfo,
  }

  export type foundAffiliatePrograms = {
    /** Represents a list of found affiliate programs */
    _: 'foundAffiliatePrograms',
    /** The total number of found affiliate programs */
    total_count: number,
    /** The list of affiliate programs */
    programs: Array<foundAffiliateProgram>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type connectedAffiliateProgram = {
    /** Describes an affiliate program that was connected to an affiliate */
    _: 'connectedAffiliateProgram',
    /** The link that can be used to refer users if the program is still active */
    url: string,
    /** User identifier of the bot created the program */
    bot_user_id: number,
    /** The parameters of the affiliate program */
    parameters: affiliateProgramParameters,
    /** Point in time (Unix timestamp) when the affiliate program was connected */
    connection_date: number,
    /**
     * True, if the program was canceled by the bot, or disconnected by the chat owner
     * and isn't available anymore
     */
    is_disconnected: boolean,
    /** The number of users that used the affiliate program */
    user_count: string,
    /** The number of Telegram Stars that were earned by the affiliate program */
    revenue_star_count: string,
  }

  export type connectedAffiliatePrograms = {
    /** Represents a list of affiliate programs that were connected to an affiliate */
    _: 'connectedAffiliatePrograms',
    /** The total number of affiliate programs that were connected to the affiliate */
    total_count: number,
    /** The list of connected affiliate programs */
    programs: Array<connectedAffiliateProgram>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type productInfo = {
    /** Contains information about a product that can be paid with invoice */
    _: 'productInfo',
    /** Product title */
    title: string,
    /** Product description */
    description: formattedText,
    /** Product photo; may be null */
    photo?: photo,
  }

  export type premiumPaymentOption = {
    /** Describes an option for buying Telegram Premium to a user */
    _: 'premiumPaymentOption',
    /** ISO 4217 currency code for Telegram Premium subscription payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** The discount associated with this option, as a percentage */
    discount_percentage: number,
    /**
     * Number of months the Telegram Premium subscription will be active. Use getPremiumInfoSticker
     * to get the sticker to be used as representation of the Telegram Premium subscription
     */
    month_count: number,
    /** Identifier of the store product associated with the option */
    store_product_id: string,
    /**
     * An internal link to be opened for buying Telegram Premium to the user if store
     * payment isn't possible; may be null if direct payment isn't available
     */
    payment_link?: InternalLinkType,
  }

  export type premiumStatePaymentOption = {
    /** Describes an option for buying or upgrading Telegram Premium for self */
    _: 'premiumStatePaymentOption',
    /** Information about the payment option */
    payment_option: premiumPaymentOption,
    /** True, if this is the currently used Telegram Premium subscription option */
    is_current: boolean,
    /**
     * True, if the payment option can be used to upgrade the existing Telegram Premium
     * subscription
     */
    is_upgrade: boolean,
    /** Identifier of the last in-store transaction for the currently used option */
    last_transaction_id: string,
  }

  export type premiumGiftPaymentOption = {
    /**
     * Describes an option for gifting Telegram Premium to a user. Use telegramPaymentPurposePremiumGift
     * for out-of-store payments or payments in Telegram Stars
     */
    _: 'premiumGiftPaymentOption',
    /** ISO 4217 currency code for the payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /**
     * The alternative amount of Telegram Stars to pay; 0 if payment in Telegram Stars
     * is not possible
     */
    star_count: number,
    /** The discount associated with this option, as a percentage */
    discount_percentage: number,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /** Identifier of the store product associated with the option */
    store_product_id: string,
    /** A sticker to be shown along with the option; may be null if unknown */
    sticker?: sticker,
  }

  export type premiumGiftPaymentOptions = {
    /** Contains a list of options for gifting Telegram Premium to a user */
    _: 'premiumGiftPaymentOptions',
    /** The list of options sorted by Telegram Premium subscription duration */
    options: Array<premiumGiftPaymentOption>,
  }

  export type premiumGiveawayPaymentOption = {
    /**
     * Describes an option for creating of Telegram Premium giveaway or manual distribution
     * of Telegram Premium among chat members. Use telegramPaymentPurposePremiumGiftCodes
     * or telegramPaymentPurposePremiumGiveaway for out-of-store payments
     */
    _: 'premiumGiveawayPaymentOption',
    /** ISO 4217 currency code for Telegram Premium gift code payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** Number of users which will be able to activate the gift codes */
    winner_count: number,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /**
     * Identifier of the store product associated with the option; may be empty if
     * none
     */
    store_product_id: string,
    /** Number of times the store product must be paid */
    store_product_quantity: number,
  }

  export type premiumGiveawayPaymentOptions = {
    /**
     * Contains a list of options for creating of Telegram Premium giveaway or manual
     * distribution of Telegram Premium among chat members
     */
    _: 'premiumGiveawayPaymentOptions',
    /** The list of options */
    options: Array<premiumGiveawayPaymentOption>,
  }

  export type premiumGiftCodeInfo = {
    /** Contains information about a Telegram Premium gift code */
    _: 'premiumGiftCodeInfo',
    /**
     * Identifier of a chat or a user that created the gift code; may be null if unknown.
     * If null and the code is from messagePremiumGiftCode message, then creator_id
     * from the message can be used
     */
    creator_id?: MessageSender,
    /** Point in time (Unix timestamp) when the code was created */
    creation_date: number,
    /** True, if the gift code was created for a giveaway */
    is_from_giveaway: boolean,
    /**
     * Identifier of the corresponding giveaway message in the creator_id chat; can
     * be 0 or an identifier of a deleted message
     */
    giveaway_message_id: number,
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
    /** Identifier of a user for which the code was created; 0 if none */
    user_id: number,
    /** Point in time (Unix timestamp) when the code was activated; 0 if none */
    use_date: number,
  }

  export type starPaymentOption = {
    /**
     * Describes an option for buying Telegram Stars. Use telegramPaymentPurposeStars
     * for out-of-store payments
     */
    _: 'starPaymentOption',
    /** ISO 4217 currency code for the payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** Number of Telegram Stars that will be purchased */
    star_count: number,
    /**
     * Identifier of the store product associated with the option; may be empty if
     * none
     */
    store_product_id: string,
    /** True, if the option must be shown only in the full list of payment options */
    is_additional: boolean,
  }

  export type starPaymentOptions = {
    /** Contains a list of options for buying Telegram Stars */
    _: 'starPaymentOptions',
    /** The list of options */
    options: Array<starPaymentOption>,
  }

  export type starGiveawayWinnerOption = {
    /** Describes an option for the number of winners of a Telegram Star giveaway */
    _: 'starGiveawayWinnerOption',
    /** The number of users that will be chosen as winners */
    winner_count: number,
    /** The number of Telegram Stars that will be won by the winners of the giveaway */
    won_star_count: number,
    /** True, if the option must be chosen by default */
    is_default: boolean,
  }

  export type starGiveawayPaymentOption = {
    /**
     * Describes an option for creating of Telegram Star giveaway. Use telegramPaymentPurposeStarGiveaway
     * for out-of-store payments
     */
    _: 'starGiveawayPaymentOption',
    /** ISO 4217 currency code for the payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** Number of Telegram Stars that will be distributed among winners */
    star_count: number,
    /**
     * Identifier of the store product associated with the option; may be empty if
     * none
     */
    store_product_id: string,
    /** Number of times the chat will be boosted for one year if the option is chosen */
    yearly_boost_count: number,
    /** Allowed options for the number of giveaway winners */
    winner_options: Array<starGiveawayWinnerOption>,
    /** True, if the option must be chosen by default */
    is_default: boolean,
    /** True, if the option must be shown only in the full list of payment options */
    is_additional: boolean,
  }

  export type starGiveawayPaymentOptions = {
    /** Contains a list of options for creating of Telegram Star giveaway */
    _: 'starGiveawayPaymentOptions',
    /** The list of options */
    options: Array<starGiveawayPaymentOption>,
  }

  export type acceptedGiftTypes = {
    /** Describes gift types that are accepted by a user */
    _: 'acceptedGiftTypes',
    /** True, if unlimited regular gifts are accepted */
    unlimited_gifts: boolean,
    /** True, if limited regular gifts are accepted */
    limited_gifts: boolean,
    /**
     * True, if upgraded gifts and regular gifts that can be upgraded for free are
     * accepted
     */
    upgraded_gifts: boolean,
    /** True, if Telegram Premium subscription is accepted */
    premium_subscription: boolean,
  }

  export type acceptedGiftTypes$Input = {
    /** Describes gift types that are accepted by a user */
    readonly _: 'acceptedGiftTypes',
    /** True, if unlimited regular gifts are accepted */
    readonly unlimited_gifts?: boolean,
    /** True, if limited regular gifts are accepted */
    readonly limited_gifts?: boolean,
    /**
     * True, if upgraded gifts and regular gifts that can be upgraded for free are
     * accepted
     */
    readonly upgraded_gifts?: boolean,
    /** True, if Telegram Premium subscription is accepted */
    readonly premium_subscription?: boolean,
  }

  export type giftSettings = {
    /** Contains settings for gift receiving for a user */
    _: 'giftSettings',
    /**
     * True, if a button for sending a gift to the user or by the user must always
     * be shown in the input field
     */
    show_gift_button: boolean,
    /** Types of gifts accepted by the user; for Telegram Premium users only */
    accepted_gift_types: acceptedGiftTypes,
  }

  export type giftSettings$Input = {
    /** Contains settings for gift receiving for a user */
    readonly _: 'giftSettings',
    /**
     * True, if a button for sending a gift to the user or by the user must always
     * be shown in the input field
     */
    readonly show_gift_button?: boolean,
    /** Types of gifts accepted by the user; for Telegram Premium users only */
    readonly accepted_gift_types?: acceptedGiftTypes$Input,
  }

  export type upgradedGiftModel = {
    /** Describes a model of an upgraded gift */
    _: 'upgradedGiftModel',
    /** Name of the model */
    name: string,
    /** The sticker representing the upgraded gift */
    sticker: sticker,
    /** The number of upgraded gifts that receive this model for each 1000 gifts upgraded */
    rarity_per_mille: number,
  }

  export type upgradedGiftSymbol = {
    /** Describes a symbol shown on the pattern of an upgraded gift */
    _: 'upgradedGiftSymbol',
    /** Name of the symbol */
    name: string,
    /** The sticker representing the symbol */
    sticker: sticker,
    /** The number of upgraded gifts that receive this symbol for each 1000 gifts upgraded */
    rarity_per_mille: number,
  }

  export type upgradedGiftBackdropColors = {
    /** Describes colors of a backdrop of an upgraded gift */
    _: 'upgradedGiftBackdropColors',
    /** A color in the center of the backdrop in the RGB format */
    center_color: number,
    /** A color on the edges of the backdrop in the RGB format */
    edge_color: number,
    /** A color to be applied for the symbol in the RGB format */
    symbol_color: number,
    /** A color for the text on the backdrop in the RGB format */
    text_color: number,
  }

  export type upgradedGiftBackdropColors$Input = {
    /** Describes colors of a backdrop of an upgraded gift */
    readonly _: 'upgradedGiftBackdropColors',
    /** A color in the center of the backdrop in the RGB format */
    readonly center_color?: number,
    /** A color on the edges of the backdrop in the RGB format */
    readonly edge_color?: number,
    /** A color to be applied for the symbol in the RGB format */
    readonly symbol_color?: number,
    /** A color for the text on the backdrop in the RGB format */
    readonly text_color?: number,
  }

  export type upgradedGiftBackdrop = {
    /** Describes a backdrop of an upgraded gift */
    _: 'upgradedGiftBackdrop',
    /** Unique identifier of the backdrop */
    id: number,
    /** Name of the backdrop */
    name: string,
    /** Colors of the backdrop */
    colors: upgradedGiftBackdropColors,
    /**
     * The number of upgraded gifts that receive this backdrop for each 1000 gifts
     * upgraded
     */
    rarity_per_mille: number,
  }

  export type upgradedGiftOriginalDetails = {
    /** Describes the original details about the gift */
    _: 'upgradedGiftOriginalDetails',
    /**
     * Identifier of the user or the chat that sent the gift; may be null if the gift
     * was private
     */
    sender_id?: MessageSender,
    /** Identifier of the user or the chat that received the gift */
    receiver_id: MessageSender,
    /** Message added to the gift */
    text: formattedText,
    /** Point in time (Unix timestamp) when the gift was sent */
    date: number,
  }

  export type gift = {
    /** Describes a gift that can be sent to another user or channel chat */
    _: 'gift',
    /** Unique identifier of the gift */
    id: string,
    /** The sticker representing the gift */
    sticker: sticker,
    /** Number of Telegram Stars that must be paid for the gift */
    star_count: number,
    /**
     * Number of Telegram Stars that can be claimed by the receiver instead of the
     * regular gift by default. If the gift was paid with just bought Telegram Stars,
     * then full value can be claimed
     */
    default_sell_star_count: number,
    /**
     * Number of Telegram Stars that must be paid to upgrade the gift; 0 if upgrade
     * isn't possible
     */
    upgrade_star_count: number,
    /** True, if the gift is a birthday gift */
    is_for_birthday: boolean,
    /**
     * Number of remaining times the gift can be purchased; 0 if not limited or the
     * gift was sold out
     */
    remaining_count: number,
    /** Number of total times the gift can be purchased; 0 if not limited */
    total_count: number,
    /**
     * Point in time (Unix timestamp) when the gift was send for the first time; for
     * sold out gifts only
     */
    first_send_date: number,
    /**
     * Point in time (Unix timestamp) when the gift was send for the last time; for
     * sold out gifts only
     */
    last_send_date: number,
  }

  export type upgradedGift = {
    /**
     * Describes an upgraded gift that can be transferred to another owner or transferred
     * to the TON blockchain as an NFT
     */
    _: 'upgradedGift',
    /** Unique identifier of the gift */
    id: string,
    /** The title of the upgraded gift */
    title: string,
    /**
     * Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift
     * or sendResoldGift
     */
    name: string,
    /** Unique number of the upgraded gift among gifts upgraded from the same gift */
    number: number,
    /** Total number of gifts that were upgraded from the same gift */
    total_upgraded_count: number,
    /** The maximum number of gifts that can be upgraded from the same gift */
    max_upgraded_count: number,
    /**
     * Identifier of the user or the chat that owns the upgraded gift; may be null
     * if none or unknown
     */
    owner_id?: MessageSender,
    /**
     * Address of the gift NFT owner in TON blockchain; may be empty if none. Append
     * the address to getOption("ton_blockchain_explorer_url") to get a link with information
     * about the address
     */
    owner_address: string,
    /** Name of the owner for the case when owner identifier and address aren't known */
    owner_name: string,
    /**
     * Address of the gift NFT in TON blockchain; may be empty if none. Append the
     * address to getOption("ton_blockchain_explorer_url") to get a link with information
     * about the address
     */
    gift_address: string,
    /** Model of the upgraded gift */
    model: upgradedGiftModel,
    /** Symbol of the upgraded gift */
    symbol: upgradedGiftSymbol,
    /** Backdrop of the upgraded gift */
    backdrop: upgradedGiftBackdrop,
    /** Information about the originally sent gift; may be null if unknown */
    original_details?: upgradedGiftOriginalDetails,
    /**
     * Number of Telegram Stars that must be paid to buy the gift and send it to someone
     * else; 0 if resale isn't possible
     */
    resale_star_count: number,
  }

  export type upgradeGiftResult = {
    /** Contains result of gift upgrading */
    _: 'upgradeGiftResult',
    /** The upgraded gift */
    gift: upgradedGift,
    /** Unique identifier of the received gift for the current user */
    received_gift_id: string,
    /** True, if the gift is displayed on the user's or the channel's profile page */
    is_saved: boolean,
    /** True, if the gift can be transferred to another owner */
    can_be_transferred: boolean,
    /** Number of Telegram Stars that must be paid to transfer the upgraded gift */
    transfer_star_count: number,
    /**
     * Point in time (Unix timestamp) when the gift can be transferred to another owner;
     * 0 if the gift can be transferred immediately or transfer isn't possible
     */
    next_transfer_date: number,
    /**
     * Point in time (Unix timestamp) when the gift can be resold to another user;
     * 0 if the gift can't be resold; only for the receiver of the gift
     */
    next_resale_date: number,
    /**
     * Point in time (Unix timestamp) when the gift can be transferred to the TON blockchain
     * as an NFT
     */
    export_date: number,
  }

  export type availableGift = {
    /** Describes a gift that is available for purchase */
    _: 'availableGift',
    /** The gift */
    gift: gift,
    /** Number of gifts that are available for resale */
    resale_count: number,
    /**
     * The minimum price for the gifts available for resale; 0 if there are no such
     * gifts
     */
    min_resale_star_count: number,
    /** The title of the upgraded gift; empty if the gift isn't available for resale */
    title: string,
  }

  export type availableGifts = {
    /** Contains a list of gifts that can be sent to another user or channel chat */
    _: 'availableGifts',
    /** The list of gifts */
    gifts: Array<availableGift>,
  }

  export type upgradedGiftAttributeIdModel$Input = {
    /** Identifier of a gift model */
    readonly _: 'upgradedGiftAttributeIdModel',
    /** Identifier of the sticker representing the model */
    readonly sticker_id?: number | string,
  }

  export type upgradedGiftAttributeIdSymbol$Input = {
    /** Identifier of a gift symbol */
    readonly _: 'upgradedGiftAttributeIdSymbol',
    /** Identifier of the sticker representing the symbol */
    readonly sticker_id?: number | string,
  }

  export type upgradedGiftAttributeIdBackdrop$Input = {
    /** Identifier of a gift backdrop */
    readonly _: 'upgradedGiftAttributeIdBackdrop',
    /** Identifier of the backdrop */
    readonly backdrop_id?: number,
  }

  export type upgradedGiftModelCount = {
    /** Describes a model of an upgraded gift with the number of gifts found */
    _: 'upgradedGiftModelCount',
    /** The model */
    model: upgradedGiftModel,
    /** Total number of gifts with the model */
    total_count: number,
  }

  export type upgradedGiftSymbolCount = {
    /** Describes a symbol shown on the pattern of an upgraded gift */
    _: 'upgradedGiftSymbolCount',
    /** The symbol */
    symbol: upgradedGiftSymbol,
    /** Total number of gifts with the symbol */
    total_count: number,
  }

  export type upgradedGiftBackdropCount = {
    /** Describes a backdrop of an upgraded gift */
    _: 'upgradedGiftBackdropCount',
    /** The backdrop */
    backdrop: upgradedGiftBackdrop,
    /** Total number of gifts with the symbol */
    total_count: number,
  }

  export type giftForResaleOrderPrice$Input = {
    /** The gifts will be sorted by their price from the lowest to the highest */
    readonly _: 'giftForResaleOrderPrice',
  }

  export type giftForResaleOrderPriceChangeDate$Input = {
    /**
     * The gifts will be sorted by the last date when their price was changed from
     * the newest to the oldest
     */
    readonly _: 'giftForResaleOrderPriceChangeDate',
  }

  export type giftForResaleOrderNumber$Input = {
    /** The gifts will be sorted by their number from the smallest to the largest */
    readonly _: 'giftForResaleOrderNumber',
  }

  export type giftForResale = {
    /** Describes a gift available for resale */
    _: 'giftForResale',
    /** The gift */
    gift: upgradedGift,
    /**
     * Unique identifier of the received gift for the current user; only for the gifts
     * owned by the current user
     */
    received_gift_id: string,
  }

  export type giftsForResale = {
    /** Describes gifts available for resale */
    _: 'giftsForResale',
    /** Total number of gifts found */
    total_count: number,
    /** The gifts */
    gifts: Array<giftForResale>,
    /**
     * Available models; for searchGiftsForResale requests without offset and attributes
     * only
     */
    models: Array<upgradedGiftModelCount>,
    /**
     * Available symbols; for searchGiftsForResale requests without offset and attributes
     * only
     */
    symbols: Array<upgradedGiftSymbolCount>,
    /**
     * Available backdrops; for searchGiftsForResale requests without offset and attributes
     * only
     */
    backdrops: Array<upgradedGiftBackdropCount>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type sentGiftRegular = {
    /** Regular gift */
    _: 'sentGiftRegular',
    /** The gift */
    gift: gift,
  }

  export type sentGiftUpgraded = {
    /** Upgraded gift */
    _: 'sentGiftUpgraded',
    /** The gift */
    gift: upgradedGift,
  }

  export type receivedGift = {
    /** Represents a gift received by a user or a chat */
    _: 'receivedGift',
    /**
     * Unique identifier of the received gift for the current user; only for the receiver
     * of the gift
     */
    received_gift_id: string,
    /** Identifier of a user or a chat that sent the gift; may be null if unknown */
    sender_id?: MessageSender,
    /** Message added to the gift */
    text: formattedText,
    /**
     * True, if the sender and gift text are shown only to the gift receiver; otherwise,
     * everyone are able to see them
     */
    is_private: boolean,
    /**
     * True, if the gift is displayed on the chat's profile page; only for the receiver
     * of the gift
     */
    is_saved: boolean,
    /** True, if the gift is pinned to the top of the chat's profile page */
    is_pinned: boolean,
    /**
     * True, if the gift is a regular gift that can be upgraded to a unique gift; only
     * for the receiver of the gift
     */
    can_be_upgraded: boolean,
    /**
     * True, if the gift is an upgraded gift that can be transferred to another owner;
     * only for the receiver of the gift
     */
    can_be_transferred: boolean,
    /** True, if the gift was refunded and isn't available anymore */
    was_refunded: boolean,
    /** Point in time (Unix timestamp) when the gift was sent */
    date: number,
    /** The gift */
    gift: SentGift,
    /**
     * Number of Telegram Stars that can be claimed by the receiver instead of the
     * regular gift; 0 if the gift can't be sold by the current user
     */
    sell_star_count: number,
    /**
     * Number of Telegram Stars that were paid by the sender for the ability to upgrade
     * the gift
     */
    prepaid_upgrade_star_count: number,
    /**
     * Number of Telegram Stars that must be paid to transfer the upgraded gift; only
     * for the receiver of the gift
     */
    transfer_star_count: number,
    /**
     * Point in time (Unix timestamp) when the gift can be transferred to another owner;
     * 0 if the gift can be transferred immediately or transfer isn't possible; only
     * for the receiver of the gift
     */
    next_transfer_date: number,
    /**
     * Point in time (Unix timestamp) when the gift can be resold to another user;
     * 0 if the gift can't be resold; only for the receiver of the gift
     */
    next_resale_date: number,
    /**
     * Point in time (Unix timestamp) when the upgraded gift can be transferred to
     * the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver
     * of the gift
     */
    export_date: number,
  }

  export type receivedGifts = {
    /** Represents a list of gifts received by a user or a chat */
    _: 'receivedGifts',
    /** The total number of received gifts */
    total_count: number,
    /** The list of gifts */
    gifts: Array<receivedGift>,
    /** True, if notifications about new gifts of the owner are enabled */
    are_notifications_enabled: boolean,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type giftUpgradePreview = {
    /** Contains examples of possible upgraded gifts for the given regular gift */
    _: 'giftUpgradePreview',
    /** Examples of possible models that can be chosen for the gift after upgrade */
    models: Array<upgradedGiftModel>,
    /** Examples of possible symbols that can be chosen for the gift after upgrade */
    symbols: Array<upgradedGiftSymbol>,
    /** Examples of possible backdrops that can be chosen for the gift after upgrade */
    backdrops: Array<upgradedGiftBackdrop>,
  }

  export type starTransactionDirectionIncoming$Input = {
    /** The transaction is incoming and increases the number of owned Telegram Stars */
    readonly _: 'starTransactionDirectionIncoming',
  }

  export type starTransactionDirectionOutgoing$Input = {
    /** The transaction is outgoing and decreases the number of owned Telegram Stars */
    readonly _: 'starTransactionDirectionOutgoing',
  }

  export type starTransactionTypePremiumBotDeposit = {
    /**
     * The transaction is a deposit of Telegram Stars from the Premium bot; for regular
     * users only
     */
    _: 'starTransactionTypePremiumBotDeposit',
  }

  export type starTransactionTypeAppStoreDeposit = {
    /**
     * The transaction is a deposit of Telegram Stars from App Store; for regular users
     * only
     */
    _: 'starTransactionTypeAppStoreDeposit',
  }

  export type starTransactionTypeGooglePlayDeposit = {
    /**
     * The transaction is a deposit of Telegram Stars from Google Play; for regular
     * users only
     */
    _: 'starTransactionTypeGooglePlayDeposit',
  }

  export type starTransactionTypeFragmentDeposit = {
    /**
     * The transaction is a deposit of Telegram Stars from Fragment; for regular users
     * and bots only
     */
    _: 'starTransactionTypeFragmentDeposit',
  }

  export type starTransactionTypeUserDeposit = {
    /**
     * The transaction is a deposit of Telegram Stars by another user; for regular
     * users only
     */
    _: 'starTransactionTypeUserDeposit',
    /** Identifier of the user that gifted Telegram Stars; 0 if the user was anonymous */
    user_id: number,
    /** The sticker to be shown in the transaction information; may be null if unknown */
    sticker?: sticker,
  }

  export type starTransactionTypeGiveawayDeposit = {
    /**
     * The transaction is a deposit of Telegram Stars from a giveaway; for regular
     * users only
     */
    _: 'starTransactionTypeGiveawayDeposit',
    /** Identifier of a supergroup or a channel chat that created the giveaway */
    chat_id: number,
    /**
     * Identifier of the message with the giveaway; can be 0 or an identifier of a
     * deleted message
     */
    giveaway_message_id: number,
  }

  export type starTransactionTypeFragmentWithdrawal = {
    /**
     * The transaction is a withdrawal of earned Telegram Stars to Fragment; for regular
     * users, bots, supergroup and channel chats only
     */
    _: 'starTransactionTypeFragmentWithdrawal',
    /** State of the withdrawal; may be null for refunds from Fragment */
    withdrawal_state?: RevenueWithdrawalState,
  }

  export type starTransactionTypeTelegramAdsWithdrawal = {
    /**
     * The transaction is a withdrawal of earned Telegram Stars to Telegram Ad platform;
     * for bots and channel chats only
     */
    _: 'starTransactionTypeTelegramAdsWithdrawal',
  }

  export type starTransactionTypeTelegramApiUsage = {
    /** The transaction is a payment for Telegram API usage; for bots only */
    _: 'starTransactionTypeTelegramApiUsage',
    /** The number of billed requests */
    request_count: number,
  }

  export type starTransactionTypeBotPaidMediaPurchase = {
    /**
     * The transaction is a purchase of paid media from a bot or a business account
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeBotPaidMediaPurchase',
    /** Identifier of the bot or the business account user that sent the paid media */
    user_id: number,
    /** The bought media if the transaction wasn't refunded */
    media: Array<PaidMedia>,
  }

  export type starTransactionTypeBotPaidMediaSale = {
    /**
     * The transaction is a sale of paid media by the bot or a business account managed
     * by the bot; for bots only
     */
    _: 'starTransactionTypeBotPaidMediaSale',
    /** Identifier of the user that bought the media */
    user_id: number,
    /** The bought media */
    media: Array<PaidMedia>,
    /** Bot-provided payload */
    payload: string,
    /**
     * Information about the affiliate which received commission from the transaction;
     * may be null if none
     */
    affiliate?: affiliateInfo,
  }

  export type starTransactionTypeChannelPaidMediaPurchase = {
    /**
     * The transaction is a purchase of paid media from a channel by the current user;
     * for regular users only
     */
    _: 'starTransactionTypeChannelPaidMediaPurchase',
    /** Identifier of the channel chat that sent the paid media */
    chat_id: number,
    /**
     * Identifier of the corresponding message with paid media; can be 0 or an identifier
     * of a deleted message
     */
    message_id: number,
    /** The bought media if the transaction wasn't refunded */
    media: Array<PaidMedia>,
  }

  export type starTransactionTypeChannelPaidMediaSale = {
    /**
     * The transaction is a sale of paid media by the channel chat; for channel chats
     * only
     */
    _: 'starTransactionTypeChannelPaidMediaSale',
    /** Identifier of the user that bought the media */
    user_id: number,
    /**
     * Identifier of the corresponding message with paid media; can be 0 or an identifier
     * of a deleted message
     */
    message_id: number,
    /** The bought media */
    media: Array<PaidMedia>,
  }

  export type starTransactionTypeBotInvoicePurchase = {
    /**
     * The transaction is a purchase of a product from a bot or a business account
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeBotInvoicePurchase',
    /** Identifier of the bot or the business account user that created the invoice */
    user_id: number,
    /** Information about the bought product */
    product_info: productInfo,
  }

  export type starTransactionTypeBotInvoiceSale = {
    /** The transaction is a sale of a product by the bot; for bots only */
    _: 'starTransactionTypeBotInvoiceSale',
    /** Identifier of the user that bought the product */
    user_id: number,
    /** Information about the bought product */
    product_info: productInfo,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /**
     * Information about the affiliate which received commission from the transaction;
     * may be null if none
     */
    affiliate?: affiliateInfo,
  }

  export type starTransactionTypeBotSubscriptionPurchase = {
    /**
     * The transaction is a purchase of a subscription from a bot or a business account
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeBotSubscriptionPurchase',
    /**
     * Identifier of the bot or the business account user that created the subscription
     * link
     */
    user_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
    /** Information about the bought subscription */
    product_info: productInfo,
  }

  export type starTransactionTypeBotSubscriptionSale = {
    /** The transaction is a sale of a subscription by the bot; for bots only */
    _: 'starTransactionTypeBotSubscriptionSale',
    /** Identifier of the user that bought the subscription */
    user_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
    /** Information about the bought subscription */
    product_info: productInfo,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /**
     * Information about the affiliate which received commission from the transaction;
     * may be null if none
     */
    affiliate?: affiliateInfo,
  }

  export type starTransactionTypeChannelSubscriptionPurchase = {
    /**
     * The transaction is a purchase of a subscription to a channel chat by the current
     * user; for regular users only
     */
    _: 'starTransactionTypeChannelSubscriptionPurchase',
    /** Identifier of the channel chat that created the subscription */
    chat_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
  }

  export type starTransactionTypeChannelSubscriptionSale = {
    /**
     * The transaction is a sale of a subscription by the channel chat; for channel
     * chats only
     */
    _: 'starTransactionTypeChannelSubscriptionSale',
    /** Identifier of the user that bought the subscription */
    user_id: number,
    /** The number of seconds between consecutive Telegram Star debitings */
    subscription_period: number,
  }

  export type starTransactionTypeGiftPurchase = {
    /**
     * The transaction is a purchase of a regular gift; for regular users and bots
     * only
     */
    _: 'starTransactionTypeGiftPurchase',
    /** Identifier of the user or the channel that received the gift */
    owner_id: MessageSender,
    /** The gift */
    gift: gift,
  }

  export type starTransactionTypeGiftTransfer = {
    /** The transaction is a transfer of an upgraded gift; for regular users only */
    _: 'starTransactionTypeGiftTransfer',
    /** Identifier of the user or the channel that received the gift */
    owner_id: MessageSender,
    /** The gift */
    gift: upgradedGift,
  }

  export type starTransactionTypeGiftSale = {
    /**
     * The transaction is a sale of a received gift; for regular users and channel
     * chats only
     */
    _: 'starTransactionTypeGiftSale',
    /** Identifier of the user that sent the gift */
    user_id: number,
    /** The gift */
    gift: gift,
  }

  export type starTransactionTypeGiftUpgrade = {
    /** The transaction is an upgrade of a gift; for regular users only */
    _: 'starTransactionTypeGiftUpgrade',
    /** Identifier of the user that initially sent the gift */
    user_id: number,
    /** The upgraded gift */
    gift: upgradedGift,
  }

  export type starTransactionTypeUpgradedGiftPurchase = {
    /**
     * The transaction is a purchase of an upgraded gift for some user or channel;
     * for regular users only
     */
    _: 'starTransactionTypeUpgradedGiftPurchase',
    /** Identifier of the user that sold the gift */
    user_id: number,
    /** The gift */
    gift: upgradedGift,
  }

  export type starTransactionTypeUpgradedGiftSale = {
    /** The transaction is a sale of an upgraded gift; for regular users only */
    _: 'starTransactionTypeUpgradedGiftSale',
    /** Identifier of the user that bought the gift */
    user_id: number,
    /** The gift */
    gift: upgradedGift,
    /** Information about commission received by Telegram from the transaction */
    affiliate: affiliateInfo,
  }

  export type starTransactionTypeChannelPaidReactionSend = {
    /**
     * The transaction is a sending of a paid reaction to a message in a channel chat
     * by the current user; for regular users only
     */
    _: 'starTransactionTypeChannelPaidReactionSend',
    /** Identifier of the channel chat */
    chat_id: number,
    /** Identifier of the reacted message; can be 0 or an identifier of a deleted message */
    message_id: number,
  }

  export type starTransactionTypeChannelPaidReactionReceive = {
    /**
     * The transaction is a receiving of a paid reaction to a message by the channel
     * chat; for channel chats only
     */
    _: 'starTransactionTypeChannelPaidReactionReceive',
    /** Identifier of the user that added the paid reaction */
    user_id: number,
    /** Identifier of the reacted message; can be 0 or an identifier of a deleted message */
    message_id: number,
  }

  export type starTransactionTypeAffiliateProgramCommission = {
    /**
     * The transaction is a receiving of a commission from an affiliate program; for
     * regular users, bots and channel chats only
     */
    _: 'starTransactionTypeAffiliateProgramCommission',
    /** Identifier of the chat that created the affiliate program */
    chat_id: number,
    /**
     * The number of Telegram Stars received by the affiliate for each 1000 Telegram
     * Stars received by the program owner
     */
    commission_per_mille: number,
  }

  export type starTransactionTypePaidMessageSend = {
    /** The transaction is a sending of a paid message; for regular users only */
    _: 'starTransactionTypePaidMessageSend',
    /** Identifier of the chat that received the payment */
    chat_id: number,
    /** Number of sent paid messages */
    message_count: number,
  }

  export type starTransactionTypePaidMessageReceive = {
    /**
     * The transaction is a receiving of a paid message; for regular users, supergroup
     * and channel chats only
     */
    _: 'starTransactionTypePaidMessageReceive',
    /** Identifier of the sender of the message */
    sender_id: MessageSender,
    /** Number of received paid messages */
    message_count: number,
    /**
     * The number of Telegram Stars received by the Telegram for each 1000 Telegram
     * Stars paid for message sending
     */
    commission_per_mille: number,
    /**
     * The amount of Telegram Stars that were received by Telegram; can be negative
     * for refunds
     */
    commission_star_amount: starAmount,
  }

  export type starTransactionTypePremiumPurchase = {
    /**
     * The transaction is a purchase of Telegram Premium subscription; for regular
     * users and bots only
     */
    _: 'starTransactionTypePremiumPurchase',
    /** Identifier of the user that received the Telegram Premium subscription */
    user_id: number,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /** A sticker to be shown in the transaction information; may be null if unknown */
    sticker?: sticker,
  }

  export type starTransactionTypeBusinessBotTransferSend = {
    /**
     * The transaction is a transfer of Telegram Stars to a business bot; for regular
     * users only
     */
    _: 'starTransactionTypeBusinessBotTransferSend',
    /** Identifier of the bot that received Telegram Stars */
    user_id: number,
  }

  export type starTransactionTypeBusinessBotTransferReceive = {
    /**
     * The transaction is a transfer of Telegram Stars from a business account; for
     * bots only
     */
    _: 'starTransactionTypeBusinessBotTransferReceive',
    /** Identifier of the user that sent Telegram Stars */
    user_id: number,
  }

  export type starTransactionTypeUnsupported = {
    /** The transaction is a transaction of an unsupported type */
    _: 'starTransactionTypeUnsupported',
  }

  export type starTransaction = {
    /** Represents a transaction changing the amount of owned Telegram Stars */
    _: 'starTransaction',
    /** Unique identifier of the transaction */
    id: string,
    /** The amount of added owned Telegram Stars; negative for outgoing transactions */
    star_amount: starAmount,
    /** True, if the transaction is a refund of a previous transaction */
    is_refund: boolean,
    /** Point in time (Unix timestamp) when the transaction was completed */
    date: number,
    /** Type of the transaction */
    type: StarTransactionType,
  }

  export type starTransactions = {
    /** Represents a list of Telegram Star transactions */
    _: 'starTransactions',
    /** The amount of owned Telegram Stars */
    star_amount: starAmount,
    /** List of transactions with Telegram Stars */
    transactions: Array<starTransaction>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type giveawayParticipantStatusEligible = {
    /** The user is eligible for the giveaway */
    _: 'giveawayParticipantStatusEligible',
  }

  export type giveawayParticipantStatusParticipating = {
    /** The user participates in the giveaway */
    _: 'giveawayParticipantStatusParticipating',
  }

  export type giveawayParticipantStatusAlreadyWasMember = {
    /**
     * The user can't participate in the giveaway, because they have already been member
     * of the chat
     */
    _: 'giveawayParticipantStatusAlreadyWasMember',
    /** Point in time (Unix timestamp) when the user joined the chat */
    joined_chat_date: number,
  }

  export type giveawayParticipantStatusAdministrator = {
    /**
     * The user can't participate in the giveaway, because they are an administrator
     * in one of the chats that created the giveaway
     */
    _: 'giveawayParticipantStatusAdministrator',
    /** Identifier of the chat administered by the user */
    chat_id: number,
  }

  export type giveawayParticipantStatusDisallowedCountry = {
    /**
     * The user can't participate in the giveaway, because they phone number is from
     * a disallowed country
     */
    _: 'giveawayParticipantStatusDisallowedCountry',
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    user_country_code: string,
  }

  export type giveawayInfoOngoing = {
    /** Describes an ongoing giveaway */
    _: 'giveawayInfoOngoing',
    /** Point in time (Unix timestamp) when the giveaway was created */
    creation_date: number,
    /** Status of the current user in the giveaway */
    status: GiveawayParticipantStatus,
    /** True, if the giveaway has ended and results are being prepared */
    is_ended: boolean,
  }

  export type giveawayInfoCompleted = {
    /** Describes a completed giveaway */
    _: 'giveawayInfoCompleted',
    /** Point in time (Unix timestamp) when the giveaway was created */
    creation_date: number,
    /**
     * Point in time (Unix timestamp) when the winners were selected. May be bigger
     * than winners selection date specified in parameters of the giveaway
     */
    actual_winners_selection_date: number,
    /** True, if the giveaway was canceled and was fully refunded */
    was_refunded: boolean,
    /** True, if the current user is a winner of the giveaway */
    is_winner: boolean,
    /** Number of winners in the giveaway */
    winner_count: number,
    /**
     * Number of winners, which activated their gift codes; for Telegram Premium giveaways
     * only
     */
    activation_count: number,
    /**
     * Telegram Premium gift code that was received by the current user; empty if the
     * user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium
     * giveaway
     */
    gift_code: string,
    /**
     * The amount of Telegram Stars won by the current user; 0 if the user isn't a
     * winner in the giveaway or the giveaway isn't a Telegram Star giveaway
     */
    won_star_count: number,
  }

  export type giveawayPrizePremium = {
    /** The giveaway sends Telegram Premium subscriptions to the winners */
    _: 'giveawayPrizePremium',
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
  }

  export type giveawayPrizeStars = {
    /** The giveaway sends Telegram Stars to the winners */
    _: 'giveawayPrizeStars',
    /** Number of Telegram Stars that will be shared by all winners */
    star_count: number,
  }

  export type accentColor = {
    /**
     * Contains information about supported accent color for user/chat name, background
     * of empty chat photo, replies to messages and link previews
     */
    _: 'accentColor',
    /** Accent color identifier */
    id: number,
    /**
     * Identifier of a built-in color to use in places, where only one color is needed;
     * 0-6
     */
    built_in_accent_color_id: number,
    /**
     * The list of 1-3 colors in RGB format, describing the accent color, as expected
     * to be shown in light themes
     */
    light_theme_colors: Array<number>,
    /**
     * The list of 1-3 colors in RGB format, describing the accent color, as expected
     * to be shown in dark themes
     */
    dark_theme_colors: Array<number>,
    /** The minimum chat boost level required to use the color in a channel chat */
    min_channel_chat_boost_level: number,
  }

  export type profileAccentColors = {
    /**
     * Contains information about supported accent colors for user profile photo background
     * in RGB format
     */
    _: 'profileAccentColors',
    /**
     * The list of 1-2 colors in RGB format, describing the colors, as expected to
     * be shown in the color palette settings
     */
    palette_colors: Array<number>,
    /**
     * The list of 1-2 colors in RGB format, describing the colors, as expected to
     * be used for the profile photo background
     */
    background_colors: Array<number>,
    /**
     * The list of 2 colors in RGB format, describing the colors of the gradient to
     * be used for the unread active story indicator around profile photo
     */
    story_colors: Array<number>,
  }

  export type profileAccentColor = {
    /** Contains information about supported accent color for user profile photo background */
    _: 'profileAccentColor',
    /** Profile accent color identifier */
    id: number,
    /** Accent colors expected to be used in light themes */
    light_theme_colors: profileAccentColors,
    /** Accent colors expected to be used in dark themes */
    dark_theme_colors: profileAccentColors,
    /** The minimum chat boost level required to use the color in a supergroup chat */
    min_supergroup_chat_boost_level: number,
    /** The minimum chat boost level required to use the color in a channel chat */
    min_channel_chat_boost_level: number,
  }

  export type emojiStatusTypeCustomEmoji = {
    /** A custom emoji set as emoji status */
    _: 'emojiStatusTypeCustomEmoji',
    /** Identifier of the custom emoji in stickerFormatTgs format */
    custom_emoji_id: string,
  }

  export type emojiStatusTypeCustomEmoji$Input = {
    /** A custom emoji set as emoji status */
    readonly _: 'emojiStatusTypeCustomEmoji',
    /** Identifier of the custom emoji in stickerFormatTgs format */
    readonly custom_emoji_id?: number | string,
  }

  export type emojiStatusTypeUpgradedGift = {
    /** An upgraded gift set as emoji status */
    _: 'emojiStatusTypeUpgradedGift',
    /** Identifier of the upgraded gift */
    upgraded_gift_id: string,
    /** The title of the upgraded gift */
    gift_title: string,
    /** Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift */
    gift_name: string,
    /** Custom emoji identifier of the model of the upgraded gift */
    model_custom_emoji_id: string,
    /** Custom emoji identifier of the symbol of the upgraded gift */
    symbol_custom_emoji_id: string,
    /** Colors of the backdrop of the upgraded gift */
    backdrop_colors: upgradedGiftBackdropColors,
  }

  export type emojiStatusTypeUpgradedGift$Input = {
    /** An upgraded gift set as emoji status */
    readonly _: 'emojiStatusTypeUpgradedGift',
    /** Identifier of the upgraded gift */
    readonly upgraded_gift_id?: number | string,
    /** The title of the upgraded gift */
    readonly gift_title?: string,
    /** Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift */
    readonly gift_name?: string,
    /** Custom emoji identifier of the model of the upgraded gift */
    readonly model_custom_emoji_id?: number | string,
    /** Custom emoji identifier of the symbol of the upgraded gift */
    readonly symbol_custom_emoji_id?: number | string,
    /** Colors of the backdrop of the upgraded gift */
    readonly backdrop_colors?: upgradedGiftBackdropColors$Input,
  }

  export type emojiStatus = {
    /** Describes an emoji to be shown instead of the Telegram Premium badge */
    _: 'emojiStatus',
    /** Type of the emoji status */
    type: EmojiStatusType,
    /** Point in time (Unix timestamp) when the status will expire; 0 if never */
    expiration_date: number,
  }

  export type emojiStatus$Input = {
    /** Describes an emoji to be shown instead of the Telegram Premium badge */
    readonly _: 'emojiStatus',
    /** Type of the emoji status */
    readonly type?: EmojiStatusType$Input,
    /** Point in time (Unix timestamp) when the status will expire; 0 if never */
    readonly expiration_date?: number,
  }

  export type emojiStatuses = {
    /** Contains a list of emoji statuses */
    _: 'emojiStatuses',
    /** The list of emoji statuses identifiers */
    emoji_statuses: Array<emojiStatus>,
  }

  export type emojiStatusCustomEmojis = {
    /** Contains a list of custom emoji identifiers for emoji statuses */
    _: 'emojiStatusCustomEmojis',
    /** The list of custom emoji identifiers */
    custom_emoji_ids: Array<string>,
  }

  export type usernames = {
    /** Describes usernames assigned to a user, a supergroup, or a channel */
    _: 'usernames',
    /**
     * List of active usernames; the first one must be shown as the primary username.
     * The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames
     * or reorderSupergroupActiveUsernames
     */
    active_usernames: Array<string>,
    /**
     * List of currently disabled usernames; the username can be activated with toggleUsernameIsActive,
     * toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
     */
    disabled_usernames: Array<string>,
    /**
     * The active username, which can be changed with setUsername or setSupergroupUsername.
     * Information about other active usernames can be received using getCollectibleItemInfo
     */
    editable_username: string,
  }

  export type user = {
    /** Represents a user */
    _: 'user',
    /** User identifier */
    id: number,
    /** First name of the user */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Usernames of the user; may be null */
    usernames?: usernames,
    /** Phone number of the user */
    phone_number: string,
    /** Current online status of the user */
    status: UserStatus,
    /** Profile photo of the user; may be null */
    profile_photo?: profilePhoto,
    /**
     * Identifier of the accent color for name, and backgrounds of profile photo, reply
     * header, and link preview
     */
    accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background; 0 if none
     */
    background_custom_emoji_id: string,
    /** Identifier of the accent color for the user's profile; -1 if none */
    profile_accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the background of the user's profile;
     * 0 if none
     */
    profile_background_custom_emoji_id: string,
    /**
     * Emoji status to be shown instead of the default Telegram Premium badge; may
     * be null
     */
    emoji_status?: emojiStatus,
    /** The user is a contact of the current user */
    is_contact: boolean,
    /**
     * The user is a contact of the current user and the current user is a contact
     * of the user
     */
    is_mutual_contact: boolean,
    /** The user is a close friend of the current user; implies that the user is a contact */
    is_close_friend: boolean,
    /** Information about verification status of the user; may be null if none */
    verification_status?: verificationStatus,
    /** True, if the user is a Telegram Premium user */
    is_premium: boolean,
    /** True, if the user is Telegram support account */
    is_support: boolean,
    /**
     * If non-empty, it contains a human-readable description of the reason why access
     * to this user must be restricted
     */
    restriction_reason: string,
    /** True, if the user has non-expired stories available to the current user */
    has_active_stories: boolean,
    /** True, if the user has unread non-expired stories available to the current user */
    has_unread_active_stories: boolean,
    /**
     * True, if the user may restrict new chats with non-contacts. Use canSendMessageToUser
     * to check whether the current user can message the user or try to create a chat
     * with them
     */
    restricts_new_chats: boolean,
    /**
     * Number of Telegram Stars that must be paid by general user for each sent message
     * to the user. If positive and userFullInfo is unknown, use canSendMessageToUser
     * to check whether the current user must pay
     */
    paid_message_star_count: number,
    /**
     * If false, the user is inaccessible, and the only information known about the
     * user is inside this class. Identifier of the user can't be passed to any method
     */
    have_access: boolean,
    /** Type of the user */
    type: UserType,
    /** IETF language tag of the user's language; only available to bots */
    language_code: string,
    /**
     * True, if the user added the current bot to attachment menu; only available to
     * bots
     */
    added_to_attachment_menu: boolean,
  }

  export type botInfo = {
    /** Contains information about a bot */
    _: 'botInfo',
    /**
     * The text that is shown on the bot's profile page and is sent together with the
     * link when users share the bot
     */
    short_description: string,
    /** The text shown in the chat with the bot if the chat is empty */
    description: string,
    /** Photo shown in the chat with the bot if the chat is empty; may be null */
    photo?: photo,
    /** Animation shown in the chat with the bot if the chat is empty; may be null */
    animation?: animation,
    /**
     * Information about a button to show instead of the bot commands menu button;
     * may be null if ordinary bot commands menu must be shown
     */
    menu_button?: botMenuButton,
    /** List of the bot commands */
    commands: Array<botCommand>,
    /**
     * The HTTP link to the privacy policy of the bot. If empty, then /privacy command
     * must be used if supported by the bot. If the command isn't supported, then https://telegram.org/privacy-tpa
     * must be opened
     */
    privacy_policy_url: string,
    /**
     * Default administrator rights for adding the bot to basic group and supergroup
     * chats; may be null
     */
    default_group_administrator_rights?: chatAdministratorRights,
    /** Default administrator rights for adding the bot to channels; may be null */
    default_channel_administrator_rights?: chatAdministratorRights,
    /** Information about the affiliate program of the bot; may be null if none */
    affiliate_program?: affiliateProgramInfo,
    /** Default light background color for bot Web Apps; -1 if not specified */
    web_app_background_light_color: number,
    /** Default dark background color for bot Web Apps; -1 if not specified */
    web_app_background_dark_color: number,
    /** Default light header color for bot Web Apps; -1 if not specified */
    web_app_header_light_color: number,
    /** Default dark header color for bot Web Apps; -1 if not specified */
    web_app_header_dark_color: number,
    /**
     * Parameters of the verification that can be provided by the bot; may be null
     * if none or the current user isn't the owner of the bot
     */
    verification_parameters?: botVerificationParameters,
    /** True, if the bot's revenue statistics are available to the current user */
    can_get_revenue_statistics: boolean,
    /** True, if the bot can manage emoji status of the current user */
    can_manage_emoji_status: boolean,
    /** True, if the bot has media previews */
    has_media_previews: boolean,
    /** The internal link, which can be used to edit bot commands; may be null */
    edit_commands_link?: InternalLinkType,
    /** The internal link, which can be used to edit bot description; may be null */
    edit_description_link?: InternalLinkType,
    /**
     * The internal link, which can be used to edit the photo or animation shown in
     * the chat with the bot if the chat is empty; may be null
     */
    edit_description_media_link?: InternalLinkType,
    /** The internal link, which can be used to edit bot settings; may be null */
    edit_settings_link?: InternalLinkType,
  }

  export type userFullInfo = {
    /** Contains full information about a user */
    _: 'userFullInfo',
    /**
     * User profile photo set by the current user for the contact; may be null. If
     * null and user.profile_photo is null, then the photo is empty; otherwise, it
     * is unknown. If non-null, then it is the same photo as in user.profile_photo
     * and chat.photo. This photo isn't returned in the list of user photos
     */
    personal_photo?: chatPhoto,
    /**
     * User profile photo; may be null. If null and user.profile_photo is null, then
     * the photo is empty; otherwise, it is unknown. If non-null and personal_photo
     * is null, then it is the same photo as in user.profile_photo and chat.photo
     */
    photo?: chatPhoto,
    /**
     * User profile photo visible if the main photo is hidden by privacy settings;
     * may be null. If null and user.profile_photo is null, then the photo is empty;
     * otherwise, it is unknown. If non-null and both photo and personal_photo are
     * null, then it is the same photo as in user.profile_photo and chat.photo. This
     * photo isn't returned in the list of user photos
     */
    public_photo?: chatPhoto,
    /** Block list to which the user is added; may be null if none */
    block_list?: BlockList,
    /** True, if the user can be called */
    can_be_called: boolean,
    /** True, if a video call can be created with the user */
    supports_video_calls: boolean,
    /** True, if the user can't be called due to their privacy settings */
    has_private_calls: boolean,
    /**
     * True, if the user can't be linked in forwarded messages due to their privacy
     * settings
     */
    has_private_forwards: boolean,
    /** True, if voice and video notes can't be sent or forwarded to the user */
    has_restricted_voice_and_video_note_messages: boolean,
    /** True, if the user has posted to profile stories */
    has_posted_to_profile_stories: boolean,
    /**
     * True, if the user always enabled sponsored messages; known only for the current
     * user
     */
    has_sponsored_messages_enabled: boolean,
    /**
     * True, if the current user needs to explicitly allow to share their phone number
     * with the user when the method addContact is used
     */
    need_phone_number_privacy_exception: boolean,
    /**
     * True, if the user set chat background for both chat users and it wasn't reverted
     * yet
     */
    set_chat_background: boolean,
    /** A short user bio; may be null for bots */
    bio?: formattedText,
    /** Birthdate of the user; may be null if unknown */
    birthdate?: birthdate,
    /** Identifier of the personal chat of the user; 0 if none */
    personal_chat_id: number,
    /**
     * Number of saved to profile gifts for other users or the total number of received
     * gifts for the current user
     */
    gift_count: number,
    /**
     * Number of group chats where both the other user and the current user are a member;
     * 0 for the current user
     */
    group_in_common_count: number,
    /**
     * Number of Telegram Stars that must be paid by the user for each sent message
     * to the current user
     */
    incoming_paid_message_star_count: number,
    /**
     * Number of Telegram Stars that must be paid by the current user for each sent
     * message to the user
     */
    outgoing_paid_message_star_count: number,
    /** Settings for gift receiving for the user */
    gift_settings: giftSettings,
    /**
     * Information about verification status of the user provided by a bot; may be
     * null if none or unknown
     */
    bot_verification?: botVerification,
    /**
     * Information about business settings for Telegram Business accounts; may be null
     * if none
     */
    business_info?: businessInfo,
    /** For bots, information about the bot; may be null if the user isn't a bot */
    bot_info?: botInfo,
  }

  export type users = {
    /** Represents a list of users */
    _: 'users',
    /** Approximate total number of users found */
    total_count: number,
    /** A list of user identifiers */
    user_ids: Array<number>,
  }

  export type foundUsers = {
    /** Represents a list of found users */
    _: 'foundUsers',
    /** Identifiers of the found users */
    user_ids: Array<number>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type chatAdministrator = {
    /** Contains information about a chat administrator */
    _: 'chatAdministrator',
    /** User identifier of the administrator */
    user_id: number,
    /** Custom title of the administrator */
    custom_title: string,
    /** True, if the user is the owner of the chat */
    is_owner: boolean,
  }

  export type chatAdministrators = {
    /** Represents a list of chat administrators */
    _: 'chatAdministrators',
    /** A list of chat administrators */
    administrators: Array<chatAdministrator>,
  }

  export type chatMemberStatusCreator = {
    /** The user is the owner of the chat and has all the administrator privileges */
    _: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emoji; applicable to supergroups
     * only
     */
    custom_title: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
    /** True, if the user is a member of the chat */
    is_member: boolean,
  }

  export type chatMemberStatusCreator$Input = {
    /** The user is the owner of the chat and has all the administrator privileges */
    readonly _: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emoji; applicable to supergroups
     * only
     */
    readonly custom_title?: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    readonly is_anonymous?: boolean,
    /** True, if the user is a member of the chat */
    readonly is_member?: boolean,
  }

  export type chatMemberStatusAdministrator = {
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    _: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emoji; applicable
     * to supergroups only
     */
    custom_title: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    can_be_edited: boolean,
    /** Rights of the administrator */
    rights: chatAdministratorRights,
  }

  export type chatMemberStatusAdministrator$Input = {
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    readonly _: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emoji; applicable
     * to supergroups only
     */
    readonly custom_title?: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    readonly can_be_edited?: boolean,
    /** Rights of the administrator */
    readonly rights?: chatAdministratorRights$Input,
  }

  export type chatMemberStatusMember = {
    /** The user is a member of the chat, without any additional privileges or restrictions */
    _: 'chatMemberStatusMember',
    /**
     * Point in time (Unix timestamp) when the user will be removed from the chat because
     * of the expired subscription; 0 if never. Ignored in setChatMemberStatus
     */
    member_until_date: number,
  }

  export type chatMemberStatusMember$Input = {
    /** The user is a member of the chat, without any additional privileges or restrictions */
    readonly _: 'chatMemberStatusMember',
    /**
     * Point in time (Unix timestamp) when the user will be removed from the chat because
     * of the expired subscription; 0 if never. Ignored in setChatMemberStatus
     */
    readonly member_until_date?: number,
  }

  export type chatMemberStatusRestricted = {
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    _: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    is_member: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    restricted_until_date: number,
    /** User permissions in the chat */
    permissions: chatPermissions,
  }

  export type chatMemberStatusRestricted$Input = {
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    readonly _: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    readonly is_member?: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    readonly restricted_until_date?: number,
    /** User permissions in the chat */
    readonly permissions?: chatPermissions$Input,
  }

  export type chatMemberStatusLeft = {
    /** The user or the chat is not a chat member */
    _: 'chatMemberStatusLeft',
  }

  export type chatMemberStatusLeft$Input = {
    /** The user or the chat is not a chat member */
    readonly _: 'chatMemberStatusLeft',
  }

  export type chatMemberStatusBanned = {
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    _: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    banned_until_date: number,
  }

  export type chatMemberStatusBanned$Input = {
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    readonly _: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    readonly banned_until_date?: number,
  }

  export type chatMember = {
    /** Describes a user or a chat as a member of another chat */
    _: 'chatMember',
    /**
     * Identifier of the chat member. Currently, other chats can be only Left or Banned.
     * Only supergroups and channels can have other chats as Left or Banned members
     * and these chats must be supergroups or channels
     */
    member_id: MessageSender,
    /**
     * Identifier of a user that invited/promoted/banned this member in the chat; 0
     * if unknown
     */
    inviter_user_id: number,
    /**
     * Point in time (Unix timestamp) when the user joined/was promoted/was banned
     * in the chat
     */
    joined_chat_date: number,
    /** Status of the member in the chat */
    status: ChatMemberStatus,
  }

  export type chatMembers = {
    /** Contains a list of chat members */
    _: 'chatMembers',
    /** Approximate total number of chat members found */
    total_count: number,
    /** A list of chat members */
    members: Array<chatMember>,
  }

  export type chatMembersFilterContacts$Input = {
    /** Returns contacts of the user */
    readonly _: 'chatMembersFilterContacts',
  }

  export type chatMembersFilterAdministrators$Input = {
    /** Returns the owner and administrators */
    readonly _: 'chatMembersFilterAdministrators',
  }

  export type chatMembersFilterMembers$Input = {
    /** Returns all chat members, including restricted chat members */
    readonly _: 'chatMembersFilterMembers',
  }

  export type chatMembersFilterMention$Input = {
    /** Returns users which can be mentioned in the chat */
    readonly _: 'chatMembersFilterMention',
    /** If non-zero, the identifier of the current message thread */
    readonly message_thread_id?: number,
  }

  export type chatMembersFilterRestricted$Input = {
    /**
     * Returns users under certain restrictions in the chat; can be used only by administrators
     * in a supergroup
     */
    readonly _: 'chatMembersFilterRestricted',
  }

  export type chatMembersFilterBanned$Input = {
    /**
     * Returns users banned from the chat; can be used only by administrators in a
     * supergroup or in a channel
     */
    readonly _: 'chatMembersFilterBanned',
  }

  export type chatMembersFilterBots$Input = {
    /** Returns bot members of the chat */
    readonly _: 'chatMembersFilterBots',
  }

  export type supergroupMembersFilterRecent$Input = {
    /** Returns recently active users in reverse chronological order */
    readonly _: 'supergroupMembersFilterRecent',
  }

  export type supergroupMembersFilterContacts$Input = {
    /** Returns contacts of the user, which are members of the supergroup or channel */
    readonly _: 'supergroupMembersFilterContacts',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterAdministrators$Input = {
    /** Returns the owner and administrators */
    readonly _: 'supergroupMembersFilterAdministrators',
  }

  export type supergroupMembersFilterSearch$Input = {
    /** Used to search for supergroup or channel members via a (string) query */
    readonly _: 'supergroupMembersFilterSearch',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterRestricted$Input = {
    /** Returns restricted supergroup members; can be used only by administrators */
    readonly _: 'supergroupMembersFilterRestricted',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterBanned$Input = {
    /** Returns users banned from the supergroup or channel; can be used only by administrators */
    readonly _: 'supergroupMembersFilterBanned',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterMention$Input = {
    /** Returns users which can be mentioned in the supergroup */
    readonly _: 'supergroupMembersFilterMention',
    /** Query to search for */
    readonly query?: string,
    /** If non-zero, the identifier of the current message thread */
    readonly message_thread_id?: number,
  }

  export type supergroupMembersFilterBots$Input = {
    /** Returns bot members of the supergroup or channel */
    readonly _: 'supergroupMembersFilterBots',
  }

  export type chatInviteLink = {
    /** Contains a chat invite link */
    _: 'chatInviteLink',
    /** Chat invite link */
    invite_link: string,
    /** Name of the link */
    name: string,
    /** User identifier of an administrator created the link */
    creator_user_id: number,
    /** Point in time (Unix timestamp) when the link was created */
    date: number,
    /**
     * Point in time (Unix timestamp) when the link was last edited; 0 if never or
     * unknown
     */
    edit_date: number,
    /** Point in time (Unix timestamp) when the link will expire; 0 if never */
    expiration_date: number,
    /**
     * Information about subscription plan that is applied to the users joining the
     * chat by the link; may be null if the link doesn't require subscription
     */
    subscription_pricing?: starSubscriptionPricing,
    /**
     * The maximum number of members, which can join the chat using the link simultaneously;
     * 0 if not limited. Always 0 if the link requires approval
     */
    member_limit: number,
    /** Number of chat members, which joined the chat using the link */
    member_count: number,
    /**
     * Number of chat members, which joined the chat using the link, but have already
     * left because of expired subscription; for subscription links only
     */
    expired_member_count: number,
    /** Number of pending join requests created using this link */
    pending_join_request_count: number,
    /**
     * True, if the link only creates join request. If true, total number of joining
     * members will be unlimited
     */
    creates_join_request: boolean,
    /**
     * True, if the link is primary. Primary invite link can't have name, expiration
     * date, or usage limit. There is exactly one primary invite link for each administrator
     * with can_invite_users right at a given time
     */
    is_primary: boolean,
    /** True, if the link was revoked */
    is_revoked: boolean,
  }

  export type chatInviteLinks = {
    /** Contains a list of chat invite links */
    _: 'chatInviteLinks',
    /** Approximate total number of chat invite links found */
    total_count: number,
    /** List of invite links */
    invite_links: Array<chatInviteLink>,
  }

  export type chatInviteLinkCount = {
    /**
     * Describes a chat administrator with a number of active and revoked chat invite
     * links
     */
    _: 'chatInviteLinkCount',
    /** Administrator's user identifier */
    user_id: number,
    /** Number of active invite links */
    invite_link_count: number,
    /** Number of revoked invite links */
    revoked_invite_link_count: number,
  }

  export type chatInviteLinkCounts = {
    /** Contains a list of chat invite link counts */
    _: 'chatInviteLinkCounts',
    /** List of invite link counts */
    invite_link_counts: Array<chatInviteLinkCount>,
  }

  export type chatInviteLinkMember = {
    /** Describes a chat member joined a chat via an invite link */
    _: 'chatInviteLinkMember',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    joined_chat_date: number,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
  }

  export type chatInviteLinkMember$Input = {
    /** Describes a chat member joined a chat via an invite link */
    readonly _: 'chatInviteLinkMember',
    /** User identifier */
    readonly user_id?: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    readonly joined_chat_date?: number,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    readonly via_chat_folder_invite_link?: boolean,
    /** User identifier of the chat administrator, approved user join request */
    readonly approver_user_id?: number,
  }

  export type chatInviteLinkMembers = {
    /** Contains a list of chat members joined a chat via an invite link */
    _: 'chatInviteLinkMembers',
    /** Approximate total number of chat members found */
    total_count: number,
    /** List of chat members, joined a chat via an invite link */
    members: Array<chatInviteLinkMember>,
  }

  export type inviteLinkChatTypeBasicGroup = {
    /** The link is an invite link for a basic group */
    _: 'inviteLinkChatTypeBasicGroup',
  }

  export type inviteLinkChatTypeSupergroup = {
    /** The link is an invite link for a supergroup */
    _: 'inviteLinkChatTypeSupergroup',
  }

  export type inviteLinkChatTypeChannel = {
    /** The link is an invite link for a channel */
    _: 'inviteLinkChatTypeChannel',
  }

  export type chatInviteLinkSubscriptionInfo = {
    /**
     * Contains information about subscription plan that must be paid by the user to
     * use a chat invite link
     */
    _: 'chatInviteLinkSubscriptionInfo',
    /**
     * Information about subscription plan that must be paid by the user to use the
     * link
     */
    pricing: starSubscriptionPricing,
    /**
     * True, if the user has already paid for the subscription and can use joinChatByInviteLink
     * to join the subscribed chat again
     */
    can_reuse: boolean,
    /**
     * Identifier of the payment form to use for subscription payment; 0 if the subscription
     * can't be paid
     */
    form_id: string,
  }

  export type chatInviteLinkInfo = {
    /** Contains information about a chat invite link */
    _: 'chatInviteLinkInfo',
    /**
     * Chat identifier of the invite link; 0 if the user has no access to the chat
     * before joining
     */
    chat_id: number,
    /**
     * If non-zero, the amount of time for which read access to the chat will remain
     * available, in seconds
     */
    accessible_for: number,
    /** Type of the chat */
    type: InviteLinkChatType,
    /** Title of the chat */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Identifier of the accent color for chat title and background of chat photo */
    accent_color_id: number,
    /** Chat description */
    description: string,
    /** Number of members in the chat */
    member_count: number,
    /** User identifiers of some chat members that may be known to the current user */
    member_user_ids: Array<number>,
    /**
     * Information about subscription plan that must be paid by the user to use the
     * link; may be null if the link doesn't require subscription
     */
    subscription_info?: chatInviteLinkSubscriptionInfo,
    /** True, if the link only creates join request */
    creates_join_request: boolean,
    /**
     * True, if the chat is a public supergroup or channel, i.e. it has a username
     * or it is a location-based supergroup
     */
    is_public: boolean,
    /** Information about verification status of the chat; may be null if none */
    verification_status?: verificationStatus,
  }

  export type chatJoinRequest = {
    /** Describes a user that sent a join request and waits for administrator approval */
    _: 'chatJoinRequest',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    date: number,
    /** A short bio of the user */
    bio: string,
  }

  export type chatJoinRequest$Input = {
    /** Describes a user that sent a join request and waits for administrator approval */
    readonly _: 'chatJoinRequest',
    /** User identifier */
    readonly user_id?: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    readonly date?: number,
    /** A short bio of the user */
    readonly bio?: string,
  }

  export type chatJoinRequests = {
    /** Contains a list of requests to join a chat */
    _: 'chatJoinRequests',
    /** Approximate total number of requests found */
    total_count: number,
    /** List of the requests */
    requests: Array<chatJoinRequest>,
  }

  export type chatJoinRequestsInfo = {
    /** Contains information about pending join requests for a chat */
    _: 'chatJoinRequestsInfo',
    /** Total number of pending join requests */
    total_count: number,
    /** Identifiers of at most 3 users sent the newest pending join requests */
    user_ids: Array<number>,
  }

  export type basicGroup = {
    /**
     * Represents a basic group of 0-200 users (must be upgraded to a supergroup to
     * accommodate more than 200 users)
     */
    _: 'basicGroup',
    /** Group identifier */
    id: number,
    /** Number of members in the group */
    member_count: number,
    /** Status of the current user in the group */
    status: ChatMemberStatus,
    /** True, if the group is active */
    is_active: boolean,
    /** Identifier of the supergroup to which this group was upgraded; 0 if none */
    upgraded_to_supergroup_id: number,
  }

  export type basicGroupFullInfo = {
    /** Contains full information about a basic group */
    _: 'basicGroupFullInfo',
    /**
     * Chat photo; may be null if empty or unknown. If non-null, then it is the same
     * photo as in chat.photo
     */
    photo?: chatPhoto,
    /** Group description. Updated only after the basic group is opened */
    description: string,
    /** User identifier of the creator of the group; 0 if unknown */
    creator_user_id: number,
    /** Group members */
    members: Array<chatMember>,
    /**
     * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers
     * and searchChatMembers for non-administrators after upgrading the basic group
     * to a supergroup
     */
    can_hide_members: boolean,
    /**
     * True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
     * after upgrading the basic group to a supergroup
     */
    can_toggle_aggressive_anti_spam: boolean,
    /**
     * Primary invite link for this group; may be null. For chat administrators with
     * can_invite_users right only. Updated only after the basic group is opened
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
  }

  export type supergroup = {
    /**
     * Represents a supergroup or channel with zero or more members (subscribers in
     * the case of channels). From the point of view of the system, a channel is a
     * special kind of a supergroup: only administrators can post and see the list
     * of members, and posts from all administrators use the name and photo of the
     * channel instead of individual names and profile photos. Unlike supergroups,
     * channels can have an unlimited number of subscribers
     */
    _: 'supergroup',
    /** Supergroup or channel identifier */
    id: number,
    /** Usernames of the supergroup or channel; may be null */
    usernames?: usernames,
    /**
     * Point in time (Unix timestamp) when the current user joined, or the point in
     * time when the supergroup or channel was created, in case the user is not a member
     */
    date: number,
    /**
     * Status of the current user in the supergroup or channel; custom title will always
     * be empty
     */
    status: ChatMemberStatus,
    /**
     * Number of members in the supergroup or channel; 0 if unknown. Currently, it
     * is guaranteed to be known only if the supergroup or channel was received through
     * getChatSimilarChats, getChatsToPostStories, getCreatedPublicChats, getGroupsInCommon,
     * getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats,
     * getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchPublicChats,
     * or in chatFolderInviteLinkInfo.missing_chat_ids, or in userFullInfo.personal_chat_id,
     * or for chats with messages or stories from publicForwards and foundStories
     */
    member_count: number,
    /** Approximate boost level for the chat */
    boost_level: number,
    /** True, if automatic translation of messages is enabled in the channel */
    has_automatic_translation: boolean,
    /**
     * True, if the channel has a discussion group, or the supergroup is the designated
     * discussion group for a channel
     */
    has_linked_chat: boolean,
    /**
     * True, if the supergroup is connected to a location, i.e. the supergroup is a
     * location-based supergroup
     */
    has_location: boolean,
    /**
     * True, if messages sent to the channel contains name of the sender. This field
     * is only applicable to channels
     */
    sign_messages: boolean,
    /**
     * True, if messages sent to the channel have information about the sender user.
     * This field is only applicable to channels
     */
    show_message_sender: boolean,
    /**
     * True, if users need to join the supergroup before they can send messages. Always
     * true for channels and non-discussion supergroups
     */
    join_to_send_messages: boolean,
    /**
     * True, if all users directly joining the supergroup need to be approved by supergroup
     * administrators. Always false for channels and supergroups without username,
     * location, or a linked chat
     */
    join_by_request: boolean,
    /** True, if the slow mode is enabled in the supergroup */
    is_slow_mode_enabled: boolean,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
    /**
     * True, if the supergroup is a broadcast group, i.e. only administrators can send
     * messages and there is no limit on the number of members
     */
    is_broadcast_group: boolean,
    /** True, if the supergroup is a forum with topics */
    is_forum: boolean,
    /** True, if the supergroup is a direct message group for a channel chat */
    is_direct_messages_group: boolean,
    /**
     * True, if the supergroup is a direct messages group for a channel chat that is
     * administered by the current user
     */
    is_administered_direct_messages_group: boolean,
    /**
     * Information about verification status of the supergroup or channel; may be null
     * if none
     */
    verification_status?: verificationStatus,
    /** True, if the channel has direct messages group */
    has_direct_messages_group: boolean,
    /**
     * True, if the supergroup is a forum, which topics are shown in the same way as
     * in channel direct messages groups
     */
    has_forum_tabs: boolean,
    /**
     * True, if content of media messages in the supergroup or channel chat must be
     * hidden with 18+ spoiler
     */
    has_sensitive_content: boolean,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this supergroup or channel must be restricted
     */
    restriction_reason: string,
    /**
     * Number of Telegram Stars that must be paid by non-administrator users of the
     * supergroup chat for each sent message
     */
    paid_message_star_count: number,
    /**
     * True, if the supergroup or channel has non-expired stories available to the
     * current user
     */
    has_active_stories: boolean,
    /**
     * True, if the supergroup or channel has unread non-expired stories available
     * to the current user
     */
    has_unread_active_stories: boolean,
  }

  export type supergroupFullInfo = {
    /** Contains full information about a supergroup or channel */
    _: 'supergroupFullInfo',
    /**
     * Chat photo; may be null if empty or unknown. If non-null, then it is the same
     * photo as in chat.photo
     */
    photo?: chatPhoto,
    /** Supergroup or channel description */
    description: string,
    /** Number of members in the supergroup or channel; 0 if unknown */
    member_count: number,
    /** Number of privileged users in the supergroup or channel; 0 if unknown */
    administrator_count: number,
    /** Number of restricted users in the supergroup; 0 if unknown */
    restricted_count: number,
    /** Number of users banned from chat; 0 if unknown */
    banned_count: number,
    /**
     * Chat identifier of a discussion group for the channel, or a channel, for which
     * the supergroup is the designated discussion group; 0 if none or unknown
     */
    linked_chat_id: number,
    /**
     * Chat identifier of a direct messages group for the channel, or a channel, for
     * which the supergroup is the designated direct messages group; 0 if none
     */
    direct_messages_chat_id: number,
    /**
     * Delay between consecutive sent messages for non-administrator supergroup members,
     * in seconds
     */
    slow_mode_delay: number,
    /**
     * Time left before next message can be sent in the supergroup, in seconds. An
     * updateSupergroupFullInfo update is not triggered when value of this field changes,
     * but both new and old values are non-zero
     */
    slow_mode_delay_expires_in: number,
    /**
     * True, if paid messages can be enabled in the supergroup chat; for supergroup
     * only
     */
    can_enable_paid_messages: boolean,
    /** True, if paid reaction can be enabled in the channel chat; for channels only */
    can_enable_paid_reaction: boolean,
    /** True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers */
    can_get_members: boolean,
    /**
     * True, if non-administrators can receive only administrators and bots using getSupergroupMembers
     * or searchChatMembers
     */
    has_hidden_members: boolean,
    /**
     * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers
     * and searchChatMembers for non-administrators
     */
    can_hide_members: boolean,
    /** True, if the supergroup sticker set can be changed */
    can_set_sticker_set: boolean,
    /** True, if the supergroup location can be changed */
    can_set_location: boolean,
    /** True, if the supergroup or channel statistics are available */
    can_get_statistics: boolean,
    /** True, if the supergroup or channel revenue statistics are available */
    can_get_revenue_statistics: boolean,
    /** True, if the supergroup or channel Telegram Star revenue statistics are available */
    can_get_star_revenue_statistics: boolean,
    /**
     * True, if the user can send a gift to the supergroup or channel using sendGift
     * or transferGift
     */
    can_send_gift: boolean,
    /** True, if aggressive anti-spam checks can be enabled or disabled in the supergroup */
    can_toggle_aggressive_anti_spam: boolean,
    /**
     * True, if new chat members will have access to old messages. In public, discussion,
     * of forum groups and all channels, old messages are always available, so this
     * option affects only private non-forum supergroups without a linked chat. The
     * value of this field is only available to chat administrators
     */
    is_all_history_available: boolean,
    /**
     * True, if the chat can have sponsored messages. The value of this field is only
     * available to the owner of the chat
     */
    can_have_sponsored_messages: boolean,
    /**
     * True, if aggressive anti-spam checks are enabled in the supergroup. The value
     * of this field is only available to chat administrators
     */
    has_aggressive_anti_spam_enabled: boolean,
    /**
     * True, if paid media can be sent and forwarded to the channel chat; for channels
     * only
     */
    has_paid_media_allowed: boolean,
    /** True, if the supergroup or channel has pinned stories */
    has_pinned_stories: boolean,
    /**
     * Number of saved to profile gifts for channels without can_post_messages administrator
     * right, otherwise, the total number of received gifts
     */
    gift_count: number,
    /** Number of times the current user boosted the supergroup or channel */
    my_boost_count: number,
    /**
     * Number of times the supergroup must be boosted by a user to ignore slow mode
     * and chat permission restrictions; 0 if unspecified
     */
    unrestrict_boost_count: number,
    /**
     * Number of Telegram Stars that must be paid by the current user for each sent
     * message to the supergroup
     */
    outgoing_paid_message_star_count: number,
    /**
     * Identifier of the supergroup sticker set that must be shown before user sticker
     * sets; 0 if none
     */
    sticker_set_id: string,
    /**
     * Identifier of the custom emoji sticker set that can be used in the supergroup
     * without Telegram Premium subscription; 0 if none
     */
    custom_emoji_sticker_set_id: string,
    /** Location to which the supergroup is connected; may be null if none */
    location?: chatLocation,
    /**
     * Primary invite link for the chat; may be null. For chat administrators with
     * can_invite_users right only
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
    /**
     * Information about verification status of the supergroup or the channel provided
     * by a bot; may be null if none or unknown
     */
    bot_verification?: botVerification,
    /** Identifier of the basic group from which supergroup was upgraded; 0 if none */
    upgraded_from_basic_group_id: number,
    /**
     * Identifier of the last message in the basic group from which supergroup was
     * upgraded; 0 if none
     */
    upgraded_from_max_message_id: number,
  }

  export type secretChatStatePending = {
    /** The secret chat is not yet created; waiting for the other user to get online */
    _: 'secretChatStatePending',
  }

  export type secretChatStateReady = {
    /** The secret chat is ready to use */
    _: 'secretChatStateReady',
  }

  export type secretChatStateClosed = {
    /** The secret chat is closed */
    _: 'secretChatStateClosed',
  }

  export type secretChat = {
    /** Represents a secret chat */
    _: 'secretChat',
    /** Secret chat identifier */
    id: number,
    /** Identifier of the chat partner */
    user_id: number,
    /** State of the secret chat */
    state: SecretChatState,
    /** True, if the chat was created by the current user; false otherwise */
    is_outbound: boolean,
    /**
     * Hash of the currently used key for comparison with the hash of the chat partner's
     * key. This is a string of 36 little-endian bytes, which must be split into groups
     * of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775,
     * and 2F99C9. The pixels must be used to make a 12x12 square image filled from
     * left to right, top to bottom. Alternatively, the first 32 bytes of the hash
     * can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
     */
    key_hash: string /* base64 */,
    /**
     * Secret chat layer; determines features supported by the chat partner's application.
     * Nested text entities and underline and strikethrough entities are supported
     * if the layer >= 101, files bigger than 2000MB are supported if the layer >=
     * 143, spoiler and custom emoji text entities are supported if the layer >= 144
     */
    layer: number,
  }

  export type messageSenderUser = {
    /** The message was sent by a known user */
    _: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    user_id: number,
  }

  export type messageSenderUser$Input = {
    /** The message was sent by a known user */
    readonly _: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    readonly user_id?: number,
  }

  export type messageSenderChat = {
    /** The message was sent on behalf of a chat */
    _: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    chat_id: number,
  }

  export type messageSenderChat$Input = {
    /** The message was sent on behalf of a chat */
    readonly _: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    readonly chat_id?: number,
  }

  export type messageSenders = {
    /** Represents a list of message senders */
    _: 'messageSenders',
    /** Approximate total number of messages senders found */
    total_count: number,
    /** List of message senders */
    senders: Array<MessageSender>,
  }

  export type chatMessageSender = {
    /** Represents a message sender, which can be used to send messages in a chat */
    _: 'chatMessageSender',
    /** The message sender */
    sender: MessageSender,
    /** True, if Telegram Premium is needed to use the message sender */
    needs_premium: boolean,
  }

  export type chatMessageSenders = {
    /**
     * Represents a list of message senders, which can be used to send messages in
     * a chat
     */
    _: 'chatMessageSenders',
    /** List of available message senders */
    senders: Array<chatMessageSender>,
  }

  export type messageReadDateRead = {
    /** Contains read date of the message */
    _: 'messageReadDateRead',
    /** Point in time (Unix timestamp) when the message was read by the other user */
    read_date: number,
  }

  export type messageReadDateUnread = {
    /** The message is unread yet */
    _: 'messageReadDateUnread',
  }

  export type messageReadDateTooOld = {
    /** The message is too old to get read date */
    _: 'messageReadDateTooOld',
  }

  export type messageReadDateUserPrivacyRestricted = {
    /** The read date is unknown due to privacy settings of the other user */
    _: 'messageReadDateUserPrivacyRestricted',
  }

  export type messageReadDateMyPrivacyRestricted = {
    /**
     * The read date is unknown due to privacy settings of the current user, but will
     * be known if the user subscribes to Telegram Premium
     */
    _: 'messageReadDateMyPrivacyRestricted',
  }

  export type messageViewer = {
    /** Represents a viewer of a message */
    _: 'messageViewer',
    /** User identifier of the viewer */
    user_id: number,
    /** Approximate point in time (Unix timestamp) when the message was viewed */
    view_date: number,
  }

  export type messageViewers = {
    /** Represents a list of message viewers */
    _: 'messageViewers',
    /** List of message viewers */
    viewers: Array<messageViewer>,
  }

  export type messageOriginUser = {
    /** The message was originally sent by a known user */
    _: 'messageOriginUser',
    /** Identifier of the user that originally sent the message */
    sender_user_id: number,
  }

  export type messageOriginHiddenUser = {
    /**
     * The message was originally sent by a user, which is hidden by their privacy
     * settings
     */
    _: 'messageOriginHiddenUser',
    /** Name of the sender */
    sender_name: string,
  }

  export type messageOriginChat = {
    /** The message was originally sent on behalf of a chat */
    _: 'messageOriginChat',
    /** Identifier of the chat that originally sent the message */
    sender_chat_id: number,
    /**
     * For messages originally sent by an anonymous chat administrator, original message
     * author signature
     */
    author_signature: string,
  }

  export type messageOriginChannel = {
    /** The message was originally a post in a channel */
    _: 'messageOriginChannel',
    /** Identifier of the channel chat to which the message was originally sent */
    chat_id: number,
    /** Message identifier of the original message */
    message_id: number,
    /** Original post author signature */
    author_signature: string,
  }

  export type forwardSource = {
    /**
     * Contains information about the last message from which a new message was forwarded
     * last time
     */
    _: 'forwardSource',
    /**
     * Identifier of the chat to which the message that was forwarded belonged; may
     * be 0 if unknown
     */
    chat_id: number,
    /** Identifier of the message; may be 0 if unknown */
    message_id: number,
    /**
     * Identifier of the sender of the message; may be null if unknown or the new message
     * was forwarded not to Saved Messages
     */
    sender_id?: MessageSender,
    /** Name of the sender of the message if the sender is hidden by their privacy settings */
    sender_name: string,
    /** Point in time (Unix timestamp) when the message is sent; 0 if unknown */
    date: number,
    /**
     * True, if the message that was forwarded is outgoing; always false if sender
     * is unknown
     */
    is_outgoing: boolean,
  }

  export type reactionTypeEmoji = {
    /** A reaction with an emoji */
    _: 'reactionTypeEmoji',
    /** Text representation of the reaction */
    emoji: string,
  }

  export type reactionTypeEmoji$Input = {
    /** A reaction with an emoji */
    readonly _: 'reactionTypeEmoji',
    /** Text representation of the reaction */
    readonly emoji?: string,
  }

  export type reactionTypeCustomEmoji = {
    /** A reaction with a custom emoji */
    _: 'reactionTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    custom_emoji_id: string,
  }

  export type reactionTypeCustomEmoji$Input = {
    /** A reaction with a custom emoji */
    readonly _: 'reactionTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    readonly custom_emoji_id?: number | string,
  }

  export type reactionTypePaid = {
    /** The paid reaction in a channel chat */
    _: 'reactionTypePaid',
  }

  export type reactionTypePaid$Input = {
    /** The paid reaction in a channel chat */
    readonly _: 'reactionTypePaid',
  }

  export type paidReactionTypeRegular = {
    /** A paid reaction on behalf of the current user */
    _: 'paidReactionTypeRegular',
  }

  export type paidReactionTypeRegular$Input = {
    /** A paid reaction on behalf of the current user */
    readonly _: 'paidReactionTypeRegular',
  }

  export type paidReactionTypeAnonymous = {
    /** An anonymous paid reaction */
    _: 'paidReactionTypeAnonymous',
  }

  export type paidReactionTypeAnonymous$Input = {
    /** An anonymous paid reaction */
    readonly _: 'paidReactionTypeAnonymous',
  }

  export type paidReactionTypeChat = {
    /** A paid reaction on behalf of an owned chat */
    _: 'paidReactionTypeChat',
    /** Identifier of the chat */
    chat_id: number,
  }

  export type paidReactionTypeChat$Input = {
    /** A paid reaction on behalf of an owned chat */
    readonly _: 'paidReactionTypeChat',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type paidReactor = {
    /** Contains information about a user that added paid reactions */
    _: 'paidReactor',
    /**
     * Identifier of the user or chat that added the reactions; may be null for anonymous
     * reactors that aren't the current user
     */
    sender_id?: MessageSender,
    /** Number of Telegram Stars added */
    star_count: number,
    /**
     * True, if the reactor is one of the most active reactors; may be false if the
     * reactor is the current user
     */
    is_top: boolean,
    /** True, if the paid reaction was added by the current user */
    is_me: boolean,
    /** True, if the reactor is anonymous */
    is_anonymous: boolean,
  }

  export type messageForwardInfo = {
    /** Contains information about a forwarded message */
    _: 'messageForwardInfo',
    /** Origin of the forwarded message */
    origin: MessageOrigin,
    /** Point in time (Unix timestamp) when the message was originally sent */
    date: number,
    /**
     * For messages forwarded to the chat with the current user (Saved Messages), to
     * the Replies bot chat, or to the channel's discussion group, information about
     * the source message from which the message was forwarded last time; may be null
     * for other forwards or if unknown
     */
    source?: forwardSource,
    /** The type of public service announcement for the forwarded message */
    public_service_announcement_type: string,
  }

  export type messageImportInfo = {
    /** Contains information about a message created with importMessages */
    _: 'messageImportInfo',
    /** Name of the original sender */
    sender_name: string,
    /** Point in time (Unix timestamp) when the message was originally sent */
    date: number,
  }

  export type messageReplyInfo = {
    /** Contains information about replies to a message */
    _: 'messageReplyInfo',
    /** Number of times the message was directly or indirectly replied */
    reply_count: number,
    /**
     * Identifiers of at most 3 recent repliers to the message; available in channels
     * with a discussion supergroup. The users and chats are expected to be inaccessible:
     * only their photo and name will be available
     */
    recent_replier_ids: Array<MessageSender>,
    /** Identifier of the last read incoming reply to the message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing reply to the message */
    last_read_outbox_message_id: number,
    /** Identifier of the last reply to the message */
    last_message_id: number,
  }

  export type messageReaction = {
    /** Contains information about a reaction to a message */
    _: 'messageReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Number of times the reaction was added */
    total_count: number,
    /** True, if the reaction is chosen by the current user */
    is_chosen: boolean,
    /**
     * Identifier of the message sender used by the current user to add the reaction;
     * may be null if unknown or the reaction isn't chosen
     */
    used_sender_id?: MessageSender,
    /**
     * Identifiers of at most 3 recent message senders, added the reaction; available
     * in private, basic group and supergroup chats
     */
    recent_sender_ids: Array<MessageSender>,
  }

  export type messageReactions = {
    /** Contains a list of reactions added to a message */
    _: 'messageReactions',
    /** List of added reactions */
    reactions: Array<messageReaction>,
    /**
     * True, if the reactions are tags and Telegram Premium users can filter messages
     * by them
     */
    are_tags: boolean,
    /** Information about top users that added the paid reaction */
    paid_reactors: Array<paidReactor>,
    /** True, if the list of added reactions is available using getMessageAddedReactions */
    can_get_added_reactions: boolean,
  }

  export type messageInteractionInfo = {
    /** Contains information about interactions with a message */
    _: 'messageInteractionInfo',
    /** Number of times the message was viewed */
    view_count: number,
    /** Number of times the message was forwarded */
    forward_count: number,
    /**
     * Information about direct or indirect replies to the message; may be null. Currently,
     * available only in channels with a discussion supergroup and discussion supergroups
     * for messages, which are not replies itself
     */
    reply_info?: messageReplyInfo,
    /** The list of reactions or tags added to the message; may be null */
    reactions?: messageReactions,
  }

  export type unreadReaction = {
    /** Contains information about an unread reaction to a message */
    _: 'unreadReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Identifier of the sender, added the reaction */
    sender_id: MessageSender,
    /** True, if the reaction was added with a big animation */
    is_big: boolean,
  }

  export type messageTopicForum = {
    /** A topic in a forum supergroup chat */
    _: 'messageTopicForum',
    /**
     * Unique identifier of the forum topic; all messages in a non-forum supergroup
     * chats belongs to the General topic
     */
    forum_topic_id: number,
  }

  export type messageTopicForum$Input = {
    /** A topic in a forum supergroup chat */
    readonly _: 'messageTopicForum',
    /**
     * Unique identifier of the forum topic; all messages in a non-forum supergroup
     * chats belongs to the General topic
     */
    readonly forum_topic_id?: number,
  }

  export type messageTopicDirectMessages = {
    /** A topic in a channel direct messages chat administered by the current user */
    _: 'messageTopicDirectMessages',
    /** Unique identifier of the topic */
    direct_messages_chat_topic_id: number,
  }

  export type messageTopicDirectMessages$Input = {
    /** A topic in a channel direct messages chat administered by the current user */
    readonly _: 'messageTopicDirectMessages',
    /** Unique identifier of the topic */
    readonly direct_messages_chat_topic_id?: number,
  }

  export type messageTopicSavedMessages = {
    /** A topic in Saved Messages chat */
    _: 'messageTopicSavedMessages',
    /** Unique identifier of the Saved Messages topic */
    saved_messages_topic_id: number,
  }

  export type messageTopicSavedMessages$Input = {
    /** A topic in Saved Messages chat */
    readonly _: 'messageTopicSavedMessages',
    /** Unique identifier of the Saved Messages topic */
    readonly saved_messages_topic_id?: number,
  }

  export type messageEffectTypeEmojiReaction = {
    /** An effect from an emoji reaction */
    _: 'messageEffectTypeEmojiReaction',
    /** Select animation for the effect in TGS format */
    select_animation: sticker,
    /** Effect animation for the effect in TGS format */
    effect_animation: sticker,
  }

  export type messageEffectTypePremiumSticker = {
    /** An effect from a premium sticker */
    _: 'messageEffectTypePremiumSticker',
    /** The premium sticker. The effect can be found at sticker.full_type.premium_animation */
    sticker: sticker,
  }

  export type messageEffect = {
    /** Contains information about an effect added to a message */
    _: 'messageEffect',
    /** Unique identifier of the effect */
    id: string,
    /** Static icon for the effect in WEBP format; may be null if none */
    static_icon?: sticker,
    /** Emoji corresponding to the effect that can be used if static icon isn't available */
    emoji: string,
    /** True, if Telegram Premium subscription is required to use the effect */
    is_premium: boolean,
    /** Type of the effect */
    type: MessageEffectType,
  }

  export type messageSendingStatePending = {
    /** The message is being sent now, but has not yet been delivered to the server */
    _: 'messageSendingStatePending',
    /** Non-persistent message sending identifier, specified by the application */
    sending_id: number,
  }

  export type messageSendingStateFailed = {
    /** The message failed to be sent */
    _: 'messageSendingStateFailed',
    /** The cause of the message sending failure */
    error: error,
    /** True, if the message can be re-sent using resendMessages or readdQuickReplyShortcutMessages */
    can_retry: boolean,
    /** True, if the message can be re-sent only on behalf of a different sender */
    need_another_sender: boolean,
    /**
     * True, if the message can be re-sent only if another quote is chosen in the message
     * that is replied by the given message
     */
    need_another_reply_quote: boolean,
    /**
     * True, if the message can be re-sent only if the message to be replied is removed.
     * This will be done automatically by resendMessages
     */
    need_drop_reply: boolean,
    /**
     * The number of Telegram Stars that must be paid to send the message; 0 if the
     * current amount is correct
     */
    required_paid_message_star_count: number,
    /**
     * Time left before the message can be re-sent, in seconds. No update is sent when
     * this field changes
     */
    retry_after: number,
  }

  export type textQuote = {
    /** Describes manually or automatically chosen quote from another message */
    _: 'textQuote',
    /**
     * Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and
     * CustomEmoji entities can be present in the text
     */
    text: formattedText,
    /**
     * Approximate quote position in the original message in UTF-16 code units as specified
     * by the message sender
     */
    position: number,
    /** True, if the quote was manually chosen by the message sender */
    is_manual: boolean,
  }

  export type inputTextQuote = {
    /** Describes manually chosen quote from another message */
    _: 'inputTextQuote',
    /**
     * Text of the quote; 0-getOption("message_reply_quote_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities
     * are allowed to be kept and must be kept in the quote
     */
    text: formattedText,
    /** Quote position in the original message in UTF-16 code units */
    position: number,
  }

  export type inputTextQuote$Input = {
    /** Describes manually chosen quote from another message */
    readonly _: 'inputTextQuote',
    /**
     * Text of the quote; 0-getOption("message_reply_quote_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities
     * are allowed to be kept and must be kept in the quote
     */
    readonly text?: formattedText$Input,
    /** Quote position in the original message in UTF-16 code units */
    readonly position?: number,
  }

  export type messageReplyToMessage = {
    /** Describes a message replied by a given message */
    _: 'messageReplyToMessage',
    /**
     * The identifier of the chat to which the message belongs; may be 0 if the replied
     * message is in unknown chat
     */
    chat_id: number,
    /**
     * The identifier of the message; may be 0 if the replied message is in unknown
     * chat
     */
    message_id: number,
    /** Chosen quote from the replied message; may be null if none */
    quote?: textQuote,
    /**
     * Information about origin of the message if the message was from another chat
     * or topic; may be null for messages from the same chat
     */
    origin?: MessageOrigin,
    /**
     * Point in time (Unix timestamp) when the message was sent if the message was
     * from another chat or topic; 0 for messages from the same chat
     */
    origin_send_date: number,
    /**
     * Media content of the message if the message was from another chat or topic;
     * may be null for messages from the same chat and messages without media. Can
     * be only one of the following types: messageAnimation, messageAudio, messageChecklist,
     * messageContact, messageDice, messageDocument, messageGame, messageGiveaway,
     * messageGiveawayWinners, messageInvoice, messageLocation, messagePaidMedia, messagePhoto,
     * messagePoll, messageSticker, messageStory, messageText (for link preview), messageVenue,
     * messageVideo, messageVideoNote, or messageVoiceNote
     */
    content?: MessageContent,
  }

  export type messageReplyToStory = {
    /** Describes a story replied by a given message */
    _: 'messageReplyToStory',
    /** The identifier of the poster of the story */
    story_poster_chat_id: number,
    /** The identifier of the story */
    story_id: number,
  }

  export type inputMessageReplyToMessage = {
    /** Describes a message to be replied in the same chat and forum topic */
    _: 'inputMessageReplyToMessage',
    /**
     * The identifier of the message to be replied in the same chat and forum topic.
     * A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
     */
    message_id: number,
    /**
     * Quote from the message to be replied; pass null if none. Must always be null
     * for replies in secret chats
     */
    quote: inputTextQuote,
  }

  export type inputMessageReplyToMessage$Input = {
    /** Describes a message to be replied in the same chat and forum topic */
    readonly _: 'inputMessageReplyToMessage',
    /**
     * The identifier of the message to be replied in the same chat and forum topic.
     * A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
     */
    readonly message_id?: number,
    /**
     * Quote from the message to be replied; pass null if none. Must always be null
     * for replies in secret chats
     */
    readonly quote?: inputTextQuote$Input,
  }

  export type inputMessageReplyToExternalMessage = {
    /**
     * Describes a message to be replied that is from a different chat or a forum topic;
     * not supported in secret chats
     */
    _: 'inputMessageReplyToExternalMessage',
    /** The identifier of the chat to which the message to be replied belongs */
    chat_id: number,
    /**
     * The identifier of the message to be replied in the specified chat. A message
     * can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
     */
    message_id: number,
    /** Quote from the message to be replied; pass null if none */
    quote: inputTextQuote,
  }

  export type inputMessageReplyToExternalMessage$Input = {
    /**
     * Describes a message to be replied that is from a different chat or a forum topic;
     * not supported in secret chats
     */
    readonly _: 'inputMessageReplyToExternalMessage',
    /** The identifier of the chat to which the message to be replied belongs */
    readonly chat_id?: number,
    /**
     * The identifier of the message to be replied in the specified chat. A message
     * can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
     */
    readonly message_id?: number,
    /** Quote from the message to be replied; pass null if none */
    readonly quote?: inputTextQuote$Input,
  }

  export type inputMessageReplyToStory = {
    /** Describes a story to be replied */
    _: 'inputMessageReplyToStory',
    /**
     * The identifier of the poster of the story. Currently, stories can be replied
     * only in the chat that posted the story; channel stories can't be replied
     */
    story_poster_chat_id: number,
    /** The identifier of the story */
    story_id: number,
  }

  export type inputMessageReplyToStory$Input = {
    /** Describes a story to be replied */
    readonly _: 'inputMessageReplyToStory',
    /**
     * The identifier of the poster of the story. Currently, stories can be replied
     * only in the chat that posted the story; channel stories can't be replied
     */
    readonly story_poster_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
  }

  export type factCheck = {
    /** Describes a fact-check added to the message by an independent checker */
    _: 'factCheck',
    /** Text of the fact-check */
    text: formattedText,
    /**
     * A two-letter ISO 3166-1 alpha-2 country code of the country for which the fact-check
     * is shown
     */
    country_code: string,
  }

  export type message = {
    /** Describes a message */
    _: 'message',
    /** Message identifier; unique for the chat to which the message belongs */
    id: number,
    /** Identifier of the sender of the message */
    sender_id: MessageSender,
    /** Chat identifier */
    chat_id: number,
    /**
     * The sending state of the message; may be null if the message isn't being sent
     * and didn't fail to be sent
     */
    sending_state?: MessageSendingState,
    /** The scheduling state of the message; may be null if the message isn't scheduled */
    scheduling_state?: MessageSchedulingState,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** True, if the message is pinned */
    is_pinned: boolean,
    /**
     * True, if the message was sent because of a scheduled action by the message sender,
     * for example, as away, or greeting service message
     */
    is_from_offline: boolean,
    /** True, if content of the message can be saved locally */
    can_be_saved: boolean,
    /**
     * True, if media timestamp entities refers to a media in this message as opposed
     * to a media in the replied message
     */
    has_timestamped_media: boolean,
    /**
     * True, if the message is a channel post. All messages to channels are channel
     * posts, all other messages are not channel posts
     */
    is_channel_post: boolean,
    /** True, if the message contains an unread mention for the current user */
    contains_unread_mention: boolean,
    /** Point in time (Unix timestamp) when the message was sent; 0 for scheduled messages */
    date: number,
    /**
     * Point in time (Unix timestamp) when the message was last edited; 0 for scheduled
     * messages
     */
    edit_date: number,
    /** Information about the initial message sender; may be null if none or unknown */
    forward_info?: messageForwardInfo,
    /**
     * Information about the initial message for messages created with importMessages;
     * may be null if the message isn't imported
     */
    import_info?: messageImportInfo,
    /** Information about interactions with the message; may be null if none */
    interaction_info?: messageInteractionInfo,
    /** Information about unread reactions added to the message */
    unread_reactions: Array<unreadReaction>,
    /** Information about fact-check added to the message; may be null if none */
    fact_check?: factCheck,
    /**
     * Information about the message or the story this message is replying to; may
     * be null if none
     */
    reply_to?: MessageReplyTo,
    /**
     * If non-zero, the identifier of the message thread the message belongs to; unique
     * within the chat to which the message belongs
     */
    message_thread_id: number,
    /**
     * Identifier of the topic within the chat to which the message belongs; may be
     * null if none
     */
    topic_id?: MessageTopic,
    /** The message's self-destruct type; may be null if none */
    self_destruct_type?: MessageSelfDestructType,
    /**
     * Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction
     * isn't scheduled yet
     */
    self_destruct_in: number,
    /**
     * Time left before the message will be automatically deleted by message_auto_delete_time
     * setting of the chat, in seconds; 0 if never
     */
    auto_delete_in: number,
    /**
     * If non-zero, the user identifier of the inline bot through which this message
     * was sent
     */
    via_bot_user_id: number,
    /** If non-zero, the user identifier of the business bot that sent this message */
    sender_business_bot_user_id: number,
    /**
     * Number of times the sender of the message boosted the supergroup at the time
     * the message was sent; 0 if none or unknown. For messages sent by the current
     * user, supergroupFullInfo.my_boost_count must be used instead
     */
    sender_boost_count: number,
    /** The number of Telegram Stars the sender paid to send the message */
    paid_message_star_count: number,
    /** For channel posts and anonymous group messages, optional author signature */
    author_signature: string,
    /**
     * Unique identifier of an album this message belongs to; 0 if none. Only audios,
     * documents, photos and videos can be grouped together in albums
     */
    media_album_id: string,
    /** Unique identifier of the effect added to the message; 0 if none */
    effect_id: string,
    /** True, if media content of the message must be hidden with 18+ spoiler */
    has_sensitive_content: boolean,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this message must be restricted
     */
    restriction_reason: string,
    /** Content of the message */
    content: MessageContent,
    /** Reply markup for the message; may be null if none */
    reply_markup?: ReplyMarkup,
  }

  export type messages = {
    /** Contains a list of messages */
    _: 'messages',
    /** Approximate total number of messages found */
    total_count: number,
    /** List of messages; messages may be null */
    messages: Array<message | null>,
  }

  export type foundMessages = {
    /** Contains a list of messages found by a search */
    _: 'foundMessages',
    /** Approximate total number of messages found; -1 if unknown */
    total_count: number,
    /** List of messages */
    messages: Array<message>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type foundChatMessages = {
    /** Contains a list of messages found by a search in a given chat */
    _: 'foundChatMessages',
    /** Approximate total number of messages found; -1 if unknown */
    total_count: number,
    /** List of messages */
    messages: Array<message>,
    /** The offset for the next request. If 0, there are no more results */
    next_from_message_id: number,
  }

  export type messagePosition = {
    /** Contains information about a message in a specific position */
    _: 'messagePosition',
    /** 0-based message position in the full list of suitable messages */
    position: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was sent */
    date: number,
  }

  export type messagePositions = {
    /** Contains a list of message positions */
    _: 'messagePositions',
    /** Total number of messages found */
    total_count: number,
    /** List of message positions */
    positions: Array<messagePosition>,
  }

  export type messageCalendarDay = {
    /** Contains information about found messages sent on a specific day */
    _: 'messageCalendarDay',
    /** Total number of found messages sent on the day */
    total_count: number,
    /** First message sent on the day */
    message: message,
  }

  export type messageCalendar = {
    /**
     * Contains information about found messages, split by days according to the option
     * "utc_time_offset"
     */
    _: 'messageCalendar',
    /** Total number of found messages */
    total_count: number,
    /** Information about messages sent */
    days: Array<messageCalendarDay>,
  }

  export type businessMessage = {
    /** Describes a message from a business account as received by a bot */
    _: 'businessMessage',
    /** The message */
    message: message,
    /** Message that is replied by the message in the same chat; may be null if none */
    reply_to_message?: message,
  }

  export type businessMessages = {
    /** Contains a list of messages from a business account as received by a bot */
    _: 'businessMessages',
    /** List of business messages */
    messages: Array<businessMessage>,
  }

  export type messageSourceChatHistory$Input = {
    /** The message is from a chat history */
    readonly _: 'messageSourceChatHistory',
  }

  export type messageSourceMessageThreadHistory$Input = {
    /** The message is from history of a message thread */
    readonly _: 'messageSourceMessageThreadHistory',
  }

  export type messageSourceForumTopicHistory$Input = {
    /** The message is from history of a forum topic */
    readonly _: 'messageSourceForumTopicHistory',
  }

  export type messageSourceDirectMessagesChatTopicHistory$Input = {
    /**
     * The message is from history of a topic in a channel direct messages chat administered
     * by the current user
     */
    readonly _: 'messageSourceDirectMessagesChatTopicHistory',
  }

  export type messageSourceHistoryPreview$Input = {
    /** The message is from chat, message thread or forum topic history preview */
    readonly _: 'messageSourceHistoryPreview',
  }

  export type messageSourceChatList$Input = {
    /** The message is from a chat list or a forum topic list */
    readonly _: 'messageSourceChatList',
  }

  export type messageSourceSearch$Input = {
    /**
     * The message is from search results, including file downloads, local file list,
     * outgoing document messages, calendar
     */
    readonly _: 'messageSourceSearch',
  }

  export type messageSourceChatEventLog$Input = {
    /** The message is from a chat event log */
    readonly _: 'messageSourceChatEventLog',
  }

  export type messageSourceNotification$Input = {
    /** The message is from a notification */
    readonly _: 'messageSourceNotification',
  }

  export type messageSourceScreenshot$Input = {
    /**
     * The message was screenshotted; the source must be used only if the message content
     * was visible during the screenshot
     */
    readonly _: 'messageSourceScreenshot',
  }

  export type messageSourceOther$Input = {
    /** The message is from some other source */
    readonly _: 'messageSourceOther',
  }

  export type advertisementSponsor = {
    /** Information about the sponsor of an advertisement */
    _: 'advertisementSponsor',
    /** URL of the sponsor to be opened when the advertisement is clicked */
    url: string,
    /** Photo of the sponsor; may be null if must not be shown */
    photo?: photo,
    /**
     * Additional optional information about the sponsor to be shown along with the
     * advertisement
     */
    info: string,
  }

  export type sponsoredMessage = {
    /** Describes a sponsored message */
    _: 'sponsoredMessage',
    /**
     * Message identifier; unique for the chat to which the sponsored message belongs
     * among both ordinary and sponsored messages
     */
    message_id: number,
    /** True, if the message needs to be labeled as "recommended" instead of "sponsored" */
    is_recommended: boolean,
    /** True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage */
    can_be_reported: boolean,
    /**
     * Content of the message. Currently, can be only of the types messageText, messageAnimation,
     * messagePhoto, or messageVideo. Video messages can be viewed fullscreen
     */
    content: MessageContent,
    /** Information about the sponsor of the message */
    sponsor: advertisementSponsor,
    /** Title of the sponsored message */
    title: string,
    /** Text for the message action button */
    button_text: string,
    /** Identifier of the accent color for title, button text and message background */
    accent_color_id: number,
    /** Identifier of a custom emoji to be shown on the message background; 0 if none */
    background_custom_emoji_id: string,
    /**
     * If non-empty, additional information about the sponsored message to be shown
     * along with the message
     */
    additional_info: string,
  }

  export type sponsoredMessages = {
    /** Contains a list of sponsored messages */
    _: 'sponsoredMessages',
    /** List of sponsored messages */
    messages: Array<sponsoredMessage>,
    /**
     * The minimum number of messages between shown sponsored messages, or 0 if only
     * one sponsored message must be shown after all ordinary messages
     */
    messages_between: number,
  }

  export type sponsoredChat = {
    /** Describes a sponsored chat */
    _: 'sponsoredChat',
    /** Unique identifier of this result */
    unique_id: number,
    /** Chat identifier */
    chat_id: number,
    /**
     * Additional optional information about the sponsor to be shown along with the
     * chat
     */
    sponsor_info: string,
    /**
     * If non-empty, additional information about the sponsored chat to be shown along
     * with the chat
     */
    additional_info: string,
  }

  export type sponsoredChats = {
    /** Contains a list of sponsored chats */
    _: 'sponsoredChats',
    /** List of sponsored chats */
    chats: Array<sponsoredChat>,
  }

  export type videoMessageAdvertisement = {
    /** Describes an advertisent to be shown while a video from a message is watched */
    _: 'videoMessageAdvertisement',
    /** Unique identifier of this result */
    unique_id: number,
    /** Text of the advertisement */
    text: string,
    /**
     * The minimum amount of time the advertisement must be dispalyed before it can
     * be hidden by the user, in seconds
     */
    min_display_duration: number,
    /**
     * The maximum amount of time the advertisement must be dispalyed before it must
     * be automatically hidden, in seconds
     */
    max_display_duration: number,
    /** True, if the advertisement can be reported to Telegram moderators through reportVideoMessageAdvertisement */
    can_be_reported: boolean,
    /** Information about the sponsor of the advertisement */
    sponsor: advertisementSponsor,
    /** Title of the sponsored message */
    title: string,
    /**
     * If non-empty, additional information about the sponsored message to be shown
     * along with the message
     */
    additional_info: string,
  }

  export type videoMessageAdvertisements = {
    /**
     * Contains a list of advertisements to be shown while a video from a message is
     * watched
     */
    _: 'videoMessageAdvertisements',
    /** List of advertisements */
    advertisements: Array<videoMessageAdvertisement>,
    /** Delay before the first advertisement is shown, in seconds */
    start_delay: number,
    /** Delay between consecutive advertisements, in seconds */
    between_delay: number,
  }

  export type reportOption = {
    /** Describes an option to report an entity to Telegram */
    _: 'reportOption',
    /** Unique identifier of the option */
    id: string /* base64 */,
    /** Text of the option */
    text: string,
  }

  export type reportSponsoredResultOk = {
    /** The message was reported successfully */
    _: 'reportSponsoredResultOk',
  }

  export type reportSponsoredResultFailed = {
    /** The sponsored message is too old or not found */
    _: 'reportSponsoredResultFailed',
  }

  export type reportSponsoredResultOptionRequired = {
    /**
     * The user must choose an option to report the message and repeat request with
     * the chosen option
     */
    _: 'reportSponsoredResultOptionRequired',
    /** Title for the option choice */
    title: string,
    /** List of available options */
    options: Array<reportOption>,
  }

  export type reportSponsoredResultAdsHidden = {
    /** Sponsored messages were hidden for the user in all chats */
    _: 'reportSponsoredResultAdsHidden',
  }

  export type reportSponsoredResultPremiumRequired = {
    /**
     * The user asked to hide sponsored messages, but Telegram Premium is required
     * for this
     */
    _: 'reportSponsoredResultPremiumRequired',
  }

  export type fileDownload = {
    /** Describes a file added to file download list */
    _: 'fileDownload',
    /** File identifier */
    file_id: number,
    /** The message with the file */
    message: message,
    /** Point in time (Unix timestamp) when the file was added to the download list */
    add_date: number,
    /**
     * Point in time (Unix timestamp) when the file downloading was completed; 0 if
     * the file downloading isn't completed
     */
    complete_date: number,
    /** True, if downloading of the file is paused */
    is_paused: boolean,
  }

  export type downloadedFileCounts = {
    /** Contains number of being downloaded and recently downloaded files found */
    _: 'downloadedFileCounts',
    /** Number of active file downloads found, including paused */
    active_count: number,
    /** Number of paused file downloads found */
    paused_count: number,
    /** Number of completed file downloads found */
    completed_count: number,
  }

  export type foundFileDownloads = {
    /** Contains a list of downloaded files, found by a search */
    _: 'foundFileDownloads',
    /** Total number of suitable files, ignoring offset */
    total_counts: downloadedFileCounts,
    /** The list of files */
    files: Array<fileDownload>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type notificationSettingsScopePrivateChats = {
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    _: 'notificationSettingsScopePrivateChats',
  }

  export type notificationSettingsScopePrivateChats$Input = {
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    readonly _: 'notificationSettingsScopePrivateChats',
  }

  export type notificationSettingsScopeGroupChats = {
    /**
     * Notification settings applied to all basic group and supergroup chats when the
     * corresponding chat setting has a default value
     */
    _: 'notificationSettingsScopeGroupChats',
  }

  export type notificationSettingsScopeGroupChats$Input = {
    /**
     * Notification settings applied to all basic group and supergroup chats when the
     * corresponding chat setting has a default value
     */
    readonly _: 'notificationSettingsScopeGroupChats',
  }

  export type notificationSettingsScopeChannelChats = {
    /**
     * Notification settings applied to all channel chats when the corresponding chat
     * setting has a default value
     */
    _: 'notificationSettingsScopeChannelChats',
  }

  export type notificationSettingsScopeChannelChats$Input = {
    /**
     * Notification settings applied to all channel chats when the corresponding chat
     * setting has a default value
     */
    readonly _: 'notificationSettingsScopeChannelChats',
  }

  export type chatNotificationSettings = {
    /** Contains information about notification settings for a chat or a forum topic */
    _: 'chatNotificationSettings',
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of mute_for
     */
    use_default_mute_for: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of sound_id
     */
    use_default_sound: boolean,
    /**
     * Identifier of the notification sound to be played for messages; 0 if sound is
     * disabled
     */
    sound_id: string,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of show_preview
     */
    use_default_show_preview: boolean,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /** If true, the value for the relevant type of chat is used instead of mute_stories */
    use_default_mute_stories: boolean,
    /** True, if story notifications are disabled for the chat */
    mute_stories: boolean,
    /** If true, the value for the relevant type of chat is used instead of story_sound_id */
    use_default_story_sound: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    story_sound_id: string,
    /** If true, the value for the relevant type of chat is used instead of show_story_poster */
    use_default_show_story_poster: boolean,
    /** True, if the chat that posted a story must be displayed in notifications */
    show_story_poster: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_pinned_message_notifications
     */
    use_default_disable_pinned_message_notifications: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_mention_notifications
     */
    use_default_disable_mention_notifications: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  }

  export type chatNotificationSettings$Input = {
    /** Contains information about notification settings for a chat or a forum topic */
    readonly _: 'chatNotificationSettings',
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of mute_for
     */
    readonly use_default_mute_for?: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    readonly mute_for?: number,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of sound_id
     */
    readonly use_default_sound?: boolean,
    /**
     * Identifier of the notification sound to be played for messages; 0 if sound is
     * disabled
     */
    readonly sound_id?: number | string,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of show_preview
     */
    readonly use_default_show_preview?: boolean,
    /** True, if message content must be displayed in notifications */
    readonly show_preview?: boolean,
    /** If true, the value for the relevant type of chat is used instead of mute_stories */
    readonly use_default_mute_stories?: boolean,
    /** True, if story notifications are disabled for the chat */
    readonly mute_stories?: boolean,
    /** If true, the value for the relevant type of chat is used instead of story_sound_id */
    readonly use_default_story_sound?: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    readonly story_sound_id?: number | string,
    /** If true, the value for the relevant type of chat is used instead of show_story_poster */
    readonly use_default_show_story_poster?: boolean,
    /** True, if the chat that posted a story must be displayed in notifications */
    readonly show_story_poster?: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_pinned_message_notifications
     */
    readonly use_default_disable_pinned_message_notifications?: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    readonly disable_pinned_message_notifications?: boolean,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of disable_mention_notifications
     */
    readonly use_default_disable_mention_notifications?: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    readonly disable_mention_notifications?: boolean,
  }

  export type scopeNotificationSettings = {
    /** Contains information about notification settings for several chats */
    _: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    sound_id: string,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /**
     * If true, story notifications are received only for the first 5 chats from topChatCategoryUsers
     * regardless of the value of mute_stories
     */
    use_default_mute_stories: boolean,
    /** True, if story notifications are disabled */
    mute_stories: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    story_sound_id: string,
    /** True, if the chat that posted a story must be displayed in notifications */
    show_story_poster: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  }

  export type scopeNotificationSettings$Input = {
    /** Contains information about notification settings for several chats */
    readonly _: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    readonly mute_for?: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    readonly sound_id?: number | string,
    /** True, if message content must be displayed in notifications */
    readonly show_preview?: boolean,
    /**
     * If true, story notifications are received only for the first 5 chats from topChatCategoryUsers
     * regardless of the value of mute_stories
     */
    readonly use_default_mute_stories?: boolean,
    /** True, if story notifications are disabled */
    readonly mute_stories?: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    readonly story_sound_id?: number | string,
    /** True, if the chat that posted a story must be displayed in notifications */
    readonly show_story_poster?: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    readonly disable_pinned_message_notifications?: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    readonly disable_mention_notifications?: boolean,
  }

  export type reactionNotificationSourceNone = {
    /** Notifications for reactions are disabled */
    _: 'reactionNotificationSourceNone',
  }

  export type reactionNotificationSourceNone$Input = {
    /** Notifications for reactions are disabled */
    readonly _: 'reactionNotificationSourceNone',
  }

  export type reactionNotificationSourceContacts = {
    /** Notifications for reactions are shown only for reactions from contacts */
    _: 'reactionNotificationSourceContacts',
  }

  export type reactionNotificationSourceContacts$Input = {
    /** Notifications for reactions are shown only for reactions from contacts */
    readonly _: 'reactionNotificationSourceContacts',
  }

  export type reactionNotificationSourceAll = {
    /** Notifications for reactions are shown for all reactions */
    _: 'reactionNotificationSourceAll',
  }

  export type reactionNotificationSourceAll$Input = {
    /** Notifications for reactions are shown for all reactions */
    readonly _: 'reactionNotificationSourceAll',
  }

  export type reactionNotificationSettings = {
    /** Contains information about notification settings for reactions */
    _: 'reactionNotificationSettings',
    /** Source of message reactions for which notifications are shown */
    message_reaction_source: ReactionNotificationSource,
    /** Source of story reactions for which notifications are shown */
    story_reaction_source: ReactionNotificationSource,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    sound_id: string,
    /** True, if reaction sender and emoji must be displayed in notifications */
    show_preview: boolean,
  }

  export type reactionNotificationSettings$Input = {
    /** Contains information about notification settings for reactions */
    readonly _: 'reactionNotificationSettings',
    /** Source of message reactions for which notifications are shown */
    readonly message_reaction_source?: ReactionNotificationSource$Input,
    /** Source of story reactions for which notifications are shown */
    readonly story_reaction_source?: ReactionNotificationSource$Input,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    readonly sound_id?: number | string,
    /** True, if reaction sender and emoji must be displayed in notifications */
    readonly show_preview?: boolean,
  }

  export type draftMessage = {
    /** Contains information about a message draft */
    _: 'draftMessage',
    /**
     * Information about the message to be replied; must be of the type inputMessageReplyToMessage;
     * may be null if none
     */
    reply_to?: InputMessageReplyTo,
    /** Point in time (Unix timestamp) when the draft was created */
    date: number,
    /**
     * Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote,
     * or inputMessageVoiceNote
     */
    input_message_text: InputMessageContent,
    /** Identifier of the effect to apply to the message when it is sent; 0 if none */
    effect_id: string,
  }

  export type draftMessage$Input = {
    /** Contains information about a message draft */
    readonly _: 'draftMessage',
    /**
     * Information about the message to be replied; must be of the type inputMessageReplyToMessage;
     * may be null if none
     */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Point in time (Unix timestamp) when the draft was created */
    readonly date?: number,
    /**
     * Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote,
     * or inputMessageVoiceNote
     */
    readonly input_message_text?: InputMessageContent$Input,
    /** Identifier of the effect to apply to the message when it is sent; 0 if none */
    readonly effect_id?: number | string,
  }

  export type chatTypePrivate = {
    /** An ordinary chat with a user */
    _: 'chatTypePrivate',
    /** User identifier */
    user_id: number,
  }

  export type chatTypeBasicGroup = {
    /** A basic group (a chat with 0-200 other users) */
    _: 'chatTypeBasicGroup',
    /** Basic group identifier */
    basic_group_id: number,
  }

  export type chatTypeSupergroup = {
    /** A supergroup or channel (with unlimited members) */
    _: 'chatTypeSupergroup',
    /** Supergroup or channel identifier */
    supergroup_id: number,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
  }

  export type chatTypeSecret = {
    /** A secret chat with a user */
    _: 'chatTypeSecret',
    /** Secret chat identifier */
    secret_chat_id: number,
    /** User identifier of the other user in the secret chat */
    user_id: number,
  }

  export type chatFolderIcon = {
    /** Represents an icon for a chat folder */
    _: 'chatFolderIcon',
    /**
     * The chosen icon name for short folder representation; one of "All", "Unread",
     * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat",
     * "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
     * "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money",
     * "Note", "Palette"
     */
    name: string,
  }

  export type chatFolderIcon$Input = {
    /** Represents an icon for a chat folder */
    readonly _: 'chatFolderIcon',
    /**
     * The chosen icon name for short folder representation; one of "All", "Unread",
     * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat",
     * "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
     * "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money",
     * "Note", "Palette"
     */
    readonly name?: string,
  }

  export type chatFolderName = {
    /** Describes name of a chat folder */
    _: 'chatFolderName',
    /**
     * The text of the chat folder name; 1-12 characters without line feeds. May contain
     * only CustomEmoji entities
     */
    text: formattedText,
    /** True, if custom emoji in the name must be animated */
    animate_custom_emoji: boolean,
  }

  export type chatFolderName$Input = {
    /** Describes name of a chat folder */
    readonly _: 'chatFolderName',
    /**
     * The text of the chat folder name; 1-12 characters without line feeds. May contain
     * only CustomEmoji entities
     */
    readonly text?: formattedText$Input,
    /** True, if custom emoji in the name must be animated */
    readonly animate_custom_emoji?: boolean,
  }

  export type chatFolder = {
    /** Represents a folder for user chats */
    _: 'chatFolder',
    /** The name of the folder */
    name: chatFolderName,
    /**
     * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName
     * to get default icon name for the folder
     */
    icon?: chatFolderIcon,
    /**
     * The identifier of the chosen color for the chat folder icon; from -1 to 6. If
     * -1, then color is disabled. Can't be changed if folder tags are disabled or
     * the current user doesn't have Telegram Premium subscription
     */
    color_id: number,
    /** True, if at least one link has been created for the folder */
    is_shareable: boolean,
    /**
     * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max")
     * pinned and always included non-secret chats and the same number of secret chats,
     * but the limit can be increased with Telegram Premium
     */
    pinned_chat_ids: Array<number>,
    /**
     * The chat identifiers of always included chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") pinned and always included
     * non-secret chats and the same number of secret chats, but the limit can be increased
     * with Telegram Premium
     */
    included_chat_ids: Array<number>,
    /**
     * The chat identifiers of always excluded chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret
     * chats and the same number of secret chats, but the limit can be increased with
     * Telegram Premium
     */
    excluded_chat_ids: Array<number>,
    /** True, if muted chats need to be excluded */
    exclude_muted: boolean,
    /** True, if read chats need to be excluded */
    exclude_read: boolean,
    /** True, if archived chats need to be excluded */
    exclude_archived: boolean,
    /** True, if contacts need to be included */
    include_contacts: boolean,
    /** True, if non-contact users need to be included */
    include_non_contacts: boolean,
    /** True, if bots need to be included */
    include_bots: boolean,
    /** True, if basic groups and supergroups need to be included */
    include_groups: boolean,
    /** True, if channels need to be included */
    include_channels: boolean,
  }

  export type chatFolder$Input = {
    /** Represents a folder for user chats */
    readonly _: 'chatFolder',
    /** The name of the folder */
    readonly name?: chatFolderName$Input,
    /**
     * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName
     * to get default icon name for the folder
     */
    readonly icon?: chatFolderIcon$Input,
    /**
     * The identifier of the chosen color for the chat folder icon; from -1 to 6. If
     * -1, then color is disabled. Can't be changed if folder tags are disabled or
     * the current user doesn't have Telegram Premium subscription
     */
    readonly color_id?: number,
    /** True, if at least one link has been created for the folder */
    readonly is_shareable?: boolean,
    /**
     * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max")
     * pinned and always included non-secret chats and the same number of secret chats,
     * but the limit can be increased with Telegram Premium
     */
    readonly pinned_chat_ids?: ReadonlyArray<number>,
    /**
     * The chat identifiers of always included chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") pinned and always included
     * non-secret chats and the same number of secret chats, but the limit can be increased
     * with Telegram Premium
     */
    readonly included_chat_ids?: ReadonlyArray<number>,
    /**
     * The chat identifiers of always excluded chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret
     * chats and the same number of secret chats, but the limit can be increased with
     * Telegram Premium
     */
    readonly excluded_chat_ids?: ReadonlyArray<number>,
    /** True, if muted chats need to be excluded */
    readonly exclude_muted?: boolean,
    /** True, if read chats need to be excluded */
    readonly exclude_read?: boolean,
    /** True, if archived chats need to be excluded */
    readonly exclude_archived?: boolean,
    /** True, if contacts need to be included */
    readonly include_contacts?: boolean,
    /** True, if non-contact users need to be included */
    readonly include_non_contacts?: boolean,
    /** True, if bots need to be included */
    readonly include_bots?: boolean,
    /** True, if basic groups and supergroups need to be included */
    readonly include_groups?: boolean,
    /** True, if channels need to be included */
    readonly include_channels?: boolean,
  }

  export type chatFolderInfo = {
    /** Contains basic information about a chat folder */
    _: 'chatFolderInfo',
    /** Unique chat folder identifier */
    id: number,
    /** The name of the folder */
    name: chatFolderName,
    /** The chosen or default icon for the chat folder */
    icon: chatFolderIcon,
    /**
     * The identifier of the chosen color for the chat folder icon; from -1 to 6. If
     * -1, then color is disabled
     */
    color_id: number,
    /** True, if at least one link has been created for the folder */
    is_shareable: boolean,
    /** True, if the chat folder has invite links created by the current user */
    has_my_invite_links: boolean,
  }

  export type chatFolderInviteLink = {
    /** Contains a chat folder invite link */
    _: 'chatFolderInviteLink',
    /** The chat folder invite link */
    invite_link: string,
    /** Name of the link */
    name: string,
    /** Identifiers of chats, included in the link */
    chat_ids: Array<number>,
  }

  export type chatFolderInviteLinks = {
    /** Represents a list of chat folder invite links */
    _: 'chatFolderInviteLinks',
    /** List of the invite links */
    invite_links: Array<chatFolderInviteLink>,
  }

  export type chatFolderInviteLinkInfo = {
    /** Contains information about an invite link to a chat folder */
    _: 'chatFolderInviteLinkInfo',
    /**
     * Basic information about the chat folder; chat folder identifier will be 0 if
     * the user didn't have the chat folder yet
     */
    chat_folder_info: chatFolderInfo,
    /** Identifiers of the chats from the link, which aren't added to the folder yet */
    missing_chat_ids: Array<number>,
    /** Identifiers of the chats from the link, which are added to the folder already */
    added_chat_ids: Array<number>,
  }

  export type recommendedChatFolder = {
    /** Describes a recommended chat folder */
    _: 'recommendedChatFolder',
    /** The chat folder */
    folder: chatFolder,
    /** Chat folder description */
    description: string,
  }

  export type recommendedChatFolders = {
    /** Contains a list of recommended chat folders */
    _: 'recommendedChatFolders',
    /** List of recommended chat folders */
    chat_folders: Array<recommendedChatFolder>,
  }

  export type archiveChatListSettings = {
    /**
     * Contains settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    _: 'archiveChatListSettings',
    /**
     * True, if new chats from non-contacts will be automatically archived and muted.
     * Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users"
     * is true
     */
    archive_and_mute_new_chats_from_unknown_users: boolean,
    /**
     * True, if unmuted chats will be kept in the Archive chat list when they get a
     * new message
     */
    keep_unmuted_chats_archived: boolean,
    /**
     * True, if unmuted chats, that are always included or pinned in a folder, will
     * be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived
     * == true
     */
    keep_chats_from_folders_archived: boolean,
  }

  export type archiveChatListSettings$Input = {
    /**
     * Contains settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    readonly _: 'archiveChatListSettings',
    /**
     * True, if new chats from non-contacts will be automatically archived and muted.
     * Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users"
     * is true
     */
    readonly archive_and_mute_new_chats_from_unknown_users?: boolean,
    /**
     * True, if unmuted chats will be kept in the Archive chat list when they get a
     * new message
     */
    readonly keep_unmuted_chats_archived?: boolean,
    /**
     * True, if unmuted chats, that are always included or pinned in a folder, will
     * be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived
     * == true
     */
    readonly keep_chats_from_folders_archived?: boolean,
  }

  export type chatListMain = {
    /** A main list of chats */
    _: 'chatListMain',
  }

  export type chatListMain$Input = {
    /** A main list of chats */
    readonly _: 'chatListMain',
  }

  export type chatListArchive = {
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    _: 'chatListArchive',
  }

  export type chatListArchive$Input = {
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    readonly _: 'chatListArchive',
  }

  export type chatListFolder = {
    /** A list of chats added to a chat folder */
    _: 'chatListFolder',
    /** Chat folder identifier */
    chat_folder_id: number,
  }

  export type chatListFolder$Input = {
    /** A list of chats added to a chat folder */
    readonly _: 'chatListFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type chatLists = {
    /** Contains a list of chat lists */
    _: 'chatLists',
    /** List of chat lists */
    chat_lists: Array<ChatList>,
  }

  export type chatSourceMtprotoProxy = {
    /** The chat is sponsored by the user's MTProxy server */
    _: 'chatSourceMtprotoProxy',
  }

  export type chatSourcePublicServiceAnnouncement = {
    /** The chat contains a public service announcement */
    _: 'chatSourcePublicServiceAnnouncement',
    /** The type of the announcement */
    type: string,
    /** The text of the announcement */
    text: string,
  }

  export type chatPosition = {
    /** Describes a position of a chat in a chat list */
    _: 'chatPosition',
    /** The chat list */
    list: ChatList,
    /**
     * A parameter used to determine order of the chat in the chat list. Chats must
     * be sorted by the pair (order, chat.id) in descending order
     */
    order: string,
    /** True, if the chat is pinned in the chat list */
    is_pinned: boolean,
    /** Source of the chat in the chat list; may be null */
    source?: ChatSource,
  }

  export type chatAvailableReactionsAll = {
    /**
     * All reactions are available in the chat, excluding the paid reaction and custom
     * reactions in channel chats
     */
    _: 'chatAvailableReactionsAll',
    /** The maximum allowed number of reactions per message; 1-11 */
    max_reaction_count: number,
  }

  export type chatAvailableReactionsAll$Input = {
    /**
     * All reactions are available in the chat, excluding the paid reaction and custom
     * reactions in channel chats
     */
    readonly _: 'chatAvailableReactionsAll',
    /** The maximum allowed number of reactions per message; 1-11 */
    readonly max_reaction_count?: number,
  }

  export type chatAvailableReactionsSome = {
    /** Only specific reactions are available in the chat */
    _: 'chatAvailableReactionsSome',
    /** The list of reactions */
    reactions: Array<ReactionType>,
    /** The maximum allowed number of reactions per message; 1-11 */
    max_reaction_count: number,
  }

  export type chatAvailableReactionsSome$Input = {
    /** Only specific reactions are available in the chat */
    readonly _: 'chatAvailableReactionsSome',
    /** The list of reactions */
    readonly reactions?: ReadonlyArray<ReactionType$Input>,
    /** The maximum allowed number of reactions per message; 1-11 */
    readonly max_reaction_count?: number,
  }

  export type savedMessagesTag = {
    /** Represents a tag used in Saved Messages or a Saved Messages topic */
    _: 'savedMessagesTag',
    /** The tag */
    tag: ReactionType,
    /**
     * Label of the tag; 0-12 characters. Always empty if the tag is returned for a
     * Saved Messages topic
     */
    label: string,
    /** Number of times the tag was used; may be 0 if the tag has non-empty label */
    count: number,
  }

  export type savedMessagesTags = {
    /** Contains a list of tags used in Saved Messages */
    _: 'savedMessagesTags',
    /** List of tags */
    tags: Array<savedMessagesTag>,
  }

  export type businessBotManageBar = {
    /** Contains information about a business bot that manages the chat */
    _: 'businessBotManageBar',
    /** User identifier of the bot */
    bot_user_id: number,
    /** URL to be opened to manage the bot */
    manage_url: string,
    /**
     * True, if the bot is paused. Use toggleBusinessConnectedBotChatIsPaused to change
     * the value of the field
     */
    is_bot_paused: boolean,
    /** True, if the bot can reply */
    can_bot_reply: boolean,
  }

  export type videoChat = {
    /** Describes a video chat, i.e. a group call bound to a chat */
    _: 'videoChat',
    /**
     * Group call identifier of an active video chat; 0 if none. Full information about
     * the video chat can be received through the method getGroupCall
     */
    group_call_id: number,
    /** True, if the video chat has participants */
    has_participants: boolean,
    /** Default group call participant identifier to join the video chat; may be null */
    default_participant_id?: MessageSender,
  }

  export type chat = {
    /** A chat. (Can be a private chat, basic group, supergroup, or secret chat) */
    _: 'chat',
    /** Chat unique identifier */
    id: number,
    /** Type of the chat */
    type: ChatType,
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /**
     * Identifier of the accent color for message sender name, and backgrounds of chat
     * photo, reply header, and link preview
     */
    accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background for messages sent by the chat; 0 if none
     */
    background_custom_emoji_id: string,
    /** Identifier of the profile accent color for the chat's profile; -1 if none */
    profile_accent_color_id: number,
    /**
     * Identifier of a custom emoji to be shown on the background of the chat's profile;
     * 0 if none
     */
    profile_background_custom_emoji_id: string,
    /** Actions that non-administrator chat members are allowed to take in the chat */
    permissions: chatPermissions,
    /** Last message in the chat; may be null if none or unknown */
    last_message?: message,
    /** Positions of the chat in chat lists */
    positions: Array<chatPosition>,
    /**
     * Chat lists to which the chat belongs. A chat can have a non-zero position in
     * a chat list even it doesn't belong to the chat list and have no position in
     * a chat list even it belongs to the chat list
     */
    chat_lists: Array<ChatList>,
    /**
     * Identifier of a user or chat that is selected to send messages in the chat;
     * may be null if the user can't change message sender
     */
    message_sender_id?: MessageSender,
    /** Block list to which the chat is added; may be null if none */
    block_list?: BlockList,
    /** True, if chat content can't be saved locally, forwarded, or copied */
    has_protected_content: boolean,
    /** True, if translation of all messages in the chat must be suggested to the user */
    is_translatable: boolean,
    /** True, if the chat is marked as unread */
    is_marked_as_unread: boolean,
    /**
     * True, if the chat is a forum supergroup that must be shown in the "View as topics"
     * mode, or Saved Messages chat that must be shown in the "View as chats"
     */
    view_as_topics: boolean,
    /** True, if the chat has scheduled messages */
    has_scheduled_messages: boolean,
    /**
     * True, if the chat messages can be deleted only for the current user while other
     * users will continue to see the messages
     */
    can_be_deleted_only_for_self: boolean,
    /** True, if the chat messages can be deleted for all users */
    can_be_deleted_for_all_users: boolean,
    /**
     * True, if the chat can be reported to Telegram moderators through reportChat
     * or reportChatPhoto
     */
    can_be_reported: boolean,
    /**
     * Default value of the disable_notification parameter, used when a message is
     * sent to the chat
     */
    default_disable_notification: boolean,
    /** Number of unread messages in the chat */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the chat */
    unread_mention_count: number,
    /** Number of messages with unread reactions in the chat */
    unread_reaction_count: number,
    /** Notification settings for the chat */
    notification_settings: chatNotificationSettings,
    /** Types of reaction, available in the chat */
    available_reactions: ChatAvailableReactions,
    /**
     * Current message auto-delete or self-destruct timer setting for the chat, in
     * seconds; 0 if disabled. Self-destruct timer in secret chats starts after the
     * message or its content is viewed. Auto-delete timer in other chats starts from
     * the send date
     */
    message_auto_delete_time: number,
    /** Emoji status to be shown along with chat title; may be null */
    emoji_status?: emojiStatus,
    /** Background set for the chat; may be null if none */
    background?: chatBackground,
    /** If non-empty, name of a theme, set for the chat */
    theme_name: string,
    /**
     * Information about actions which must be possible to do through the chat action
     * bar; may be null if none
     */
    action_bar?: ChatActionBar,
    /**
     * Information about bar for managing a business bot in the chat; may be null if
     * none
     */
    business_bot_manage_bar?: businessBotManageBar,
    /** Information about video chat of the chat */
    video_chat: videoChat,
    /** Information about pending join requests; may be null if none */
    pending_join_requests?: chatJoinRequestsInfo,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
    /** A draft of a message in the chat; may be null if none */
    draft_message?: draftMessage,
    /**
     * Application-specific data associated with the chat. (For example, the chat scroll
     * position or local chat notification settings can be stored here.) Persistent
     * if the message database is used
     */
    client_data: string,
  }

  export type chats = {
    /** Represents a list of chats */
    _: 'chats',
    /** Approximate total number of chats found */
    total_count: number,
    /** List of chat identifiers */
    chat_ids: Array<number>,
  }

  export type failedToAddMember = {
    /** Contains information about a user that has failed to be added to a chat */
    _: 'failedToAddMember',
    /** User identifier */
    user_id: number,
    /**
     * True, if subscription to Telegram Premium would have allowed to add the user
     * to the chat
     */
    premium_would_allow_invite: boolean,
    /**
     * True, if subscription to Telegram Premium is required to send the user chat
     * invite link
     */
    premium_required_to_send_messages: boolean,
  }

  export type failedToAddMembers = {
    /** Represents a list of users that has failed to be added to a chat */
    _: 'failedToAddMembers',
    /** Information about users that weren't added to the chat */
    failed_to_add_members: Array<failedToAddMember>,
  }

  export type createdBasicGroupChat = {
    /** Contains information about a newly created basic group chat */
    _: 'createdBasicGroupChat',
    /** Chat identifier */
    chat_id: number,
    /** Information about failed to add members */
    failed_to_add_members: failedToAddMembers,
  }

  export type publicChatTypeHasUsername$Input = {
    /** The chat is public, because it has an active username */
    readonly _: 'publicChatTypeHasUsername',
  }

  export type publicChatTypeIsLocationBased$Input = {
    /** The chat is public, because it is a location-based supergroup */
    readonly _: 'publicChatTypeIsLocationBased',
  }

  export type accountInfo = {
    /**
     * Contains basic information about another user that started a chat with the current
     * user
     */
    _: 'accountInfo',
    /** Month when the user was registered in Telegram; 0-12; may be 0 if unknown */
    registration_month: number,
    /** Year when the user was registered in Telegram; 0-9999; may be 0 if unknown */
    registration_year: number,
    /**
     * A two-letter ISO 3166-1 alpha-2 country code based on the phone number of the
     * user; may be empty if unknown
     */
    phone_number_country_code: string,
    /** Point in time (Unix timestamp) when the user changed name last time; 0 if unknown */
    last_name_change_date: number,
    /** Point in time (Unix timestamp) when the user changed photo last time; 0 if unknown */
    last_photo_change_date: number,
  }

  export type chatActionBarReportSpam = {
    /**
     * The chat can be reported as spam using the method reportChat with an empty option_id
     * and message_ids. If the chat is a private chat with a user with an emoji status,
     * then a notice about emoji status usage must be shown
     */
    _: 'chatActionBarReportSpam',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
  }

  export type chatActionBarInviteMembers = {
    /** The chat is a recently created group chat to which new members can be invited */
    _: 'chatActionBarInviteMembers',
  }

  export type chatActionBarReportAddBlock = {
    /**
     * The chat is a private or secret chat, which can be reported using the method
     * reportChat, or the other user can be blocked using the method setMessageSenderBlockList,
     * or the other user can be added to the contact list using the method addContact.
     * If the chat is a private chat with a user with an emoji status, then a notice
     * about emoji status usage must be shown
     */
    _: 'chatActionBarReportAddBlock',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
    /** Basic information about the other user in the chat; may be null if unknown */
    account_info?: accountInfo,
  }

  export type chatActionBarAddContact = {
    /**
     * The chat is a private or secret chat and the other user can be added to the
     * contact list using the method addContact
     */
    _: 'chatActionBarAddContact',
  }

  export type chatActionBarSharePhoneNumber = {
    /**
     * The chat is a private or secret chat with a mutual contact and the user's phone
     * number can be shared with the other user using the method sharePhoneNumber
     */
    _: 'chatActionBarSharePhoneNumber',
  }

  export type chatActionBarJoinRequest = {
    /**
     * The chat is a private chat with an administrator of a chat to which the user
     * sent join request
     */
    _: 'chatActionBarJoinRequest',
    /** Title of the chat to which the join request was sent */
    title: string,
    /** True, if the join request was sent to a channel chat */
    is_channel: boolean,
    /** Point in time (Unix timestamp) when the join request was sent */
    request_date: number,
  }

  export type keyboardButtonTypeText = {
    /** A simple button, with text that must be sent when the button is pressed */
    _: 'keyboardButtonTypeText',
  }

  export type keyboardButtonTypeText$Input = {
    /** A simple button, with text that must be sent when the button is pressed */
    readonly _: 'keyboardButtonTypeText',
  }

  export type keyboardButtonTypeRequestPhoneNumber = {
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    _: 'keyboardButtonTypeRequestPhoneNumber',
  }

  export type keyboardButtonTypeRequestPhoneNumber$Input = {
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    readonly _: 'keyboardButtonTypeRequestPhoneNumber',
  }

  export type keyboardButtonTypeRequestLocation = {
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    _: 'keyboardButtonTypeRequestLocation',
  }

  export type keyboardButtonTypeRequestLocation$Input = {
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    readonly _: 'keyboardButtonTypeRequestLocation',
  }

  export type keyboardButtonTypeRequestPoll = {
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    _: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    force_regular: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    force_quiz: boolean,
  }

  export type keyboardButtonTypeRequestPoll$Input = {
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    readonly _: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    readonly force_regular?: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    readonly force_quiz?: boolean,
  }

  export type keyboardButtonTypeRequestUsers = {
    /**
     * A button that requests users to be shared by the current user; available only
     * in private chats. Use the method shareUsersWithBot to complete the request
     */
    _: 'keyboardButtonTypeRequestUsers',
    /** Unique button identifier */
    id: number,
    /** True, if the shared users must or must not be bots */
    restrict_user_is_bot: boolean,
    /**
     * True, if the shared users must be bots; otherwise, the shared users must not
     * be bots. Ignored if restrict_user_is_bot is false
     */
    user_is_bot: boolean,
    /** True, if the shared users must or must not be Telegram Premium users */
    restrict_user_is_premium: boolean,
    /**
     * True, if the shared users must be Telegram Premium users; otherwise, the shared
     * users must not be Telegram Premium users. Ignored if restrict_user_is_premium
     * is false
     */
    user_is_premium: boolean,
    /** The maximum number of users to share */
    max_quantity: number,
    /** Pass true to request name of the users; bots only */
    request_name: boolean,
    /** Pass true to request username of the users; bots only */
    request_username: boolean,
    /** Pass true to request photo of the users; bots only */
    request_photo: boolean,
  }

  export type keyboardButtonTypeRequestUsers$Input = {
    /**
     * A button that requests users to be shared by the current user; available only
     * in private chats. Use the method shareUsersWithBot to complete the request
     */
    readonly _: 'keyboardButtonTypeRequestUsers',
    /** Unique button identifier */
    readonly id?: number,
    /** True, if the shared users must or must not be bots */
    readonly restrict_user_is_bot?: boolean,
    /**
     * True, if the shared users must be bots; otherwise, the shared users must not
     * be bots. Ignored if restrict_user_is_bot is false
     */
    readonly user_is_bot?: boolean,
    /** True, if the shared users must or must not be Telegram Premium users */
    readonly restrict_user_is_premium?: boolean,
    /**
     * True, if the shared users must be Telegram Premium users; otherwise, the shared
     * users must not be Telegram Premium users. Ignored if restrict_user_is_premium
     * is false
     */
    readonly user_is_premium?: boolean,
    /** The maximum number of users to share */
    readonly max_quantity?: number,
    /** Pass true to request name of the users; bots only */
    readonly request_name?: boolean,
    /** Pass true to request username of the users; bots only */
    readonly request_username?: boolean,
    /** Pass true to request photo of the users; bots only */
    readonly request_photo?: boolean,
  }

  export type keyboardButtonTypeRequestChat = {
    /**
     * A button that requests a chat to be shared by the current user; available only
     * in private chats. Use the method shareChatWithBot to complete the request
     */
    _: 'keyboardButtonTypeRequestChat',
    /** Unique button identifier */
    id: number,
    /**
     * True, if the chat must be a channel; otherwise, a basic group or a supergroup
     * chat is shared
     */
    chat_is_channel: boolean,
    /** True, if the chat must or must not be a forum supergroup */
    restrict_chat_is_forum: boolean,
    /**
     * True, if the chat must be a forum supergroup; otherwise, the chat must not be
     * a forum supergroup. Ignored if restrict_chat_is_forum is false
     */
    chat_is_forum: boolean,
    /** True, if the chat must or must not have a username */
    restrict_chat_has_username: boolean,
    /**
     * True, if the chat must have a username; otherwise, the chat must not have a
     * username. Ignored if restrict_chat_has_username is false
     */
    chat_has_username: boolean,
    /** True, if the chat must be created by the current user */
    chat_is_created: boolean,
    /** Expected user administrator rights in the chat; may be null if they aren't restricted */
    user_administrator_rights?: chatAdministratorRights,
    /** Expected bot administrator rights in the chat; may be null if they aren't restricted */
    bot_administrator_rights?: chatAdministratorRights,
    /**
     * True, if the bot must be a member of the chat; for basic group and supergroup
     * chats only
     */
    bot_is_member: boolean,
    /** Pass true to request title of the chat; bots only */
    request_title: boolean,
    /** Pass true to request username of the chat; bots only */
    request_username: boolean,
    /** Pass true to request photo of the chat; bots only */
    request_photo: boolean,
  }

  export type keyboardButtonTypeRequestChat$Input = {
    /**
     * A button that requests a chat to be shared by the current user; available only
     * in private chats. Use the method shareChatWithBot to complete the request
     */
    readonly _: 'keyboardButtonTypeRequestChat',
    /** Unique button identifier */
    readonly id?: number,
    /**
     * True, if the chat must be a channel; otherwise, a basic group or a supergroup
     * chat is shared
     */
    readonly chat_is_channel?: boolean,
    /** True, if the chat must or must not be a forum supergroup */
    readonly restrict_chat_is_forum?: boolean,
    /**
     * True, if the chat must be a forum supergroup; otherwise, the chat must not be
     * a forum supergroup. Ignored if restrict_chat_is_forum is false
     */
    readonly chat_is_forum?: boolean,
    /** True, if the chat must or must not have a username */
    readonly restrict_chat_has_username?: boolean,
    /**
     * True, if the chat must have a username; otherwise, the chat must not have a
     * username. Ignored if restrict_chat_has_username is false
     */
    readonly chat_has_username?: boolean,
    /** True, if the chat must be created by the current user */
    readonly chat_is_created?: boolean,
    /** Expected user administrator rights in the chat; may be null if they aren't restricted */
    readonly user_administrator_rights?: chatAdministratorRights$Input,
    /** Expected bot administrator rights in the chat; may be null if they aren't restricted */
    readonly bot_administrator_rights?: chatAdministratorRights$Input,
    /**
     * True, if the bot must be a member of the chat; for basic group and supergroup
     * chats only
     */
    readonly bot_is_member?: boolean,
    /** Pass true to request title of the chat; bots only */
    readonly request_title?: boolean,
    /** Pass true to request username of the chat; bots only */
    readonly request_username?: boolean,
    /** Pass true to request photo of the chat; bots only */
    readonly request_photo?: boolean,
  }

  export type keyboardButtonTypeWebApp = {
    /** A button that opens a Web App by calling getWebAppUrl */
    _: 'keyboardButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    url: string,
  }

  export type keyboardButtonTypeWebApp$Input = {
    /** A button that opens a Web App by calling getWebAppUrl */
    readonly _: 'keyboardButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    readonly url?: string,
  }

  export type keyboardButton = {
    /** Represents a single button in a bot keyboard */
    _: 'keyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: KeyboardButtonType,
  }

  export type keyboardButton$Input = {
    /** Represents a single button in a bot keyboard */
    readonly _: 'keyboardButton',
    /** Text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: KeyboardButtonType$Input,
  }

  export type inlineKeyboardButtonTypeUrl = {
    /** A button that opens a specified URL */
    _: 'inlineKeyboardButtonTypeUrl',
    /**
     * HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp,
     * then the button must be marked as a Web App button
     */
    url: string,
  }

  export type inlineKeyboardButtonTypeUrl$Input = {
    /** A button that opens a specified URL */
    readonly _: 'inlineKeyboardButtonTypeUrl',
    /**
     * HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp,
     * then the button must be marked as a Web App button
     */
    readonly url?: string,
  }

  export type inlineKeyboardButtonTypeLoginUrl = {
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user by calling getLoginUrlInfo
     */
    _: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to pass to getLoginUrlInfo */
    url: string,
    /** Unique button identifier */
    id: number,
    /** If non-empty, new text of the button in forwarded messages */
    forward_text: string,
  }

  export type inlineKeyboardButtonTypeLoginUrl$Input = {
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user by calling getLoginUrlInfo
     */
    readonly _: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to pass to getLoginUrlInfo */
    readonly url?: string,
    /** Unique button identifier */
    readonly id?: number,
    /** If non-empty, new text of the button in forwarded messages */
    readonly forward_text?: string,
  }

  export type inlineKeyboardButtonTypeWebApp = {
    /** A button that opens a Web App by calling openWebApp */
    _: 'inlineKeyboardButtonTypeWebApp',
    /** An HTTP URL to pass to openWebApp */
    url: string,
  }

  export type inlineKeyboardButtonTypeWebApp$Input = {
    /** A button that opens a Web App by calling openWebApp */
    readonly _: 'inlineKeyboardButtonTypeWebApp',
    /** An HTTP URL to pass to openWebApp */
    readonly url?: string,
  }

  export type inlineKeyboardButtonTypeCallback = {
    /** A button that sends a callback query to a bot */
    _: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    data: string /* base64 */,
  }

  export type inlineKeyboardButtonTypeCallback$Input = {
    /** A button that sends a callback query to a bot */
    readonly _: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    readonly data?: string /* base64 */,
  }

  export type inlineKeyboardButtonTypeCallbackWithPassword = {
    /**
     * A button that asks for the 2-step verification password of the current user
     * and then sends a callback query to a bot
     */
    _: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    data: string /* base64 */,
  }

  export type inlineKeyboardButtonTypeCallbackWithPassword$Input = {
    /**
     * A button that asks for the 2-step verification password of the current user
     * and then sends a callback query to a bot
     */
    readonly _: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    readonly data?: string /* base64 */,
  }

  export type inlineKeyboardButtonTypeCallbackGame = {
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    _: 'inlineKeyboardButtonTypeCallbackGame',
  }

  export type inlineKeyboardButtonTypeCallbackGame$Input = {
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    readonly _: 'inlineKeyboardButtonTypeCallbackGame',
  }

  export type inlineKeyboardButtonTypeSwitchInline = {
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    _: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    query: string,
    /** Target chat from which to send the inline query */
    target_chat: TargetChat,
  }

  export type inlineKeyboardButtonTypeSwitchInline$Input = {
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    readonly _: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    readonly query?: string,
    /** Target chat from which to send the inline query */
    readonly target_chat?: TargetChat$Input,
  }

  export type inlineKeyboardButtonTypeBuy = {
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    _: 'inlineKeyboardButtonTypeBuy',
  }

  export type inlineKeyboardButtonTypeBuy$Input = {
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    readonly _: 'inlineKeyboardButtonTypeBuy',
  }

  export type inlineKeyboardButtonTypeUser = {
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    _: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    user_id: number,
  }

  export type inlineKeyboardButtonTypeUser$Input = {
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    readonly _: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    readonly user_id?: number,
  }

  export type inlineKeyboardButtonTypeCopyText = {
    /** A button that copies specified text to clipboard */
    _: 'inlineKeyboardButtonTypeCopyText',
    /** The text to copy to clipboard */
    text: string,
  }

  export type inlineKeyboardButtonTypeCopyText$Input = {
    /** A button that copies specified text to clipboard */
    readonly _: 'inlineKeyboardButtonTypeCopyText',
    /** The text to copy to clipboard */
    readonly text?: string,
  }

  export type inlineKeyboardButton = {
    /** Represents a single button in an inline keyboard */
    _: 'inlineKeyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: InlineKeyboardButtonType,
  }

  export type inlineKeyboardButton$Input = {
    /** Represents a single button in an inline keyboard */
    readonly _: 'inlineKeyboardButton',
    /** Text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: InlineKeyboardButtonType$Input,
  }

  export type replyMarkupRemoveKeyboard = {
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    _: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    is_personal: boolean,
  }

  export type replyMarkupRemoveKeyboard$Input = {
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    readonly _: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    readonly is_personal?: boolean,
  }

  export type replyMarkupForceReply = {
    /** Instructs application to force a reply to this message */
    _: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  }

  export type replyMarkupForceReply$Input = {
    /** Instructs application to force a reply to this message */
    readonly _: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    readonly is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    readonly input_field_placeholder?: string,
  }

  export type replyMarkupShowKeyboard = {
    /** Contains a custom keyboard layout to quickly reply to bots */
    _: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    rows: Array<Array<keyboardButton>>,
    /**
     * True, if the keyboard is expected to always be shown when the ordinary keyboard
     * is hidden
     */
    is_persistent: boolean,
    /** True, if the application needs to resize the keyboard vertically */
    resize_keyboard: boolean,
    /** True, if the application needs to hide the keyboard after use */
    one_time: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  }

  export type replyMarkupShowKeyboard$Input = {
    /** Contains a custom keyboard layout to quickly reply to bots */
    readonly _: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    readonly rows?: ReadonlyArray<ReadonlyArray<keyboardButton$Input>>,
    /**
     * True, if the keyboard is expected to always be shown when the ordinary keyboard
     * is hidden
     */
    readonly is_persistent?: boolean,
    /** True, if the application needs to resize the keyboard vertically */
    readonly resize_keyboard?: boolean,
    /** True, if the application needs to hide the keyboard after use */
    readonly one_time?: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    readonly is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    readonly input_field_placeholder?: string,
  }

  export type replyMarkupInlineKeyboard = {
    /** Contains an inline keyboard layout */
    _: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    rows: Array<Array<inlineKeyboardButton>>,
  }

  export type replyMarkupInlineKeyboard$Input = {
    /** Contains an inline keyboard layout */
    readonly _: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    readonly rows?: ReadonlyArray<ReadonlyArray<inlineKeyboardButton$Input>>,
  }

  export type loginUrlInfoOpen = {
    /** An HTTP URL needs to be open */
    _: 'loginUrlInfoOpen',
    /** The URL to open */
    url: string,
    /** True, if there is no need to show an ordinary open URL confirmation */
    skip_confirmation: boolean,
  }

  export type loginUrlInfoRequestConfirmation = {
    /** An authorization confirmation dialog needs to be shown to the user */
    _: 'loginUrlInfoRequestConfirmation',
    /** An HTTP URL to be opened */
    url: string,
    /** A domain of the URL */
    domain: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /** True, if the user must be asked for the permission to the bot to send them messages */
    request_write_access: boolean,
  }

  export type themeParameters$Input = {
    /** Contains parameters of the application theme */
    readonly _: 'themeParameters',
    /** A color of the background in the RGB format */
    readonly background_color?: number,
    /** A secondary color for the background in the RGB format */
    readonly secondary_background_color?: number,
    /** A color of the header background in the RGB format */
    readonly header_background_color?: number,
    /** A color of the bottom bar background in the RGB format */
    readonly bottom_bar_background_color?: number,
    /** A color of the section background in the RGB format */
    readonly section_background_color?: number,
    /** A color of the section separator in the RGB format */
    readonly section_separator_color?: number,
    /** A color of text in the RGB format */
    readonly text_color?: number,
    /** An accent color of the text in the RGB format */
    readonly accent_text_color?: number,
    /** A color of text on the section headers in the RGB format */
    readonly section_header_text_color?: number,
    /** A color of the subtitle text in the RGB format */
    readonly subtitle_text_color?: number,
    /** A color of the text for destructive actions in the RGB format */
    readonly destructive_text_color?: number,
    /** A color of hints in the RGB format */
    readonly hint_color?: number,
    /** A color of links in the RGB format */
    readonly link_color?: number,
    /** A color of the buttons in the RGB format */
    readonly button_color?: number,
    /** A color of text on the buttons in the RGB format */
    readonly button_text_color?: number,
  }

  export type webAppOpenModeCompact = {
    /** The Web App is opened in the compact mode */
    _: 'webAppOpenModeCompact',
  }

  export type webAppOpenModeCompact$Input = {
    /** The Web App is opened in the compact mode */
    readonly _: 'webAppOpenModeCompact',
  }

  export type webAppOpenModeFullSize = {
    /** The Web App is opened in the full-size mode */
    _: 'webAppOpenModeFullSize',
  }

  export type webAppOpenModeFullSize$Input = {
    /** The Web App is opened in the full-size mode */
    readonly _: 'webAppOpenModeFullSize',
  }

  export type webAppOpenModeFullScreen = {
    /** The Web App is opened in the full-screen mode */
    _: 'webAppOpenModeFullScreen',
  }

  export type webAppOpenModeFullScreen$Input = {
    /** The Web App is opened in the full-screen mode */
    readonly _: 'webAppOpenModeFullScreen',
  }

  export type foundWebApp = {
    /** Contains information about a Web App found by its short name */
    _: 'foundWebApp',
    /** The Web App */
    web_app: webApp,
    /** True, if the user must be asked for the permission to the bot to send them messages */
    request_write_access: boolean,
    /**
     * True, if there is no need to show an ordinary open URL confirmation before opening
     * the Web App. The field must be ignored and confirmation must be shown anyway
     * if the Web App link was hidden
     */
    skip_confirmation: boolean,
  }

  export type webAppInfo = {
    /** Contains information about a Web App */
    _: 'webAppInfo',
    /** Unique identifier for the Web App launch */
    launch_id: string,
    /** A Web App URL to open in a web view */
    url: string,
  }

  export type mainWebApp = {
    /** Contains information about the main Web App of a bot */
    _: 'mainWebApp',
    /** URL of the Web App to open */
    url: string,
    /** The mode in which the Web App must be opened */
    mode: WebAppOpenMode,
  }

  export type webAppOpenParameters$Input = {
    /** Options to be used when a Web App is opened */
    readonly _: 'webAppOpenParameters',
    /** Preferred Web App theme; pass null to use the default theme */
    readonly theme?: themeParameters$Input,
    /** Short name of the current application; 0-64 English letters, digits, and underscores */
    readonly application_name?: string,
    /** The mode in which the Web App is opened; pass null to open in webAppOpenModeFullSize */
    readonly mode?: WebAppOpenMode$Input,
  }

  export type messageThreadInfo = {
    /** Contains information about a message thread */
    _: 'messageThreadInfo',
    /** Identifier of the chat to which the message thread belongs */
    chat_id: number,
    /** Message thread identifier, unique within the chat */
    message_thread_id: number,
    /** Information about the message thread; may be null for forum topic threads */
    reply_info?: messageReplyInfo,
    /** Approximate number of unread messages in the message thread */
    unread_message_count: number,
    /**
     * The messages from which the thread starts. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    messages: Array<message>,
    /** A draft of a message in the message thread; may be null if none */
    draft_message?: draftMessage,
  }

  export type savedMessagesTopicTypeMyNotes = {
    /**
     * Topic containing messages sent by the current user of forwarded from an unknown
     * chat
     */
    _: 'savedMessagesTopicTypeMyNotes',
  }

  export type savedMessagesTopicTypeAuthorHidden = {
    /** Topic containing messages forwarded from a user with hidden privacy */
    _: 'savedMessagesTopicTypeAuthorHidden',
  }

  export type savedMessagesTopicTypeSavedFromChat = {
    /** Topic containing messages forwarded from a specific chat */
    _: 'savedMessagesTopicTypeSavedFromChat',
    /** Identifier of the chat */
    chat_id: number,
  }

  export type savedMessagesTopic = {
    /** Contains information about a Saved Messages topic */
    _: 'savedMessagesTopic',
    /** Unique topic identifier */
    id: number,
    /** Type of the topic */
    type: SavedMessagesTopicType,
    /** True, if the topic is pinned */
    is_pinned: boolean,
    /**
     * A parameter used to determine order of the topic in the topic list. Topics must
     * be sorted by the order in descending order
     */
    order: string,
    /** Last message in the topic; may be null if none or unknown */
    last_message?: message,
    /** A draft of a message in the topic; may be null if none */
    draft_message?: draftMessage,
  }

  export type directMessagesChatTopic = {
    /**
     * Contains information about a topic in a channel direct messages chat administered
     * by the current user
     */
    _: 'directMessagesChatTopic',
    /** Identifier of the chat to which the topic belongs */
    chat_id: number,
    /** Unique topic identifier */
    id: number,
    /** Identifier of the user or chat that sends the messages to the topic */
    sender_id: MessageSender,
    /**
     * A parameter used to determine order of the topic in the topic list. Topics must
     * be sorted by the order in descending order
     */
    order: string,
    /**
     * True, if the other party can send unpaid messages even if the chat has paid
     * messages enabled
     */
    can_send_unpaid_messages: boolean,
    /** True, if the forum topic is marked as unread */
    is_marked_as_unread: boolean,
    /** Number of unread messages in the chat */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of messages with unread reactions in the chat */
    unread_reaction_count: number,
    /** Last message in the topic; may be null if none or unknown */
    last_message?: message,
    /** A draft of a message in the topic; may be null if none */
    draft_message?: draftMessage,
  }

  export type forumTopicIcon = {
    /** Describes a forum topic icon */
    _: 'forumTopicIcon',
    /** Color of the topic icon in RGB format */
    color: number,
    /** Unique identifier of the custom emoji shown on the topic icon; 0 if none */
    custom_emoji_id: string,
  }

  export type forumTopicIcon$Input = {
    /** Describes a forum topic icon */
    readonly _: 'forumTopicIcon',
    /** Color of the topic icon in RGB format */
    readonly color?: number,
    /** Unique identifier of the custom emoji shown on the topic icon; 0 if none */
    readonly custom_emoji_id?: number | string,
  }

  export type forumTopicInfo = {
    /** Contains basic information about a forum topic */
    _: 'forumTopicInfo',
    /** Identifier of the forum chat to which the topic belongs */
    chat_id: number,
    /** Forum topic identifier of the topic */
    forum_topic_id: number,
    /** Message thread identifier of the topic */
    message_thread_id: number,
    /** Name of the topic */
    name: string,
    /** Icon of the topic */
    icon: forumTopicIcon,
    /** Point in time (Unix timestamp) when the topic was created */
    creation_date: number,
    /** Identifier of the creator of the topic */
    creator_id: MessageSender,
    /** True, if the topic is the General topic list */
    is_general: boolean,
    /** True, if the topic was created by the current user */
    is_outgoing: boolean,
    /** True, if the topic is closed */
    is_closed: boolean,
    /**
     * True, if the topic is hidden above the topic list and closed; for General topic
     * only
     */
    is_hidden: boolean,
  }

  export type forumTopic = {
    /** Describes a forum topic */
    _: 'forumTopic',
    /** Basic information about the topic */
    info: forumTopicInfo,
    /** Last message in the topic; may be null if unknown */
    last_message?: message,
    /**
     * A parameter used to determine order of the topic in the topic list. Topics must
     * be sorted by the order in descending order
     */
    order: string,
    /** True, if the topic is pinned in the topic list */
    is_pinned: boolean,
    /** Number of unread messages in the topic */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the topic */
    unread_mention_count: number,
    /** Number of messages with unread reactions in the topic */
    unread_reaction_count: number,
    /** Notification settings for the topic */
    notification_settings: chatNotificationSettings,
    /** A draft of a message in the topic; may be null if none */
    draft_message?: draftMessage,
  }

  export type forumTopics = {
    /** Describes a list of forum topics */
    _: 'forumTopics',
    /** Approximate total number of forum topics found */
    total_count: number,
    /** List of forum topics */
    topics: Array<forumTopic>,
    /** Offset date for the next getForumTopics request */
    next_offset_date: number,
    /** Offset message identifier for the next getForumTopics request */
    next_offset_message_id: number,
    /** Offset message thread identifier for the next getForumTopics request */
    next_offset_message_thread_id: number,
  }

  export type linkPreviewOptions = {
    /** Options to be used for generation of a link preview */
    _: 'linkPreviewOptions',
    /** True, if link preview must be disabled */
    is_disabled: boolean,
    /**
     * URL to use for link preview. If empty, then the first URL found in the message
     * text will be used
     */
    url: string,
    /**
     * True, if shown media preview must be small; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    force_small_media: boolean,
    /**
     * True, if shown media preview must be large; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    force_large_media: boolean,
    /**
     * True, if link preview must be shown above message text; otherwise, the link
     * preview will be shown below the message text; ignored in secret chats
     */
    show_above_text: boolean,
  }

  export type linkPreviewOptions$Input = {
    /** Options to be used for generation of a link preview */
    readonly _: 'linkPreviewOptions',
    /** True, if link preview must be disabled */
    readonly is_disabled?: boolean,
    /**
     * URL to use for link preview. If empty, then the first URL found in the message
     * text will be used
     */
    readonly url?: string,
    /**
     * True, if shown media preview must be small; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    readonly force_small_media?: boolean,
    /**
     * True, if shown media preview must be large; ignored in secret chats or if the
     * URL isn't explicitly specified
     */
    readonly force_large_media?: boolean,
    /**
     * True, if link preview must be shown above message text; otherwise, the link
     * preview will be shown below the message text; ignored in secret chats
     */
    readonly show_above_text?: boolean,
  }

  export type sharedUser = {
    /** Contains information about a user shared with a bot */
    _: 'sharedUser',
    /** User identifier */
    user_id: number,
    /** First name of the user; for bots only */
    first_name: string,
    /** Last name of the user; for bots only */
    last_name: string,
    /** Username of the user; for bots only */
    username: string,
    /** Profile photo of the user; for bots only; may be null */
    photo?: photo,
  }

  export type sharedChat = {
    /** Contains information about a chat shared with a bot */
    _: 'sharedChat',
    /** Chat identifier */
    chat_id: number,
    /** Title of the chat; for bots only */
    title: string,
    /** Username of the chat; for bots only */
    username: string,
    /** Photo of the chat; for bots only; may be null */
    photo?: photo,
  }

  export type themeSettings = {
    /** Describes theme settings */
    _: 'themeSettings',
    /** Theme accent color in ARGB format */
    accent_color: number,
    /** The background to be used in chats; may be null */
    background?: background,
    /** The fill to be used as a background for outgoing messages */
    outgoing_message_fill: BackgroundFill,
    /** If true, the freeform gradient fill needs to be animated on every sent message */
    animate_outgoing_message_fill: boolean,
    /** Accent color of outgoing messages in ARGB format */
    outgoing_message_accent_color: number,
  }

  export type richTextPlain = {
    /** A plain text */
    _: 'richTextPlain',
    /** Text */
    text: string,
  }

  export type richTextBold = {
    /** A bold rich text */
    _: 'richTextBold',
    /** Text */
    text: RichText,
  }

  export type richTextItalic = {
    /** An italicized rich text */
    _: 'richTextItalic',
    /** Text */
    text: RichText,
  }

  export type richTextUnderline = {
    /** An underlined rich text */
    _: 'richTextUnderline',
    /** Text */
    text: RichText,
  }

  export type richTextStrikethrough = {
    /** A strikethrough rich text */
    _: 'richTextStrikethrough',
    /** Text */
    text: RichText,
  }

  export type richTextFixed = {
    /** A fixed-width rich text */
    _: 'richTextFixed',
    /** Text */
    text: RichText,
  }

  export type richTextUrl = {
    /** A rich text URL link */
    _: 'richTextUrl',
    /** Text */
    text: RichText,
    /** URL */
    url: string,
    /** True, if the URL has cached instant view server-side */
    is_cached: boolean,
  }

  export type richTextEmailAddress = {
    /** A rich text email link */
    _: 'richTextEmailAddress',
    /** Text */
    text: RichText,
    /** Email address */
    email_address: string,
  }

  export type richTextSubscript = {
    /** A subscript rich text */
    _: 'richTextSubscript',
    /** Text */
    text: RichText,
  }

  export type richTextSuperscript = {
    /** A superscript rich text */
    _: 'richTextSuperscript',
    /** Text */
    text: RichText,
  }

  export type richTextMarked = {
    /** A marked rich text */
    _: 'richTextMarked',
    /** Text */
    text: RichText,
  }

  export type richTextPhoneNumber = {
    /** A rich text phone number */
    _: 'richTextPhoneNumber',
    /** Text */
    text: RichText,
    /** Phone number */
    phone_number: string,
  }

  export type richTextIcon = {
    /** A small image inside the text */
    _: 'richTextIcon',
    /** The image represented as a document. The image can be in GIF, JPEG or PNG format */
    document: document,
    /** Width of a bounding box in which the image must be shown; 0 if unknown */
    width: number,
    /** Height of a bounding box in which the image must be shown; 0 if unknown */
    height: number,
  }

  export type richTextReference = {
    /** A reference to a richTexts object on the same page */
    _: 'richTextReference',
    /** The text */
    text: RichText,
    /**
     * The name of a richTextAnchor object, which is the first element of the target
     * richTexts object
     */
    anchor_name: string,
    /** An HTTP URL, opening the reference */
    url: string,
  }

  export type richTextAnchor = {
    /** An anchor */
    _: 'richTextAnchor',
    /** Anchor name */
    name: string,
  }

  export type richTextAnchorLink = {
    /** A link to an anchor on the same page */
    _: 'richTextAnchorLink',
    /** The link text */
    text: RichText,
    /** The anchor name. If the name is empty, the link must bring back to top */
    anchor_name: string,
    /** An HTTP URL, opening the anchor */
    url: string,
  }

  export type richTexts = {
    /** A concatenation of rich texts */
    _: 'richTexts',
    /** Texts */
    texts: Array<RichText>,
  }

  export type pageBlockCaption = {
    /** Contains a caption of another block */
    _: 'pageBlockCaption',
    /** Content of the caption */
    text: RichText,
    /** Block credit (like HTML tag <cite>) */
    credit: RichText,
  }

  export type pageBlockListItem = {
    /** Describes an item of a list page block */
    _: 'pageBlockListItem',
    /** Item label */
    label: string,
    /** Item blocks */
    page_blocks: Array<PageBlock>,
  }

  export type pageBlockHorizontalAlignmentLeft = {
    /** The content must be left-aligned */
    _: 'pageBlockHorizontalAlignmentLeft',
  }

  export type pageBlockHorizontalAlignmentCenter = {
    /** The content must be center-aligned */
    _: 'pageBlockHorizontalAlignmentCenter',
  }

  export type pageBlockHorizontalAlignmentRight = {
    /** The content must be right-aligned */
    _: 'pageBlockHorizontalAlignmentRight',
  }

  export type pageBlockVerticalAlignmentTop = {
    /** The content must be top-aligned */
    _: 'pageBlockVerticalAlignmentTop',
  }

  export type pageBlockVerticalAlignmentMiddle = {
    /** The content must be middle-aligned */
    _: 'pageBlockVerticalAlignmentMiddle',
  }

  export type pageBlockVerticalAlignmentBottom = {
    /** The content must be bottom-aligned */
    _: 'pageBlockVerticalAlignmentBottom',
  }

  export type pageBlockTableCell = {
    /** Represents a cell of a table */
    _: 'pageBlockTableCell',
    /** Cell text; may be null. If the text is null, then the cell must be invisible */
    text?: RichText,
    /** True, if it is a header cell */
    is_header: boolean,
    /** The number of columns the cell spans */
    colspan: number,
    /** The number of rows the cell spans */
    rowspan: number,
    /** Horizontal cell content alignment */
    align: PageBlockHorizontalAlignment,
    /** Vertical cell content alignment */
    valign: PageBlockVerticalAlignment,
  }

  export type pageBlockRelatedArticle = {
    /** Contains information about a related article */
    _: 'pageBlockRelatedArticle',
    /** Related article URL */
    url: string,
    /** Article title; may be empty */
    title: string,
    /** Article description; may be empty */
    description: string,
    /** Article photo; may be null */
    photo?: photo,
    /** Article author; may be empty */
    author: string,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  }

  export type pageBlockTitle = {
    /** The title of a page */
    _: 'pageBlockTitle',
    /** Title */
    title: RichText,
  }

  export type pageBlockSubtitle = {
    /** The subtitle of a page */
    _: 'pageBlockSubtitle',
    /** Subtitle */
    subtitle: RichText,
  }

  export type pageBlockAuthorDate = {
    /** The author and publishing date of a page */
    _: 'pageBlockAuthorDate',
    /** Author */
    author: RichText,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  }

  export type pageBlockHeader = {
    /** A header */
    _: 'pageBlockHeader',
    /** Header */
    header: RichText,
  }

  export type pageBlockSubheader = {
    /** A subheader */
    _: 'pageBlockSubheader',
    /** Subheader */
    subheader: RichText,
  }

  export type pageBlockKicker = {
    /** A kicker */
    _: 'pageBlockKicker',
    /** Kicker */
    kicker: RichText,
  }

  export type pageBlockParagraph = {
    /** A text paragraph */
    _: 'pageBlockParagraph',
    /** Paragraph text */
    text: RichText,
  }

  export type pageBlockPreformatted = {
    /** A preformatted text paragraph */
    _: 'pageBlockPreformatted',
    /** Paragraph text */
    text: RichText,
    /** Programming language for which the text needs to be formatted */
    language: string,
  }

  export type pageBlockFooter = {
    /** The footer of a page */
    _: 'pageBlockFooter',
    /** Footer */
    footer: RichText,
  }

  export type pageBlockDivider = {
    /** An empty block separating a page */
    _: 'pageBlockDivider',
  }

  export type pageBlockAnchor = {
    /**
     * An invisible anchor on a page, which can be used in a URL to open the page from
     * the specified anchor
     */
    _: 'pageBlockAnchor',
    /** Name of the anchor */
    name: string,
  }

  export type pageBlockList = {
    /** A list of data blocks */
    _: 'pageBlockList',
    /** The items of the list */
    items: Array<pageBlockListItem>,
  }

  export type pageBlockBlockQuote = {
    /** A block quote */
    _: 'pageBlockBlockQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  }

  export type pageBlockPullQuote = {
    /** A pull quote */
    _: 'pageBlockPullQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  }

  export type pageBlockAnimation = {
    /** An animation */
    _: 'pageBlockAnimation',
    /** Animation file; may be null */
    animation?: animation,
    /** Animation caption */
    caption: pageBlockCaption,
    /** True, if the animation must be played automatically */
    need_autoplay: boolean,
  }

  export type pageBlockAudio = {
    /** An audio file */
    _: 'pageBlockAudio',
    /** Audio file; may be null */
    audio?: audio,
    /** Audio file caption */
    caption: pageBlockCaption,
  }

  export type pageBlockPhoto = {
    /** A photo */
    _: 'pageBlockPhoto',
    /** Photo file; may be null */
    photo?: photo,
    /** Photo caption */
    caption: pageBlockCaption,
    /** URL that needs to be opened when the photo is clicked */
    url: string,
  }

  export type pageBlockVideo = {
    /** A video */
    _: 'pageBlockVideo',
    /** Video file; may be null */
    video?: video,
    /** Video caption */
    caption: pageBlockCaption,
    /** True, if the video must be played automatically */
    need_autoplay: boolean,
    /** True, if the video must be looped */
    is_looped: boolean,
  }

  export type pageBlockVoiceNote = {
    /** A voice note */
    _: 'pageBlockVoiceNote',
    /** Voice note; may be null */
    voice_note?: voiceNote,
    /** Voice note caption */
    caption: pageBlockCaption,
  }

  export type pageBlockCover = {
    /** A page cover */
    _: 'pageBlockCover',
    /** Cover */
    cover: PageBlock,
  }

  export type pageBlockEmbedded = {
    /** An embedded web page */
    _: 'pageBlockEmbedded',
    /** URL of the embedded page, if available */
    url: string,
    /** HTML-markup of the embedded page */
    html: string,
    /** Poster photo, if available; may be null */
    poster_photo?: photo,
    /** Block width; 0 if unknown */
    width: number,
    /** Block height; 0 if unknown */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
    /** True, if the block must be full width */
    is_full_width: boolean,
    /** True, if scrolling needs to be allowed */
    allow_scrolling: boolean,
  }

  export type pageBlockEmbeddedPost = {
    /** An embedded post */
    _: 'pageBlockEmbeddedPost',
    /** URL of the embedded post */
    url: string,
    /** Post author */
    author: string,
    /** Post author photo; may be null */
    author_photo?: photo,
    /** Point in time (Unix timestamp) when the post was created; 0 if unknown */
    date: number,
    /** Post content */
    page_blocks: Array<PageBlock>,
    /** Post caption */
    caption: pageBlockCaption,
  }

  export type pageBlockCollage = {
    /** A collage */
    _: 'pageBlockCollage',
    /** Collage item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type pageBlockSlideshow = {
    /** A slideshow */
    _: 'pageBlockSlideshow',
    /** Slideshow item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type pageBlockChatLink = {
    /** A link to a chat */
    _: 'pageBlockChatLink',
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Identifier of the accent color for chat title and background of chat photo */
    accent_color_id: number,
    /** Chat username by which all other information about the chat can be resolved */
    username: string,
  }

  export type pageBlockTable = {
    /** A table */
    _: 'pageBlockTable',
    /** Table caption */
    caption: RichText,
    /** Table cells */
    cells: Array<Array<pageBlockTableCell>>,
    /** True, if the table is bordered */
    is_bordered: boolean,
    /** True, if the table is striped */
    is_striped: boolean,
  }

  export type pageBlockDetails = {
    /** A collapsible block */
    _: 'pageBlockDetails',
    /** Always visible heading for the block */
    header: RichText,
    /** Block contents */
    page_blocks: Array<PageBlock>,
    /** True, if the block is open by default */
    is_open: boolean,
  }

  export type pageBlockRelatedArticles = {
    /** Related articles */
    _: 'pageBlockRelatedArticles',
    /** Block header */
    header: RichText,
    /** List of related articles */
    articles: Array<pageBlockRelatedArticle>,
  }

  export type pageBlockMap = {
    /** A map */
    _: 'pageBlockMap',
    /** Location of the map center */
    location: location,
    /** Map zoom level */
    zoom: number,
    /** Map width */
    width: number,
    /** Map height */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type webPageInstantView = {
    /** Describes an instant view page for a web page */
    _: 'webPageInstantView',
    /** Content of the instant view page */
    page_blocks: Array<PageBlock>,
    /** Number of the instant view views; 0 if unknown */
    view_count: number,
    /** Version of the instant view; currently, can be 1 or 2 */
    version: number,
    /** True, if the instant view must be shown from right to left */
    is_rtl: boolean,
    /**
     * True, if the instant view contains the full page. A network request might be
     * needed to get the full instant view
     */
    is_full: boolean,
    /** An internal link to be opened to leave feedback about the instant view */
    feedback_link: InternalLinkType,
  }

  export type linkPreviewAlbumMediaPhoto = {
    /** The media is a photo */
    _: 'linkPreviewAlbumMediaPhoto',
    /** Photo description */
    photo: photo,
  }

  export type linkPreviewAlbumMediaVideo = {
    /** The media is a video */
    _: 'linkPreviewAlbumMediaVideo',
    /** Video description */
    video: video,
  }

  export type linkPreviewTypeAlbum = {
    /** The link is a link to a media album consisting of photos and videos */
    _: 'linkPreviewTypeAlbum',
    /** The list of album media */
    media: Array<LinkPreviewAlbumMedia>,
    /** Album caption */
    caption: string,
  }

  export type linkPreviewTypeAnimation = {
    /** The link is a link to an animation */
    _: 'linkPreviewTypeAnimation',
    /** The animation */
    animation: animation,
  }

  export type linkPreviewTypeApp = {
    /** The link is a link to an app at App Store or Google Play */
    _: 'linkPreviewTypeApp',
    /** Photo for the app */
    photo: photo,
  }

  export type linkPreviewTypeArticle = {
    /** The link is a link to a web site */
    _: 'linkPreviewTypeArticle',
    /** Article's main photo; may be null */
    photo?: photo,
  }

  export type linkPreviewTypeAudio = {
    /** The link is a link to an audio */
    _: 'linkPreviewTypeAudio',
    /** The audio description */
    audio: audio,
  }

  export type linkPreviewTypeBackground = {
    /**
     * The link is a link to a background. Link preview title and description are available
     * only for filled backgrounds
     */
    _: 'linkPreviewTypeBackground',
    /** Document with the background; may be null for filled backgrounds */
    document?: document,
    /** Type of the background; may be null if unknown */
    background_type?: BackgroundType,
  }

  export type linkPreviewTypeChannelBoost = {
    /** The link is a link to boost a channel chat */
    _: 'linkPreviewTypeChannelBoost',
    /** Photo of the chat; may be null */
    photo?: chatPhoto,
  }

  export type linkPreviewTypeChat = {
    /** The link is a link to a chat */
    _: 'linkPreviewTypeChat',
    /** Type of the chat */
    type: InviteLinkChatType,
    /** Photo of the chat; may be null */
    photo?: chatPhoto,
    /** True, if the link only creates join request */
    creates_join_request: boolean,
  }

  export type linkPreviewTypeDocument = {
    /** The link is a link to a general file */
    _: 'linkPreviewTypeDocument',
    /** The document description */
    document: document,
  }

  export type linkPreviewTypeEmbeddedAnimationPlayer = {
    /** The link is a link to an animation player */
    _: 'linkPreviewTypeEmbeddedAnimationPlayer',
    /** URL of the external animation player */
    url: string,
    /** Thumbnail of the animation; may be null if unknown */
    thumbnail?: photo,
    /** Duration of the animation, in seconds */
    duration: number,
    /** Expected width of the embedded player */
    width: number,
    /** Expected height of the embedded player */
    height: number,
  }

  export type linkPreviewTypeEmbeddedAudioPlayer = {
    /** The link is a link to an audio player */
    _: 'linkPreviewTypeEmbeddedAudioPlayer',
    /** URL of the external audio player */
    url: string,
    /** Thumbnail of the audio; may be null if unknown */
    thumbnail?: photo,
    /** Duration of the audio, in seconds */
    duration: number,
    /** Expected width of the embedded player */
    width: number,
    /** Expected height of the embedded player */
    height: number,
  }

  export type linkPreviewTypeEmbeddedVideoPlayer = {
    /** The link is a link to a video player */
    _: 'linkPreviewTypeEmbeddedVideoPlayer',
    /** URL of the external video player */
    url: string,
    /** Thumbnail of the video; may be null if unknown */
    thumbnail?: photo,
    /** Duration of the video, in seconds */
    duration: number,
    /** Expected width of the embedded player */
    width: number,
    /** Expected height of the embedded player */
    height: number,
  }

  export type linkPreviewTypeExternalAudio = {
    /** The link is a link to an audio file */
    _: 'linkPreviewTypeExternalAudio',
    /** URL of the audio file */
    url: string,
    /** MIME type of the audio file */
    mime_type: string,
    /** Duration of the audio, in seconds; 0 if unknown */
    duration: number,
  }

  export type linkPreviewTypeExternalVideo = {
    /** The link is a link to a video file */
    _: 'linkPreviewTypeExternalVideo',
    /** URL of the video file */
    url: string,
    /** MIME type of the video file */
    mime_type: string,
    /** Expected width of the video preview; 0 if unknown */
    width: number,
    /** Expected height of the video preview; 0 if unknown */
    height: number,
    /** Duration of the video, in seconds; 0 if unknown */
    duration: number,
  }

  export type linkPreviewTypeGroupCall = {
    /** The link is a link to a group call that isn't bound to a chat */
    _: 'linkPreviewTypeGroupCall',
  }

  export type linkPreviewTypeInvoice = {
    /** The link is a link to an invoice */
    _: 'linkPreviewTypeInvoice',
  }

  export type linkPreviewTypeMessage = {
    /** The link is a link to a text or a poll Telegram message */
    _: 'linkPreviewTypeMessage',
  }

  export type linkPreviewTypePhoto = {
    /** The link is a link to a photo */
    _: 'linkPreviewTypePhoto',
    /** The photo */
    photo: photo,
  }

  export type linkPreviewTypePremiumGiftCode = {
    /** The link is a link to a Telegram Premium gift code */
    _: 'linkPreviewTypePremiumGiftCode',
  }

  export type linkPreviewTypeShareableChatFolder = {
    /** The link is a link to a shareable chat folder */
    _: 'linkPreviewTypeShareableChatFolder',
  }

  export type linkPreviewTypeSticker = {
    /** The link is a link to a sticker */
    _: 'linkPreviewTypeSticker',
    /**
     * The sticker. It can be an arbitrary WEBP image and can have dimensions bigger
     * than 512
     */
    sticker: sticker,
  }

  export type linkPreviewTypeStickerSet = {
    /** The link is a link to a sticker set */
    _: 'linkPreviewTypeStickerSet',
    /** Up to 4 stickers from the sticker set */
    stickers: Array<sticker>,
  }

  export type linkPreviewTypeStory = {
    /** The link is a link to a story. Link preview description is unavailable */
    _: 'linkPreviewTypeStory',
    /** The identifier of the chat that posted the story */
    story_poster_chat_id: number,
    /** Story identifier */
    story_id: number,
  }

  export type linkPreviewTypeSupergroupBoost = {
    /** The link is a link to boost a supergroup chat */
    _: 'linkPreviewTypeSupergroupBoost',
    /** Photo of the chat; may be null */
    photo?: chatPhoto,
  }

  export type linkPreviewTypeTheme = {
    /** The link is a link to a cloud theme. TDLib has no theme support yet */
    _: 'linkPreviewTypeTheme',
    /** The list of files with theme description */
    documents: Array<document>,
    /** Settings for the cloud theme; may be null if unknown */
    settings?: themeSettings,
  }

  export type linkPreviewTypeUnsupported = {
    /** The link preview type is unsupported yet */
    _: 'linkPreviewTypeUnsupported',
  }

  export type linkPreviewTypeUpgradedGift = {
    /** The link is a link to an upgraded gift */
    _: 'linkPreviewTypeUpgradedGift',
    /** The gift */
    gift: upgradedGift,
  }

  export type linkPreviewTypeUser = {
    /** The link is a link to a user */
    _: 'linkPreviewTypeUser',
    /** Photo of the user; may be null if none */
    photo?: chatPhoto,
    /** True, if the user is a bot */
    is_bot: boolean,
  }

  export type linkPreviewTypeVideo = {
    /** The link is a link to a video */
    _: 'linkPreviewTypeVideo',
    /** The video description */
    video: video,
    /** Cover of the video; may be null if none */
    cover?: photo,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
  }

  export type linkPreviewTypeVideoChat = {
    /** The link is a link to a video chat */
    _: 'linkPreviewTypeVideoChat',
    /** Photo of the chat with the video chat; may be null if none */
    photo?: chatPhoto,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    is_live_stream: boolean,
  }

  export type linkPreviewTypeVideoNote = {
    /** The link is a link to a video note message */
    _: 'linkPreviewTypeVideoNote',
    /** The video note */
    video_note: videoNote,
  }

  export type linkPreviewTypeVoiceNote = {
    /** The link is a link to a voice note message */
    _: 'linkPreviewTypeVoiceNote',
    /** The voice note */
    voice_note: voiceNote,
  }

  export type linkPreviewTypeWebApp = {
    /** The link is a link to a Web App */
    _: 'linkPreviewTypeWebApp',
    /** Web App photo; may be null if none */
    photo?: photo,
  }

  export type linkPreview = {
    /** Describes a link preview */
    _: 'linkPreview',
    /** Original URL of the link */
    url: string,
    /** URL to display */
    display_url: string,
    /** Short name of the site (e.g., Google Docs, App Store) */
    site_name: string,
    /** Title of the content */
    title: string,
    /** Description of the content */
    description: formattedText,
    /** Author of the content */
    author: string,
    /** Type of the link preview */
    type: LinkPreviewType,
    /** True, if size of media in the preview can be changed */
    has_large_media: boolean,
    /**
     * True, if large media preview must be shown; otherwise, the media preview must
     * be shown small and only the first frame must be shown for videos
     */
    show_large_media: boolean,
    /**
     * True, if media must be shown above link preview description; otherwise, the
     * media must be shown below the description
     */
    show_media_above_description: boolean,
    /**
     * True, if there is no need to show an ordinary open URL confirmation, when opening
     * the URL from the preview, because the URL is shown in the message text in clear
     */
    skip_confirmation: boolean,
    /**
     * True, if the link preview must be shown above message text; otherwise, the link
     * preview must be shown below the message text
     */
    show_above_text: boolean,
    /** Version of instant view (currently, can be 1 or 2) for the web page; 0 if none */
    instant_view_version: number,
  }

  export type countryInfo = {
    /** Contains information about a country */
    _: 'countryInfo',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** Native name of the country */
    name: string,
    /** English name of the country */
    english_name: string,
    /** True, if the country must be hidden from the list of all countries */
    is_hidden: boolean,
    /** List of country calling codes */
    calling_codes: Array<string>,
  }

  export type countries = {
    /** Contains information about countries */
    _: 'countries',
    /** The list of countries */
    countries: Array<countryInfo>,
  }

  export type phoneNumberInfo = {
    /** Contains information about a phone number */
    _: 'phoneNumberInfo',
    /** Information about the country to which the phone number belongs; may be null */
    country?: countryInfo,
    /** The part of the phone number denoting country calling code or its part */
    country_calling_code: string,
    /**
     * The phone number without country calling code formatted accordingly to local
     * rules. Expected digits are returned as '-', but even more digits might be entered
     * by the user
     */
    formatted_phone_number: string,
    /**
     * True, if the phone number was bought at https://fragment.com and isn't tied
     * to a SIM card. Information about the phone number can be received using getCollectibleItemInfo
     */
    is_anonymous: boolean,
  }

  export type collectibleItemTypeUsername$Input = {
    /** A username */
    readonly _: 'collectibleItemTypeUsername',
    /** The username */
    readonly username?: string,
  }

  export type collectibleItemTypePhoneNumber$Input = {
    /** A phone number */
    readonly _: 'collectibleItemTypePhoneNumber',
    /** The phone number */
    readonly phone_number?: string,
  }

  export type collectibleItemInfo = {
    /** Contains information about a collectible item and its last purchase */
    _: 'collectibleItemInfo',
    /** Point in time (Unix timestamp) when the item was purchased */
    purchase_date: number,
    /** Currency for the paid amount */
    currency: string,
    /** The paid amount, in the smallest units of the currency */
    amount: number,
    /** Cryptocurrency used to pay for the item */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency */
    cryptocurrency_amount: string,
    /** Individual URL for the item on https://fragment.com */
    url: string,
  }

  export type bankCardActionOpenUrl = {
    /** Describes an action associated with a bank card number */
    _: 'bankCardActionOpenUrl',
    /** Action text */
    text: string,
    /** The URL to be opened */
    url: string,
  }

  export type bankCardInfo = {
    /** Information about a bank card */
    _: 'bankCardInfo',
    /** Title of the bank card description */
    title: string,
    /** Actions that can be done with the bank card number */
    actions: Array<bankCardActionOpenUrl>,
  }

  export type address = {
    /** Describes an address */
    _: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** State, if applicable */
    state: string,
    /** City */
    city: string,
    /** First line of the address */
    street_line1: string,
    /** Second line of the address */
    street_line2: string,
    /** Address postal code */
    postal_code: string,
  }

  export type address$Input = {
    /** Describes an address */
    readonly _: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    readonly country_code?: string,
    /** State, if applicable */
    readonly state?: string,
    /** City */
    readonly city?: string,
    /** First line of the address */
    readonly street_line1?: string,
    /** Second line of the address */
    readonly street_line2?: string,
    /** Address postal code */
    readonly postal_code?: string,
  }

  export type locationAddress = {
    /** Describes an address of a location */
    _: 'locationAddress',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** State, if applicable; empty if unknown */
    state: string,
    /** City; empty if unknown */
    city: string,
    /** The address; empty if unknown */
    street: string,
  }

  export type locationAddress$Input = {
    /** Describes an address of a location */
    readonly _: 'locationAddress',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    readonly country_code?: string,
    /** State, if applicable; empty if unknown */
    readonly state?: string,
    /** City; empty if unknown */
    readonly city?: string,
    /** The address; empty if unknown */
    readonly street?: string,
  }

  export type labeledPricePart = {
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    _: 'labeledPricePart',
    /** Label for this portion of the product price */
    label: string,
    /** Currency amount in the smallest units of the currency */
    amount: number,
  }

  export type labeledPricePart$Input = {
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    readonly _: 'labeledPricePart',
    /** Label for this portion of the product price */
    readonly label?: string,
    /** Currency amount in the smallest units of the currency */
    readonly amount?: number,
  }

  export type invoice = {
    /** Product invoice */
    _: 'invoice',
    /** ISO 4217 currency code */
    currency: string,
    /** A list of objects used to calculate the total price of the product */
    price_parts: Array<labeledPricePart>,
    /**
     * The number of seconds between consecutive Telegram Star debiting for subscription
     * invoices; 0 if the invoice doesn't create subscription
     */
    subscription_period: number,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    max_tip_amount: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    suggested_tip_amounts: Array<number>,
    /**
     * An HTTP URL with terms of service for recurring payments. If non-empty, the
     * invoice payment will result in recurring payments and the user must accept the
     * terms of service before allowed to pay
     */
    recurring_payment_terms_of_service_url: string,
    /**
     * An HTTP URL with terms of service for non-recurring payments. If non-empty,
     * then the user must accept the terms of service before allowed to pay
     */
    terms_of_service_url: string,
    /** True, if the payment is a test payment */
    is_test: boolean,
    /** True, if the user's name is needed for payment */
    need_name: boolean,
    /** True, if the user's phone number is needed for payment */
    need_phone_number: boolean,
    /** True, if the user's email address is needed for payment */
    need_email_address: boolean,
    /** True, if the user's shipping address is needed for payment */
    need_shipping_address: boolean,
    /** True, if the user's phone number will be sent to the provider */
    send_phone_number_to_provider: boolean,
    /** True, if the user's email address will be sent to the provider */
    send_email_address_to_provider: boolean,
    /** True, if the total price depends on the shipping method */
    is_flexible: boolean,
  }

  export type invoice$Input = {
    /** Product invoice */
    readonly _: 'invoice',
    /** ISO 4217 currency code */
    readonly currency?: string,
    /** A list of objects used to calculate the total price of the product */
    readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
    /**
     * The number of seconds between consecutive Telegram Star debiting for subscription
     * invoices; 0 if the invoice doesn't create subscription
     */
    readonly subscription_period?: number,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    readonly max_tip_amount?: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    readonly suggested_tip_amounts?: ReadonlyArray<number>,
    /**
     * An HTTP URL with terms of service for recurring payments. If non-empty, the
     * invoice payment will result in recurring payments and the user must accept the
     * terms of service before allowed to pay
     */
    readonly recurring_payment_terms_of_service_url?: string,
    /**
     * An HTTP URL with terms of service for non-recurring payments. If non-empty,
     * then the user must accept the terms of service before allowed to pay
     */
    readonly terms_of_service_url?: string,
    /** True, if the payment is a test payment */
    readonly is_test?: boolean,
    /** True, if the user's name is needed for payment */
    readonly need_name?: boolean,
    /** True, if the user's phone number is needed for payment */
    readonly need_phone_number?: boolean,
    /** True, if the user's email address is needed for payment */
    readonly need_email_address?: boolean,
    /** True, if the user's shipping address is needed for payment */
    readonly need_shipping_address?: boolean,
    /** True, if the user's phone number will be sent to the provider */
    readonly send_phone_number_to_provider?: boolean,
    /** True, if the user's email address will be sent to the provider */
    readonly send_email_address_to_provider?: boolean,
    /** True, if the total price depends on the shipping method */
    readonly is_flexible?: boolean,
  }

  export type orderInfo = {
    /** Order information */
    _: 'orderInfo',
    /** Name of the user */
    name: string,
    /** Phone number of the user */
    phone_number: string,
    /** Email address of the user */
    email_address: string,
    /** Shipping address for this order; may be null */
    shipping_address?: address,
  }

  export type orderInfo$Input = {
    /** Order information */
    readonly _: 'orderInfo',
    /** Name of the user */
    readonly name?: string,
    /** Phone number of the user */
    readonly phone_number?: string,
    /** Email address of the user */
    readonly email_address?: string,
    /** Shipping address for this order; may be null */
    readonly shipping_address?: address$Input,
  }

  export type shippingOption = {
    /** One shipping option */
    _: 'shippingOption',
    /** Shipping option identifier */
    id: string,
    /** Option title */
    title: string,
    /** A list of objects used to calculate the total shipping costs */
    price_parts: Array<labeledPricePart>,
  }

  export type shippingOption$Input = {
    /** One shipping option */
    readonly _: 'shippingOption',
    /** Shipping option identifier */
    readonly id?: string,
    /** Option title */
    readonly title?: string,
    /** A list of objects used to calculate the total shipping costs */
    readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
  }

  export type savedCredentials = {
    /** Contains information about saved payment credentials */
    _: 'savedCredentials',
    /** Unique identifier of the saved credentials */
    id: string,
    /** Title of the saved credentials */
    title: string,
  }

  export type inputCredentialsSaved$Input = {
    /**
     * Applies if a user chooses some previously saved payment credentials. To use
     * their previously saved credentials, the user must have a valid temporary password
     */
    readonly _: 'inputCredentialsSaved',
    /** Identifier of the saved credentials */
    readonly saved_credentials_id?: string,
  }

  export type inputCredentialsNew$Input = {
    /** Applies if a user enters new credentials on a payment provider website */
    readonly _: 'inputCredentialsNew',
    /** JSON-encoded data with the credential identifier from the payment provider */
    readonly data?: string,
    /** True, if the credential identifier can be saved on the server side */
    readonly allow_save?: boolean,
  }

  export type inputCredentialsApplePay$Input = {
    /** Applies if a user enters new credentials using Apple Pay */
    readonly _: 'inputCredentialsApplePay',
    /** JSON-encoded data with the credential identifier */
    readonly data?: string,
  }

  export type inputCredentialsGooglePay$Input = {
    /** Applies if a user enters new credentials using Google Pay */
    readonly _: 'inputCredentialsGooglePay',
    /** JSON-encoded data with the credential identifier */
    readonly data?: string,
  }

  export type paymentProviderSmartGlocal = {
    /** Smart Glocal payment provider */
    _: 'paymentProviderSmartGlocal',
    /** Public payment token */
    public_token: string,
    /** URL for sending card tokenization requests */
    tokenize_url: string,
  }

  export type paymentProviderStripe = {
    /** Stripe payment provider */
    _: 'paymentProviderStripe',
    /** Stripe API publishable key */
    publishable_key: string,
    /** True, if the user country must be provided */
    need_country: boolean,
    /** True, if the user ZIP/postal code must be provided */
    need_postal_code: boolean,
    /** True, if the cardholder name must be provided */
    need_cardholder_name: boolean,
  }

  export type paymentProviderOther = {
    /** Some other payment provider, for which a web payment form must be shown */
    _: 'paymentProviderOther',
    /** Payment form URL */
    url: string,
  }

  export type paymentOption = {
    /** Describes an additional payment option */
    _: 'paymentOption',
    /** Title for the payment option */
    title: string,
    /** Payment form URL to be opened in a web view */
    url: string,
  }

  export type paymentFormTypeRegular = {
    /** The payment form is for a regular payment */
    _: 'paymentFormTypeRegular',
    /** Full information about the invoice */
    invoice: invoice,
    /** User identifier of the payment provider bot */
    payment_provider_user_id: number,
    /** Information about the payment provider */
    payment_provider: PaymentProvider,
    /** The list of additional payment options */
    additional_payment_options: Array<paymentOption>,
    /** Saved server-side order information; may be null */
    saved_order_info?: orderInfo,
    /** The list of saved payment credentials */
    saved_credentials: Array<savedCredentials>,
    /** True, if the user can choose to save credentials */
    can_save_credentials: boolean,
    /**
     * True, if the user will be able to save credentials, if sets up a 2-step verification
     * password
     */
    need_password: boolean,
  }

  export type paymentFormTypeStars = {
    /** The payment form is for a payment in Telegram Stars */
    _: 'paymentFormTypeStars',
    /** Number of Telegram Stars that will be paid */
    star_count: number,
  }

  export type paymentFormTypeStarSubscription = {
    /** The payment form is for a payment in Telegram Stars for subscription */
    _: 'paymentFormTypeStarSubscription',
    /** Information about subscription plan */
    pricing: starSubscriptionPricing,
  }

  export type paymentForm = {
    /** Contains information about an invoice payment form */
    _: 'paymentForm',
    /** The payment form identifier */
    id: string,
    /** Type of the payment form */
    type: PaymentFormType,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** Information about the product */
    product_info: productInfo,
  }

  export type validatedOrderInfo = {
    /**
     * Contains a temporary identifier of validated order information, which is stored
     * for one hour, and the available shipping options
     */
    _: 'validatedOrderInfo',
    /** Temporary identifier of the order information */
    order_info_id: string,
    /** Available shipping options */
    shipping_options: Array<shippingOption>,
  }

  export type paymentResult = {
    /** Contains the result of a payment request */
    _: 'paymentResult',
    /**
     * True, if the payment request was successful; otherwise, the verification_url
     * will be non-empty
     */
    success: boolean,
    /** URL for additional payment credentials verification */
    verification_url: string,
  }

  export type paymentReceiptTypeRegular = {
    /** The payment was done using a third-party payment provider */
    _: 'paymentReceiptTypeRegular',
    /** User identifier of the payment provider bot */
    payment_provider_user_id: number,
    /** Information about the invoice */
    invoice: invoice,
    /** Order information; may be null */
    order_info?: orderInfo,
    /** Chosen shipping option; may be null */
    shipping_option?: shippingOption,
    /** Title of the saved credentials chosen by the buyer */
    credentials_title: string,
    /** The amount of tip chosen by the buyer in the smallest units of the currency */
    tip_amount: number,
  }

  export type paymentReceiptTypeStars = {
    /** The payment was done using Telegram Stars */
    _: 'paymentReceiptTypeStars',
    /** Number of Telegram Stars that were paid */
    star_count: number,
    /** Unique identifier of the transaction that can be used to dispute it */
    transaction_id: string,
  }

  export type paymentReceipt = {
    /** Contains information about a successful payment */
    _: 'paymentReceipt',
    /** Information about the product */
    product_info: productInfo,
    /** Point in time (Unix timestamp) when the payment was made */
    date: number,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** Type of the payment receipt */
    type: PaymentReceiptType,
  }

  export type inputInvoiceMessage$Input = {
    /**
     * An invoice from a message of the type messageInvoice or paid media purchase
     * from messagePaidMedia
     */
    readonly _: 'inputInvoiceMessage',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /**
     * Message identifier. Use messageProperties.can_be_paid to check whether the message
     * can be used in the method
     */
    readonly message_id?: number,
  }

  export type inputInvoiceName$Input = {
    /** An invoice from a link of the type internalLinkTypeInvoice */
    readonly _: 'inputInvoiceName',
    /** Name of the invoice */
    readonly name?: string,
  }

  export type inputInvoiceTelegram$Input = {
    /** An invoice for a payment toward Telegram; must not be used in the in-store apps */
    readonly _: 'inputInvoiceTelegram',
    /** Transaction purpose */
    readonly purpose?: TelegramPaymentPurpose$Input,
  }

  export type paidMediaPreview = {
    /** The media is hidden until the invoice is paid */
    _: 'paidMediaPreview',
    /** Media width; 0 if unknown */
    width: number,
    /** Media height; 0 if unknown */
    height: number,
    /** Media duration, in seconds; 0 if unknown */
    duration: number,
    /** Media minithumbnail; may be null */
    minithumbnail?: minithumbnail,
  }

  export type paidMediaPhoto = {
    /** The media is a photo */
    _: 'paidMediaPhoto',
    /** The photo */
    photo: photo,
  }

  export type paidMediaVideo = {
    /** The media is a video */
    _: 'paidMediaVideo',
    /** The video */
    video: video,
    /** Cover of the video; may be null if none */
    cover?: photo,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
  }

  export type paidMediaUnsupported = {
    /** The media is unsupported */
    _: 'paidMediaUnsupported',
  }

  export type giveawayParameters = {
    /** Describes parameters of a giveaway */
    _: 'giveawayParameters',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the winners of the giveaway for duration of the Telegram Premium subscription,
     * or for the specified time. If the chat is a channel, then can_post_messages
     * right is required in the channel, otherwise, the user must be an administrator
     * in the supergroup
     */
    boosted_chat_id: number,
    /**
     * Identifiers of other supergroup or channel chats that must be subscribed by
     * the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max")
     * additional chats
     */
    additional_chat_ids: Array<number>,
    /**
     * Point in time (Unix timestamp) when the giveaway is expected to be performed;
     * must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled
     * giveaways
     */
    winners_selection_date: number,
    /** True, if only new members of the chats will be eligible for the giveaway */
    only_new_members: boolean,
    /** True, if the list of winners of the giveaway will be available to everyone */
    has_public_winners: boolean,
    /**
     * The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which
     * will be eligible for the giveaway. If empty, then all users can participate
     * in the giveaway. There can be up to getOption("giveaway_country_count_max")
     * chosen countries. Users with phone number that was bought at https://fragment.com
     * can participate in any giveaway and the country code "FT" must not be specified
     * in the list
     */
    country_codes: Array<string>,
    /** Additional description of the giveaway prize; 0-128 characters */
    prize_description: string,
  }

  export type giveawayParameters$Input = {
    /** Describes parameters of a giveaway */
    readonly _: 'giveawayParameters',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the winners of the giveaway for duration of the Telegram Premium subscription,
     * or for the specified time. If the chat is a channel, then can_post_messages
     * right is required in the channel, otherwise, the user must be an administrator
     * in the supergroup
     */
    readonly boosted_chat_id?: number,
    /**
     * Identifiers of other supergroup or channel chats that must be subscribed by
     * the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max")
     * additional chats
     */
    readonly additional_chat_ids?: ReadonlyArray<number>,
    /**
     * Point in time (Unix timestamp) when the giveaway is expected to be performed;
     * must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled
     * giveaways
     */
    readonly winners_selection_date?: number,
    /** True, if only new members of the chats will be eligible for the giveaway */
    readonly only_new_members?: boolean,
    /** True, if the list of winners of the giveaway will be available to everyone */
    readonly has_public_winners?: boolean,
    /**
     * The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which
     * will be eligible for the giveaway. If empty, then all users can participate
     * in the giveaway. There can be up to getOption("giveaway_country_count_max")
     * chosen countries. Users with phone number that was bought at https://fragment.com
     * can participate in any giveaway and the country code "FT" must not be specified
     * in the list
     */
    readonly country_codes?: ReadonlyArray<string>,
    /** Additional description of the giveaway prize; 0-128 characters */
    readonly prize_description?: string,
  }

  export type datedFile = {
    /** File with the date it was uploaded */
    _: 'datedFile',
    /** The file */
    file: file,
    /** Point in time (Unix timestamp) when the file was uploaded */
    date: number,
  }

  export type passportElementTypePersonalDetails = {
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementTypePersonalDetails',
  }

  export type passportElementTypePersonalDetails$Input = {
    /** A Telegram Passport element containing the user's personal details */
    readonly _: 'passportElementTypePersonalDetails',
  }

  export type passportElementTypePassport = {
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementTypePassport',
  }

  export type passportElementTypePassport$Input = {
    /** A Telegram Passport element containing the user's passport */
    readonly _: 'passportElementTypePassport',
  }

  export type passportElementTypeDriverLicense = {
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementTypeDriverLicense',
  }

  export type passportElementTypeDriverLicense$Input = {
    /** A Telegram Passport element containing the user's driver license */
    readonly _: 'passportElementTypeDriverLicense',
  }

  export type passportElementTypeIdentityCard = {
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementTypeIdentityCard',
  }

  export type passportElementTypeIdentityCard$Input = {
    /** A Telegram Passport element containing the user's identity card */
    readonly _: 'passportElementTypeIdentityCard',
  }

  export type passportElementTypeInternalPassport = {
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementTypeInternalPassport',
  }

  export type passportElementTypeInternalPassport$Input = {
    /** A Telegram Passport element containing the user's internal passport */
    readonly _: 'passportElementTypeInternalPassport',
  }

  export type passportElementTypeAddress = {
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementTypeAddress',
  }

  export type passportElementTypeAddress$Input = {
    /** A Telegram Passport element containing the user's address */
    readonly _: 'passportElementTypeAddress',
  }

  export type passportElementTypeUtilityBill = {
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementTypeUtilityBill',
  }

  export type passportElementTypeUtilityBill$Input = {
    /** A Telegram Passport element containing the user's utility bill */
    readonly _: 'passportElementTypeUtilityBill',
  }

  export type passportElementTypeBankStatement = {
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementTypeBankStatement',
  }

  export type passportElementTypeBankStatement$Input = {
    /** A Telegram Passport element containing the user's bank statement */
    readonly _: 'passportElementTypeBankStatement',
  }

  export type passportElementTypeRentalAgreement = {
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementTypeRentalAgreement',
  }

  export type passportElementTypeRentalAgreement$Input = {
    /** A Telegram Passport element containing the user's rental agreement */
    readonly _: 'passportElementTypeRentalAgreement',
  }

  export type passportElementTypePassportRegistration = {
    /** A Telegram Passport element containing the registration page of the user's passport */
    _: 'passportElementTypePassportRegistration',
  }

  export type passportElementTypePassportRegistration$Input = {
    /** A Telegram Passport element containing the registration page of the user's passport */
    readonly _: 'passportElementTypePassportRegistration',
  }

  export type passportElementTypeTemporaryRegistration = {
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTypeTemporaryRegistration',
  }

  export type passportElementTypeTemporaryRegistration$Input = {
    /** A Telegram Passport element containing the user's temporary registration */
    readonly _: 'passportElementTypeTemporaryRegistration',
  }

  export type passportElementTypePhoneNumber = {
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementTypePhoneNumber',
  }

  export type passportElementTypePhoneNumber$Input = {
    /** A Telegram Passport element containing the user's phone number */
    readonly _: 'passportElementTypePhoneNumber',
  }

  export type passportElementTypeEmailAddress = {
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementTypeEmailAddress',
  }

  export type passportElementTypeEmailAddress$Input = {
    /** A Telegram Passport element containing the user's email address */
    readonly _: 'passportElementTypeEmailAddress',
  }

  export type date = {
    /** Represents a date according to the Gregorian calendar */
    _: 'date',
    /** Day of the month; 1-31 */
    day: number,
    /** Month; 1-12 */
    month: number,
    /** Year; 1-9999 */
    year: number,
  }

  export type date$Input = {
    /** Represents a date according to the Gregorian calendar */
    readonly _: 'date',
    /** Day of the month; 1-31 */
    readonly day?: number,
    /** Month; 1-12 */
    readonly month?: number,
    /** Year; 1-9999 */
    readonly year?: number,
  }

  export type personalDetails = {
    /** Contains the user's personal details */
    _: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    first_name: string,
    /** Middle name of the user written in English; 0-255 characters */
    middle_name: string,
    /** Last name of the user written in English; 1-255 characters */
    last_name: string,
    /** Native first name of the user; 1-255 characters */
    native_first_name: string,
    /** Native middle name of the user; 0-255 characters */
    native_middle_name: string,
    /** Native last name of the user; 1-255 characters */
    native_last_name: string,
    /** Birthdate of the user */
    birthdate: date,
    /** Gender of the user, "male" or "female" */
    gender: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    country_code: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    residence_country_code: string,
  }

  export type personalDetails$Input = {
    /** Contains the user's personal details */
    readonly _: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    readonly first_name?: string,
    /** Middle name of the user written in English; 0-255 characters */
    readonly middle_name?: string,
    /** Last name of the user written in English; 1-255 characters */
    readonly last_name?: string,
    /** Native first name of the user; 1-255 characters */
    readonly native_first_name?: string,
    /** Native middle name of the user; 0-255 characters */
    readonly native_middle_name?: string,
    /** Native last name of the user; 1-255 characters */
    readonly native_last_name?: string,
    /** Birthdate of the user */
    readonly birthdate?: date$Input,
    /** Gender of the user, "male" or "female" */
    readonly gender?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    readonly country_code?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    readonly residence_country_code?: string,
  }

  export type identityDocument = {
    /** An identity document */
    _: 'identityDocument',
    /** Document number; 1-24 characters */
    number: string,
    /** Document expiration date; may be null if not applicable */
    expiration_date?: date,
    /** Front side of the document */
    front_side: datedFile,
    /**
     * Reverse side of the document; only for driver license and identity card; may
     * be null
     */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  }

  export type inputIdentityDocument$Input = {
    /** An identity document to be saved to Telegram Passport */
    readonly _: 'inputIdentityDocument',
    /** Document number; 1-24 characters */
    readonly number?: string,
    /** Document expiration date; pass null if not applicable */
    readonly expiration_date?: date$Input,
    /** Front side of the document */
    readonly front_side?: InputFile$Input,
    /**
     * Reverse side of the document; only for driver license and identity card; pass
     * null otherwise
     */
    readonly reverse_side?: InputFile$Input,
    /** Selfie with the document; pass null if unavailable */
    readonly selfie?: InputFile$Input,
    /** List of files containing a certified English translation of the document */
    readonly translation?: ReadonlyArray<InputFile$Input>,
  }

  export type personalDocument = {
    /** A personal document, containing some information about a user */
    _: 'personalDocument',
    /** List of files containing the pages of the document */
    files: Array<datedFile>,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  }

  export type inputPersonalDocument$Input = {
    /** A personal document to be saved to Telegram Passport */
    readonly _: 'inputPersonalDocument',
    /** List of files containing the pages of the document */
    readonly files?: ReadonlyArray<InputFile$Input>,
    /** List of files containing a certified English translation of the document */
    readonly translation?: ReadonlyArray<InputFile$Input>,
  }

  export type passportElementPersonalDetails = {
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementPersonalDetails',
    /** Personal details of the user */
    personal_details: personalDetails,
  }

  export type passportElementPassport = {
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementPassport',
    /** Passport */
    passport: identityDocument,
  }

  export type passportElementDriverLicense = {
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementDriverLicense',
    /** Driver license */
    driver_license: identityDocument,
  }

  export type passportElementIdentityCard = {
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementIdentityCard',
    /** Identity card */
    identity_card: identityDocument,
  }

  export type passportElementInternalPassport = {
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementInternalPassport',
    /** Internal passport */
    internal_passport: identityDocument,
  }

  export type passportElementAddress = {
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementAddress',
    /** Address */
    address: address,
  }

  export type passportElementUtilityBill = {
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementUtilityBill',
    /** Utility bill */
    utility_bill: personalDocument,
  }

  export type passportElementBankStatement = {
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementBankStatement',
    /** Bank statement */
    bank_statement: personalDocument,
  }

  export type passportElementRentalAgreement = {
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementRentalAgreement',
    /** Rental agreement */
    rental_agreement: personalDocument,
  }

  export type passportElementPassportRegistration = {
    /** A Telegram Passport element containing the user's passport registration pages */
    _: 'passportElementPassportRegistration',
    /** Passport registration pages */
    passport_registration: personalDocument,
  }

  export type passportElementTemporaryRegistration = {
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTemporaryRegistration',
    /** Temporary registration */
    temporary_registration: personalDocument,
  }

  export type passportElementPhoneNumber = {
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementPhoneNumber',
    /** Phone number */
    phone_number: string,
  }

  export type passportElementEmailAddress = {
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementEmailAddress',
    /** Email address */
    email_address: string,
  }

  export type inputPassportElementPersonalDetails$Input = {
    /** A Telegram Passport element to be saved containing the user's personal details */
    readonly _: 'inputPassportElementPersonalDetails',
    /** Personal details of the user */
    readonly personal_details?: personalDetails$Input,
  }

  export type inputPassportElementPassport$Input = {
    /** A Telegram Passport element to be saved containing the user's passport */
    readonly _: 'inputPassportElementPassport',
    /** The passport to be saved */
    readonly passport?: inputIdentityDocument$Input,
  }

  export type inputPassportElementDriverLicense$Input = {
    /** A Telegram Passport element to be saved containing the user's driver license */
    readonly _: 'inputPassportElementDriverLicense',
    /** The driver license to be saved */
    readonly driver_license?: inputIdentityDocument$Input,
  }

  export type inputPassportElementIdentityCard$Input = {
    /** A Telegram Passport element to be saved containing the user's identity card */
    readonly _: 'inputPassportElementIdentityCard',
    /** The identity card to be saved */
    readonly identity_card?: inputIdentityDocument$Input,
  }

  export type inputPassportElementInternalPassport$Input = {
    /** A Telegram Passport element to be saved containing the user's internal passport */
    readonly _: 'inputPassportElementInternalPassport',
    /** The internal passport to be saved */
    readonly internal_passport?: inputIdentityDocument$Input,
  }

  export type inputPassportElementAddress$Input = {
    /** A Telegram Passport element to be saved containing the user's address */
    readonly _: 'inputPassportElementAddress',
    /** The address to be saved */
    readonly address?: address$Input,
  }

  export type inputPassportElementUtilityBill$Input = {
    /** A Telegram Passport element to be saved containing the user's utility bill */
    readonly _: 'inputPassportElementUtilityBill',
    /** The utility bill to be saved */
    readonly utility_bill?: inputPersonalDocument$Input,
  }

  export type inputPassportElementBankStatement$Input = {
    /** A Telegram Passport element to be saved containing the user's bank statement */
    readonly _: 'inputPassportElementBankStatement',
    /** The bank statement to be saved */
    readonly bank_statement?: inputPersonalDocument$Input,
  }

  export type inputPassportElementRentalAgreement$Input = {
    /** A Telegram Passport element to be saved containing the user's rental agreement */
    readonly _: 'inputPassportElementRentalAgreement',
    /** The rental agreement to be saved */
    readonly rental_agreement?: inputPersonalDocument$Input,
  }

  export type inputPassportElementPassportRegistration$Input = {
    /** A Telegram Passport element to be saved containing the user's passport registration */
    readonly _: 'inputPassportElementPassportRegistration',
    /** The passport registration page to be saved */
    readonly passport_registration?: inputPersonalDocument$Input,
  }

  export type inputPassportElementTemporaryRegistration$Input = {
    /** A Telegram Passport element to be saved containing the user's temporary registration */
    readonly _: 'inputPassportElementTemporaryRegistration',
    /** The temporary registration document to be saved */
    readonly temporary_registration?: inputPersonalDocument$Input,
  }

  export type inputPassportElementPhoneNumber$Input = {
    /** A Telegram Passport element to be saved containing the user's phone number */
    readonly _: 'inputPassportElementPhoneNumber',
    /** The phone number to be saved */
    readonly phone_number?: string,
  }

  export type inputPassportElementEmailAddress$Input = {
    /** A Telegram Passport element to be saved containing the user's email address */
    readonly _: 'inputPassportElementEmailAddress',
    /** The email address to be saved */
    readonly email_address?: string,
  }

  export type passportElements = {
    /** Contains information about saved Telegram Passport elements */
    _: 'passportElements',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
  }

  export type passportElementErrorSourceUnspecified = {
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    _: 'passportElementErrorSourceUnspecified',
  }

  export type passportElementErrorSourceDataField = {
    /**
     * One of the data fields contains an error. The error will be considered resolved
     * when the value of the field changes
     */
    _: 'passportElementErrorSourceDataField',
    /** Field name */
    field_name: string,
  }

  export type passportElementErrorSourceFrontSide = {
    /**
     * The front side of the document contains an error. The error will be considered
     * resolved when the file with the front side changes
     */
    _: 'passportElementErrorSourceFrontSide',
  }

  export type passportElementErrorSourceReverseSide = {
    /**
     * The reverse side of the document contains an error. The error will be considered
     * resolved when the file with the reverse side changes
     */
    _: 'passportElementErrorSourceReverseSide',
  }

  export type passportElementErrorSourceSelfie = {
    /**
     * The selfie with the document contains an error. The error will be considered
     * resolved when the file with the selfie changes
     */
    _: 'passportElementErrorSourceSelfie',
  }

  export type passportElementErrorSourceTranslationFile = {
    /**
     * One of files with the translation of the document contains an error. The error
     * will be considered resolved when the file changes
     */
    _: 'passportElementErrorSourceTranslationFile',
    /** Index of a file with the error */
    file_index: number,
  }

  export type passportElementErrorSourceTranslationFiles = {
    /**
     * The translation of the document contains an error. The error will be considered
     * resolved when the list of translation files changes
     */
    _: 'passportElementErrorSourceTranslationFiles',
  }

  export type passportElementErrorSourceFile = {
    /**
     * The file contains an error. The error will be considered resolved when the file
     * changes
     */
    _: 'passportElementErrorSourceFile',
    /** Index of a file with the error */
    file_index: number,
  }

  export type passportElementErrorSourceFiles = {
    /**
     * The list of attached files contains an error. The error will be considered resolved
     * when the list of files changes
     */
    _: 'passportElementErrorSourceFiles',
  }

  export type passportElementError = {
    /** Contains the description of an error in a Telegram Passport element */
    _: 'passportElementError',
    /** Type of the Telegram Passport element which has the error */
    type: PassportElementType,
    /** Error message */
    message: string,
    /** Error source */
    source: PassportElementErrorSource,
  }

  export type passportSuitableElement = {
    /**
     * Contains information about a Telegram Passport element that was requested by
     * a service
     */
    _: 'passportSuitableElement',
    /** Type of the element */
    type: PassportElementType,
    /** True, if a selfie is required with the identity document */
    is_selfie_required: boolean,
    /** True, if a certified English translation is required with the document */
    is_translation_required: boolean,
    /**
     * True, if personal details must include the user's name in the language of their
     * country of residence
     */
    is_native_name_required: boolean,
  }

  export type passportRequiredElement = {
    /**
     * Contains a description of the required Telegram Passport element that was requested
     * by a service
     */
    _: 'passportRequiredElement',
    /** List of Telegram Passport elements any of which is enough to provide */
    suitable_elements: Array<passportSuitableElement>,
  }

  export type passportAuthorizationForm = {
    /** Contains information about a Telegram Passport authorization form that was requested */
    _: 'passportAuthorizationForm',
    /** Unique identifier of the authorization form */
    id: number,
    /** Telegram Passport elements that must be provided to complete the form */
    required_elements: Array<passportRequiredElement>,
    /** URL for the privacy policy of the service; may be empty */
    privacy_policy_url: string,
  }

  export type passportElementsWithErrors = {
    /** Contains information about a Telegram Passport elements and corresponding errors */
    _: 'passportElementsWithErrors',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
    /** Errors in the elements that are already available */
    errors: Array<passportElementError>,
  }

  export type encryptedCredentials = {
    /** Contains encrypted Telegram Passport data credentials */
    _: 'encryptedCredentials',
    /** The encrypted credentials */
    data: string /* base64 */,
    /** The decrypted data hash */
    hash: string /* base64 */,
    /** Secret for data decryption, encrypted with the service's public key */
    secret: string /* base64 */,
  }

  export type encryptedPassportElement = {
    /**
     * Contains information about an encrypted Telegram Passport element; for bots
     * only
     */
    _: 'encryptedPassportElement',
    /** Type of Telegram Passport element */
    type: PassportElementType,
    /** Encrypted JSON-encoded data about the user */
    data: string /* base64 */,
    /** The front side of an identity document */
    front_side: datedFile,
    /** The reverse side of an identity document; may be null */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
    /** List of attached files */
    files: Array<datedFile>,
    /** Unencrypted data, phone number or email address */
    value: string,
    /** Hash of the entire element */
    hash: string,
  }

  export type inputPassportElementErrorSourceUnspecified$Input = {
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    readonly _: 'inputPassportElementErrorSourceUnspecified',
    /** Current hash of the entire element */
    readonly element_hash?: string /* base64 */,
  }

  export type inputPassportElementErrorSourceDataField$Input = {
    /**
     * A data field contains an error. The error is considered resolved when the field's
     * value changes
     */
    readonly _: 'inputPassportElementErrorSourceDataField',
    /** Field name */
    readonly field_name?: string,
    /** Current data hash */
    readonly data_hash?: string /* base64 */,
  }

  export type inputPassportElementErrorSourceFrontSide$Input = {
    /**
     * The front side of the document contains an error. The error is considered resolved
     * when the file with the front side of the document changes
     */
    readonly _: 'inputPassportElementErrorSourceFrontSide',
    /** Current hash of the file containing the front side */
    readonly file_hash?: string /* base64 */,
  }

  export type inputPassportElementErrorSourceReverseSide$Input = {
    /**
     * The reverse side of the document contains an error. The error is considered
     * resolved when the file with the reverse side of the document changes
     */
    readonly _: 'inputPassportElementErrorSourceReverseSide',
    /** Current hash of the file containing the reverse side */
    readonly file_hash?: string /* base64 */,
  }

  export type inputPassportElementErrorSourceSelfie$Input = {
    /**
     * The selfie contains an error. The error is considered resolved when the file
     * with the selfie changes
     */
    readonly _: 'inputPassportElementErrorSourceSelfie',
    /** Current hash of the file containing the selfie */
    readonly file_hash?: string /* base64 */,
  }

  export type inputPassportElementErrorSourceTranslationFile$Input = {
    /**
     * One of the files containing the translation of the document contains an error.
     * The error is considered resolved when the file with the translation changes
     */
    readonly _: 'inputPassportElementErrorSourceTranslationFile',
    /** Current hash of the file containing the translation */
    readonly file_hash?: string /* base64 */,
  }

  export type inputPassportElementErrorSourceTranslationFiles$Input = {
    /**
     * The translation of the document contains an error. The error is considered resolved
     * when the list of files changes
     */
    readonly _: 'inputPassportElementErrorSourceTranslationFiles',
    /** Current hashes of all files with the translation */
    readonly file_hashes?: ReadonlyArray<string /* base64 */>,
  }

  export type inputPassportElementErrorSourceFile$Input = {
    /** The file contains an error. The error is considered resolved when the file changes */
    readonly _: 'inputPassportElementErrorSourceFile',
    /** Current hash of the file which has the error */
    readonly file_hash?: string /* base64 */,
  }

  export type inputPassportElementErrorSourceFiles$Input = {
    /**
     * The list of attached files contains an error. The error is considered resolved
     * when the file list changes
     */
    readonly _: 'inputPassportElementErrorSourceFiles',
    /** Current hashes of all attached files */
    readonly file_hashes?: ReadonlyArray<string /* base64 */>,
  }

  export type inputPassportElementError$Input = {
    /**
     * Contains the description of an error in a Telegram Passport element; for bots
     * only
     */
    readonly _: 'inputPassportElementError',
    /** Type of Telegram Passport element that has the error */
    readonly type?: PassportElementType$Input,
    /** Error message */
    readonly message?: string,
    /** Error source */
    readonly source?: InputPassportElementErrorSource$Input,
  }

  export type messageText = {
    /** A text message */
    _: 'messageText',
    /** Text of the message */
    text: formattedText,
    /** A link preview attached to the message; may be null */
    link_preview?: linkPreview,
    /**
     * Options which were used for generation of the link preview; may be null if default
     * options were used
     */
    link_preview_options?: linkPreviewOptions,
  }

  export type messageAnimation = {
    /** An animation message (GIF-style). */
    _: 'messageAnimation',
    /** The animation description */
    animation: animation,
    /** Animation caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the animation; otherwise, the caption
     * must be shown below the animation
     */
    show_caption_above_media: boolean,
    /** True, if the animation preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /**
     * True, if the animation thumbnail must be blurred and the animation must be shown
     * only while tapped
     */
    is_secret: boolean,
  }

  export type messageAudio = {
    /** An audio message */
    _: 'messageAudio',
    /** The audio description */
    audio: audio,
    /** Audio caption */
    caption: formattedText,
  }

  export type messageDocument = {
    /** A document message (general file) */
    _: 'messageDocument',
    /** The document description */
    document: document,
    /** Document caption */
    caption: formattedText,
  }

  export type messagePaidMedia = {
    /** A message with paid media */
    _: 'messagePaidMedia',
    /** Number of Telegram Stars needed to buy access to the media in the message */
    star_count: number,
    /** Information about the media */
    media: Array<PaidMedia>,
    /** Media caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the media; otherwise, the caption must
     * be shown below the media
     */
    show_caption_above_media: boolean,
  }

  export type messagePhoto = {
    /** A photo message */
    _: 'messagePhoto',
    /** The photo */
    photo: photo,
    /** Photo caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the photo; otherwise, the caption must
     * be shown below the photo
     */
    show_caption_above_media: boolean,
    /** True, if the photo preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /** True, if the photo must be blurred and must be shown only while tapped */
    is_secret: boolean,
  }

  export type messageSticker = {
    /** A sticker message */
    _: 'messageSticker',
    /** The sticker description */
    sticker: sticker,
    /** True, if premium animation of the sticker must be played */
    is_premium: boolean,
  }

  export type messageVideo = {
    /** A video message */
    _: 'messageVideo',
    /** The video description */
    video: video,
    /** Alternative qualities of the video */
    alternative_videos: Array<alternativeVideo>,
    /** Available storyboards for the video */
    storyboards: Array<videoStoryboard>,
    /** Cover of the video; may be null if none */
    cover?: photo,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
    /** Video caption */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the video; otherwise, the caption must
     * be shown below the video
     */
    show_caption_above_media: boolean,
    /** True, if the video preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /**
     * True, if the video thumbnail must be blurred and the video must be shown only
     * while tapped
     */
    is_secret: boolean,
  }

  export type messageVideoNote = {
    /** A video note message */
    _: 'messageVideoNote',
    /** The video note description */
    video_note: videoNote,
    /** True, if at least one of the recipients has viewed the video note */
    is_viewed: boolean,
    /**
     * True, if the video note thumbnail must be blurred and the video note must be
     * shown only while tapped
     */
    is_secret: boolean,
  }

  export type messageVoiceNote = {
    /** A voice note message */
    _: 'messageVoiceNote',
    /** The voice note description */
    voice_note: voiceNote,
    /** Voice note caption */
    caption: formattedText,
    /** True, if at least one of the recipients has listened to the voice note */
    is_listened: boolean,
  }

  export type messageExpiredPhoto = {
    /** A self-destructed photo message */
    _: 'messageExpiredPhoto',
  }

  export type messageExpiredVideo = {
    /** A self-destructed video message */
    _: 'messageExpiredVideo',
  }

  export type messageExpiredVideoNote = {
    /** A self-destructed video note message */
    _: 'messageExpiredVideoNote',
  }

  export type messageExpiredVoiceNote = {
    /** A self-destructed voice note message */
    _: 'messageExpiredVoiceNote',
  }

  export type messageLocation = {
    /** A message with a location */
    _: 'messageLocation',
    /** The location description */
    location: location,
    /**
     * Time relative to the message send date, for which the location can be updated,
     * in seconds; if 0x7FFFFFFF, then location can be updated forever
     */
    live_period: number,
    /**
     * Left time for which the location can be updated, in seconds. If 0, then the
     * location can't be updated anymore. The update updateMessageContent is not sent
     * when this field changes
     */
    expires_in: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * If 0 the direction is unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). 0 if the notification is disabled. Available only
     * to the message sender
     */
    proximity_alert_radius: number,
  }

  export type messageVenue = {
    /** A message with information about a venue */
    _: 'messageVenue',
    /** The venue description */
    venue: venue,
  }

  export type messageContact = {
    /** A message with a user contact */
    _: 'messageContact',
    /** The contact description */
    contact: contact,
  }

  export type messageAnimatedEmoji = {
    /** A message with an animated emoji */
    _: 'messageAnimatedEmoji',
    /** The animated emoji */
    animated_emoji: animatedEmoji,
    /** The corresponding emoji */
    emoji: string,
  }

  export type messageDice = {
    /** A dice message. The dice value is randomly generated by the server */
    _: 'messageDice',
    /**
     * The animated stickers with the initial dice animation; may be null if unknown.
     * The update updateMessageContent will be sent when the sticker became known
     */
    initial_state?: DiceStickers,
    /**
     * The animated stickers with the final dice animation; may be null if unknown.
     * The update updateMessageContent will be sent when the sticker became known
     */
    final_state?: DiceStickers,
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** The dice value. If the value is 0, the dice don't have final state yet */
    value: number,
    /**
     * Number of frame after which a success animation like a shower of confetti needs
     * to be shown on updateMessageSendSucceeded
     */
    success_animation_frame_number: number,
  }

  export type messageGame = {
    /** A message with a game */
    _: 'messageGame',
    /** The game description */
    game: game,
  }

  export type messagePoll = {
    /** A message with a poll */
    _: 'messagePoll',
    /** The poll description */
    poll: poll,
  }

  export type messageStory = {
    /** A message with a forwarded story */
    _: 'messageStory',
    /** Identifier of the chat that posted the story */
    story_poster_chat_id: number,
    /** Story identifier */
    story_id: number,
    /** True, if the story was automatically forwarded because of a mention of the user */
    via_mention: boolean,
  }

  export type messageChecklist = {
    /** A message with a checklist */
    _: 'messageChecklist',
    /** The checklist description */
    list: checklist,
  }

  export type messageInvoice = {
    /**
     * A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart
     * to share the invoice
     */
    _: 'messageInvoice',
    /** Information about the product */
    product_info: productInfo,
    /** Currency for the product price */
    currency: string,
    /** Product total price in the smallest units of the currency */
    total_amount: number,
    /** Unique invoice bot start_parameter to be passed to getInternalLink */
    start_parameter: string,
    /** True, if the invoice is a test invoice */
    is_test: boolean,
    /** True, if the shipping address must be specified */
    need_shipping_address: boolean,
    /** The identifier of the message with the receipt, after the product has been purchased */
    receipt_message_id: number,
    /** Extended media attached to the invoice; may be null if none */
    paid_media?: PaidMedia,
    /** Extended media caption; may be null if none */
    paid_media_caption?: formattedText,
  }

  export type messageCall = {
    /** A message with information about an ended call */
    _: 'messageCall',
    /** True, if the call was a video call */
    is_video: boolean,
    /** Reason why the call was discarded */
    discard_reason: CallDiscardReason,
    /** Call duration, in seconds */
    duration: number,
  }

  export type messageGroupCall = {
    /**
     * A message with information about a group call not bound to a chat. If the message
     * is incoming, the call isn't active, isn't missed, and has no duration, and getOption("can_accept_calls")
     * is true, then incoming call screen must be shown to the user. Use getGroupCallParticipants
     * to show current group call participants on the screen. Use joinGroupCall to
     * accept the call or declineGroupCallInvitation to decline it. If the call become
     * active or missed, then the call screen must be hidden
     */
    _: 'messageGroupCall',
    /** True, if the call is active, i.e. the called user joined the call */
    is_active: boolean,
    /** True, if the called user missed or declined the call */
    was_missed: boolean,
    /** True, if the call is a video call */
    is_video: boolean,
    /** Call duration, in seconds; for left calls only */
    duration: number,
    /** Identifiers of some other call participants */
    other_participant_ids: Array<MessageSender>,
  }

  export type messageVideoChatScheduled = {
    /** A new video chat was scheduled */
    _: 'messageVideoChatScheduled',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /**
     * Point in time (Unix timestamp) when the group call is expected to be started
     * by an administrator
     */
    start_date: number,
  }

  export type messageVideoChatStarted = {
    /** A newly created video chat */
    _: 'messageVideoChatStarted',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type messageVideoChatEnded = {
    /** A message with information about an ended video chat */
    _: 'messageVideoChatEnded',
    /** Call duration, in seconds */
    duration: number,
  }

  export type messageInviteVideoChatParticipants = {
    /** A message with information about an invitation to a video chat */
    _: 'messageInviteVideoChatParticipants',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /** Invited user identifiers */
    user_ids: Array<number>,
  }

  export type messageBasicGroupChatCreate = {
    /** A newly created basic group */
    _: 'messageBasicGroupChatCreate',
    /** Title of the basic group */
    title: string,
    /** User identifiers of members in the basic group */
    member_user_ids: Array<number>,
  }

  export type messageSupergroupChatCreate = {
    /** A newly created supergroup or channel */
    _: 'messageSupergroupChatCreate',
    /** Title of the supergroup or channel */
    title: string,
  }

  export type messageChatChangeTitle = {
    /** An updated chat title */
    _: 'messageChatChangeTitle',
    /** New chat title */
    title: string,
  }

  export type messageChatChangePhoto = {
    /** An updated chat photo */
    _: 'messageChatChangePhoto',
    /** New chat photo */
    photo: chatPhoto,
  }

  export type messageChatDeletePhoto = {
    /** A deleted chat photo */
    _: 'messageChatDeletePhoto',
  }

  export type messageChatAddMembers = {
    /** New chat members were added */
    _: 'messageChatAddMembers',
    /** User identifiers of the new members */
    member_user_ids: Array<number>,
  }

  export type messageChatJoinByLink = {
    /** A new member joined the chat via an invite link */
    _: 'messageChatJoinByLink',
  }

  export type messageChatJoinByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'messageChatJoinByRequest',
  }

  export type messageChatDeleteMember = {
    /** A chat member was deleted */
    _: 'messageChatDeleteMember',
    /** User identifier of the deleted chat member */
    user_id: number,
  }

  export type messageChatUpgradeTo = {
    /** A basic group was upgraded to a supergroup and was deactivated as the result */
    _: 'messageChatUpgradeTo',
    /** Identifier of the supergroup to which the basic group was upgraded */
    supergroup_id: number,
  }

  export type messageChatUpgradeFrom = {
    /** A supergroup has been created from a basic group */
    _: 'messageChatUpgradeFrom',
    /** Title of the newly created supergroup */
    title: string,
    /** The identifier of the original basic group */
    basic_group_id: number,
  }

  export type messagePinMessage = {
    /** A message has been pinned */
    _: 'messagePinMessage',
    /**
     * Identifier of the pinned message, can be an identifier of a deleted message
     * or 0
     */
    message_id: number,
  }

  export type messageScreenshotTaken = {
    /** A screenshot of a message in the chat has been taken */
    _: 'messageScreenshotTaken',
  }

  export type messageChatSetBackground = {
    /** A new background was set in the chat */
    _: 'messageChatSetBackground',
    /**
     * Identifier of the message with a previously set same background; 0 if none.
     * Can be an identifier of a deleted message
     */
    old_background_message_id: number,
    /** The new background */
    background: chatBackground,
    /** True, if the background was set only for self */
    only_for_self: boolean,
  }

  export type messageChatSetTheme = {
    /** A theme in the chat has been changed */
    _: 'messageChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was
     * reset to the default one
     */
    theme_name: string,
  }

  export type messageChatSetMessageAutoDeleteTime = {
    /** The auto-delete or self-destruct timer for messages in the chat has been changed */
    _: 'messageChatSetMessageAutoDeleteTime',
    /** New value auto-delete or self-destruct time, in seconds; 0 if disabled */
    message_auto_delete_time: number,
    /** If not 0, a user identifier, which default setting was automatically applied */
    from_user_id: number,
  }

  export type messageChatBoost = {
    /** The chat was boosted by the sender of the message */
    _: 'messageChatBoost',
    /** Number of times the chat was boosted */
    boost_count: number,
  }

  export type messageForumTopicCreated = {
    /** A forum topic has been created */
    _: 'messageForumTopicCreated',
    /** Name of the topic */
    name: string,
    /** Icon of the topic */
    icon: forumTopicIcon,
  }

  export type messageForumTopicEdited = {
    /** A forum topic has been edited */
    _: 'messageForumTopicEdited',
    /** If non-empty, the new name of the topic */
    name: string,
    /** True, if icon's custom_emoji_id is changed */
    edit_icon_custom_emoji_id: boolean,
    /**
     * New unique identifier of the custom emoji shown on the topic icon; 0 if none.
     * Must be ignored if edit_icon_custom_emoji_id is false
     */
    icon_custom_emoji_id: string,
  }

  export type messageForumTopicIsClosedToggled = {
    /** A forum topic has been closed or opened */
    _: 'messageForumTopicIsClosedToggled',
    /** True, if the topic was closed; otherwise, the topic was reopened */
    is_closed: boolean,
  }

  export type messageForumTopicIsHiddenToggled = {
    /** A General forum topic has been hidden or unhidden */
    _: 'messageForumTopicIsHiddenToggled',
    /** True, if the topic was hidden; otherwise, the topic was unhidden */
    is_hidden: boolean,
  }

  export type messageSuggestProfilePhoto = {
    /** A profile photo was suggested to a user in a private chat */
    _: 'messageSuggestProfilePhoto',
    /**
     * The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious
     * to apply the photo
     */
    photo: chatPhoto,
  }

  export type messageCustomServiceAction = {
    /** A non-standard action has happened in the chat */
    _: 'messageCustomServiceAction',
    /** Message text to be shown in the chat */
    text: string,
  }

  export type messageGameScore = {
    /** A new high score was achieved in a game */
    _: 'messageGameScore',
    /** Identifier of the message with the game, can be an identifier of a deleted message */
    game_message_id: number,
    /**
     * Identifier of the game; may be different from the games presented in the message
     * with the game
     */
    game_id: string,
    /** New score */
    score: number,
  }

  export type messagePaymentSuccessful = {
    /** A payment has been sent to a bot or a business account */
    _: 'messagePaymentSuccessful',
    /** Identifier of the chat, containing the corresponding invoice message */
    invoice_chat_id: number,
    /**
     * Identifier of the message with the corresponding invoice; can be 0 or an identifier
     * of a deleted message
     */
    invoice_message_id: number,
    /** Currency for the price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /**
     * Point in time (Unix timestamp) when the subscription will expire; 0 if unknown
     * or the payment isn't recurring
     */
    subscription_until_date: number,
    /** True, if this is a recurring payment */
    is_recurring: boolean,
    /** True, if this is the first recurring payment */
    is_first_recurring: boolean,
    /** Name of the invoice; may be empty if unknown */
    invoice_name: string,
  }

  export type messagePaymentSuccessfulBot = {
    /** A payment has been received by the bot or the business account */
    _: 'messagePaymentSuccessfulBot',
    /** Currency for price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /**
     * Point in time (Unix timestamp) when the subscription will expire; 0 if unknown
     * or the payment isn't recurring
     */
    subscription_until_date: number,
    /** True, if this is a recurring payment */
    is_recurring: boolean,
    /** True, if this is the first recurring payment */
    is_first_recurring: boolean,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /**
     * Identifier of the shipping option chosen by the user; may be empty if not applicable;
     * for bots only
     */
    shipping_option_id: string,
    /** Information about the order; may be null; for bots only */
    order_info?: orderInfo,
    /** Telegram payment identifier */
    telegram_payment_charge_id: string,
    /** Provider payment identifier */
    provider_payment_charge_id: string,
  }

  export type messagePaymentRefunded = {
    /** A payment has been refunded */
    _: 'messagePaymentRefunded',
    /** Identifier of the previous owner of the Telegram Stars that refunds them */
    owner_id: MessageSender,
    /** Currency for the price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** Invoice payload; only for bots */
    invoice_payload: string /* base64 */,
    /** Telegram payment identifier */
    telegram_payment_charge_id: string,
    /** Provider payment identifier */
    provider_payment_charge_id: string,
  }

  export type messageGiftedPremium = {
    /** Telegram Premium was gifted to a user */
    _: 'messageGiftedPremium',
    /**
     * The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous
     * or is outgoing
     */
    gifter_user_id: number,
    /** The identifier of a user that received Telegram Premium; 0 if the gift is incoming */
    receiver_user_id: number,
    /** Message added to the gifted Telegram Premium by the sender */
    text: formattedText,
    /** Currency for the paid amount */
    currency: string,
    /** The paid amount, in the smallest units of the currency */
    amount: number,
    /** Cryptocurrency used to pay for the gift; may be empty if none */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency; 0 if none */
    cryptocurrency_amount: string,
    /** Number of months the Telegram Premium subscription will be active */
    month_count: number,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  }

  export type messagePremiumGiftCode = {
    /** A Telegram Premium gift code was created for the user */
    _: 'messagePremiumGiftCode',
    /** Identifier of a chat or a user that created the gift code; may be null if unknown */
    creator_id?: MessageSender,
    /** Message added to the gift */
    text: formattedText,
    /** True, if the gift code was created for a giveaway */
    is_from_giveaway: boolean,
    /**
     * True, if the winner for the corresponding Telegram Premium subscription wasn't
     * chosen
     */
    is_unclaimed: boolean,
    /** Currency for the paid amount; empty if unknown */
    currency: string,
    /** The paid amount, in the smallest units of the currency; 0 if unknown */
    amount: number,
    /** Cryptocurrency used to pay for the gift; may be empty if none or unknown */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency; 0 if unknown */
    cryptocurrency_amount: string,
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
    /** The gift code */
    code: string,
  }

  export type messageGiveawayCreated = {
    /**
     * A giveaway was created for the chat. Use telegramPaymentPurposePremiumGiveaway,
     * storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway
     * to create a giveaway
     */
    _: 'messageGiveawayCreated',
    /**
     * Number of Telegram Stars that will be shared by winners of the giveaway; 0 for
     * Telegram Premium giveaways
     */
    star_count: number,
  }

  export type messageGiveaway = {
    /** A giveaway */
    _: 'messageGiveaway',
    /** Giveaway parameters */
    parameters: giveawayParameters,
    /** Number of users which will receive Telegram Premium subscription gift codes */
    winner_count: number,
    /** Prize of the giveaway */
    prize: GiveawayPrize,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  }

  export type messageGiveawayCompleted = {
    /** A giveaway without public winners has been completed for the chat */
    _: 'messageGiveawayCompleted',
    /** Identifier of the message with the giveaway; can be 0 if the message was deleted */
    giveaway_message_id: number,
    /** Number of winners in the giveaway */
    winner_count: number,
    /** True, if the giveaway is a Telegram Star giveaway */
    is_star_giveaway: boolean,
    /** Number of undistributed prizes; for Telegram Premium giveaways only */
    unclaimed_prize_count: number,
  }

  export type messageGiveawayWinners = {
    /** A giveaway with public winners has been completed for the chat */
    _: 'messageGiveawayWinners',
    /**
     * Identifier of the supergroup or channel chat, which was automatically boosted
     * by the winners of the giveaway
     */
    boosted_chat_id: number,
    /** Identifier of the message with the giveaway in the boosted chat */
    giveaway_message_id: number,
    /** Number of other chats that participated in the giveaway */
    additional_chat_count: number,
    /**
     * Point in time (Unix timestamp) when the winners were selected. May be bigger
     * than winners selection date specified in parameters of the giveaway
     */
    actual_winners_selection_date: number,
    /** True, if only new members of the chats were eligible for the giveaway */
    only_new_members: boolean,
    /** True, if the giveaway was canceled and was fully refunded */
    was_refunded: boolean,
    /** Prize of the giveaway */
    prize: GiveawayPrize,
    /** Additional description of the giveaway prize */
    prize_description: string,
    /** Total number of winners in the giveaway */
    winner_count: number,
    /** Up to 100 user identifiers of the winners of the giveaway */
    winner_user_ids: Array<number>,
    /** Number of undistributed prizes; for Telegram Premium giveaways only */
    unclaimed_prize_count: number,
  }

  export type messageGiftedStars = {
    /** Telegram Stars were gifted to a user */
    _: 'messageGiftedStars',
    /**
     * The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous
     * or is outgoing
     */
    gifter_user_id: number,
    /** The identifier of a user that received Telegram Stars; 0 if the gift is incoming */
    receiver_user_id: number,
    /** Currency for the paid amount */
    currency: string,
    /** The paid amount, in the smallest units of the currency */
    amount: number,
    /** Cryptocurrency used to pay for the gift; may be empty if none */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency; 0 if none */
    cryptocurrency_amount: string,
    /** Number of Telegram Stars that were gifted */
    star_count: number,
    /** Identifier of the transaction for Telegram Stars purchase; for receiver only */
    transaction_id: string,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  }

  export type messageGiveawayPrizeStars = {
    /** A Telegram Stars were received by the current user from a giveaway */
    _: 'messageGiveawayPrizeStars',
    /** Number of Telegram Stars that were received */
    star_count: number,
    /** Identifier of the transaction for Telegram Stars credit */
    transaction_id: string,
    /**
     * Identifier of the supergroup or channel chat, which was automatically boosted
     * by the winners of the giveaway
     */
    boosted_chat_id: number,
    /**
     * Identifier of the message with the giveaway in the boosted chat; can be 0 if
     * the message was deleted
     */
    giveaway_message_id: number,
    /**
     * True, if the corresponding winner wasn't chosen and the Telegram Stars were
     * received by the owner of the boosted chat
     */
    is_unclaimed: boolean,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  }

  export type messageGift = {
    /**
     * A regular gift was received or sent by the current user, or the current user
     * was notified about a channel gift
     */
    _: 'messageGift',
    /** The gift */
    gift: gift,
    /** Sender of the gift */
    sender_id: MessageSender,
    /** Receiver of the gift */
    receiver_id: MessageSender,
    /**
     * Unique identifier of the received gift for the current user; only for the receiver
     * of the gift
     */
    received_gift_id: string,
    /** Message added to the gift */
    text: formattedText,
    /**
     * Number of Telegram Stars that can be claimed by the receiver instead of the
     * regular gift; 0 if the gift can't be sold by the receiver
     */
    sell_star_count: number,
    /**
     * Number of Telegram Stars that were paid by the sender for the ability to upgrade
     * the gift
     */
    prepaid_upgrade_star_count: number,
    /**
     * True, if the sender and gift text are shown only to the gift receiver; otherwise,
     * everyone will be able to see them
     */
    is_private: boolean,
    /**
     * True, if the gift is displayed on the user's or the channel's profile page;
     * only for the receiver of the gift
     */
    is_saved: boolean,
    /**
     * True, if the gift can be upgraded to a unique gift; only for the receiver of
     * the gift
     */
    can_be_upgraded: boolean,
    /**
     * True, if the gift was converted to Telegram Stars; only for the receiver of
     * the gift
     */
    was_converted: boolean,
    /** True, if the gift was upgraded to a unique gift */
    was_upgraded: boolean,
    /** True, if the gift was refunded and isn't available anymore */
    was_refunded: boolean,
    /**
     * Identifier of the corresponding upgraded gift; may be empty if unknown. Use
     * getReceivedGift to get information about the gift
     */
    upgraded_received_gift_id: string,
  }

  export type messageUpgradedGift = {
    /**
     * An upgraded gift was received or sent by the current user, or the current user
     * was notified about a channel gift
     */
    _: 'messageUpgradedGift',
    /** The gift */
    gift: upgradedGift,
    /** Sender of the gift; may be null for anonymous gifts */
    sender_id?: MessageSender,
    /** Receiver of the gift */
    receiver_id: MessageSender,
    /**
     * Unique identifier of the received gift for the current user; only for the receiver
     * of the gift
     */
    received_gift_id: string,
    /**
     * True, if the gift was obtained by upgrading of a previously received gift; otherwise,
     * this is a transferred or resold gift
     */
    is_upgrade: boolean,
    /**
     * True, if the gift is displayed on the user's or the channel's profile page;
     * only for the receiver of the gift
     */
    is_saved: boolean,
    /**
     * True, if the gift can be transferred to another owner; only for the receiver
     * of the gift
     */
    can_be_transferred: boolean,
    /**
     * True, if the gift was transferred to another owner; only for the receiver of
     * the gift
     */
    was_transferred: boolean,
    /**
     * Number of Telegram Stars that were paid by the sender for the gift; 0 if the
     * gift was upgraded or transferred
     */
    last_resale_star_count: number,
    /**
     * Number of Telegram Stars that must be paid to transfer the upgraded gift; only
     * for the receiver of the gift
     */
    transfer_star_count: number,
    /**
     * Point in time (Unix timestamp) when the gift can be transferred to another owner;
     * 0 if the gift can be transferred immediately or transfer isn't possible; only
     * for the receiver of the gift
     */
    next_transfer_date: number,
    /**
     * Point in time (Unix timestamp) when the gift can be resold to another user;
     * 0 if the gift can't be resold; only for the receiver of the gift
     */
    next_resale_date: number,
    /**
     * Point in time (Unix timestamp) when the gift can be transferred to the TON blockchain
     * as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift
     */
    export_date: number,
  }

  export type messageRefundedUpgradedGift = {
    /** A gift which purchase, upgrade or transfer were refunded */
    _: 'messageRefundedUpgradedGift',
    /** The gift */
    gift: gift,
    /** Sender of the gift */
    sender_id: MessageSender,
    /** Receiver of the gift */
    receiver_id: MessageSender,
    /**
     * True, if the gift was obtained by upgrading of a previously received gift; otherwise,
     * this is a transferred or resold gift
     */
    is_upgrade: boolean,
  }

  export type messagePaidMessagesRefunded = {
    /** Paid messages were refunded */
    _: 'messagePaidMessagesRefunded',
    /** The number of refunded messages */
    message_count: number,
    /** The number of refunded Telegram Stars */
    star_count: number,
  }

  export type messagePaidMessagePriceChanged = {
    /** A price for paid messages was changed in the supergroup chat */
    _: 'messagePaidMessagePriceChanged',
    /**
     * The new number of Telegram Stars that must be paid by non-administrator users
     * of the supergroup chat for each sent message
     */
    paid_message_star_count: number,
  }

  export type messageDirectMessagePriceChanged = {
    /** A price for direct messages was changed in the channel chat */
    _: 'messageDirectMessagePriceChanged',
    /** True, if direct messages group was enabled for the channel; false otherwise */
    is_enabled: boolean,
    /**
     * The new number of Telegram Stars that must be paid by non-administrator users
     * of the channel chat for each message sent to the direct messages group; 0 if
     * the direct messages group was disabled or the messages are free
     */
    paid_message_star_count: number,
  }

  export type messageChecklistTasksDone = {
    /** Some tasks from a checklist were marked as done or not done */
    _: 'messageChecklistTasksDone',
    /** Identifier of the message with the checklist; can be 0 if the message was deleted */
    checklist_message_id: number,
    /** Identifiers of tasks that were marked as done */
    marked_as_done_task_ids: Array<number>,
    /** Identifiers of tasks that were marked as not done */
    marked_as_not_done_task_ids: Array<number>,
  }

  export type messageChecklistTasksAdded = {
    /** Some tasks were added to a checklist */
    _: 'messageChecklistTasksAdded',
    /** Identifier of the message with the checklist; can be 0 if the message was deleted */
    checklist_message_id: number,
    /** List of tasks added to the checklist */
    tasks: Array<checklistTask>,
  }

  export type messageContactRegistered = {
    /** A contact has registered with Telegram */
    _: 'messageContactRegistered',
  }

  export type messageUsersShared = {
    /** The current user shared users, which were requested by the bot */
    _: 'messageUsersShared',
    /** The shared users */
    users: Array<sharedUser>,
    /** Identifier of the keyboard button with the request */
    button_id: number,
  }

  export type messageChatShared = {
    /** The current user shared a chat, which was requested by the bot */
    _: 'messageChatShared',
    /** The shared chat */
    chat: sharedChat,
    /** Identifier of the keyboard button with the request */
    button_id: number,
  }

  export type messageBotWriteAccessAllowed = {
    /** The user allowed the bot to send messages */
    _: 'messageBotWriteAccessAllowed',
    /** The reason why the bot was allowed to write messages */
    reason: BotWriteAccessAllowReason,
  }

  export type messageWebAppDataSent = {
    /** Data from a Web App has been sent to a bot */
    _: 'messageWebAppDataSent',
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    button_text: string,
  }

  export type messageWebAppDataReceived = {
    /** Data from a Web App has been received; for bots only */
    _: 'messageWebAppDataReceived',
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    button_text: string,
    /** The data */
    data: string,
  }

  export type messagePassportDataSent = {
    /** Telegram Passport data has been sent to a bot */
    _: 'messagePassportDataSent',
    /** List of Telegram Passport element types sent */
    types: Array<PassportElementType>,
  }

  export type messagePassportDataReceived = {
    /** Telegram Passport data has been received; for bots only */
    _: 'messagePassportDataReceived',
    /** List of received Telegram Passport elements */
    elements: Array<encryptedPassportElement>,
    /** Encrypted data credentials */
    credentials: encryptedCredentials,
  }

  export type messageProximityAlertTriggered = {
    /** A user in the chat came within proximity alert range */
    _: 'messageProximityAlertTriggered',
    /** The identifier of a user or chat that triggered the proximity alert */
    traveler_id: MessageSender,
    /** The identifier of a user or chat that subscribed for the proximity alert */
    watcher_id: MessageSender,
    /** The distance between the users */
    distance: number,
  }

  export type messageUnsupported = {
    /** A message content that is not supported in the current TDLib version */
    _: 'messageUnsupported',
  }

  export type textEntityTypeMention = {
    /** A mention of a user, a supergroup, or a channel by their username */
    _: 'textEntityTypeMention',
  }

  export type textEntityTypeMention$Input = {
    /** A mention of a user, a supergroup, or a channel by their username */
    readonly _: 'textEntityTypeMention',
  }

  export type textEntityTypeHashtag = {
    /**
     * A hashtag text, beginning with "#" and optionally containing a chat username
     * at the end
     */
    _: 'textEntityTypeHashtag',
  }

  export type textEntityTypeHashtag$Input = {
    /**
     * A hashtag text, beginning with "#" and optionally containing a chat username
     * at the end
     */
    readonly _: 'textEntityTypeHashtag',
  }

  export type textEntityTypeCashtag = {
    /**
     * A cashtag text, beginning with "$", consisting of capital English letters (e.g.,
     * "$USD"), and optionally containing a chat username at the end
     */
    _: 'textEntityTypeCashtag',
  }

  export type textEntityTypeCashtag$Input = {
    /**
     * A cashtag text, beginning with "$", consisting of capital English letters (e.g.,
     * "$USD"), and optionally containing a chat username at the end
     */
    readonly _: 'textEntityTypeCashtag',
  }

  export type textEntityTypeBotCommand = {
    /** A bot command, beginning with "/" */
    _: 'textEntityTypeBotCommand',
  }

  export type textEntityTypeBotCommand$Input = {
    /** A bot command, beginning with "/" */
    readonly _: 'textEntityTypeBotCommand',
  }

  export type textEntityTypeUrl = {
    /** An HTTP URL */
    _: 'textEntityTypeUrl',
  }

  export type textEntityTypeUrl$Input = {
    /** An HTTP URL */
    readonly _: 'textEntityTypeUrl',
  }

  export type textEntityTypeEmailAddress = {
    /** An email address */
    _: 'textEntityTypeEmailAddress',
  }

  export type textEntityTypeEmailAddress$Input = {
    /** An email address */
    readonly _: 'textEntityTypeEmailAddress',
  }

  export type textEntityTypePhoneNumber = {
    /** A phone number */
    _: 'textEntityTypePhoneNumber',
  }

  export type textEntityTypePhoneNumber$Input = {
    /** A phone number */
    readonly _: 'textEntityTypePhoneNumber',
  }

  export type textEntityTypeBankCardNumber = {
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    _: 'textEntityTypeBankCardNumber',
  }

  export type textEntityTypeBankCardNumber$Input = {
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    readonly _: 'textEntityTypeBankCardNumber',
  }

  export type textEntityTypeBold = {
    /** A bold text */
    _: 'textEntityTypeBold',
  }

  export type textEntityTypeBold$Input = {
    /** A bold text */
    readonly _: 'textEntityTypeBold',
  }

  export type textEntityTypeItalic = {
    /** An italic text */
    _: 'textEntityTypeItalic',
  }

  export type textEntityTypeItalic$Input = {
    /** An italic text */
    readonly _: 'textEntityTypeItalic',
  }

  export type textEntityTypeUnderline = {
    /** An underlined text */
    _: 'textEntityTypeUnderline',
  }

  export type textEntityTypeUnderline$Input = {
    /** An underlined text */
    readonly _: 'textEntityTypeUnderline',
  }

  export type textEntityTypeStrikethrough = {
    /** A strikethrough text */
    _: 'textEntityTypeStrikethrough',
  }

  export type textEntityTypeStrikethrough$Input = {
    /** A strikethrough text */
    readonly _: 'textEntityTypeStrikethrough',
  }

  export type textEntityTypeSpoiler = {
    /** A spoiler text */
    _: 'textEntityTypeSpoiler',
  }

  export type textEntityTypeSpoiler$Input = {
    /** A spoiler text */
    readonly _: 'textEntityTypeSpoiler',
  }

  export type textEntityTypeCode = {
    /** Text that must be formatted as if inside a code HTML tag */
    _: 'textEntityTypeCode',
  }

  export type textEntityTypeCode$Input = {
    /** Text that must be formatted as if inside a code HTML tag */
    readonly _: 'textEntityTypeCode',
  }

  export type textEntityTypePre = {
    /** Text that must be formatted as if inside a pre HTML tag */
    _: 'textEntityTypePre',
  }

  export type textEntityTypePre$Input = {
    /** Text that must be formatted as if inside a pre HTML tag */
    readonly _: 'textEntityTypePre',
  }

  export type textEntityTypePreCode = {
    /** Text that must be formatted as if inside pre, and code HTML tags */
    _: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    language: string,
  }

  export type textEntityTypePreCode$Input = {
    /** Text that must be formatted as if inside pre, and code HTML tags */
    readonly _: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    readonly language?: string,
  }

  export type textEntityTypeBlockQuote = {
    /**
     * Text that must be formatted as if inside a blockquote HTML tag; not supported
     * in secret chats
     */
    _: 'textEntityTypeBlockQuote',
  }

  export type textEntityTypeBlockQuote$Input = {
    /**
     * Text that must be formatted as if inside a blockquote HTML tag; not supported
     * in secret chats
     */
    readonly _: 'textEntityTypeBlockQuote',
  }

  export type textEntityTypeExpandableBlockQuote = {
    /**
     * Text that must be formatted as if inside a blockquote HTML tag and collapsed
     * by default to 3 lines with the ability to show full text; not supported in secret
     * chats
     */
    _: 'textEntityTypeExpandableBlockQuote',
  }

  export type textEntityTypeExpandableBlockQuote$Input = {
    /**
     * Text that must be formatted as if inside a blockquote HTML tag and collapsed
     * by default to 3 lines with the ability to show full text; not supported in secret
     * chats
     */
    readonly _: 'textEntityTypeExpandableBlockQuote',
  }

  export type textEntityTypeTextUrl = {
    /** A text description shown instead of a raw URL */
    _: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    url: string,
  }

  export type textEntityTypeTextUrl$Input = {
    /** A text description shown instead of a raw URL */
    readonly _: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    readonly url?: string,
  }

  export type textEntityTypeMentionName = {
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    _: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    user_id: number,
  }

  export type textEntityTypeMentionName$Input = {
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    readonly _: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    readonly user_id?: number,
  }

  export type textEntityTypeCustomEmoji = {
    /**
     * A custom emoji. The text behind a custom emoji must be an emoji. Only premium
     * users can use premium custom emoji
     */
    _: 'textEntityTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    custom_emoji_id: string,
  }

  export type textEntityTypeCustomEmoji$Input = {
    /**
     * A custom emoji. The text behind a custom emoji must be an emoji. Only premium
     * users can use premium custom emoji
     */
    readonly _: 'textEntityTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    readonly custom_emoji_id?: number | string,
  }

  export type textEntityTypeMediaTimestamp = {
    /** A media timestamp */
    _: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note/story playing must
     * start, in seconds. The media can be in the content or the link preview of the
     * current message, or in the same places in the replied message
     */
    media_timestamp: number,
  }

  export type textEntityTypeMediaTimestamp$Input = {
    /** A media timestamp */
    readonly _: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note/story playing must
     * start, in seconds. The media can be in the content or the link preview of the
     * current message, or in the same places in the replied message
     */
    readonly media_timestamp?: number,
  }

  export type inputThumbnail = {
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    _: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    thumbnail: InputFile,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    width: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    height: number,
  }

  export type inputThumbnail$Input = {
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    readonly _: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    readonly thumbnail?: InputFile$Input,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    readonly width?: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    readonly height?: number,
  }

  export type inputPaidMediaTypePhoto = {
    /**
     * The media is a photo. The photo must be at most 10 MB in size. The photo's width
     * and height must not exceed 10000 in total. Width and height ratio must be at
     * most 20
     */
    _: 'inputPaidMediaTypePhoto',
  }

  export type inputPaidMediaTypePhoto$Input = {
    /**
     * The media is a photo. The photo must be at most 10 MB in size. The photo's width
     * and height must not exceed 10000 in total. Width and height ratio must be at
     * most 20
     */
    readonly _: 'inputPaidMediaTypePhoto',
  }

  export type inputPaidMediaTypeVideo = {
    /** The media is a video */
    _: 'inputPaidMediaTypeVideo',
    /** Cover of the video; pass null to skip cover uploading */
    cover: InputFile,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
    /** Duration of the video, in seconds */
    duration: number,
    /** True, if the video is expected to be streamed */
    supports_streaming: boolean,
  }

  export type inputPaidMediaTypeVideo$Input = {
    /** The media is a video */
    readonly _: 'inputPaidMediaTypeVideo',
    /** Cover of the video; pass null to skip cover uploading */
    readonly cover?: InputFile$Input,
    /** Timestamp from which the video playing must start, in seconds */
    readonly start_timestamp?: number,
    /** Duration of the video, in seconds */
    readonly duration?: number,
    /** True, if the video is expected to be streamed */
    readonly supports_streaming?: boolean,
  }

  export type inputPaidMedia = {
    /** Describes a paid media to be sent */
    _: 'inputPaidMedia',
    /** Type of the media */
    type: InputPaidMediaType,
    /** Photo or video to be sent */
    media: InputFile,
    /** Media thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the media, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Media width */
    width: number,
    /** Media height */
    height: number,
  }

  export type inputPaidMedia$Input = {
    /** Describes a paid media to be sent */
    readonly _: 'inputPaidMedia',
    /** Type of the media */
    readonly type?: InputPaidMediaType$Input,
    /** Photo or video to be sent */
    readonly media?: InputFile$Input,
    /** Media thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the media, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Media width */
    readonly width?: number,
    /** Media height */
    readonly height?: number,
  }

  export type messageSchedulingStateSendAtDate = {
    /** The message will be sent at the specified date */
    _: 'messageSchedulingStateSendAtDate',
    /**
     * Point in time (Unix timestamp) when the message will be sent. The date must
     * be within 367 days in the future
     */
    send_date: number,
  }

  export type messageSchedulingStateSendAtDate$Input = {
    /** The message will be sent at the specified date */
    readonly _: 'messageSchedulingStateSendAtDate',
    /**
     * Point in time (Unix timestamp) when the message will be sent. The date must
     * be within 367 days in the future
     */
    readonly send_date?: number,
  }

  export type messageSchedulingStateSendWhenOnline = {
    /**
     * The message will be sent when the other user is online. Applicable to private
     * chats only and when the exact online status of the other user is known
     */
    _: 'messageSchedulingStateSendWhenOnline',
  }

  export type messageSchedulingStateSendWhenOnline$Input = {
    /**
     * The message will be sent when the other user is online. Applicable to private
     * chats only and when the exact online status of the other user is known
     */
    readonly _: 'messageSchedulingStateSendWhenOnline',
  }

  export type messageSchedulingStateSendWhenVideoProcessed = {
    /**
     * The message will be sent when the video in the message is converted and optimized;
     * can be used only by the server
     */
    _: 'messageSchedulingStateSendWhenVideoProcessed',
    /**
     * Approximate point in time (Unix timestamp) when the message is expected to be
     * sent
     */
    send_date: number,
  }

  export type messageSchedulingStateSendWhenVideoProcessed$Input = {
    /**
     * The message will be sent when the video in the message is converted and optimized;
     * can be used only by the server
     */
    readonly _: 'messageSchedulingStateSendWhenVideoProcessed',
    /**
     * Approximate point in time (Unix timestamp) when the message is expected to be
     * sent
     */
    readonly send_date?: number,
  }

  export type messageSelfDestructTypeTimer = {
    /**
     * The message will be self-destructed in the specified time after its content
     * was opened
     */
    _: 'messageSelfDestructTypeTimer',
    /**
     * The message's self-destruct time, in seconds; must be between 0 and 60 in private
     * chats
     */
    self_destruct_time: number,
  }

  export type messageSelfDestructTypeTimer$Input = {
    /**
     * The message will be self-destructed in the specified time after its content
     * was opened
     */
    readonly _: 'messageSelfDestructTypeTimer',
    /**
     * The message's self-destruct time, in seconds; must be between 0 and 60 in private
     * chats
     */
    readonly self_destruct_time?: number,
  }

  export type messageSelfDestructTypeImmediately = {
    /** The message can be opened only once and will be self-destructed once closed */
    _: 'messageSelfDestructTypeImmediately',
  }

  export type messageSelfDestructTypeImmediately$Input = {
    /** The message can be opened only once and will be self-destructed once closed */
    readonly _: 'messageSelfDestructTypeImmediately',
  }

  export type messageSendOptions$Input = {
    /** Options to be used when a message is sent */
    readonly _: 'messageSendOptions',
    /**
     * Unique identifier of the topic in a channel direct messages chat administered
     * by the current user; pass 0 if the chat isn't a channel direct messages chat
     * administered by the current user
     */
    readonly direct_messages_chat_topic_id?: number,
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /** Pass true if the message is sent from the background */
    readonly from_background?: boolean,
    /**
     * Pass true if the content of the message must be protected from forwarding and
     * saving; for bots only
     */
    readonly protect_content?: boolean,
    /**
     * Pass true to allow the message to ignore regular broadcast limits for a small
     * fee; for bots only
     */
    readonly allow_paid_broadcast?: boolean,
    /** The number of Telegram Stars the user agreed to pay to send the messages */
    readonly paid_message_star_count?: number,
    /**
     * Pass true if the user explicitly chosen a sticker or a custom emoji from an
     * installed sticker set; applicable only to sendMessage and sendMessageAlbum
     */
    readonly update_order_of_installed_sticker_sets?: boolean,
    /**
     * Message scheduling state; pass null to send message immediately. Messages sent
     * to a secret chat, to a chat with paid messages, to a channel direct messages
     * chat, live location messages and self-destructing messages can't be scheduled
     */
    readonly scheduling_state?: MessageSchedulingState$Input,
    /**
     * Identifier of the effect to apply to the message; pass 0 if none; applicable
     * only to sendMessage and sendMessageAlbum in private chats
     */
    readonly effect_id?: number | string,
    /**
     * Non-persistent identifier, which will be returned back in messageSendingStatePending
     * object and can be used to match sent messages and corresponding updateNewMessage
     * updates
     */
    readonly sending_id?: number,
    /** Pass true to get a fake message instead of actually sending them */
    readonly only_preview?: boolean,
  }

  export type messageCopyOptions = {
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages, messages with messageInvoice, messagePaidMedia,
     * messageGiveaway, or messageGiveawayWinners content can't be copied
     */
    _: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local. Use messageProperties.can_be_copied and messageProperties.can_be_copied_to_secret_chat
     * to check whether the message is suitable
     */
    send_copy: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    replace_caption: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    new_caption: formattedText,
    /**
     * True, if new caption must be shown above the media; otherwise, new caption must
     * be shown below the media; not supported in secret chats. Ignored if replace_caption
     * is false
     */
    new_show_caption_above_media: boolean,
  }

  export type messageCopyOptions$Input = {
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages, messages with messageInvoice, messagePaidMedia,
     * messageGiveaway, or messageGiveawayWinners content can't be copied
     */
    readonly _: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local. Use messageProperties.can_be_copied and messageProperties.can_be_copied_to_secret_chat
     * to check whether the message is suitable
     */
    readonly send_copy?: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    readonly replace_caption?: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    readonly new_caption?: formattedText$Input,
    /**
     * True, if new caption must be shown above the media; otherwise, new caption must
     * be shown below the media; not supported in secret chats. Ignored if replace_caption
     * is false
     */
    readonly new_show_caption_above_media?: boolean,
  }

  export type inputMessageText = {
    /** A text message */
    _: 'inputMessageText',
    /**
     * Formatted text to be sent; 0-getOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote,
     * ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are
     * allowed to be specified manually
     */
    text: formattedText,
    /**
     * Options to be used for generation of a link preview; may be null if none; pass
     * null to use default link preview options
     */
    link_preview_options?: linkPreviewOptions,
    /** True, if a chat message draft must be deleted */
    clear_draft: boolean,
  }

  export type inputMessageText$Input = {
    /** A text message */
    readonly _: 'inputMessageText',
    /**
     * Formatted text to be sent; 0-getOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote,
     * ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are
     * allowed to be specified manually
     */
    readonly text?: formattedText$Input,
    /**
     * Options to be used for generation of a link preview; may be null if none; pass
     * null to use default link preview options
     */
    readonly link_preview_options?: linkPreviewOptions$Input,
    /** True, if a chat message draft must be deleted */
    readonly clear_draft?: boolean,
  }

  export type inputMessageAnimation = {
    /** An animation message (GIF-style). */
    _: 'inputMessageAnimation',
    /** Animation file to be sent */
    animation: InputFile,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the animation, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the animation, in seconds */
    duration: number,
    /** Width of the animation; may be replaced by the server */
    width: number,
    /** Height of the animation; may be replaced by the server */
    height: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the animation; otherwise, the caption
     * must be shown below the animation; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /**
     * True, if the animation preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  }

  export type inputMessageAnimation$Input = {
    /** An animation message (GIF-style). */
    readonly _: 'inputMessageAnimation',
    /** Animation file to be sent */
    readonly animation?: InputFile$Input,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the animation, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Duration of the animation, in seconds */
    readonly duration?: number,
    /** Width of the animation; may be replaced by the server */
    readonly width?: number,
    /** Height of the animation; may be replaced by the server */
    readonly height?: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the animation; otherwise, the caption
     * must be shown below the animation; not supported in secret chats
     */
    readonly show_caption_above_media?: boolean,
    /**
     * True, if the animation preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    readonly has_spoiler?: boolean,
  }

  export type inputMessageAudio = {
    /** An audio message */
    _: 'inputMessageAudio',
    /** Audio file to be sent */
    audio: InputFile,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    album_cover_thumbnail: inputThumbnail,
    /** Duration of the audio, in seconds; may be replaced by the server */
    duration: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    title: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    performer: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageAudio$Input = {
    /** An audio message */
    readonly _: 'inputMessageAudio',
    /** Audio file to be sent */
    readonly audio?: InputFile$Input,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    readonly album_cover_thumbnail?: inputThumbnail$Input,
    /** Duration of the audio, in seconds; may be replaced by the server */
    readonly duration?: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    readonly title?: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    readonly performer?: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessageDocument = {
    /** A document message (general file) */
    _: 'inputMessageDocument',
    /** Document to be sent */
    document: InputFile,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /**
     * Pass true to disable automatic file type detection and send the document as
     * a file. Always true for files sent to secret chats
     */
    disable_content_type_detection: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageDocument$Input = {
    /** A document message (general file) */
    readonly _: 'inputMessageDocument',
    /** Document to be sent */
    readonly document?: InputFile$Input,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /**
     * Pass true to disable automatic file type detection and send the document as
     * a file. Always true for files sent to secret chats
     */
    readonly disable_content_type_detection?: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessagePaidMedia = {
    /** A message with paid media; can be used only in channel chats with supergroupFullInfo.has_paid_media_allowed */
    _: 'inputMessagePaidMedia',
    /** The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max") */
    star_count: number,
    /** The content of the paid media */
    paid_media: Array<inputPaidMedia>,
    /**
     * Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the media; otherwise, the caption must
     * be shown below the media; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /** Bot-provided data for the paid media; bots only */
    payload: string,
  }

  export type inputMessagePaidMedia$Input = {
    /** A message with paid media; can be used only in channel chats with supergroupFullInfo.has_paid_media_allowed */
    readonly _: 'inputMessagePaidMedia',
    /** The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max") */
    readonly star_count?: number,
    /** The content of the paid media */
    readonly paid_media?: ReadonlyArray<inputPaidMedia$Input>,
    /**
     * Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the media; otherwise, the caption must
     * be shown below the media; not supported in secret chats
     */
    readonly show_caption_above_media?: boolean,
    /** Bot-provided data for the paid media; bots only */
    readonly payload?: string,
  }

  export type inputMessagePhoto = {
    /** A photo message */
    _: 'inputMessagePhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo's width and
     * height must not exceed 10000 in total. Width and height ratio must be at most
     * 20
     */
    photo: InputFile,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the photo, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Photo width */
    width: number,
    /** Photo height */
    height: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the photo; otherwise, the caption must
     * be shown below the photo; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /** Photo self-destruct type; pass null if none; private chats only */
    self_destruct_type: MessageSelfDestructType,
    /**
     * True, if the photo preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  }

  export type inputMessagePhoto$Input = {
    /** A photo message */
    readonly _: 'inputMessagePhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo's width and
     * height must not exceed 10000 in total. Width and height ratio must be at most
     * 20
     */
    readonly photo?: InputFile$Input,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the photo, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Photo width */
    readonly width?: number,
    /** Photo height */
    readonly height?: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the photo; otherwise, the caption must
     * be shown below the photo; not supported in secret chats
     */
    readonly show_caption_above_media?: boolean,
    /** Photo self-destruct type; pass null if none; private chats only */
    readonly self_destruct_type?: MessageSelfDestructType$Input,
    /**
     * True, if the photo preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    readonly has_spoiler?: boolean,
  }

  export type inputMessageSticker = {
    /** A sticker message */
    _: 'inputMessageSticker',
    /** Sticker to be sent */
    sticker: InputFile,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** Sticker width */
    width: number,
    /** Sticker height */
    height: number,
    /** Emoji used to choose the sticker */
    emoji: string,
  }

  export type inputMessageSticker$Input = {
    /** A sticker message */
    readonly _: 'inputMessageSticker',
    /** Sticker to be sent */
    readonly sticker?: InputFile$Input,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** Sticker width */
    readonly width?: number,
    /** Sticker height */
    readonly height?: number,
    /** Emoji used to choose the sticker */
    readonly emoji?: string,
  }

  export type inputMessageVideo = {
    /** A video message */
    _: 'inputMessageVideo',
    /**
     * Video to be sent. The video is expected to be re-encoded to MPEG4 format with
     * H.264 codec by the sender
     */
    video: InputFile,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /**
     * Cover of the video; pass null to skip cover uploading; not supported in secret
     * chats and for self-destructing messages
     */
    cover: InputFile,
    /** Timestamp from which the video playing must start, in seconds */
    start_timestamp: number,
    /** File identifiers of the stickers added to the video, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /** True, if the video is expected to be streamed */
    supports_streaming: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the caption must be shown above the video; otherwise, the caption must
     * be shown below the video; not supported in secret chats
     */
    show_caption_above_media: boolean,
    /** Video self-destruct type; pass null if none; private chats only */
    self_destruct_type: MessageSelfDestructType,
    /**
     * True, if the video preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  }

  export type inputMessageVideo$Input = {
    /** A video message */
    readonly _: 'inputMessageVideo',
    /**
     * Video to be sent. The video is expected to be re-encoded to MPEG4 format with
     * H.264 codec by the sender
     */
    readonly video?: InputFile$Input,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /**
     * Cover of the video; pass null to skip cover uploading; not supported in secret
     * chats and for self-destructing messages
     */
    readonly cover?: InputFile$Input,
    /** Timestamp from which the video playing must start, in seconds */
    readonly start_timestamp?: number,
    /** File identifiers of the stickers added to the video, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Duration of the video, in seconds */
    readonly duration?: number,
    /** Video width */
    readonly width?: number,
    /** Video height */
    readonly height?: number,
    /** True, if the video is expected to be streamed */
    readonly supports_streaming?: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * True, if the caption must be shown above the video; otherwise, the caption must
     * be shown below the video; not supported in secret chats
     */
    readonly show_caption_above_media?: boolean,
    /** Video self-destruct type; pass null if none; private chats only */
    readonly self_destruct_type?: MessageSelfDestructType$Input,
    /**
     * True, if the video preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    readonly has_spoiler?: boolean,
  }

  export type inputMessageVideoNote = {
    /** A video note message */
    _: 'inputMessageVideoNote',
    /**
     * Video note to be sent. The video is expected to be encoded to MPEG4 format with
     * H.264 codec and have no data outside of the visible circle
     */
    video_note: InputFile,
    /** Video thumbnail; may be null if empty; pass null to skip thumbnail uploading */
    thumbnail?: inputThumbnail,
    /** Duration of the video, in seconds; 0-60 */
    duration: number,
    /** Video width and height; must be positive and not greater than 640 */
    length: number,
    /**
     * Video note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    self_destruct_type?: MessageSelfDestructType,
  }

  export type inputMessageVideoNote$Input = {
    /** A video note message */
    readonly _: 'inputMessageVideoNote',
    /**
     * Video note to be sent. The video is expected to be encoded to MPEG4 format with
     * H.264 codec and have no data outside of the visible circle
     */
    readonly video_note?: InputFile$Input,
    /** Video thumbnail; may be null if empty; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** Duration of the video, in seconds; 0-60 */
    readonly duration?: number,
    /** Video width and height; must be positive and not greater than 640 */
    readonly length?: number,
    /**
     * Video note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    readonly self_destruct_type?: MessageSelfDestructType$Input,
  }

  export type inputMessageVoiceNote = {
    /** A voice note message */
    _: 'inputMessageVoiceNote',
    /**
     * Voice note to be sent. The voice note must be encoded with the Opus codec and
     * stored inside an OGG container with a single audio channel, or be in MP3 or
     * M4A format as regular audio
     */
    voice_note: InputFile,
    /** Duration of the voice note, in seconds */
    duration: number,
    /** Waveform representation of the voice note in 5-bit format */
    waveform: string /* base64 */,
    /**
     * Voice note caption; may be null if empty; pass null to use an empty caption;
     * 0-getOption("message_caption_length_max") characters
     */
    caption?: formattedText,
    /**
     * Voice note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    self_destruct_type?: MessageSelfDestructType,
  }

  export type inputMessageVoiceNote$Input = {
    /** A voice note message */
    readonly _: 'inputMessageVoiceNote',
    /**
     * Voice note to be sent. The voice note must be encoded with the Opus codec and
     * stored inside an OGG container with a single audio channel, or be in MP3 or
     * M4A format as regular audio
     */
    readonly voice_note?: InputFile$Input,
    /** Duration of the voice note, in seconds */
    readonly duration?: number,
    /** Waveform representation of the voice note in 5-bit format */
    readonly waveform?: string /* base64 */,
    /**
     * Voice note caption; may be null if empty; pass null to use an empty caption;
     * 0-getOption("message_caption_length_max") characters
     */
    readonly caption?: formattedText$Input,
    /**
     * Voice note self-destruct type; may be null if none; pass null if none; private
     * chats only
     */
    readonly self_destruct_type?: MessageSelfDestructType$Input,
  }

  export type inputMessageLocation = {
    /** A message with a location */
    _: 'inputMessageLocation',
    /** Location to be sent */
    location: location,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location,
     * and 0 otherwise
     */
    live_period: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    proximity_alert_radius: number,
  }

  export type inputMessageLocation$Input = {
    /** A message with a location */
    readonly _: 'inputMessageLocation',
    /** Location to be sent */
    readonly location?: location$Input,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location,
     * and 0 otherwise
     */
    readonly live_period?: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    readonly heading?: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    readonly proximity_alert_radius?: number,
  }

  export type inputMessageVenue = {
    /** A message with information about a venue */
    _: 'inputMessageVenue',
    /** Venue to send */
    venue: venue,
  }

  export type inputMessageVenue$Input = {
    /** A message with information about a venue */
    readonly _: 'inputMessageVenue',
    /** Venue to send */
    readonly venue?: venue$Input,
  }

  export type inputMessageContact = {
    /** A message containing a user contact */
    _: 'inputMessageContact',
    /** Contact to send */
    contact: contact,
  }

  export type inputMessageContact$Input = {
    /** A message containing a user contact */
    readonly _: 'inputMessageContact',
    /** Contact to send */
    readonly contact?: contact$Input,
  }

  export type inputMessageDice = {
    /** A dice message */
    _: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** True, if the chat message draft must be deleted */
    clear_draft: boolean,
  }

  export type inputMessageDice$Input = {
    /** A dice message */
    readonly _: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    readonly emoji?: string,
    /** True, if the chat message draft must be deleted */
    readonly clear_draft?: boolean,
  }

  export type inputMessageGame = {
    /** A message with a game; not supported for channels or secret chats */
    _: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    bot_user_id: number,
    /** Short name of the game */
    game_short_name: string,
  }

  export type inputMessageGame$Input = {
    /** A message with a game; not supported for channels or secret chats */
    readonly _: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    readonly bot_user_id?: number,
    /** Short name of the game */
    readonly game_short_name?: string,
  }

  export type inputMessageInvoice = {
    /** A message with an invoice; can be used only by bots */
    _: 'inputMessageInvoice',
    /** Invoice */
    invoice: invoice,
    /** Product title; 1-32 characters */
    title: string,
    /** Product description; 0-255 characters */
    description: string,
    /** Product photo URL; optional */
    photo_url: string,
    /** Product photo size */
    photo_size: number,
    /** Product photo width */
    photo_width: number,
    /** Product photo height */
    photo_height: number,
    /** The invoice payload */
    payload: string /* base64 */,
    /** Payment provider token; may be empty for payments in Telegram Stars */
    provider_token: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    provider_data: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    start_parameter: string,
    /** The content of paid media attached to the invoice; pass null if none */
    paid_media: inputPaidMedia,
    /**
     * Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    paid_media_caption: formattedText,
  }

  export type inputMessageInvoice$Input = {
    /** A message with an invoice; can be used only by bots */
    readonly _: 'inputMessageInvoice',
    /** Invoice */
    readonly invoice?: invoice$Input,
    /** Product title; 1-32 characters */
    readonly title?: string,
    /** Product description; 0-255 characters */
    readonly description?: string,
    /** Product photo URL; optional */
    readonly photo_url?: string,
    /** Product photo size */
    readonly photo_size?: number,
    /** Product photo width */
    readonly photo_width?: number,
    /** Product photo height */
    readonly photo_height?: number,
    /** The invoice payload */
    readonly payload?: string /* base64 */,
    /** Payment provider token; may be empty for payments in Telegram Stars */
    readonly provider_token?: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    readonly provider_data?: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    readonly start_parameter?: string,
    /** The content of paid media attached to the invoice; pass null if none */
    readonly paid_media?: inputPaidMedia$Input,
    /**
     * Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly paid_media_caption?: formattedText$Input,
  }

  export type inputMessagePoll = {
    /**
     * A message with a poll. Polls can't be sent to secret chats and channel direct
     * messages chats. Polls can be sent to a private chat only if the chat is a chat
     * with a bot or the Saved Messages chat
     */
    _: 'inputMessagePoll',
    /**
     * Poll question; 1-255 characters (up to 300 characters for bots). Only custom
     * emoji entities are allowed to be added and only by Premium users
     */
    question: formattedText,
    /**
     * List of poll answer options, 2-getOption("poll_answer_count_max") strings 1-100
     * characters each. Only custom emoji entities are allowed to be added and only
     * by Premium users
     */
    options: Array<formattedText>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    open_period: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    close_date: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    is_closed: boolean,
  }

  export type inputMessagePoll$Input = {
    /**
     * A message with a poll. Polls can't be sent to secret chats and channel direct
     * messages chats. Polls can be sent to a private chat only if the chat is a chat
     * with a bot or the Saved Messages chat
     */
    readonly _: 'inputMessagePoll',
    /**
     * Poll question; 1-255 characters (up to 300 characters for bots). Only custom
     * emoji entities are allowed to be added and only by Premium users
     */
    readonly question?: formattedText$Input,
    /**
     * List of poll answer options, 2-getOption("poll_answer_count_max") strings 1-100
     * characters each. Only custom emoji entities are allowed to be added and only
     * by Premium users
     */
    readonly options?: ReadonlyArray<formattedText$Input>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    readonly is_anonymous?: boolean,
    /** Type of the poll */
    readonly type?: PollType$Input,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    readonly open_period?: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    readonly close_date?: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    readonly is_closed?: boolean,
  }

  export type inputMessageStory = {
    /**
     * A message with a forwarded story. Stories can't be forwarded to secret chats.
     * A story can be forwarded only if story.can_be_forwarded
     */
    _: 'inputMessageStory',
    /** Identifier of the chat that posted the story */
    story_poster_chat_id: number,
    /** Story identifier */
    story_id: number,
  }

  export type inputMessageStory$Input = {
    /**
     * A message with a forwarded story. Stories can't be forwarded to secret chats.
     * A story can be forwarded only if story.can_be_forwarded
     */
    readonly _: 'inputMessageStory',
    /** Identifier of the chat that posted the story */
    readonly story_poster_chat_id?: number,
    /** Story identifier */
    readonly story_id?: number,
  }

  export type inputMessageChecklist = {
    /**
     * A message with a checklist. Checklists can't be sent to secret chats, channel
     * chats and channel direct messages chats; for Telegram Premium users only
     */
    _: 'inputMessageChecklist',
    /** The checklist to send */
    checklist: inputChecklist,
  }

  export type inputMessageChecklist$Input = {
    /**
     * A message with a checklist. Checklists can't be sent to secret chats, channel
     * chats and channel direct messages chats; for Telegram Premium users only
     */
    readonly _: 'inputMessageChecklist',
    /** The checklist to send */
    readonly checklist?: inputChecklist$Input,
  }

  export type inputMessageForwarded = {
    /** A forwarded message */
    _: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    from_chat_id: number,
    /** Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded */
    message_id: number,
    /**
     * Pass true if a game message is being shared from a launched game; applies only
     * to game messages
     */
    in_game_share: boolean,
    /** Pass true to replace video start timestamp in the forwarded message */
    replace_video_start_timestamp: boolean,
    /** The new video start timestamp; ignored if replace_video_start_timestamp == false */
    new_video_start_timestamp: number,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    copy_options: messageCopyOptions,
  }

  export type inputMessageForwarded$Input = {
    /** A forwarded message */
    readonly _: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    readonly from_chat_id?: number,
    /** Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded */
    readonly message_id?: number,
    /**
     * Pass true if a game message is being shared from a launched game; applies only
     * to game messages
     */
    readonly in_game_share?: boolean,
    /** Pass true to replace video start timestamp in the forwarded message */
    readonly replace_video_start_timestamp?: boolean,
    /** The new video start timestamp; ignored if replace_video_start_timestamp == false */
    readonly new_video_start_timestamp?: number,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    readonly copy_options?: messageCopyOptions$Input,
  }

  export type messageProperties = {
    /**
     * Contains properties of a message and describes actions that can be done with
     * the message right now
     */
    _: 'messageProperties',
    /**
     * True, if tasks can be added to the message's checklist using addChecklistTasks
     * if the current user has Telegram Premium subscription
     */
    can_add_tasks: boolean,
    /**
     * True, if content of the message can be copied using inputMessageForwarded or
     * forwardMessages with copy options
     */
    can_be_copied: boolean,
    /**
     * True, if content of the message can be copied to a secret chat using inputMessageForwarded
     * or forwardMessages with copy options
     */
    can_be_copied_to_secret_chat: boolean,
    /**
     * True, if the message can be deleted only for the current user while other users
     * will continue to see it using the method deleteMessages with revoke == false
     */
    can_be_deleted_only_for_self: boolean,
    /**
     * True, if the message can be deleted for all users using the method deleteMessages
     * with revoke == true
     */
    can_be_deleted_for_all_users: boolean,
    /**
     * True, if the message can be edited using the methods editMessageText, editMessageCaption,
     * or editMessageReplyMarkup. For live location, poll, and checklist messages this
     * fields shows whether editMessageLiveLocation, stopPoll, or editMessageChecklist
     * respectively can be used with this message
     */
    can_be_edited: boolean,
    /**
     * True, if the message can be forwarded using inputMessageForwarded or forwardMessages
     * without copy options
     */
    can_be_forwarded: boolean,
    /** True, if the message can be paid using inputInvoiceMessage */
    can_be_paid: boolean,
    /**
     * True, if the message can be pinned or unpinned in the chat using pinChatMessage
     * or unpinChatMessage
     */
    can_be_pinned: boolean,
    /** True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage */
    can_be_replied: boolean,
    /** True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage */
    can_be_replied_in_another_chat: boolean,
    /** True, if content of the message can be saved locally */
    can_be_saved: boolean,
    /** True, if the message can be shared in a story using inputStoryAreaTypeMessage */
    can_be_shared_in_story: boolean,
    /** True, if the message can be edited using the method editMessageMedia */
    can_edit_media: boolean,
    /** True, if scheduling state of the message can be edited */
    can_edit_scheduling_state: boolean,
    /**
     * True, if author of the message sent on behalf of a chat can be received through
     * getMessageAuthor
     */
    can_get_author: boolean,
    /** True, if code for message embedding can be received using getMessageEmbeddingCode */
    can_get_embedding_code: boolean,
    /** True, if a link can be generated for the message using getMessageLink */
    can_get_link: boolean,
    /**
     * True, if media timestamp links can be generated for media timestamp entities
     * in the message text, caption or link preview description using getMessageLink
     */
    can_get_media_timestamp_links: boolean,
    /**
     * True, if information about the message thread is available through getMessageThread
     * and getMessageThreadHistory
     */
    can_get_message_thread: boolean,
    /** True, if read date of the message can be received through getMessageReadDate */
    can_get_read_date: boolean,
    /**
     * True, if message statistics are available through getMessageStatistics and message
     * forwards can be received using getMessagePublicForwards
     */
    can_get_statistics: boolean,
    /** True, if advertisements for video of the message can be received though getVideoMessageAdvertisements */
    can_get_video_advertisements: boolean,
    /** True, if chat members already viewed the message can be received through getMessageViewers */
    can_get_viewers: boolean,
    /**
     * True, if tasks can be marked as done or not done in the message's checklist
     * using markChecklistTasksAsDone if the current user has Telegram Premium subscription
     */
    can_mark_tasks_as_done: boolean,
    /** True, if speech can be recognized for the message through recognizeSpeech */
    can_recognize_speech: boolean,
    /** True, if the message can be reported using reportChat */
    can_report_chat: boolean,
    /** True, if reactions on the message can be reported through reportMessageReactions */
    can_report_reactions: boolean,
    /** True, if the message can be reported using reportSupergroupSpam */
    can_report_supergroup_spam: boolean,
    /** True, if fact check for the message can be changed through setMessageFactCheck */
    can_set_fact_check: boolean,
    /** True, if message statistics must be available from context menu of the message */
    need_show_statistics: boolean,
  }

  export type searchMessagesFilterEmpty$Input = {
    /** Returns all found messages, no filter is applied */
    readonly _: 'searchMessagesFilterEmpty',
  }

  export type searchMessagesFilterAnimation$Input = {
    /** Returns only animation messages */
    readonly _: 'searchMessagesFilterAnimation',
  }

  export type searchMessagesFilterAudio$Input = {
    /** Returns only audio messages */
    readonly _: 'searchMessagesFilterAudio',
  }

  export type searchMessagesFilterDocument$Input = {
    /** Returns only document messages */
    readonly _: 'searchMessagesFilterDocument',
  }

  export type searchMessagesFilterPhoto$Input = {
    /** Returns only photo messages */
    readonly _: 'searchMessagesFilterPhoto',
  }

  export type searchMessagesFilterVideo$Input = {
    /** Returns only video messages */
    readonly _: 'searchMessagesFilterVideo',
  }

  export type searchMessagesFilterVoiceNote$Input = {
    /** Returns only voice note messages */
    readonly _: 'searchMessagesFilterVoiceNote',
  }

  export type searchMessagesFilterPhotoAndVideo$Input = {
    /** Returns only photo and video messages */
    readonly _: 'searchMessagesFilterPhotoAndVideo',
  }

  export type searchMessagesFilterUrl$Input = {
    /** Returns only messages containing URLs */
    readonly _: 'searchMessagesFilterUrl',
  }

  export type searchMessagesFilterChatPhoto$Input = {
    /** Returns only messages containing chat photos */
    readonly _: 'searchMessagesFilterChatPhoto',
  }

  export type searchMessagesFilterVideoNote$Input = {
    /** Returns only video note messages */
    readonly _: 'searchMessagesFilterVideoNote',
  }

  export type searchMessagesFilterVoiceAndVideoNote$Input = {
    /** Returns only voice and video note messages */
    readonly _: 'searchMessagesFilterVoiceAndVideoNote',
  }

  export type searchMessagesFilterMention$Input = {
    /**
     * Returns only messages with mentions of the current user, or messages that are
     * replies to their messages
     */
    readonly _: 'searchMessagesFilterMention',
  }

  export type searchMessagesFilterUnreadMention$Input = {
    /**
     * Returns only messages with unread mentions of the current user, or messages
     * that are replies to their messages. When using this filter the results can't
     * be additionally filtered by a query, a message thread or by the sending user
     */
    readonly _: 'searchMessagesFilterUnreadMention',
  }

  export type searchMessagesFilterUnreadReaction$Input = {
    /**
     * Returns only messages with unread reactions for the current user. When using
     * this filter the results can't be additionally filtered by a query, a message
     * thread or by the sending user
     */
    readonly _: 'searchMessagesFilterUnreadReaction',
  }

  export type searchMessagesFilterFailedToSend$Input = {
    /**
     * Returns only failed to send messages. This filter can be used only if the message
     * database is used
     */
    readonly _: 'searchMessagesFilterFailedToSend',
  }

  export type searchMessagesFilterPinned$Input = {
    /** Returns only pinned messages */
    readonly _: 'searchMessagesFilterPinned',
  }

  export type searchMessagesChatTypeFilterPrivate$Input = {
    /** Returns only messages in private chats */
    readonly _: 'searchMessagesChatTypeFilterPrivate',
  }

  export type searchMessagesChatTypeFilterGroup$Input = {
    /** Returns only messages in basic group and supergroup chats */
    readonly _: 'searchMessagesChatTypeFilterGroup',
  }

  export type searchMessagesChatTypeFilterChannel$Input = {
    /** Returns only messages in channel chats */
    readonly _: 'searchMessagesChatTypeFilterChannel',
  }

  export type chatActionTyping = {
    /** The user is typing a message */
    _: 'chatActionTyping',
  }

  export type chatActionTyping$Input = {
    /** The user is typing a message */
    readonly _: 'chatActionTyping',
  }

  export type chatActionRecordingVideo = {
    /** The user is recording a video */
    _: 'chatActionRecordingVideo',
  }

  export type chatActionRecordingVideo$Input = {
    /** The user is recording a video */
    readonly _: 'chatActionRecordingVideo',
  }

  export type chatActionUploadingVideo = {
    /** The user is uploading a video */
    _: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVideo$Input = {
    /** The user is uploading a video */
    readonly _: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionRecordingVoiceNote = {
    /** The user is recording a voice note */
    _: 'chatActionRecordingVoiceNote',
  }

  export type chatActionRecordingVoiceNote$Input = {
    /** The user is recording a voice note */
    readonly _: 'chatActionRecordingVoiceNote',
  }

  export type chatActionUploadingVoiceNote = {
    /** The user is uploading a voice note */
    _: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVoiceNote$Input = {
    /** The user is uploading a voice note */
    readonly _: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionUploadingPhoto = {
    /** The user is uploading a photo */
    _: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingPhoto$Input = {
    /** The user is uploading a photo */
    readonly _: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionUploadingDocument = {
    /** The user is uploading a document */
    _: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingDocument$Input = {
    /** The user is uploading a document */
    readonly _: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionChoosingSticker = {
    /** The user is picking a sticker to send */
    _: 'chatActionChoosingSticker',
  }

  export type chatActionChoosingSticker$Input = {
    /** The user is picking a sticker to send */
    readonly _: 'chatActionChoosingSticker',
  }

  export type chatActionChoosingLocation = {
    /** The user is picking a location or venue to send */
    _: 'chatActionChoosingLocation',
  }

  export type chatActionChoosingLocation$Input = {
    /** The user is picking a location or venue to send */
    readonly _: 'chatActionChoosingLocation',
  }

  export type chatActionChoosingContact = {
    /** The user is picking a contact to send */
    _: 'chatActionChoosingContact',
  }

  export type chatActionChoosingContact$Input = {
    /** The user is picking a contact to send */
    readonly _: 'chatActionChoosingContact',
  }

  export type chatActionStartPlayingGame = {
    /** The user has started to play a game */
    _: 'chatActionStartPlayingGame',
  }

  export type chatActionStartPlayingGame$Input = {
    /** The user has started to play a game */
    readonly _: 'chatActionStartPlayingGame',
  }

  export type chatActionRecordingVideoNote = {
    /** The user is recording a video note */
    _: 'chatActionRecordingVideoNote',
  }

  export type chatActionRecordingVideoNote$Input = {
    /** The user is recording a video note */
    readonly _: 'chatActionRecordingVideoNote',
  }

  export type chatActionUploadingVideoNote = {
    /** The user is uploading a video note */
    _: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVideoNote$Input = {
    /** The user is uploading a video note */
    readonly _: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionWatchingAnimations = {
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    _: 'chatActionWatchingAnimations',
    /** The animated emoji */
    emoji: string,
  }

  export type chatActionWatchingAnimations$Input = {
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    readonly _: 'chatActionWatchingAnimations',
    /** The animated emoji */
    readonly emoji?: string,
  }

  export type chatActionCancel = {
    /** The user has canceled the previous action */
    _: 'chatActionCancel',
  }

  export type chatActionCancel$Input = {
    /** The user has canceled the previous action */
    readonly _: 'chatActionCancel',
  }

  export type userStatusEmpty = {
    /** The user's status has never been changed */
    _: 'userStatusEmpty',
  }

  export type userStatusOnline = {
    /** The user is online */
    _: 'userStatusOnline',
    /** Point in time (Unix timestamp) when the user's online status will expire */
    expires: number,
  }

  export type userStatusOffline = {
    /** The user is offline */
    _: 'userStatusOffline',
    /** Point in time (Unix timestamp) when the user was last online */
    was_online: number,
  }

  export type userStatusRecently = {
    /** The user was online recently */
    _: 'userStatusRecently',
    /**
     * Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus
     * privacy setting for the user and has no Telegram Premium
     */
    by_my_privacy_settings: boolean,
  }

  export type userStatusLastWeek = {
    /** The user is offline, but was online last week */
    _: 'userStatusLastWeek',
    /**
     * Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus
     * privacy setting for the user and has no Telegram Premium
     */
    by_my_privacy_settings: boolean,
  }

  export type userStatusLastMonth = {
    /** The user is offline, but was online last month */
    _: 'userStatusLastMonth',
    /**
     * Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus
     * privacy setting for the user and has no Telegram Premium
     */
    by_my_privacy_settings: boolean,
  }

  export type emojiKeyword = {
    /** Represents an emoji with its keyword */
    _: 'emojiKeyword',
    /** The emoji */
    emoji: string,
    /** The keyword */
    keyword: string,
  }

  export type emojiKeywords = {
    /** Represents a list of emojis with their keywords */
    _: 'emojiKeywords',
    /** List of emojis with their keywords */
    emoji_keywords: Array<emojiKeyword>,
  }

  export type stickers = {
    /** Represents a list of stickers */
    _: 'stickers',
    /** List of stickers */
    stickers: Array<sticker>,
  }

  export type emojis = {
    /** Represents a list of emojis */
    _: 'emojis',
    /** List of emojis */
    emojis: Array<string>,
  }

  export type stickerSet = {
    /** Represents a sticker set */
    _: 'stickerSet',
    /** Identifier of the sticker set */
    id: string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100;
     * may be null. The file can be downloaded only before the thumbnail is changed
     */
    thumbnail?: thumbnail,
    /** Sticker set thumbnail's outline; may be null if unknown */
    thumbnail_outline?: outline,
    /** True, if the sticker set is owned by the current user */
    is_owned: boolean,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** Type of the stickers in the set */
    sticker_type: StickerType,
    /**
     * True, if stickers in the sticker set are custom emoji that must be repainted;
     * for custom emoji sticker sets only
     */
    needs_repainting: boolean,
    /**
     * True, if stickers in the sticker set are custom emoji that can be used as chat
     * emoji status; for custom emoji sticker sets only
     */
    is_allowed_as_chat_emoji_status: boolean,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** List of stickers in this set */
    stickers: Array<sticker>,
    /**
     * A list of emojis corresponding to the stickers in the same order. The list is
     * only for informational purposes, because a sticker is always sent with a fixed
     * emoji from the corresponding Sticker object
     */
    emojis: Array<emojis>,
  }

  export type stickerSetInfo = {
    /** Represents short information about a sticker set */
    _: 'stickerSetInfo',
    /** Identifier of the sticker set */
    id: string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100;
     * may be null. The file can be downloaded only before the thumbnail is changed
     */
    thumbnail?: thumbnail,
    /** Sticker set thumbnail's outline; may be null if unknown */
    thumbnail_outline?: outline,
    /** True, if the sticker set is owned by the current user */
    is_owned: boolean,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** Type of the stickers in the set */
    sticker_type: StickerType,
    /**
     * True, if stickers in the sticker set are custom emoji that must be repainted;
     * for custom emoji sticker sets only
     */
    needs_repainting: boolean,
    /**
     * True, if stickers in the sticker set are custom emoji that can be used as chat
     * emoji status; for custom emoji sticker sets only
     */
    is_allowed_as_chat_emoji_status: boolean,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** Total number of stickers in the set */
    size: number,
    /**
     * Up to the first 5 stickers from the set, depending on the context. If the application
     * needs more stickers the full sticker set needs to be requested
     */
    covers: Array<sticker>,
  }

  export type stickerSets = {
    /** Represents a list of sticker sets */
    _: 'stickerSets',
    /** Approximate total number of sticker sets found */
    total_count: number,
    /** List of sticker sets */
    sets: Array<stickerSetInfo>,
  }

  export type trendingStickerSets = {
    /** Represents a list of trending sticker sets */
    _: 'trendingStickerSets',
    /** Approximate total number of trending sticker sets */
    total_count: number,
    /** List of trending sticker sets */
    sets: Array<stickerSetInfo>,
    /** True, if the list contains sticker sets with premium stickers */
    is_premium: boolean,
  }

  export type emojiCategorySourceSearch = {
    /**
     * The category contains a list of similar emoji to search for in getStickers and
     * searchStickers for stickers, or getInlineQueryResults with the bot getOption("animation_search_bot_username")
     * for animations
     */
    _: 'emojiCategorySourceSearch',
    /** List of emojis to search for */
    emojis: Array<string>,
  }

  export type emojiCategorySourcePremium = {
    /** The category contains premium stickers that must be found by getPremiumStickers */
    _: 'emojiCategorySourcePremium',
  }

  export type emojiCategory = {
    /** Describes an emoji category */
    _: 'emojiCategory',
    /** Name of the category */
    name: string,
    /** Custom emoji sticker, which represents icon of the category */
    icon: sticker,
    /** Source of stickers for the emoji category */
    source: EmojiCategorySource,
    /**
     * True, if the category must be shown first when choosing a sticker for the start
     * page
     */
    is_greeting: boolean,
  }

  export type emojiCategories = {
    /** Represents a list of emoji categories */
    _: 'emojiCategories',
    /** List of categories */
    categories: Array<emojiCategory>,
  }

  export type emojiCategoryTypeDefault$Input = {
    /** The category must be used by default (e.g., for custom emoji or animation search) */
    readonly _: 'emojiCategoryTypeDefault',
  }

  export type emojiCategoryTypeRegularStickers$Input = {
    /**
     * The category must be used by default for regular sticker selection. It may contain
     * greeting emoji category and premium stickers
     */
    readonly _: 'emojiCategoryTypeRegularStickers',
  }

  export type emojiCategoryTypeEmojiStatus$Input = {
    /** The category must be used for emoji status selection */
    readonly _: 'emojiCategoryTypeEmojiStatus',
  }

  export type emojiCategoryTypeChatPhoto$Input = {
    /** The category must be used for chat photo emoji selection */
    readonly _: 'emojiCategoryTypeChatPhoto',
  }

  export type currentWeather = {
    /** Describes the current weather */
    _: 'currentWeather',
    /** Temperature, in degree Celsius */
    temperature: number,
    /** Emoji representing the weather */
    emoji: string,
  }

  export type storyAreaPosition = {
    /** Describes position of a clickable rectangle area on a story media */
    _: 'storyAreaPosition',
    /** The abscissa of the rectangle's center, as a percentage of the media width */
    x_percentage: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    y_percentage: number,
    /** The width of the rectangle, as a percentage of the media width */
    width_percentage: number,
    /** The height of the rectangle, as a percentage of the media height */
    height_percentage: number,
    /** Clockwise rotation angle of the rectangle, in degrees; 0-360 */
    rotation_angle: number,
    /** The radius of the rectangle corner rounding, as a percentage of the media width */
    corner_radius_percentage: number,
  }

  export type storyAreaPosition$Input = {
    /** Describes position of a clickable rectangle area on a story media */
    readonly _: 'storyAreaPosition',
    /** The abscissa of the rectangle's center, as a percentage of the media width */
    readonly x_percentage?: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    readonly y_percentage?: number,
    /** The width of the rectangle, as a percentage of the media width */
    readonly width_percentage?: number,
    /** The height of the rectangle, as a percentage of the media height */
    readonly height_percentage?: number,
    /** Clockwise rotation angle of the rectangle, in degrees; 0-360 */
    readonly rotation_angle?: number,
    /** The radius of the rectangle corner rounding, as a percentage of the media width */
    readonly corner_radius_percentage?: number,
  }

  export type storyAreaTypeLocation = {
    /** An area pointing to a location */
    _: 'storyAreaTypeLocation',
    /** The location */
    location: location,
    /** Address of the location; may be null if unknown */
    address?: locationAddress,
  }

  export type storyAreaTypeVenue = {
    /** An area pointing to a venue */
    _: 'storyAreaTypeVenue',
    /** Information about the venue */
    venue: venue,
  }

  export type storyAreaTypeSuggestedReaction = {
    /**
     * An area pointing to a suggested reaction. App needs to show a clickable reaction
     * on the area and call setStoryReaction when the are is clicked
     */
    _: 'storyAreaTypeSuggestedReaction',
    /** Type of the reaction */
    reaction_type: ReactionType,
    /** Number of times the reaction was added */
    total_count: number,
    /** True, if reaction has a dark background */
    is_dark: boolean,
    /** True, if reaction corner is flipped */
    is_flipped: boolean,
  }

  export type storyAreaTypeMessage = {
    /** An area pointing to a message */
    _: 'storyAreaTypeMessage',
    /** Identifier of the chat with the message */
    chat_id: number,
    /** Identifier of the message */
    message_id: number,
  }

  export type storyAreaTypeLink = {
    /** An area pointing to a HTTP or tg:// link */
    _: 'storyAreaTypeLink',
    /** HTTP or tg:// URL to be opened when the area is clicked */
    url: string,
  }

  export type storyAreaTypeWeather = {
    /** An area with information about weather */
    _: 'storyAreaTypeWeather',
    /** Temperature, in degree Celsius */
    temperature: number,
    /** Emoji representing the weather */
    emoji: string,
    /** A color of the area background in the ARGB format */
    background_color: number,
  }

  export type storyAreaTypeUpgradedGift = {
    /** An area with an upgraded gift */
    _: 'storyAreaTypeUpgradedGift',
    /** Unique name of the upgraded gift */
    gift_name: string,
  }

  export type storyArea = {
    /** Describes a clickable rectangle area on a story media */
    _: 'storyArea',
    /** Position of the area */
    position: storyAreaPosition,
    /** Type of the area */
    type: StoryAreaType,
  }

  export type inputStoryAreaTypeLocation$Input = {
    /** An area pointing to a location */
    readonly _: 'inputStoryAreaTypeLocation',
    /** The location */
    readonly location?: location$Input,
    /** Address of the location; pass null if unknown */
    readonly address?: locationAddress$Input,
  }

  export type inputStoryAreaTypeFoundVenue$Input = {
    /** An area pointing to a venue found by the bot getOption("venue_search_bot_username") */
    readonly _: 'inputStoryAreaTypeFoundVenue',
    /** Identifier of the inline query, used to found the venue */
    readonly query_id?: number | string,
    /** Identifier of the inline query result */
    readonly result_id?: string,
  }

  export type inputStoryAreaTypePreviousVenue$Input = {
    /** An area pointing to a venue already added to the story */
    readonly _: 'inputStoryAreaTypePreviousVenue',
    /** Provider of the venue */
    readonly venue_provider?: string,
    /** Identifier of the venue in the provider database */
    readonly venue_id?: string,
  }

  export type inputStoryAreaTypeSuggestedReaction$Input = {
    /** An area pointing to a suggested reaction */
    readonly _: 'inputStoryAreaTypeSuggestedReaction',
    /** Type of the reaction */
    readonly reaction_type?: ReactionType$Input,
    /** True, if reaction has a dark background */
    readonly is_dark?: boolean,
    /** True, if reaction corner is flipped */
    readonly is_flipped?: boolean,
  }

  export type inputStoryAreaTypeMessage$Input = {
    /** An area pointing to a message */
    readonly _: 'inputStoryAreaTypeMessage',
    /**
     * Identifier of the chat with the message. Currently, the chat must be a supergroup
     * or a channel chat
     */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_shared_in_story to check
     * whether the message is suitable
     */
    readonly message_id?: number,
  }

  export type inputStoryAreaTypeLink$Input = {
    /** An area pointing to a HTTP or tg:// link */
    readonly _: 'inputStoryAreaTypeLink',
    /** HTTP or tg:// URL to be opened when the area is clicked */
    readonly url?: string,
  }

  export type inputStoryAreaTypeWeather$Input = {
    /** An area with information about weather */
    readonly _: 'inputStoryAreaTypeWeather',
    /** Temperature, in degree Celsius */
    readonly temperature?: number,
    /** Emoji representing the weather */
    readonly emoji?: string,
    /** A color of the area background in the ARGB format */
    readonly background_color?: number,
  }

  export type inputStoryAreaTypeUpgradedGift$Input = {
    /** An area with an upgraded gift */
    readonly _: 'inputStoryAreaTypeUpgradedGift',
    /** Unique name of the upgraded gift */
    readonly gift_name?: string,
  }

  export type inputStoryArea$Input = {
    /** Describes a clickable rectangle area on a story media to be added */
    readonly _: 'inputStoryArea',
    /** Position of the area */
    readonly position?: storyAreaPosition$Input,
    /** Type of the area */
    readonly type?: InputStoryAreaType$Input,
  }

  export type inputStoryAreas$Input = {
    /** Contains a list of story areas to be added */
    readonly _: 'inputStoryAreas',
    /**
     * List of input story areas. Currently, a story can have up to 10 inputStoryAreaTypeLocation,
     * inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up
     * to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction
     * areas, up to 1 inputStoryAreaTypeMessage area, up to getOption("story_link_area_count_max")
     * inputStoryAreaTypeLink areas if the current user is a Telegram Premium user,
     * up to 3 inputStoryAreaTypeWeather areas, and up to 1 inputStoryAreaTypeUpgradedGift
     * area
     */
    readonly areas?: ReadonlyArray<inputStoryArea$Input>,
  }

  export type storyVideo = {
    /** Describes a video file posted as a story */
    _: 'storyVideo',
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /**
     * True, if stickers were added to the video. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** True, if the video has no sound */
    is_animation: boolean,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG or MPEG4 format; may be null */
    thumbnail?: thumbnail,
    /** Size of file prefix, which is expected to be preloaded, in bytes */
    preload_prefix_size: number,
    /** Timestamp of the frame used as video thumbnail */
    cover_frame_timestamp: number,
    /** File containing the video */
    video: file,
  }

  export type storyContentPhoto = {
    /** A photo story */
    _: 'storyContentPhoto',
    /** The photo */
    photo: photo,
  }

  export type storyContentVideo = {
    /** A video story */
    _: 'storyContentVideo',
    /** The video in MPEG4 format */
    video: storyVideo,
    /**
     * Alternative version of the video in MPEG4 format, encoded with H.264 codec;
     * may be null
     */
    alternative_video?: storyVideo,
  }

  export type storyContentUnsupported = {
    /** A story content that is not supported in the current TDLib version */
    _: 'storyContentUnsupported',
  }

  export type inputStoryContentPhoto$Input = {
    /** A photo story */
    readonly _: 'inputStoryContentPhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo size must
     * be 1080x1920
     */
    readonly photo?: InputFile$Input,
    /** File identifiers of the stickers added to the photo, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
  }

  export type inputStoryContentVideo$Input = {
    /** A video story */
    readonly _: 'inputStoryContentVideo',
    /**
     * Video to be sent. The video size must be 720x1280. The video must be streamable
     * and stored in MPEG4 format, after encoding with H.265 codec and key frames added
     * each second
     */
    readonly video?: InputFile$Input,
    /** File identifiers of the stickers added to the video, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Precise duration of the video, in seconds; 0-60 */
    readonly duration?: number,
    /** Timestamp of the frame, which will be used as video thumbnail */
    readonly cover_frame_timestamp?: number,
    /** True, if the video has no sound */
    readonly is_animation?: boolean,
  }

  export type storyListMain = {
    /** The list of stories, shown in the main chat list and folder chat lists */
    _: 'storyListMain',
  }

  export type storyListMain$Input = {
    /** The list of stories, shown in the main chat list and folder chat lists */
    readonly _: 'storyListMain',
  }

  export type storyListArchive = {
    /** The list of stories, shown in the Arvhive chat list */
    _: 'storyListArchive',
  }

  export type storyListArchive$Input = {
    /** The list of stories, shown in the Arvhive chat list */
    readonly _: 'storyListArchive',
  }

  export type storyOriginPublicStory = {
    /** The original story was a public story that was posted by a known chat */
    _: 'storyOriginPublicStory',
    /** Identifier of the chat that posted original story */
    chat_id: number,
    /** Story identifier of the original story */
    story_id: number,
  }

  export type storyOriginHiddenUser = {
    /** The original story was posted by an unknown user */
    _: 'storyOriginHiddenUser',
    /** Name of the user or the chat that posted the story */
    poster_name: string,
  }

  export type storyRepostInfo = {
    /** Contains information about original story that was reposted */
    _: 'storyRepostInfo',
    /** Origin of the story that was reposted */
    origin: StoryOrigin,
    /**
     * True, if story content was modified during reposting; otherwise, story wasn't
     * modified
     */
    is_content_modified: boolean,
  }

  export type storyInteractionInfo = {
    /** Contains information about interactions with a story */
    _: 'storyInteractionInfo',
    /** Number of times the story was viewed */
    view_count: number,
    /** Number of times the story was forwarded; 0 if none or unknown */
    forward_count: number,
    /** Number of reactions added to the story; 0 if none or unknown */
    reaction_count: number,
    /** Identifiers of at most 3 recent viewers of the story */
    recent_viewer_user_ids: Array<number>,
  }

  export type story = {
    /** Represents a story */
    _: 'story',
    /** Unique story identifier among stories posted by the given chat */
    id: number,
    /** Identifier of the chat that posted the story */
    poster_chat_id: number,
    /**
     * Identifier of the user or chat that posted the story; may be null if the story
     * is posted on behalf of the poster_chat_id
     */
    poster_id?: MessageSender,
    /** Point in time (Unix timestamp) when the story was published */
    date: number,
    /** True, if the story is being posted by the current user */
    is_being_posted: boolean,
    /** True, if the story is being edited by the current user */
    is_being_edited: boolean,
    /** True, if the story was edited */
    is_edited: boolean,
    /**
     * True, if the story is saved in the profile of the chat that posted it and will
     * be available there after expiration
     */
    is_posted_to_chat_page: boolean,
    /** True, if the story is visible only for the current user */
    is_visible_only_for_self: boolean,
    /** True, if the story can be deleted */
    can_be_deleted: boolean,
    /** True, if the story can be edited */
    can_be_edited: boolean,
    /**
     * True, if the story can be forwarded as a message. Otherwise, screenshots and
     * saving of the story content must be also forbidden
     */
    can_be_forwarded: boolean,
    /**
     * True, if the story can be replied in the chat with the user that posted the
     * story
     */
    can_be_replied: boolean,
    /** True, if the story's is_posted_to_chat_page value can be changed */
    can_toggle_is_posted_to_chat_page: boolean,
    /** True, if the story statistics are available through getStoryStatistics */
    can_get_statistics: boolean,
    /** True, if interactions with the story can be received through getStoryInteractions */
    can_get_interactions: boolean,
    /**
     * True, if users viewed the story can't be received, because the story has expired
     * more than getOption("story_viewers_expiration_delay") seconds ago
     */
    has_expired_viewers: boolean,
    /** Information about the original story; may be null if the story wasn't reposted */
    repost_info?: storyRepostInfo,
    /**
     * Information about interactions with the story; may be null if the story isn't
     * owned or there were no interactions
     */
    interaction_info?: storyInteractionInfo,
    /** Type of the chosen reaction; may be null if none */
    chosen_reaction_type?: ReactionType,
    /** Privacy rules affecting story visibility; may be approximate for non-owned stories */
    privacy_settings: StoryPrivacySettings,
    /** Content of the story */
    content: StoryContent,
    /** Clickable areas to be shown on the story content */
    areas: Array<storyArea>,
    /** Caption of the story */
    caption: formattedText,
  }

  export type stories = {
    /** Represents a list of stories */
    _: 'stories',
    /** Approximate total number of stories found */
    total_count: number,
    /** The list of stories */
    stories: Array<story>,
    /**
     * Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories
     * with from_story_id == 0
     */
    pinned_story_ids: Array<number>,
  }

  export type foundStories = {
    /** Contains a list of stories found by a search */
    _: 'foundStories',
    /** Approximate total number of stories found */
    total_count: number,
    /** List of stories */
    stories: Array<story>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type storyFullId$Input = {
    /**
     * Contains identifier of a story along with identifier of the chat that posted
     * it
     */
    readonly _: 'storyFullId',
    /** Identifier of the chat that posted the story */
    readonly poster_chat_id?: number,
    /** Unique story identifier among stories of the chat */
    readonly story_id?: number,
  }

  export type storyInfo = {
    /** Contains basic information about a story */
    _: 'storyInfo',
    /** Unique story identifier among stories of the chat */
    story_id: number,
    /** Point in time (Unix timestamp) when the story was published */
    date: number,
    /** True, if the story is available only to close friends */
    is_for_close_friends: boolean,
  }

  export type chatActiveStories = {
    /** Describes active stories posted by a chat */
    _: 'chatActiveStories',
    /** Identifier of the chat that posted the stories */
    chat_id: number,
    /**
     * Identifier of the story list in which the stories are shown; may be null if
     * the stories aren't shown in a story list
     */
    list?: StoryList,
    /**
     * A parameter used to determine order of the stories in the story list; 0 if the
     * stories doesn't need to be shown in the story list. Stories must be sorted by
     * the pair (order, story_poster_chat_id) in descending order
     */
    order: number,
    /** Identifier of the last read active story */
    max_read_story_id: number,
    /**
     * Basic information about the stories; use getStory to get full information about
     * the stories. The stories are in chronological order (i.e., in order of increasing
     * story identifiers)
     */
    stories: Array<storyInfo>,
  }

  export type storyInteractionTypeView = {
    /** A view of the story */
    _: 'storyInteractionTypeView',
    /** Type of the reaction that was chosen by the viewer; may be null if none */
    chosen_reaction_type?: ReactionType,
  }

  export type storyInteractionTypeForward = {
    /** A forward of the story as a message */
    _: 'storyInteractionTypeForward',
    /** The message with story forward */
    message: message,
  }

  export type storyInteractionTypeRepost = {
    /** A repost of the story as a story */
    _: 'storyInteractionTypeRepost',
    /** The reposted story */
    story: story,
  }

  export type storyInteraction = {
    /** Represents interaction with a story */
    _: 'storyInteraction',
    /** Identifier of the user or chat that made the interaction */
    actor_id: MessageSender,
    /** Approximate point in time (Unix timestamp) when the interaction happened */
    interaction_date: number,
    /** Block list to which the actor is added; may be null if none or for chat stories */
    block_list?: BlockList,
    /** Type of the interaction */
    type: StoryInteractionType,
  }

  export type storyInteractions = {
    /** Represents a list of interactions with a story */
    _: 'storyInteractions',
    /** Approximate total number of interactions found */
    total_count: number,
    /** Approximate total number of found forwards and reposts; always 0 for chat stories */
    total_forward_count: number,
    /** Approximate total number of found reactions; always 0 for chat stories */
    total_reaction_count: number,
    /** List of story interactions */
    interactions: Array<storyInteraction>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type quickReplyMessage = {
    /** Describes a message that can be used for quick reply */
    _: 'quickReplyMessage',
    /** Unique message identifier among all quick replies */
    id: number,
    /**
     * The sending state of the message; may be null if the message isn't being sent
     * and didn't fail to be sent
     */
    sending_state?: MessageSendingState,
    /** True, if the message can be edited */
    can_be_edited: boolean,
    /**
     * The identifier of the quick reply message to which the message replies; 0 if
     * none
     */
    reply_to_message_id: number,
    /** If non-zero, the user identifier of the bot through which this message was sent */
    via_bot_user_id: number,
    /**
     * Unique identifier of an album this message belongs to; 0 if none. Only audios,
     * documents, photos and videos can be grouped together in albums
     */
    media_album_id: string,
    /** Content of the message */
    content: MessageContent,
    /** Inline keyboard reply markup for the message; may be null if none */
    reply_markup?: ReplyMarkup,
  }

  export type quickReplyMessages = {
    /** Contains a list of quick reply messages */
    _: 'quickReplyMessages',
    /** List of quick reply messages; messages may be null */
    messages: Array<quickReplyMessage | null>,
  }

  export type quickReplyShortcut = {
    /** Describes a shortcut that can be used for a quick reply */
    _: 'quickReplyShortcut',
    /** Unique shortcut identifier */
    id: number,
    /** The name of the shortcut that can be used to use the shortcut */
    name: string,
    /** The first shortcut message */
    first_message: quickReplyMessage,
    /** The total number of messages in the shortcut */
    message_count: number,
  }

  export type publicForwardMessage = {
    /** Contains a public forward as a message */
    _: 'publicForwardMessage',
    /** Information about the message */
    message: message,
  }

  export type publicForwardStory = {
    /** Contains a public repost to a story */
    _: 'publicForwardStory',
    /** Information about the story */
    story: story,
  }

  export type publicForwards = {
    /**
     * Represents a list of public forwards and reposts as a story of a message or
     * a story
     */
    _: 'publicForwards',
    /** Approximate total number of messages and stories found */
    total_count: number,
    /** List of found public forwards and reposts */
    forwards: Array<PublicForward>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type botMediaPreview = {
    /** Describes media previews of a bot */
    _: 'botMediaPreview',
    /** Point in time (Unix timestamp) when the preview was added or changed last time */
    date: number,
    /** Content of the preview */
    content: StoryContent,
  }

  export type botMediaPreviews = {
    /** Contains a list of media previews of a bot */
    _: 'botMediaPreviews',
    /** List of media previews */
    previews: Array<botMediaPreview>,
  }

  export type botMediaPreviewInfo = {
    /**
     * Contains a list of media previews of a bot for the given language and the list
     * of languages for which the bot has dedicated previews
     */
    _: 'botMediaPreviewInfo',
    /** List of media previews */
    previews: Array<botMediaPreview>,
    /** List of language codes for which the bot has dedicated previews */
    language_codes: Array<string>,
  }

  export type chatBoostLevelFeatures = {
    /** Contains a list of features available on a specific chat boost level */
    _: 'chatBoostLevelFeatures',
    /** Target chat boost level */
    level: number,
    /** Number of stories that the chat can publish daily */
    story_per_day_count: number,
    /**
     * Number of custom emoji reactions that can be added to the list of available
     * reactions
     */
    custom_emoji_reaction_count: number,
    /** Number of custom colors for chat title */
    title_color_count: number,
    /** Number of custom colors for profile photo background */
    profile_accent_color_count: number,
    /** True, if custom emoji for profile background can be set */
    can_set_profile_background_custom_emoji: boolean,
    /**
     * Number of custom colors for background of empty chat photo, replies to messages
     * and link previews
     */
    accent_color_count: number,
    /** True, if custom emoji for reply header and link preview background can be set */
    can_set_background_custom_emoji: boolean,
    /** True, if emoji status can be set */
    can_set_emoji_status: boolean,
    /** Number of chat theme backgrounds that can be set as chat background */
    chat_theme_background_count: number,
    /** True, if custom background can be set in the chat for all users */
    can_set_custom_background: boolean,
    /** True, if custom emoji sticker set can be set for the chat */
    can_set_custom_emoji_sticker_set: boolean,
    /** True, if automatic translation of messages can be enabled in the chat */
    can_enable_automatic_translation: boolean,
    /**
     * True, if speech recognition can be used for video note and voice note messages
     * by all users
     */
    can_recognize_speech: boolean,
    /** True, if sponsored messages can be disabled in the chat */
    can_disable_sponsored_messages: boolean,
  }

  export type chatBoostFeatures = {
    /** Contains a list of features available on the first chat boost levels */
    _: 'chatBoostFeatures',
    /** The list of features */
    features: Array<chatBoostLevelFeatures>,
    /** The minimum boost level required to set custom emoji for profile background */
    min_profile_background_custom_emoji_boost_level: number,
    /**
     * The minimum boost level required to set custom emoji for reply header and link
     * preview background; for channel chats only
     */
    min_background_custom_emoji_boost_level: number,
    /** The minimum boost level required to set emoji status */
    min_emoji_status_boost_level: number,
    /** The minimum boost level required to set a chat theme background as chat background */
    min_chat_theme_background_boost_level: number,
    /** The minimum boost level required to set custom chat background */
    min_custom_background_boost_level: number,
    /**
     * The minimum boost level required to set custom emoji sticker set for the chat;
     * for supergroup chats only
     */
    min_custom_emoji_sticker_set_boost_level: number,
    /**
     * The minimum boost level allowing to enable automatic translation of messages
     * for non-Premium users; for channel chats only
     */
    min_automatic_translation_boost_level: number,
    /**
     * The minimum boost level allowing to recognize speech in video note and voice
     * note messages for non-Premium users; for supergroup chats only
     */
    min_speech_recognition_boost_level: number,
    /**
     * The minimum boost level allowing to disable sponsored messages in the chat;
     * for channel chats only
     */
    min_sponsored_message_disable_boost_level: number,
  }

  export type chatBoostSourceGiftCode = {
    /** The chat created a Telegram Premium gift code for a user */
    _: 'chatBoostSourceGiftCode',
    /** Identifier of a user, for which the gift code was created */
    user_id: number,
    /**
     * The created Telegram Premium gift code, which is known only if this is a gift
     * code for the current user, or it has already been claimed
     */
    gift_code: string,
  }

  export type chatBoostSourceGiveaway = {
    /** The chat created a giveaway */
    _: 'chatBoostSourceGiveaway',
    /** Identifier of a user that won in the giveaway; 0 if none */
    user_id: number,
    /**
     * The created Telegram Premium gift code if it was used by the user or can be
     * claimed by the current user; an empty string otherwise; for Telegram Premium
     * giveways only
     */
    gift_code: string,
    /** Number of Telegram Stars distributed among winners of the giveaway */
    star_count: number,
    /**
     * Identifier of the corresponding giveaway message; can be an identifier of a
     * deleted message
     */
    giveaway_message_id: number,
    /**
     * True, if the winner for the corresponding giveaway prize wasn't chosen, because
     * there were not enough participants
     */
    is_unclaimed: boolean,
  }

  export type chatBoostSourcePremium = {
    /**
     * A user with Telegram Premium subscription or gifted Telegram Premium boosted
     * the chat
     */
    _: 'chatBoostSourcePremium',
    /** Identifier of the user */
    user_id: number,
  }

  export type prepaidGiveaway = {
    /** Describes a prepaid giveaway */
    _: 'prepaidGiveaway',
    /** Unique identifier of the prepaid giveaway */
    id: string,
    /** Number of users which will receive giveaway prize */
    winner_count: number,
    /** Prize of the giveaway */
    prize: GiveawayPrize,
    /**
     * The number of boosts received by the chat from the giveaway; for Telegram Star
     * giveaways only
     */
    boost_count: number,
    /** Point in time (Unix timestamp) when the giveaway was paid */
    payment_date: number,
  }

  export type chatBoostStatus = {
    /** Describes current boost status of a chat */
    _: 'chatBoostStatus',
    /** An HTTP URL, which can be used to boost the chat */
    boost_url: string,
    /** Identifiers of boost slots of the current user applied to the chat */
    applied_slot_ids: Array<number>,
    /** Current boost level of the chat */
    level: number,
    /**
     * The number of boosts received by the chat from created Telegram Premium gift
     * codes and giveaways; always 0 if the current user isn't an administrator in
     * the chat
     */
    gift_code_boost_count: number,
    /** The number of boosts received by the chat */
    boost_count: number,
    /** The number of boosts added to reach the current level */
    current_level_boost_count: number,
    /**
     * The number of boosts needed to reach the next level; 0 if the next level isn't
     * available
     */
    next_level_boost_count: number,
    /**
     * Approximate number of Telegram Premium subscribers joined the chat; always 0
     * if the current user isn't an administrator in the chat
     */
    premium_member_count: number,
    /**
     * A percentage of Telegram Premium subscribers joined the chat; always 0 if the
     * current user isn't an administrator in the chat
     */
    premium_member_percentage: number,
    /** The list of prepaid giveaways available for the chat; only for chat administrators */
    prepaid_giveaways: Array<prepaidGiveaway>,
  }

  export type chatBoost = {
    /** Describes a boost applied to a chat */
    _: 'chatBoost',
    /** Unique identifier of the boost */
    id: string,
    /** The number of identical boosts applied */
    count: number,
    /** Source of the boost */
    source: ChatBoostSource,
    /** Point in time (Unix timestamp) when the chat was boosted */
    start_date: number,
    /** Point in time (Unix timestamp) when the boost will expire */
    expiration_date: number,
  }

  export type foundChatBoosts = {
    /** Contains a list of boosts applied to a chat */
    _: 'foundChatBoosts',
    /** Total number of boosts applied to the chat */
    total_count: number,
    /** List of boosts */
    boosts: Array<chatBoost>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type chatBoostSlot = {
    /** Describes a slot for chat boost */
    _: 'chatBoostSlot',
    /** Unique identifier of the slot */
    slot_id: number,
    /** Identifier of the currently boosted chat; 0 if none */
    currently_boosted_chat_id: number,
    /** Point in time (Unix timestamp) when the chat was boosted; 0 if none */
    start_date: number,
    /** Point in time (Unix timestamp) when the boost will expire */
    expiration_date: number,
    /**
     * Point in time (Unix timestamp) after which the boost can be used for another
     * chat
     */
    cooldown_until_date: number,
  }

  export type chatBoostSlots = {
    /** Contains a list of chat boost slots */
    _: 'chatBoostSlots',
    /** List of boost slots */
    slots: Array<chatBoostSlot>,
  }

  export type resendCodeReasonUserRequest$Input = {
    /** The user requested to resend the code */
    readonly _: 'resendCodeReasonUserRequest',
  }

  export type resendCodeReasonVerificationFailed$Input = {
    /** The code is re-sent, because device verification has failed */
    readonly _: 'resendCodeReasonVerificationFailed',
    /**
     * Cause of the verification failure, for example, "PLAY_SERVICES_NOT_AVAILABLE",
     * "APNS_RECEIVE_TIMEOUT", or "APNS_INIT_FAILED"
     */
    readonly error_message?: string,
  }

  export type callDiscardReasonEmpty = {
    /** The call wasn't discarded, or the reason is unknown */
    _: 'callDiscardReasonEmpty',
  }

  export type callDiscardReasonMissed = {
    /**
     * The call was ended before the conversation started. It was canceled by the caller
     * or missed by the other party
     */
    _: 'callDiscardReasonMissed',
  }

  export type callDiscardReasonDeclined = {
    /**
     * The call was ended before the conversation started. It was declined by the other
     * party
     */
    _: 'callDiscardReasonDeclined',
  }

  export type callDiscardReasonDisconnected = {
    /** The call was ended during the conversation because the users were disconnected */
    _: 'callDiscardReasonDisconnected',
  }

  export type callDiscardReasonHungUp = {
    /** The call was ended because one of the parties hung up */
    _: 'callDiscardReasonHungUp',
  }

  export type callDiscardReasonUpgradeToGroupCall = {
    /** The call was ended because it has been upgraded to a group call */
    _: 'callDiscardReasonUpgradeToGroupCall',
    /** Invite link for the group call */
    invite_link: string,
  }

  export type callProtocol = {
    /** Specifies the supported call protocols */
    _: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    udp_p2p: boolean,
    /** True, if connection through UDP reflectors is supported */
    udp_reflector: boolean,
    /** The minimum supported API layer; use 65 */
    min_layer: number,
    /** The maximum supported API layer; use 92 */
    max_layer: number,
    /** List of supported tgcalls versions */
    library_versions: Array<string>,
  }

  export type callProtocol$Input = {
    /** Specifies the supported call protocols */
    readonly _: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    readonly udp_p2p?: boolean,
    /** True, if connection through UDP reflectors is supported */
    readonly udp_reflector?: boolean,
    /** The minimum supported API layer; use 65 */
    readonly min_layer?: number,
    /** The maximum supported API layer; use 92 */
    readonly max_layer?: number,
    /** List of supported tgcalls versions */
    readonly library_versions?: ReadonlyArray<string>,
  }

  export type callServerTypeTelegramReflector = {
    /** A Telegram call reflector */
    _: 'callServerTypeTelegramReflector',
    /** A peer tag to be used with the reflector */
    peer_tag: string /* base64 */,
    /** True, if the server uses TCP instead of UDP */
    is_tcp: boolean,
  }

  export type callServerTypeWebrtc = {
    /** A WebRTC server */
    _: 'callServerTypeWebrtc',
    /** Username to be used for authentication */
    username: string,
    /** Authentication password */
    password: string,
    /** True, if the server supports TURN */
    supports_turn: boolean,
    /** True, if the server supports STUN */
    supports_stun: boolean,
  }

  export type callServer = {
    /** Describes a server for relaying call data */
    _: 'callServer',
    /** Server identifier */
    id: string,
    /** Server IPv4 address */
    ip_address: string,
    /** Server IPv6 address */
    ipv6_address: string,
    /** Server port number */
    port: number,
    /** Server type */
    type: CallServerType,
  }

  export type callId = {
    /** Contains the call identifier */
    _: 'callId',
    /** Call identifier */
    id: number,
  }

  export type groupCallId = {
    /** Contains the group call identifier */
    _: 'groupCallId',
    /** Group call identifier */
    id: number,
  }

  export type callStatePending = {
    /** The call is pending, waiting to be accepted by a user */
    _: 'callStatePending',
    /** True, if the call has already been created by the server */
    is_created: boolean,
    /** True, if the call has already been received by the other party */
    is_received: boolean,
  }

  export type callStateExchangingKeys = {
    /** The call has been answered and encryption keys are being exchanged */
    _: 'callStateExchangingKeys',
  }

  export type callStateReady = {
    /** The call is ready to use */
    _: 'callStateReady',
    /** Call protocols supported by the other call participant */
    protocol: callProtocol,
    /** List of available call servers */
    servers: Array<callServer>,
    /** A JSON-encoded call config */
    config: string,
    /** Call encryption key */
    encryption_key: string /* base64 */,
    /** Encryption key fingerprint represented as 4 emoji */
    emojis: Array<string>,
    /** True, if peer-to-peer connection is allowed by users privacy settings */
    allow_p2p: boolean,
    /** True, if the other party supports upgrading of the call to a group call */
    is_group_call_supported: boolean,
    /** Custom JSON-encoded call parameters to be passed to tgcalls */
    custom_parameters: string,
  }

  export type callStateHangingUp = {
    /** The call is hanging up after discardCall has been called */
    _: 'callStateHangingUp',
  }

  export type callStateDiscarded = {
    /** The call has ended successfully */
    _: 'callStateDiscarded',
    /** The reason why the call has ended */
    reason: CallDiscardReason,
    /** True, if the call rating must be sent to the server */
    need_rating: boolean,
    /** True, if the call debug information must be sent to the server */
    need_debug_information: boolean,
    /** True, if the call log must be sent to the server */
    need_log: boolean,
  }

  export type callStateError = {
    /** The call has ended with an error */
    _: 'callStateError',
    /**
     * Error. An error with the code 4005000 will be returned if an outgoing call is
     * missed because of an expired timeout
     */
    error: error,
  }

  export type groupCallJoinParameters$Input = {
    /** Describes parameters used to join a group call */
    readonly _: 'groupCallJoinParameters',
    /** Audio channel synchronization source identifier; received from tgcalls */
    readonly audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    readonly payload?: string,
    /** Pass true to join the call with muted microphone */
    readonly is_muted?: boolean,
    /** Pass true if the user's video is enabled */
    readonly is_my_video_enabled?: boolean,
  }

  export type groupCallVideoQualityThumbnail$Input = {
    /** The worst available video quality */
    readonly _: 'groupCallVideoQualityThumbnail',
  }

  export type groupCallVideoQualityMedium$Input = {
    /** The medium video quality */
    readonly _: 'groupCallVideoQualityMedium',
  }

  export type groupCallVideoQualityFull$Input = {
    /** The best available video quality */
    readonly _: 'groupCallVideoQualityFull',
  }

  export type videoChatStream = {
    /** Describes an available stream in a video chat */
    _: 'videoChatStream',
    /** Identifier of an audio/video channel */
    channel_id: number,
    /** Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds */
    scale: number,
    /** Point in time when the stream currently ends; Unix timestamp in milliseconds */
    time_offset: number,
  }

  export type videoChatStreams = {
    /** Represents a list of video chat streams */
    _: 'videoChatStreams',
    /** A list of video chat streams */
    streams: Array<videoChatStream>,
  }

  export type rtmpUrl = {
    /** Represents an RTMP URL */
    _: 'rtmpUrl',
    /** The URL */
    url: string,
    /** Stream key */
    stream_key: string,
  }

  export type groupCallRecentSpeaker = {
    /** Describes a recently speaking participant in a group call */
    _: 'groupCallRecentSpeaker',
    /** Group call participant identifier */
    participant_id: MessageSender,
    /** True, is the user has spoken recently */
    is_speaking: boolean,
  }

  export type groupCall = {
    /** Describes a group call */
    _: 'groupCall',
    /** Group call identifier */
    id: number,
    /** Group call title; for video chats only */
    title: string,
    /**
     * Invite link for the group call; for group calls that aren't bound to a chat.
     * For video chats call getVideoChatInviteLink to get the link
     */
    invite_link: string,
    /**
     * Point in time (Unix timestamp) when the group call is expected to be started
     * by an administrator; 0 if it is already active or was ended; for video chats
     * only
     */
    scheduled_start_date: number,
    /**
     * True, if the group call is scheduled and the current user will receive a notification
     * when the group call starts; for video chats only
     */
    enabled_start_notification: boolean,
    /** True, if the call is active */
    is_active: boolean,
    /** True, if the call is bound to a chat */
    is_video_chat: boolean,
    /**
     * True, if the call is an RTMP stream instead of an ordinary video chat; for video
     * chats only
     */
    is_rtmp_stream: boolean,
    /** True, if the call is joined */
    is_joined: boolean,
    /**
     * True, if user was kicked from the call because of network loss and the call
     * needs to be rejoined
     */
    need_rejoin: boolean,
    /**
     * True, if the user is the owner of the call and can end the call, change volume
     * level of other users, or ban users there; for group calls that aren't bound
     * to a chat
     */
    is_owned: boolean,
    /** True, if the current user can manage the group call; for video chats only */
    can_be_managed: boolean,
    /** Number of participants in the group call */
    participant_count: number,
    /**
     * True, if group call participants, which are muted, aren't returned in participant
     * list; for video chats only
     */
    has_hidden_listeners: boolean,
    /** True, if all group call participants are loaded */
    loaded_all_participants: boolean,
    /** At most 3 recently speaking users in the group call */
    recent_speakers: Array<groupCallRecentSpeaker>,
    /** True, if the current user's video is enabled */
    is_my_video_enabled: boolean,
    /** True, if the current user's video is paused */
    is_my_video_paused: boolean,
    /** True, if the current user can broadcast video or share screen */
    can_enable_video: boolean,
    /**
     * True, if only group call administrators can unmute new participants; for video
     * chats only
     */
    mute_new_participants: boolean,
    /**
     * True, if the current user can enable or disable mute_new_participants setting;
     * for video chats only
     */
    can_toggle_mute_new_participants: boolean,
    /**
     * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall
     * update is not triggered when value of this field changes, but the same recording
     * goes on
     */
    record_duration: number,
    /** True, if a video file is being recorded for the call */
    is_video_recorded: boolean,
    /** Call duration, in seconds; for ended calls only */
    duration: number,
  }

  export type groupCallVideoSourceGroup = {
    /** Describes a group of video synchronization source identifiers */
    _: 'groupCallVideoSourceGroup',
    /** The semantics of sources, one of "SIM" or "FID" */
    semantics: string,
    /** The list of synchronization source identifiers */
    source_ids: Array<number>,
  }

  export type groupCallParticipantVideoInfo = {
    /** Contains information about a group call participant's video channel */
    _: 'groupCallParticipantVideoInfo',
    /** List of synchronization source groups of the video */
    source_groups: Array<groupCallVideoSourceGroup>,
    /** Video channel endpoint identifier */
    endpoint_id: string,
    /**
     * True, if the video is paused. This flag needs to be ignored, if new video frames
     * are received
     */
    is_paused: boolean,
  }

  export type groupCallParticipant = {
    /** Represents a group call participant */
    _: 'groupCallParticipant',
    /** Identifier of the group call participant */
    participant_id: MessageSender,
    /** User's audio channel synchronization source identifier */
    audio_source_id: number,
    /** User's screen sharing audio channel synchronization source identifier */
    screen_sharing_audio_source_id: number,
    /** Information about user's video channel; may be null if there is no active video */
    video_info?: groupCallParticipantVideoInfo,
    /**
     * Information about user's screen sharing video channel; may be null if there
     * is no active screen sharing video
     */
    screen_sharing_video_info?: groupCallParticipantVideoInfo,
    /** The participant user's bio or the participant chat's description */
    bio: string,
    /** True, if the participant is the current user */
    is_current_user: boolean,
    /** True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking */
    is_speaking: boolean,
    /** True, if the participant hand is raised */
    is_hand_raised: boolean,
    /**
     * True, if the current user can mute the participant for all other group call
     * participants
     */
    can_be_muted_for_all_users: boolean,
    /**
     * True, if the current user can allow the participant to unmute themselves or
     * unmute the participant (if the participant is the current user)
     */
    can_be_unmuted_for_all_users: boolean,
    /** True, if the current user can mute the participant only for self */
    can_be_muted_for_current_user: boolean,
    /** True, if the current user can unmute the participant for self */
    can_be_unmuted_for_current_user: boolean,
    /** True, if the participant is muted for all users */
    is_muted_for_all_users: boolean,
    /** True, if the participant is muted for the current user */
    is_muted_for_current_user: boolean,
    /** True, if the participant is muted for all users, but can unmute themselves */
    can_unmute_self: boolean,
    /** Participant's volume level; 1-20000 in hundreds of percents */
    volume_level: number,
    /**
     * User's order in the group call participant list. Orders must be compared lexicographically.
     * The bigger is order, the higher is user in the list. If order is empty, the
     * user must be removed from the participant list
     */
    order: string,
  }

  export type groupCallParticipants = {
    /** Contains identifiers of group call participants */
    _: 'groupCallParticipants',
    /** Total number of group call participants */
    total_count: number,
    /** Identifiers of the participants */
    participant_ids: Array<MessageSender>,
  }

  export type groupCallInfo = {
    /** Contains information about a just created or just joined group call */
    _: 'groupCallInfo',
    /** Identifier of the group call */
    group_call_id: number,
    /** Join response payload for tgcalls; empty if the call isn't joined */
    join_payload: string,
  }

  export type inviteGroupCallParticipantResultUserPrivacyRestricted = {
    /** The user can't be invited due to their privacy settings */
    _: 'inviteGroupCallParticipantResultUserPrivacyRestricted',
  }

  export type inviteGroupCallParticipantResultUserAlreadyParticipant = {
    /** The user can't be invited because they are already a participant of the call */
    _: 'inviteGroupCallParticipantResultUserAlreadyParticipant',
  }

  export type inviteGroupCallParticipantResultUserWasBanned = {
    /**
     * The user can't be invited because they were banned by the owner of the call
     * and can be invited back only by the owner of the group call
     */
    _: 'inviteGroupCallParticipantResultUserWasBanned',
  }

  export type inviteGroupCallParticipantResultSuccess = {
    /**
     * The user was invited and a service message of the type messageGroupCall was
     * sent which can be used in declineGroupCallInvitation to cancel the invitation
     */
    _: 'inviteGroupCallParticipantResultSuccess',
    /** Identifier of the chat with the invitation message */
    chat_id: number,
    /** Identifier of the message */
    message_id: number,
  }

  export type groupCallDataChannelMain$Input = {
    /** The main data channel for audio and video data */
    readonly _: 'groupCallDataChannelMain',
  }

  export type groupCallDataChannelScreenSharing$Input = {
    /** The data channel for screen sharing */
    readonly _: 'groupCallDataChannelScreenSharing',
  }

  export type inputGroupCallLink$Input = {
    /** The group call is accessible through a link */
    readonly _: 'inputGroupCallLink',
    /** The link for the group call */
    readonly link?: string,
  }

  export type inputGroupCallMessage$Input = {
    /** The group call is accessible through a message of the type messageGroupCall */
    readonly _: 'inputGroupCallMessage',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /** Identifier of the message of the type messageGroupCall */
    readonly message_id?: number,
  }

  export type callProblemEcho$Input = {
    /** The user heard their own voice */
    readonly _: 'callProblemEcho',
  }

  export type callProblemNoise$Input = {
    /** The user heard background noise */
    readonly _: 'callProblemNoise',
  }

  export type callProblemInterruptions$Input = {
    /** The other side kept disappearing */
    readonly _: 'callProblemInterruptions',
  }

  export type callProblemDistortedSpeech$Input = {
    /** The speech was distorted */
    readonly _: 'callProblemDistortedSpeech',
  }

  export type callProblemSilentLocal$Input = {
    /** The user couldn't hear the other side */
    readonly _: 'callProblemSilentLocal',
  }

  export type callProblemSilentRemote$Input = {
    /** The other side couldn't hear the user */
    readonly _: 'callProblemSilentRemote',
  }

  export type callProblemDropped$Input = {
    /** The call ended unexpectedly */
    readonly _: 'callProblemDropped',
  }

  export type callProblemDistortedVideo$Input = {
    /** The video was distorted */
    readonly _: 'callProblemDistortedVideo',
  }

  export type callProblemPixelatedVideo$Input = {
    /** The video was pixelated */
    readonly _: 'callProblemPixelatedVideo',
  }

  export type call = {
    /** Describes a call */
    _: 'call',
    /** Call identifier, not persistent */
    id: number,
    /** User identifier of the other call participant */
    user_id: number,
    /** True, if the call is outgoing */
    is_outgoing: boolean,
    /** True, if the call is a video call */
    is_video: boolean,
    /** Call state */
    state: CallState,
  }

  export type firebaseAuthenticationSettingsAndroid$Input = {
    /** Settings for Firebase Authentication in the official Android application */
    readonly _: 'firebaseAuthenticationSettingsAndroid',
  }

  export type firebaseAuthenticationSettingsIos$Input = {
    /** Settings for Firebase Authentication in the official iOS application */
    readonly _: 'firebaseAuthenticationSettingsIos',
    /** Device token from Apple Push Notification service */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
  }

  export type phoneNumberAuthenticationSettings$Input = {
    /** Contains settings for the authentication of the user's phone number */
    readonly _: 'phoneNumberAuthenticationSettings',
    /**
     * Pass true if the authentication code may be sent via a flash call to the specified
     * phone number
     */
    readonly allow_flash_call?: boolean,
    /**
     * Pass true if the authentication code may be sent via a missed call to the specified
     * phone number
     */
    readonly allow_missed_call?: boolean,
    /** Pass true if the authenticated phone number is used on the current device */
    readonly is_current_phone_number?: boolean,
    /**
     * Pass true if there is a SIM card in the current device, but it is not possible
     * to check whether phone number matches
     */
    readonly has_unknown_phone_number?: boolean,
    /**
     * For official applications only. True, if the application can use Android SMS
     * Retriever API (requires Google Play Services >= 10.2) to automatically receive
     * the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/
     * for more details
     */
    readonly allow_sms_retriever_api?: boolean,
    /**
     * For official Android and iOS applications only; pass null otherwise. Settings
     * for Firebase Authentication
     */
    readonly firebase_authentication_settings?: FirebaseAuthenticationSettings$Input,
    /**
     * List of up to 20 authentication tokens, recently received in updateOption("authentication_token")
     * in previously logged out sessions; for setAuthenticationPhoneNumber only
     */
    readonly authentication_tokens?: ReadonlyArray<string>,
  }

  export type addedReaction = {
    /** Represents a reaction applied to a message */
    _: 'addedReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Identifier of the chat member, applied the reaction */
    sender_id: MessageSender,
    /** True, if the reaction was added by the current user */
    is_outgoing: boolean,
    /** Point in time (Unix timestamp) when the reaction was added */
    date: number,
  }

  export type addedReactions = {
    /** Represents a list of reactions added to a message */
    _: 'addedReactions',
    /** The total number of found reactions */
    total_count: number,
    /** The list of added reactions */
    reactions: Array<addedReaction>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type availableReaction = {
    /** Represents an available reaction */
    _: 'availableReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** True, if Telegram Premium is needed to send the reaction */
    needs_premium: boolean,
  }

  export type availableReactions = {
    /** Represents a list of reactions that can be added to a message */
    _: 'availableReactions',
    /** List of reactions to be shown at the top */
    top_reactions: Array<availableReaction>,
    /** List of recently used reactions */
    recent_reactions: Array<availableReaction>,
    /** List of popular reactions */
    popular_reactions: Array<availableReaction>,
    /** True, if any custom emoji reaction can be added by Telegram Premium subscribers */
    allow_custom_emoji: boolean,
    /** True, if the reactions will be tags and the message can be found by them */
    are_tags: boolean,
    /**
     * The reason why the current user can't add reactions to the message, despite
     * some other users can; may be null if none
     */
    unavailability_reason?: ReactionUnavailabilityReason,
  }

  export type emojiReaction = {
    /** Contains information about an emoji reaction */
    _: 'emojiReaction',
    /** Text representation of the reaction */
    emoji: string,
    /** Reaction title */
    title: string,
    /** True, if the reaction can be added to new messages and enabled in chats */
    is_active: boolean,
    /** Static icon for the reaction */
    static_icon: sticker,
    /** Appear animation for the reaction */
    appear_animation: sticker,
    /** Select animation for the reaction */
    select_animation: sticker,
    /** Activate animation for the reaction */
    activate_animation: sticker,
    /** Effect animation for the reaction */
    effect_animation: sticker,
    /** Around animation for the reaction; may be null */
    around_animation?: sticker,
    /** Center animation for the reaction; may be null */
    center_animation?: sticker,
  }

  export type reactionUnavailabilityReasonAnonymousAdministrator = {
    /**
     * The user is an anonymous administrator in the supergroup, but isn't a creator
     * of it, so they can't vote on behalf of the supergroup
     */
    _: 'reactionUnavailabilityReasonAnonymousAdministrator',
  }

  export type reactionUnavailabilityReasonGuest = {
    /**
     * The user isn't a member of the supergroup and can't send messages and reactions
     * there without joining
     */
    _: 'reactionUnavailabilityReasonGuest',
  }

  export type animations = {
    /** Represents a list of animations */
    _: 'animations',
    /** List of animations */
    animations: Array<animation>,
  }

  export type diceStickersRegular = {
    /** A regular animated sticker */
    _: 'diceStickersRegular',
    /** The animated sticker with the dice animation */
    sticker: sticker,
  }

  export type diceStickersSlotMachine = {
    /** Animated stickers to be combined into a slot machine */
    _: 'diceStickersSlotMachine',
    /**
     * The animated sticker with the slot machine background. The background animation
     * must start playing after all reel animations finish
     */
    background: sticker,
    /**
     * The animated sticker with the lever animation. The lever animation must play
     * once in the initial dice state
     */
    lever: sticker,
    /** The animated sticker with the left reel */
    left_reel: sticker,
    /** The animated sticker with the center reel */
    center_reel: sticker,
    /** The animated sticker with the right reel */
    right_reel: sticker,
  }

  export type importedContacts = {
    /** Represents the result of an importContacts request */
    _: 'importedContacts',
    /**
     * User identifiers of the imported contacts in the same order as they were specified
     * in the request; 0 if the contact is not yet a registered user
     */
    user_ids: Array<number>,
    /**
     * The number of users that imported the corresponding contact; 0 for already registered
     * users or if unavailable
     */
    importer_count: Array<number>,
  }

  export type speechRecognitionResultPending = {
    /** The speech recognition is ongoing */
    _: 'speechRecognitionResultPending',
    /** Partially recognized text */
    partial_text: string,
  }

  export type speechRecognitionResultText = {
    /** The speech recognition successfully finished */
    _: 'speechRecognitionResultText',
    /** Recognized text */
    text: string,
  }

  export type speechRecognitionResultError = {
    /** The speech recognition failed */
    _: 'speechRecognitionResultError',
    /**
     * Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned
     * when media duration is too big to be recognized
     */
    error: error,
  }

  export type businessConnection = {
    /** Describes a connection of the bot with a business account */
    _: 'businessConnection',
    /** Unique identifier of the connection */
    id: string,
    /** Identifier of the business user that created the connection */
    user_id: number,
    /** Chat identifier of the private chat with the user */
    user_chat_id: number,
    /** Point in time (Unix timestamp) when the connection was established */
    date: number,
    /** Rights of the bot; may be null if the connection was disabled */
    rights?: businessBotRights,
    /** True, if the connection is enabled; false otherwise */
    is_enabled: boolean,
  }

  export type attachmentMenuBotColor = {
    /** Describes a color to highlight a bot added to attachment menu */
    _: 'attachmentMenuBotColor',
    /** Color in the RGB format for light themes */
    light_color: number,
    /** Color in the RGB format for dark themes */
    dark_color: number,
  }

  export type attachmentMenuBot = {
    /** Represents a bot, which can be added to attachment or side menu */
    _: 'attachmentMenuBot',
    /** User identifier of the bot */
    bot_user_id: number,
    /**
     * True, if the bot supports opening from attachment menu in the chat with the
     * bot
     */
    supports_self_chat: boolean,
    /**
     * True, if the bot supports opening from attachment menu in private chats with
     * ordinary users
     */
    supports_user_chats: boolean,
    /**
     * True, if the bot supports opening from attachment menu in private chats with
     * other bots
     */
    supports_bot_chats: boolean,
    /**
     * True, if the bot supports opening from attachment menu in basic group and supergroup
     * chats
     */
    supports_group_chats: boolean,
    /** True, if the bot supports opening from attachment menu in channel chats */
    supports_channel_chats: boolean,
    /** True, if the user must be asked for the permission to send messages to the bot */
    request_write_access: boolean,
    /**
     * True, if the bot was explicitly added by the user. If the bot isn't added, then
     * on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and
     * the bot must be added or removed
     */
    is_added: boolean,
    /** True, if the bot must be shown in the attachment menu */
    show_in_attachment_menu: boolean,
    /** True, if the bot must be shown in the side menu */
    show_in_side_menu: boolean,
    /** True, if a disclaimer, why the bot is shown in the side menu, is needed */
    show_disclaimer_in_side_menu: boolean,
    /** Name for the bot in attachment menu */
    name: string,
    /** Color to highlight selected name of the bot if appropriate; may be null */
    name_color?: attachmentMenuBotColor,
    /** Default icon for the bot in SVG format; may be null */
    default_icon?: file,
    /** Icon for the bot in SVG format for the official iOS app; may be null */
    ios_static_icon?: file,
    /** Icon for the bot in TGS format for the official iOS app; may be null */
    ios_animated_icon?: file,
    /** Icon for the bot in PNG format for the official iOS app side menu; may be null */
    ios_side_menu_icon?: file,
    /** Icon for the bot in TGS format for the official Android app; may be null */
    android_icon?: file,
    /**
     * Icon for the bot in SVG format for the official Android app side menu; may be
     * null
     */
    android_side_menu_icon?: file,
    /** Icon for the bot in TGS format for the official native macOS app; may be null */
    macos_icon?: file,
    /**
     * Icon for the bot in PNG format for the official macOS app side menu; may be
     * null
     */
    macos_side_menu_icon?: file,
    /** Color to highlight selected icon of the bot if appropriate; may be null */
    icon_color?: attachmentMenuBotColor,
    /** Default placeholder for opened Web Apps in SVG format; may be null */
    web_app_placeholder?: file,
  }

  export type sentWebAppMessage = {
    /** Information about the message sent by answerWebAppQuery */
    _: 'sentWebAppMessage',
    /** Identifier of the sent inline message, if known */
    inline_message_id: string,
  }

  export type botWriteAccessAllowReasonConnectedWebsite = {
    /** The user connected a website by logging in using Telegram Login Widget on it */
    _: 'botWriteAccessAllowReasonConnectedWebsite',
    /** Domain name of the connected website */
    domain_name: string,
  }

  export type botWriteAccessAllowReasonAddedToAttachmentMenu = {
    /** The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu */
    _: 'botWriteAccessAllowReasonAddedToAttachmentMenu',
  }

  export type botWriteAccessAllowReasonLaunchedWebApp = {
    /** The user launched a Web App using getWebAppLinkUrl */
    _: 'botWriteAccessAllowReasonLaunchedWebApp',
    /** Information about the Web App */
    web_app: webApp,
  }

  export type botWriteAccessAllowReasonAcceptedRequest = {
    /** The user accepted bot's request to send messages with allowBotToSendMessages */
    _: 'botWriteAccessAllowReasonAcceptedRequest',
  }

  export type httpUrl = {
    /** Contains an HTTP URL */
    _: 'httpUrl',
    /** The URL */
    url: string,
  }

  export type userLink = {
    /** Contains an HTTPS URL, which can be used to get information about a user */
    _: 'userLink',
    /** The URL */
    url: string,
    /**
     * Left time for which the link is valid, in seconds; 0 if the link is a public
     * username link
     */
    expires_in: number,
  }

  export type targetChatTypes = {
    /** Describes allowed types for the target chat */
    _: 'targetChatTypes',
    /** True, if private chats with ordinary users are allowed */
    allow_user_chats: boolean,
    /** True, if private chats with other bots are allowed */
    allow_bot_chats: boolean,
    /** True, if basic group and supergroup chats are allowed */
    allow_group_chats: boolean,
    /** True, if channel chats are allowed */
    allow_channel_chats: boolean,
  }

  export type targetChatTypes$Input = {
    /** Describes allowed types for the target chat */
    readonly _: 'targetChatTypes',
    /** True, if private chats with ordinary users are allowed */
    readonly allow_user_chats?: boolean,
    /** True, if private chats with other bots are allowed */
    readonly allow_bot_chats?: boolean,
    /** True, if basic group and supergroup chats are allowed */
    readonly allow_group_chats?: boolean,
    /** True, if channel chats are allowed */
    readonly allow_channel_chats?: boolean,
  }

  export type targetChatCurrent = {
    /** The currently opened chat and forum topic must be kept */
    _: 'targetChatCurrent',
  }

  export type targetChatCurrent$Input = {
    /** The currently opened chat and forum topic must be kept */
    readonly _: 'targetChatCurrent',
  }

  export type targetChatChosen = {
    /** The chat needs to be chosen by the user among chats of the specified types */
    _: 'targetChatChosen',
    /** Allowed types for the chat */
    types: targetChatTypes,
  }

  export type targetChatChosen$Input = {
    /** The chat needs to be chosen by the user among chats of the specified types */
    readonly _: 'targetChatChosen',
    /** Allowed types for the chat */
    readonly types?: targetChatTypes$Input,
  }

  export type targetChatInternalLink = {
    /** The chat needs to be open with the provided internal link */
    _: 'targetChatInternalLink',
    /** An internal link pointing to the chat */
    link: InternalLinkType,
  }

  export type targetChatInternalLink$Input = {
    /** The chat needs to be open with the provided internal link */
    readonly _: 'targetChatInternalLink',
    /** An internal link pointing to the chat */
    readonly link?: InternalLinkType$Input,
  }

  export type inputInlineQueryResultAnimation$Input = {
    /**
     * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4
     * AVC video
     */
    readonly _: 'inputInlineQueryResultAnimation',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the query result */
    readonly title?: string,
    /** URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists */
    readonly thumbnail_url?: string,
    /**
     * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg",
     * "image/gif" and "video/mp4"
     */
    readonly thumbnail_mime_type?: string,
    /** The URL of the video file (file size must not exceed 1MB) */
    readonly video_url?: string,
    /** MIME type of the video file. Must be one of "image/gif" and "video/mp4" */
    readonly video_mime_type?: string,
    /** Duration of the video, in seconds */
    readonly video_duration?: number,
    /** Width of the video */
    readonly video_width?: number,
    /** Height of the video */
    readonly video_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultArticle$Input = {
    /** Represents a link to an article or web page */
    readonly _: 'inputInlineQueryResultArticle',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** URL of the result, if it exists */
    readonly url?: string,
    /** Title of the result */
    readonly title?: string,
    /** A short description of the result */
    readonly description?: string,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultAudio$Input = {
    /** Represents a link to an MP3 audio file */
    readonly _: 'inputInlineQueryResultAudio',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the audio file */
    readonly title?: string,
    /** Performer of the audio file */
    readonly performer?: string,
    /** The URL of the audio file */
    readonly audio_url?: string,
    /** Audio file duration, in seconds */
    readonly audio_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultContact$Input = {
    /** Represents a user contact */
    readonly _: 'inputInlineQueryResultContact',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** User contact */
    readonly contact?: contact$Input,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultDocument$Input = {
    /** Represents a link to a file */
    readonly _: 'inputInlineQueryResultDocument',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the resulting file */
    readonly title?: string,
    /** Short description of the result, if known */
    readonly description?: string,
    /** URL of the file */
    readonly document_url?: string,
    /**
     * MIME type of the file content; only "application/pdf" and "application/zip"
     * are currently allowed
     */
    readonly mime_type?: string,
    /** The URL of the file thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Width of the thumbnail */
    readonly thumbnail_width?: number,
    /** Height of the thumbnail */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultGame$Input = {
    /** Represents a game */
    readonly _: 'inputInlineQueryResultGame',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Short name of the game */
    readonly game_short_name?: string,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type inputInlineQueryResultLocation$Input = {
    /** Represents a point on the map */
    readonly _: 'inputInlineQueryResultLocation',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Location result */
    readonly location?: location$Input,
    /**
     * Amount of time relative to the message sent time until the location can be updated,
     * in seconds
     */
    readonly live_period?: number,
    /** Title of the result */
    readonly title?: string,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultPhoto$Input = {
    /** Represents link to a JPEG image */
    readonly _: 'inputInlineQueryResultPhoto',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the result, if known */
    readonly title?: string,
    /** A short description of the result, if known */
    readonly description?: string,
    /** URL of the photo thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** The URL of the JPEG photo (photo size must not exceed 5MB) */
    readonly photo_url?: string,
    /** Width of the photo */
    readonly photo_width?: number,
    /** Height of the photo */
    readonly photo_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultSticker$Input = {
    /** Represents a link to a WEBP, TGS, or WEBM sticker */
    readonly _: 'inputInlineQueryResultSticker',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** URL of the sticker thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /**
     * The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed
     * 5MB)
     */
    readonly sticker_url?: string,
    /** Width of the sticker */
    readonly sticker_width?: number,
    /** Height of the sticker */
    readonly sticker_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVenue$Input = {
    /** Represents information about a venue */
    readonly _: 'inputInlineQueryResultVenue',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Venue result */
    readonly venue?: venue$Input,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVideo$Input = {
    /** Represents a link to a page containing an embedded video player or a video file */
    readonly _: 'inputInlineQueryResultVideo',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the result */
    readonly title?: string,
    /** A short description of the result, if known */
    readonly description?: string,
    /** The URL of the video thumbnail (JPEG), if it exists */
    readonly thumbnail_url?: string,
    /** URL of the embedded video player or video file */
    readonly video_url?: string,
    /**
     * MIME type of the content of the video URL, only "text/html" or "video/mp4" are
     * currently supported
     */
    readonly mime_type?: string,
    /** Width of the video */
    readonly video_width?: number,
    /** Height of the video */
    readonly video_height?: number,
    /** Video duration, in seconds */
    readonly video_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVoiceNote$Input = {
    /**
     * Represents a link to an opus-encoded audio file within an OGG container, single
     * channel audio
     */
    readonly _: 'inputInlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the voice note */
    readonly title?: string,
    /** The URL of the voice note file */
    readonly voice_note_url?: string,
    /** Duration of the voice note, in seconds */
    readonly voice_note_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inlineQueryResultArticle = {
    /** Represents a link to an article or web page */
    _: 'inlineQueryResultArticle',
    /** Unique identifier of the query result */
    id: string,
    /** URL of the result, if it exists */
    url: string,
    /** Title of the result */
    title: string,
    /** A short description of the result */
    description: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultContact = {
    /** Represents a user contact */
    _: 'inlineQueryResultContact',
    /** Unique identifier of the query result */
    id: string,
    /** A user contact */
    contact: contact,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultLocation = {
    /** Represents a point on the map */
    _: 'inlineQueryResultLocation',
    /** Unique identifier of the query result */
    id: string,
    /** Location result */
    location: location,
    /** Title of the result */
    title: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultVenue = {
    /** Represents information about a venue */
    _: 'inlineQueryResultVenue',
    /** Unique identifier of the query result */
    id: string,
    /** Venue result */
    venue: venue,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultGame = {
    /** Represents information about a game */
    _: 'inlineQueryResultGame',
    /** Unique identifier of the query result */
    id: string,
    /** Game result */
    game: game,
  }

  export type inlineQueryResultAnimation = {
    /** Represents an animation file */
    _: 'inlineQueryResultAnimation',
    /** Unique identifier of the query result */
    id: string,
    /** Animation file */
    animation: animation,
    /** Animation title */
    title: string,
  }

  export type inlineQueryResultAudio = {
    /** Represents an audio file */
    _: 'inlineQueryResultAudio',
    /** Unique identifier of the query result */
    id: string,
    /** Audio file */
    audio: audio,
  }

  export type inlineQueryResultDocument = {
    /** Represents a document */
    _: 'inlineQueryResultDocument',
    /** Unique identifier of the query result */
    id: string,
    /** Document */
    document: document,
    /** Document title */
    title: string,
    /** Document description */
    description: string,
  }

  export type inlineQueryResultPhoto = {
    /** Represents a photo */
    _: 'inlineQueryResultPhoto',
    /** Unique identifier of the query result */
    id: string,
    /** Photo */
    photo: photo,
    /** Title of the result, if known */
    title: string,
    /** A short description of the result, if known */
    description: string,
  }

  export type inlineQueryResultSticker = {
    /** Represents a sticker */
    _: 'inlineQueryResultSticker',
    /** Unique identifier of the query result */
    id: string,
    /** Sticker */
    sticker: sticker,
  }

  export type inlineQueryResultVideo = {
    /** Represents a video */
    _: 'inlineQueryResultVideo',
    /** Unique identifier of the query result */
    id: string,
    /** Video */
    video: video,
    /** Title of the video */
    title: string,
    /** Description of the video */
    description: string,
  }

  export type inlineQueryResultVoiceNote = {
    /** Represents a voice note */
    _: 'inlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    id: string,
    /** Voice note */
    voice_note: voiceNote,
    /** Title of the voice note */
    title: string,
  }

  export type inlineQueryResultsButtonTypeStartBot = {
    /**
     * Describes the button that opens a private chat with the bot and sends a start
     * message to the bot with the given parameter
     */
    _: 'inlineQueryResultsButtonTypeStartBot',
    /** The parameter for the bot start message */
    parameter: string,
  }

  export type inlineQueryResultsButtonTypeStartBot$Input = {
    /**
     * Describes the button that opens a private chat with the bot and sends a start
     * message to the bot with the given parameter
     */
    readonly _: 'inlineQueryResultsButtonTypeStartBot',
    /** The parameter for the bot start message */
    readonly parameter?: string,
  }

  export type inlineQueryResultsButtonTypeWebApp = {
    /** Describes the button that opens a Web App by calling getWebAppUrl */
    _: 'inlineQueryResultsButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    url: string,
  }

  export type inlineQueryResultsButtonTypeWebApp$Input = {
    /** Describes the button that opens a Web App by calling getWebAppUrl */
    readonly _: 'inlineQueryResultsButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    readonly url?: string,
  }

  export type inlineQueryResultsButton = {
    /** Represents a button to be shown above inline query results */
    _: 'inlineQueryResultsButton',
    /** The text of the button */
    text: string,
    /** Type of the button */
    type: InlineQueryResultsButtonType,
  }

  export type inlineQueryResultsButton$Input = {
    /** Represents a button to be shown above inline query results */
    readonly _: 'inlineQueryResultsButton',
    /** The text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: InlineQueryResultsButtonType$Input,
  }

  export type inlineQueryResults = {
    /**
     * Represents the results of the inline query. Use sendInlineQueryResultMessage
     * to send the result of the query
     */
    _: 'inlineQueryResults',
    /** Unique identifier of the inline query */
    inline_query_id: string,
    /** Button to be shown above inline query results; may be null */
    button?: inlineQueryResultsButton,
    /** Results of the query */
    results: Array<InlineQueryResult>,
    /** The offset for the next request. If empty, then there are no more results */
    next_offset: string,
  }

  export type preparedInlineMessageId = {
    /** Represents an inline message that can be sent via the bot */
    _: 'preparedInlineMessageId',
    /** Unique identifier for the message */
    id: string,
    /** Point in time (Unix timestamp) when the message can't be used anymore */
    expiration_date: number,
  }

  export type preparedInlineMessage = {
    /**
     * Represents a ready to send inline message. Use sendInlineQueryResultMessage
     * to send the message
     */
    _: 'preparedInlineMessage',
    /** Unique identifier of the inline query to pass to sendInlineQueryResultMessage */
    inline_query_id: string,
    /** Resulted inline message of the query */
    result: InlineQueryResult,
    /** Types of the chats to which the message can be sent */
    chat_types: targetChatTypes,
  }

  export type callbackQueryPayloadData = {
    /** The payload for a general callback button */
    _: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    data: string /* base64 */,
  }

  export type callbackQueryPayloadData$Input = {
    /** The payload for a general callback button */
    readonly _: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    readonly data?: string /* base64 */,
  }

  export type callbackQueryPayloadDataWithPassword = {
    /** The payload for a callback button requiring password */
    _: 'callbackQueryPayloadDataWithPassword',
    /** The 2-step verification password for the current user */
    password: string,
    /** Data that was attached to the callback button */
    data: string /* base64 */,
  }

  export type callbackQueryPayloadDataWithPassword$Input = {
    /** The payload for a callback button requiring password */
    readonly _: 'callbackQueryPayloadDataWithPassword',
    /** The 2-step verification password for the current user */
    readonly password?: string,
    /** Data that was attached to the callback button */
    readonly data?: string /* base64 */,
  }

  export type callbackQueryPayloadGame = {
    /** The payload for a game callback button */
    _: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    game_short_name: string,
  }

  export type callbackQueryPayloadGame$Input = {
    /** The payload for a game callback button */
    readonly _: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    readonly game_short_name?: string,
  }

  export type callbackQueryAnswer = {
    /** Contains a bot's answer to a callback query */
    _: 'callbackQueryAnswer',
    /** Text of the answer */
    text: string,
    /** True, if an alert must be shown to the user instead of a toast notification */
    show_alert: boolean,
    /** URL to be opened */
    url: string,
  }

  export type customRequestResult = {
    /** Contains the result of a custom request */
    _: 'customRequestResult',
    /** A JSON-serialized result */
    result: string,
  }

  export type gameHighScore = {
    /** Contains one row of the game high score table */
    _: 'gameHighScore',
    /** Position in the high score table */
    position: number,
    /** User identifier */
    user_id: number,
    /** User score */
    score: number,
  }

  export type gameHighScores = {
    /** Contains a list of game high scores */
    _: 'gameHighScores',
    /** A list of game high scores */
    scores: Array<gameHighScore>,
  }

  export type chatEventMessageEdited = {
    /** A message was edited */
    _: 'chatEventMessageEdited',
    /** The original message before the edit */
    old_message: message,
    /** The message after it was edited */
    new_message: message,
  }

  export type chatEventMessageDeleted = {
    /** A message was deleted */
    _: 'chatEventMessageDeleted',
    /** Deleted message */
    message: message,
    /** True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive */
    can_report_anti_spam_false_positive: boolean,
  }

  export type chatEventMessagePinned = {
    /** A message was pinned */
    _: 'chatEventMessagePinned',
    /** Pinned message */
    message: message,
  }

  export type chatEventMessageUnpinned = {
    /** A message was unpinned */
    _: 'chatEventMessageUnpinned',
    /** Unpinned message */
    message: message,
  }

  export type chatEventPollStopped = {
    /** A poll in a message was stopped */
    _: 'chatEventPollStopped',
    /** The message with the poll */
    message: message,
  }

  export type chatEventMemberJoined = {
    /** A new member joined the chat */
    _: 'chatEventMemberJoined',
  }

  export type chatEventMemberJoinedByInviteLink = {
    /** A new member joined the chat via an invite link */
    _: 'chatEventMemberJoinedByInviteLink',
    /** Invite link used to join the chat */
    invite_link: chatInviteLink,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
  }

  export type chatEventMemberJoinedByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'chatEventMemberJoinedByRequest',
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
    /** Invite link used to join the chat; may be null */
    invite_link?: chatInviteLink,
  }

  export type chatEventMemberInvited = {
    /** A new chat member was invited */
    _: 'chatEventMemberInvited',
    /** New member user identifier */
    user_id: number,
    /** New member status */
    status: ChatMemberStatus,
  }

  export type chatEventMemberLeft = {
    /** A member left the chat */
    _: 'chatEventMemberLeft',
  }

  export type chatEventMemberPromoted = {
    /**
     * A chat member has gained/lost administrator status, or the list of their administrator
     * privileges has changed
     */
    _: 'chatEventMemberPromoted',
    /** Affected chat member user identifier */
    user_id: number,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  }

  export type chatEventMemberRestricted = {
    /**
     * A chat member was restricted/unrestricted or banned/unbanned, or the list of
     * their restrictions has changed
     */
    _: 'chatEventMemberRestricted',
    /** Affected chat member identifier */
    member_id: MessageSender,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  }

  export type chatEventMemberSubscriptionExtended = {
    /** A chat member extended their subscription to the chat */
    _: 'chatEventMemberSubscriptionExtended',
    /** Affected chat member user identifier */
    user_id: number,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  }

  export type chatEventAvailableReactionsChanged = {
    /** The chat available reactions were changed */
    _: 'chatEventAvailableReactionsChanged',
    /** Previous chat available reactions */
    old_available_reactions: ChatAvailableReactions,
    /** New chat available reactions */
    new_available_reactions: ChatAvailableReactions,
  }

  export type chatEventBackgroundChanged = {
    /** The chat background was changed */
    _: 'chatEventBackgroundChanged',
    /** Previous background; may be null if none */
    old_background?: chatBackground,
    /** New background; may be null if none */
    new_background?: chatBackground,
  }

  export type chatEventDescriptionChanged = {
    /** The chat description was changed */
    _: 'chatEventDescriptionChanged',
    /** Previous chat description */
    old_description: string,
    /** New chat description */
    new_description: string,
  }

  export type chatEventEmojiStatusChanged = {
    /** The chat emoji status was changed */
    _: 'chatEventEmojiStatusChanged',
    /** Previous emoji status; may be null if none */
    old_emoji_status?: emojiStatus,
    /** New emoji status; may be null if none */
    new_emoji_status?: emojiStatus,
  }

  export type chatEventLinkedChatChanged = {
    /** The linked chat of a supergroup was changed */
    _: 'chatEventLinkedChatChanged',
    /** Previous supergroup linked chat identifier */
    old_linked_chat_id: number,
    /** New supergroup linked chat identifier */
    new_linked_chat_id: number,
  }

  export type chatEventLocationChanged = {
    /** The supergroup location was changed */
    _: 'chatEventLocationChanged',
    /** Previous location; may be null */
    old_location?: chatLocation,
    /** New location; may be null */
    new_location?: chatLocation,
  }

  export type chatEventMessageAutoDeleteTimeChanged = {
    /** The message auto-delete timer was changed */
    _: 'chatEventMessageAutoDeleteTimeChanged',
    /** Previous value of message_auto_delete_time */
    old_message_auto_delete_time: number,
    /** New value of message_auto_delete_time */
    new_message_auto_delete_time: number,
  }

  export type chatEventPermissionsChanged = {
    /** The chat permissions were changed */
    _: 'chatEventPermissionsChanged',
    /** Previous chat permissions */
    old_permissions: chatPermissions,
    /** New chat permissions */
    new_permissions: chatPermissions,
  }

  export type chatEventPhotoChanged = {
    /** The chat photo was changed */
    _: 'chatEventPhotoChanged',
    /** Previous chat photo value; may be null */
    old_photo?: chatPhoto,
    /** New chat photo value; may be null */
    new_photo?: chatPhoto,
  }

  export type chatEventSlowModeDelayChanged = {
    /** The slow_mode_delay setting of a supergroup was changed */
    _: 'chatEventSlowModeDelayChanged',
    /** Previous value of slow_mode_delay, in seconds */
    old_slow_mode_delay: number,
    /** New value of slow_mode_delay, in seconds */
    new_slow_mode_delay: number,
  }

  export type chatEventStickerSetChanged = {
    /** The supergroup sticker set was changed */
    _: 'chatEventStickerSetChanged',
    /** Previous identifier of the chat sticker set; 0 if none */
    old_sticker_set_id: string,
    /** New identifier of the chat sticker set; 0 if none */
    new_sticker_set_id: string,
  }

  export type chatEventCustomEmojiStickerSetChanged = {
    /** The supergroup sticker set with allowed custom emoji was changed */
    _: 'chatEventCustomEmojiStickerSetChanged',
    /** Previous identifier of the chat sticker set; 0 if none */
    old_sticker_set_id: string,
    /** New identifier of the chat sticker set; 0 if none */
    new_sticker_set_id: string,
  }

  export type chatEventTitleChanged = {
    /** The chat title was changed */
    _: 'chatEventTitleChanged',
    /** Previous chat title */
    old_title: string,
    /** New chat title */
    new_title: string,
  }

  export type chatEventUsernameChanged = {
    /** The chat editable username was changed */
    _: 'chatEventUsernameChanged',
    /** Previous chat username */
    old_username: string,
    /** New chat username */
    new_username: string,
  }

  export type chatEventActiveUsernamesChanged = {
    /** The chat active usernames were changed */
    _: 'chatEventActiveUsernamesChanged',
    /** Previous list of active usernames */
    old_usernames: Array<string>,
    /** New list of active usernames */
    new_usernames: Array<string>,
  }

  export type chatEventAccentColorChanged = {
    /** The chat accent color or background custom emoji were changed */
    _: 'chatEventAccentColorChanged',
    /** Previous identifier of chat accent color */
    old_accent_color_id: number,
    /** Previous identifier of the custom emoji; 0 if none */
    old_background_custom_emoji_id: string,
    /** New identifier of chat accent color */
    new_accent_color_id: number,
    /** New identifier of the custom emoji; 0 if none */
    new_background_custom_emoji_id: string,
  }

  export type chatEventProfileAccentColorChanged = {
    /** The chat's profile accent color or profile background custom emoji were changed */
    _: 'chatEventProfileAccentColorChanged',
    /** Previous identifier of chat's profile accent color; -1 if none */
    old_profile_accent_color_id: number,
    /** Previous identifier of the custom emoji; 0 if none */
    old_profile_background_custom_emoji_id: string,
    /** New identifier of chat's profile accent color; -1 if none */
    new_profile_accent_color_id: number,
    /** New identifier of the custom emoji; 0 if none */
    new_profile_background_custom_emoji_id: string,
  }

  export type chatEventHasProtectedContentToggled = {
    /** The has_protected_content setting of a channel was toggled */
    _: 'chatEventHasProtectedContentToggled',
    /** New value of has_protected_content */
    has_protected_content: boolean,
  }

  export type chatEventInvitesToggled = {
    /** The can_invite_users permission of a supergroup chat was toggled */
    _: 'chatEventInvitesToggled',
    /** New value of can_invite_users permission */
    can_invite_users: boolean,
  }

  export type chatEventIsAllHistoryAvailableToggled = {
    /** The is_all_history_available setting of a supergroup was toggled */
    _: 'chatEventIsAllHistoryAvailableToggled',
    /** New value of is_all_history_available */
    is_all_history_available: boolean,
  }

  export type chatEventHasAggressiveAntiSpamEnabledToggled = {
    /** The has_aggressive_anti_spam_enabled setting of a supergroup was toggled */
    _: 'chatEventHasAggressiveAntiSpamEnabledToggled',
    /** New value of has_aggressive_anti_spam_enabled */
    has_aggressive_anti_spam_enabled: boolean,
  }

  export type chatEventSignMessagesToggled = {
    /** The sign_messages setting of a channel was toggled */
    _: 'chatEventSignMessagesToggled',
    /** New value of sign_messages */
    sign_messages: boolean,
  }

  export type chatEventShowMessageSenderToggled = {
    /** The show_message_sender setting of a channel was toggled */
    _: 'chatEventShowMessageSenderToggled',
    /** New value of show_message_sender */
    show_message_sender: boolean,
  }

  export type chatEventAutomaticTranslationToggled = {
    /** The has_automatic_translation setting of a channel was toggled */
    _: 'chatEventAutomaticTranslationToggled',
    /** New value of has_automatic_translation */
    has_automatic_translation: boolean,
  }

  export type chatEventInviteLinkEdited = {
    /** A chat invite link was edited */
    _: 'chatEventInviteLinkEdited',
    /** Previous information about the invite link */
    old_invite_link: chatInviteLink,
    /** New information about the invite link */
    new_invite_link: chatInviteLink,
  }

  export type chatEventInviteLinkRevoked = {
    /** A chat invite link was revoked */
    _: 'chatEventInviteLinkRevoked',
    /** The invite link */
    invite_link: chatInviteLink,
  }

  export type chatEventInviteLinkDeleted = {
    /** A revoked chat invite link was deleted */
    _: 'chatEventInviteLinkDeleted',
    /** The invite link */
    invite_link: chatInviteLink,
  }

  export type chatEventVideoChatCreated = {
    /** A video chat was created */
    _: 'chatEventVideoChatCreated',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type chatEventVideoChatEnded = {
    /** A video chat was ended */
    _: 'chatEventVideoChatEnded',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type chatEventVideoChatMuteNewParticipantsToggled = {
    /** The mute_new_participants setting of a video chat was toggled */
    _: 'chatEventVideoChatMuteNewParticipantsToggled',
    /** New value of the mute_new_participants setting */
    mute_new_participants: boolean,
  }

  export type chatEventVideoChatParticipantIsMutedToggled = {
    /** A video chat participant was muted or unmuted */
    _: 'chatEventVideoChatParticipantIsMutedToggled',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of is_muted */
    is_muted: boolean,
  }

  export type chatEventVideoChatParticipantVolumeLevelChanged = {
    /** A video chat participant volume level was changed */
    _: 'chatEventVideoChatParticipantVolumeLevelChanged',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of volume_level; 1-20000 in hundreds of percents */
    volume_level: number,
  }

  export type chatEventIsForumToggled = {
    /** The is_forum setting of a channel was toggled */
    _: 'chatEventIsForumToggled',
    /** New value of is_forum */
    is_forum: boolean,
  }

  export type chatEventForumTopicCreated = {
    /** A new forum topic was created */
    _: 'chatEventForumTopicCreated',
    /** Information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicEdited = {
    /** A forum topic was edited */
    _: 'chatEventForumTopicEdited',
    /** Old information about the topic */
    old_topic_info: forumTopicInfo,
    /** New information about the topic */
    new_topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicToggleIsClosed = {
    /** A forum topic was closed or reopened */
    _: 'chatEventForumTopicToggleIsClosed',
    /** New information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicToggleIsHidden = {
    /** The General forum topic was hidden or unhidden */
    _: 'chatEventForumTopicToggleIsHidden',
    /** New information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicDeleted = {
    /** A forum topic was deleted */
    _: 'chatEventForumTopicDeleted',
    /** Information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicPinned = {
    /** A pinned forum topic was changed */
    _: 'chatEventForumTopicPinned',
    /** Information about the old pinned topic; may be null */
    old_topic_info?: forumTopicInfo,
    /** Information about the new pinned topic; may be null */
    new_topic_info?: forumTopicInfo,
  }

  export type chatEvent = {
    /** Represents a chat event */
    _: 'chatEvent',
    /** Chat event identifier */
    id: string,
    /** Point in time (Unix timestamp) when the event happened */
    date: number,
    /** Identifier of the user or chat who performed the action */
    member_id: MessageSender,
    /** The action */
    action: ChatEventAction,
  }

  export type chatEvents = {
    /** Contains a list of chat events */
    _: 'chatEvents',
    /** List of events */
    events: Array<chatEvent>,
  }

  export type chatEventLogFilters$Input = {
    /** Represents a set of filters used to obtain a chat event log */
    readonly _: 'chatEventLogFilters',
    /** True, if message edits need to be returned */
    readonly message_edits?: boolean,
    /** True, if message deletions need to be returned */
    readonly message_deletions?: boolean,
    /** True, if pin/unpin events need to be returned */
    readonly message_pins?: boolean,
    /** True, if members joining events need to be returned */
    readonly member_joins?: boolean,
    /** True, if members leaving events need to be returned */
    readonly member_leaves?: boolean,
    /** True, if invited member events need to be returned */
    readonly member_invites?: boolean,
    /** True, if member promotion/demotion events need to be returned */
    readonly member_promotions?: boolean,
    /** True, if member restricted/unrestricted/banned/unbanned events need to be returned */
    readonly member_restrictions?: boolean,
    /** True, if changes in chat information need to be returned */
    readonly info_changes?: boolean,
    /** True, if changes in chat settings need to be returned */
    readonly setting_changes?: boolean,
    /** True, if changes to invite links need to be returned */
    readonly invite_link_changes?: boolean,
    /** True, if video chat actions need to be returned */
    readonly video_chat_changes?: boolean,
    /** True, if forum-related actions need to be returned */
    readonly forum_changes?: boolean,
    /** True, if subscription extensions need to be returned */
    readonly subscription_extensions?: boolean,
  }

  export type languagePackStringValueOrdinary = {
    /** An ordinary language pack string */
    _: 'languagePackStringValueOrdinary',
    /** String value */
    value: string,
  }

  export type languagePackStringValueOrdinary$Input = {
    /** An ordinary language pack string */
    readonly _: 'languagePackStringValueOrdinary',
    /** String value */
    readonly value?: string,
  }

  export type languagePackStringValuePluralized = {
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    _: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    zero_value: string,
    /** Value for one object */
    one_value: string,
    /** Value for two objects */
    two_value: string,
    /** Value for few objects */
    few_value: string,
    /** Value for many objects */
    many_value: string,
    /** Default value */
    other_value: string,
  }

  export type languagePackStringValuePluralized$Input = {
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    readonly _: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    readonly zero_value?: string,
    /** Value for one object */
    readonly one_value?: string,
    /** Value for two objects */
    readonly two_value?: string,
    /** Value for few objects */
    readonly few_value?: string,
    /** Value for many objects */
    readonly many_value?: string,
    /** Default value */
    readonly other_value?: string,
  }

  export type languagePackStringValueDeleted = {
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    _: 'languagePackStringValueDeleted',
  }

  export type languagePackStringValueDeleted$Input = {
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    readonly _: 'languagePackStringValueDeleted',
  }

  export type languagePackString = {
    /** Represents one language pack string */
    _: 'languagePackString',
    /** String key */
    key: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    value: LanguagePackStringValue,
  }

  export type languagePackString$Input = {
    /** Represents one language pack string */
    readonly _: 'languagePackString',
    /** String key */
    readonly key?: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    readonly value?: LanguagePackStringValue$Input,
  }

  export type languagePackStrings = {
    /** Contains a list of language pack strings */
    _: 'languagePackStrings',
    /** A list of language pack strings */
    strings: Array<languagePackString>,
  }

  export type languagePackInfo = {
    /** Contains information about a language pack */
    _: 'languagePackInfo',
    /** Unique language pack identifier */
    id: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    base_language_pack_id: string,
    /** Language name */
    name: string,
    /** Name of the language in that language */
    native_name: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    plural_code: string,
    /** True, if the language pack is official */
    is_official: boolean,
    /** True, if the language pack strings are RTL */
    is_rtl: boolean,
    /** True, if the language pack is a beta language pack */
    is_beta: boolean,
    /** True, if the language pack is installed by the current user */
    is_installed: boolean,
    /** Total number of non-deleted strings from the language pack */
    total_string_count: number,
    /** Total number of translated strings from the language pack */
    translated_string_count: number,
    /** Total number of non-deleted strings from the language pack available locally */
    local_string_count: number,
    /** Link to language translation interface; empty for custom local language packs */
    translation_url: string,
  }

  export type languagePackInfo$Input = {
    /** Contains information about a language pack */
    readonly _: 'languagePackInfo',
    /** Unique language pack identifier */
    readonly id?: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    readonly base_language_pack_id?: string,
    /** Language name */
    readonly name?: string,
    /** Name of the language in that language */
    readonly native_name?: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    readonly plural_code?: string,
    /** True, if the language pack is official */
    readonly is_official?: boolean,
    /** True, if the language pack strings are RTL */
    readonly is_rtl?: boolean,
    /** True, if the language pack is a beta language pack */
    readonly is_beta?: boolean,
    /** True, if the language pack is installed by the current user */
    readonly is_installed?: boolean,
    /** Total number of non-deleted strings from the language pack */
    readonly total_string_count?: number,
    /** Total number of translated strings from the language pack */
    readonly translated_string_count?: number,
    /** Total number of non-deleted strings from the language pack available locally */
    readonly local_string_count?: number,
    /** Link to language translation interface; empty for custom local language packs */
    readonly translation_url?: string,
  }

  export type localizationTargetInfo = {
    /** Contains information about the current localization target */
    _: 'localizationTargetInfo',
    /** List of available language packs for this application */
    language_packs: Array<languagePackInfo>,
  }

  export type premiumLimitTypeSupergroupCount = {
    /** The maximum number of joined supergroups and channels */
    _: 'premiumLimitTypeSupergroupCount',
  }

  export type premiumLimitTypeSupergroupCount$Input = {
    /** The maximum number of joined supergroups and channels */
    readonly _: 'premiumLimitTypeSupergroupCount',
  }

  export type premiumLimitTypePinnedChatCount = {
    /** The maximum number of pinned chats in the main chat list */
    _: 'premiumLimitTypePinnedChatCount',
  }

  export type premiumLimitTypePinnedChatCount$Input = {
    /** The maximum number of pinned chats in the main chat list */
    readonly _: 'premiumLimitTypePinnedChatCount',
  }

  export type premiumLimitTypeCreatedPublicChatCount = {
    /** The maximum number of created public chats */
    _: 'premiumLimitTypeCreatedPublicChatCount',
  }

  export type premiumLimitTypeCreatedPublicChatCount$Input = {
    /** The maximum number of created public chats */
    readonly _: 'premiumLimitTypeCreatedPublicChatCount',
  }

  export type premiumLimitTypeSavedAnimationCount = {
    /** The maximum number of saved animations */
    _: 'premiumLimitTypeSavedAnimationCount',
  }

  export type premiumLimitTypeSavedAnimationCount$Input = {
    /** The maximum number of saved animations */
    readonly _: 'premiumLimitTypeSavedAnimationCount',
  }

  export type premiumLimitTypeFavoriteStickerCount = {
    /** The maximum number of favorite stickers */
    _: 'premiumLimitTypeFavoriteStickerCount',
  }

  export type premiumLimitTypeFavoriteStickerCount$Input = {
    /** The maximum number of favorite stickers */
    readonly _: 'premiumLimitTypeFavoriteStickerCount',
  }

  export type premiumLimitTypeChatFolderCount = {
    /** The maximum number of chat folders */
    _: 'premiumLimitTypeChatFolderCount',
  }

  export type premiumLimitTypeChatFolderCount$Input = {
    /** The maximum number of chat folders */
    readonly _: 'premiumLimitTypeChatFolderCount',
  }

  export type premiumLimitTypeChatFolderChosenChatCount = {
    /**
     * The maximum number of pinned and always included, or always excluded chats in
     * a chat folder
     */
    _: 'premiumLimitTypeChatFolderChosenChatCount',
  }

  export type premiumLimitTypeChatFolderChosenChatCount$Input = {
    /**
     * The maximum number of pinned and always included, or always excluded chats in
     * a chat folder
     */
    readonly _: 'premiumLimitTypeChatFolderChosenChatCount',
  }

  export type premiumLimitTypePinnedArchivedChatCount = {
    /** The maximum number of pinned chats in the archive chat list */
    _: 'premiumLimitTypePinnedArchivedChatCount',
  }

  export type premiumLimitTypePinnedArchivedChatCount$Input = {
    /** The maximum number of pinned chats in the archive chat list */
    readonly _: 'premiumLimitTypePinnedArchivedChatCount',
  }

  export type premiumLimitTypePinnedSavedMessagesTopicCount = {
    /** The maximum number of pinned Saved Messages topics */
    _: 'premiumLimitTypePinnedSavedMessagesTopicCount',
  }

  export type premiumLimitTypePinnedSavedMessagesTopicCount$Input = {
    /** The maximum number of pinned Saved Messages topics */
    readonly _: 'premiumLimitTypePinnedSavedMessagesTopicCount',
  }

  export type premiumLimitTypeCaptionLength = {
    /** The maximum length of sent media caption */
    _: 'premiumLimitTypeCaptionLength',
  }

  export type premiumLimitTypeCaptionLength$Input = {
    /** The maximum length of sent media caption */
    readonly _: 'premiumLimitTypeCaptionLength',
  }

  export type premiumLimitTypeBioLength = {
    /** The maximum length of the user's bio */
    _: 'premiumLimitTypeBioLength',
  }

  export type premiumLimitTypeBioLength$Input = {
    /** The maximum length of the user's bio */
    readonly _: 'premiumLimitTypeBioLength',
  }

  export type premiumLimitTypeChatFolderInviteLinkCount = {
    /** The maximum number of invite links for a chat folder */
    _: 'premiumLimitTypeChatFolderInviteLinkCount',
  }

  export type premiumLimitTypeChatFolderInviteLinkCount$Input = {
    /** The maximum number of invite links for a chat folder */
    readonly _: 'premiumLimitTypeChatFolderInviteLinkCount',
  }

  export type premiumLimitTypeShareableChatFolderCount = {
    /** The maximum number of added shareable chat folders */
    _: 'premiumLimitTypeShareableChatFolderCount',
  }

  export type premiumLimitTypeShareableChatFolderCount$Input = {
    /** The maximum number of added shareable chat folders */
    readonly _: 'premiumLimitTypeShareableChatFolderCount',
  }

  export type premiumLimitTypeActiveStoryCount = {
    /** The maximum number of active stories */
    _: 'premiumLimitTypeActiveStoryCount',
  }

  export type premiumLimitTypeActiveStoryCount$Input = {
    /** The maximum number of active stories */
    readonly _: 'premiumLimitTypeActiveStoryCount',
  }

  export type premiumLimitTypeWeeklyPostedStoryCount = {
    /** The maximum number of stories posted per week */
    _: 'premiumLimitTypeWeeklyPostedStoryCount',
  }

  export type premiumLimitTypeWeeklyPostedStoryCount$Input = {
    /** The maximum number of stories posted per week */
    readonly _: 'premiumLimitTypeWeeklyPostedStoryCount',
  }

  export type premiumLimitTypeMonthlyPostedStoryCount = {
    /** The maximum number of stories posted per month */
    _: 'premiumLimitTypeMonthlyPostedStoryCount',
  }

  export type premiumLimitTypeMonthlyPostedStoryCount$Input = {
    /** The maximum number of stories posted per month */
    readonly _: 'premiumLimitTypeMonthlyPostedStoryCount',
  }

  export type premiumLimitTypeStoryCaptionLength = {
    /** The maximum length of captions of posted stories */
    _: 'premiumLimitTypeStoryCaptionLength',
  }

  export type premiumLimitTypeStoryCaptionLength$Input = {
    /** The maximum length of captions of posted stories */
    readonly _: 'premiumLimitTypeStoryCaptionLength',
  }

  export type premiumLimitTypeStorySuggestedReactionAreaCount = {
    /** The maximum number of suggested reaction areas on a story */
    _: 'premiumLimitTypeStorySuggestedReactionAreaCount',
  }

  export type premiumLimitTypeStorySuggestedReactionAreaCount$Input = {
    /** The maximum number of suggested reaction areas on a story */
    readonly _: 'premiumLimitTypeStorySuggestedReactionAreaCount',
  }

  export type premiumLimitTypeSimilarChatCount = {
    /** The maximum number of received similar chats */
    _: 'premiumLimitTypeSimilarChatCount',
  }

  export type premiumLimitTypeSimilarChatCount$Input = {
    /** The maximum number of received similar chats */
    readonly _: 'premiumLimitTypeSimilarChatCount',
  }

  export type premiumFeatureIncreasedLimits = {
    /** Increased limits */
    _: 'premiumFeatureIncreasedLimits',
  }

  export type premiumFeatureIncreasedLimits$Input = {
    /** Increased limits */
    readonly _: 'premiumFeatureIncreasedLimits',
  }

  export type premiumFeatureIncreasedUploadFileSize = {
    /** Increased maximum upload file size */
    _: 'premiumFeatureIncreasedUploadFileSize',
  }

  export type premiumFeatureIncreasedUploadFileSize$Input = {
    /** Increased maximum upload file size */
    readonly _: 'premiumFeatureIncreasedUploadFileSize',
  }

  export type premiumFeatureImprovedDownloadSpeed = {
    /** Improved download speed */
    _: 'premiumFeatureImprovedDownloadSpeed',
  }

  export type premiumFeatureImprovedDownloadSpeed$Input = {
    /** Improved download speed */
    readonly _: 'premiumFeatureImprovedDownloadSpeed',
  }

  export type premiumFeatureVoiceRecognition = {
    /** The ability to convert voice notes to text */
    _: 'premiumFeatureVoiceRecognition',
  }

  export type premiumFeatureVoiceRecognition$Input = {
    /** The ability to convert voice notes to text */
    readonly _: 'premiumFeatureVoiceRecognition',
  }

  export type premiumFeatureDisabledAds = {
    /** Disabled ads */
    _: 'premiumFeatureDisabledAds',
  }

  export type premiumFeatureDisabledAds$Input = {
    /** Disabled ads */
    readonly _: 'premiumFeatureDisabledAds',
  }

  export type premiumFeatureUniqueReactions = {
    /** Allowed to use more reactions */
    _: 'premiumFeatureUniqueReactions',
  }

  export type premiumFeatureUniqueReactions$Input = {
    /** Allowed to use more reactions */
    readonly _: 'premiumFeatureUniqueReactions',
  }

  export type premiumFeatureUniqueStickers = {
    /** Allowed to use premium stickers with unique effects */
    _: 'premiumFeatureUniqueStickers',
  }

  export type premiumFeatureUniqueStickers$Input = {
    /** Allowed to use premium stickers with unique effects */
    readonly _: 'premiumFeatureUniqueStickers',
  }

  export type premiumFeatureCustomEmoji = {
    /** Allowed to use custom emoji stickers in message texts and captions */
    _: 'premiumFeatureCustomEmoji',
  }

  export type premiumFeatureCustomEmoji$Input = {
    /** Allowed to use custom emoji stickers in message texts and captions */
    readonly _: 'premiumFeatureCustomEmoji',
  }

  export type premiumFeatureAdvancedChatManagement = {
    /**
     * Ability to change position of the main chat list, archive and mute all new chats
     * from non-contacts, and completely disable notifications about the user's contacts
     * joined Telegram
     */
    _: 'premiumFeatureAdvancedChatManagement',
  }

  export type premiumFeatureAdvancedChatManagement$Input = {
    /**
     * Ability to change position of the main chat list, archive and mute all new chats
     * from non-contacts, and completely disable notifications about the user's contacts
     * joined Telegram
     */
    readonly _: 'premiumFeatureAdvancedChatManagement',
  }

  export type premiumFeatureProfileBadge = {
    /** A badge in the user's profile */
    _: 'premiumFeatureProfileBadge',
  }

  export type premiumFeatureProfileBadge$Input = {
    /** A badge in the user's profile */
    readonly _: 'premiumFeatureProfileBadge',
  }

  export type premiumFeatureEmojiStatus = {
    /** The ability to show an emoji status along with the user's name */
    _: 'premiumFeatureEmojiStatus',
  }

  export type premiumFeatureEmojiStatus$Input = {
    /** The ability to show an emoji status along with the user's name */
    readonly _: 'premiumFeatureEmojiStatus',
  }

  export type premiumFeatureAnimatedProfilePhoto = {
    /** Profile photo animation on message and chat screens */
    _: 'premiumFeatureAnimatedProfilePhoto',
  }

  export type premiumFeatureAnimatedProfilePhoto$Input = {
    /** Profile photo animation on message and chat screens */
    readonly _: 'premiumFeatureAnimatedProfilePhoto',
  }

  export type premiumFeatureForumTopicIcon = {
    /** The ability to set a custom emoji as a forum topic icon */
    _: 'premiumFeatureForumTopicIcon',
  }

  export type premiumFeatureForumTopicIcon$Input = {
    /** The ability to set a custom emoji as a forum topic icon */
    readonly _: 'premiumFeatureForumTopicIcon',
  }

  export type premiumFeatureAppIcons = {
    /** Allowed to set a premium application icons */
    _: 'premiumFeatureAppIcons',
  }

  export type premiumFeatureAppIcons$Input = {
    /** Allowed to set a premium application icons */
    readonly _: 'premiumFeatureAppIcons',
  }

  export type premiumFeatureRealTimeChatTranslation = {
    /** Allowed to translate chat messages real-time */
    _: 'premiumFeatureRealTimeChatTranslation',
  }

  export type premiumFeatureRealTimeChatTranslation$Input = {
    /** Allowed to translate chat messages real-time */
    readonly _: 'premiumFeatureRealTimeChatTranslation',
  }

  export type premiumFeatureUpgradedStories = {
    /** Allowed to use many additional features for stories */
    _: 'premiumFeatureUpgradedStories',
  }

  export type premiumFeatureUpgradedStories$Input = {
    /** Allowed to use many additional features for stories */
    readonly _: 'premiumFeatureUpgradedStories',
  }

  export type premiumFeatureChatBoost = {
    /** The ability to boost chats */
    _: 'premiumFeatureChatBoost',
  }

  export type premiumFeatureChatBoost$Input = {
    /** The ability to boost chats */
    readonly _: 'premiumFeatureChatBoost',
  }

  export type premiumFeatureAccentColor = {
    /** The ability to choose accent color for replies and user profile */
    _: 'premiumFeatureAccentColor',
  }

  export type premiumFeatureAccentColor$Input = {
    /** The ability to choose accent color for replies and user profile */
    readonly _: 'premiumFeatureAccentColor',
  }

  export type premiumFeatureBackgroundForBoth = {
    /** The ability to set private chat background for both users */
    _: 'premiumFeatureBackgroundForBoth',
  }

  export type premiumFeatureBackgroundForBoth$Input = {
    /** The ability to set private chat background for both users */
    readonly _: 'premiumFeatureBackgroundForBoth',
  }

  export type premiumFeatureSavedMessagesTags = {
    /** The ability to use tags in Saved Messages */
    _: 'premiumFeatureSavedMessagesTags',
  }

  export type premiumFeatureSavedMessagesTags$Input = {
    /** The ability to use tags in Saved Messages */
    readonly _: 'premiumFeatureSavedMessagesTags',
  }

  export type premiumFeatureMessagePrivacy = {
    /**
     * The ability to disallow incoming voice and video note messages in private chats
     * using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
     * and to restrict incoming messages from non-contacts using setNewChatPrivacySettings
     */
    _: 'premiumFeatureMessagePrivacy',
  }

  export type premiumFeatureMessagePrivacy$Input = {
    /**
     * The ability to disallow incoming voice and video note messages in private chats
     * using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
     * and to restrict incoming messages from non-contacts using setNewChatPrivacySettings
     */
    readonly _: 'premiumFeatureMessagePrivacy',
  }

  export type premiumFeatureLastSeenTimes = {
    /**
     * The ability to view last seen and read times of other users even they can't
     * view last seen or read time for the current user
     */
    _: 'premiumFeatureLastSeenTimes',
  }

  export type premiumFeatureLastSeenTimes$Input = {
    /**
     * The ability to view last seen and read times of other users even they can't
     * view last seen or read time for the current user
     */
    readonly _: 'premiumFeatureLastSeenTimes',
  }

  export type premiumFeatureBusiness = {
    /** The ability to use Business features */
    _: 'premiumFeatureBusiness',
  }

  export type premiumFeatureBusiness$Input = {
    /** The ability to use Business features */
    readonly _: 'premiumFeatureBusiness',
  }

  export type premiumFeatureMessageEffects = {
    /** The ability to use all available message effects */
    _: 'premiumFeatureMessageEffects',
  }

  export type premiumFeatureMessageEffects$Input = {
    /** The ability to use all available message effects */
    readonly _: 'premiumFeatureMessageEffects',
  }

  export type premiumFeatureChecklists = {
    /** The ability to create and use checklist messages */
    _: 'premiumFeatureChecklists',
  }

  export type premiumFeatureChecklists$Input = {
    /** The ability to create and use checklist messages */
    readonly _: 'premiumFeatureChecklists',
  }

  export type businessFeatureLocation = {
    /** The ability to set location */
    _: 'businessFeatureLocation',
  }

  export type businessFeatureLocation$Input = {
    /** The ability to set location */
    readonly _: 'businessFeatureLocation',
  }

  export type businessFeatureOpeningHours = {
    /** The ability to set opening hours */
    _: 'businessFeatureOpeningHours',
  }

  export type businessFeatureOpeningHours$Input = {
    /** The ability to set opening hours */
    readonly _: 'businessFeatureOpeningHours',
  }

  export type businessFeatureQuickReplies = {
    /** The ability to use quick replies */
    _: 'businessFeatureQuickReplies',
  }

  export type businessFeatureQuickReplies$Input = {
    /** The ability to use quick replies */
    readonly _: 'businessFeatureQuickReplies',
  }

  export type businessFeatureGreetingMessage = {
    /** The ability to set up a greeting message */
    _: 'businessFeatureGreetingMessage',
  }

  export type businessFeatureGreetingMessage$Input = {
    /** The ability to set up a greeting message */
    readonly _: 'businessFeatureGreetingMessage',
  }

  export type businessFeatureAwayMessage = {
    /** The ability to set up an away message */
    _: 'businessFeatureAwayMessage',
  }

  export type businessFeatureAwayMessage$Input = {
    /** The ability to set up an away message */
    readonly _: 'businessFeatureAwayMessage',
  }

  export type businessFeatureAccountLinks = {
    /**
     * The ability to create links to the business account with predefined message
     * text
     */
    _: 'businessFeatureAccountLinks',
  }

  export type businessFeatureAccountLinks$Input = {
    /**
     * The ability to create links to the business account with predefined message
     * text
     */
    readonly _: 'businessFeatureAccountLinks',
  }

  export type businessFeatureStartPage = {
    /** The ability to customize start page */
    _: 'businessFeatureStartPage',
  }

  export type businessFeatureStartPage$Input = {
    /** The ability to customize start page */
    readonly _: 'businessFeatureStartPage',
  }

  export type businessFeatureBots = {
    /** The ability to connect a bot to the account */
    _: 'businessFeatureBots',
  }

  export type businessFeatureBots$Input = {
    /** The ability to connect a bot to the account */
    readonly _: 'businessFeatureBots',
  }

  export type businessFeatureEmojiStatus = {
    /** The ability to show an emoji status along with the business name */
    _: 'businessFeatureEmojiStatus',
  }

  export type businessFeatureEmojiStatus$Input = {
    /** The ability to show an emoji status along with the business name */
    readonly _: 'businessFeatureEmojiStatus',
  }

  export type businessFeatureChatFolderTags = {
    /** The ability to display folder names for each chat in the chat list */
    _: 'businessFeatureChatFolderTags',
  }

  export type businessFeatureChatFolderTags$Input = {
    /** The ability to display folder names for each chat in the chat list */
    readonly _: 'businessFeatureChatFolderTags',
  }

  export type businessFeatureUpgradedStories = {
    /** Allowed to use many additional features for stories */
    _: 'businessFeatureUpgradedStories',
  }

  export type businessFeatureUpgradedStories$Input = {
    /** Allowed to use many additional features for stories */
    readonly _: 'businessFeatureUpgradedStories',
  }

  export type premiumStoryFeaturePriorityOrder$Input = {
    /**
     * Stories of the current user are displayed before stories of non-Premium contacts,
     * supergroups, and channels
     */
    readonly _: 'premiumStoryFeaturePriorityOrder',
  }

  export type premiumStoryFeatureStealthMode$Input = {
    /** The ability to hide the fact that the user viewed other's stories */
    readonly _: 'premiumStoryFeatureStealthMode',
  }

  export type premiumStoryFeaturePermanentViewsHistory$Input = {
    /** The ability to check who opened the current user's stories after they expire */
    readonly _: 'premiumStoryFeaturePermanentViewsHistory',
  }

  export type premiumStoryFeatureCustomExpirationDuration$Input = {
    /** The ability to set custom expiration duration for stories */
    readonly _: 'premiumStoryFeatureCustomExpirationDuration',
  }

  export type premiumStoryFeatureSaveStories$Input = {
    /** The ability to save other's unprotected stories */
    readonly _: 'premiumStoryFeatureSaveStories',
  }

  export type premiumStoryFeatureLinksAndFormatting$Input = {
    /**
     * The ability to use links and formatting in story caption, and use inputStoryAreaTypeLink
     * areas
     */
    readonly _: 'premiumStoryFeatureLinksAndFormatting',
  }

  export type premiumStoryFeatureVideoQuality$Input = {
    /** The ability to choose better quality for viewed stories */
    readonly _: 'premiumStoryFeatureVideoQuality',
  }

  export type premiumLimit = {
    /** Contains information about a limit, increased for Premium users */
    _: 'premiumLimit',
    /** The type of the limit */
    type: PremiumLimitType,
    /** Default value of the limit */
    default_value: number,
    /** Value of the limit for Premium users */
    premium_value: number,
  }

  export type premiumFeatures = {
    /** Contains information about features, available to Premium users */
    _: 'premiumFeatures',
    /** The list of available features */
    features: Array<PremiumFeature>,
    /** The list of limits, increased for Premium users */
    limits: Array<premiumLimit>,
    /**
     * An internal link to be opened to pay for Telegram Premium if store payment isn't
     * possible; may be null if direct payment isn't available
     */
    payment_link?: InternalLinkType,
  }

  export type businessFeatures = {
    /** Contains information about features, available to Business user accounts */
    _: 'businessFeatures',
    /** The list of available business features */
    features: Array<BusinessFeature>,
  }

  export type premiumSourceLimitExceeded$Input = {
    /** A limit was exceeded */
    readonly _: 'premiumSourceLimitExceeded',
    /** Type of the exceeded limit */
    readonly limit_type?: PremiumLimitType$Input,
  }

  export type premiumSourceFeature$Input = {
    /** A user tried to use a Premium feature */
    readonly _: 'premiumSourceFeature',
    /** The used feature */
    readonly feature?: PremiumFeature$Input,
  }

  export type premiumSourceBusinessFeature$Input = {
    /** A user tried to use a Business feature */
    readonly _: 'premiumSourceBusinessFeature',
    /** The used feature; pass null if none specific feature was used */
    readonly feature?: BusinessFeature$Input,
  }

  export type premiumSourceStoryFeature$Input = {
    /** A user tried to use a Premium story feature */
    readonly _: 'premiumSourceStoryFeature',
    /** The used feature */
    readonly feature?: PremiumStoryFeature$Input,
  }

  export type premiumSourceLink$Input = {
    /** A user opened an internal link of the type internalLinkTypePremiumFeatures */
    readonly _: 'premiumSourceLink',
    /** The referrer from the link */
    readonly referrer?: string,
  }

  export type premiumSourceSettings$Input = {
    /** A user opened the Premium features screen from settings */
    readonly _: 'premiumSourceSettings',
  }

  export type premiumFeaturePromotionAnimation = {
    /** Describes a promotion animation for a Premium feature */
    _: 'premiumFeaturePromotionAnimation',
    /** Premium feature */
    feature: PremiumFeature,
    /** Promotion animation for the feature */
    animation: animation,
  }

  export type businessFeaturePromotionAnimation = {
    /** Describes a promotion animation for a Business feature */
    _: 'businessFeaturePromotionAnimation',
    /** Business feature */
    feature: BusinessFeature,
    /** Promotion animation for the feature */
    animation: animation,
  }

  export type premiumState = {
    /**
     * Contains state of Telegram Premium subscription and promotion videos for Premium
     * features
     */
    _: 'premiumState',
    /**
     * Text description of the state of the current Premium subscription; may be empty
     * if the current user has no Telegram Premium subscription
     */
    state: formattedText,
    /** The list of available options for buying Telegram Premium */
    payment_options: Array<premiumStatePaymentOption>,
    /** The list of available promotion animations for Premium features */
    animations: Array<premiumFeaturePromotionAnimation>,
    /** The list of available promotion animations for Business features */
    business_animations: Array<businessFeaturePromotionAnimation>,
  }

  export type storePaymentPurposePremiumSubscription$Input = {
    /** The user subscribing to Telegram Premium */
    readonly _: 'storePaymentPurposePremiumSubscription',
    /**
     * Pass true if this is a restore of a Telegram Premium purchase; only for App
     * Store
     */
    readonly is_restore?: boolean,
    /**
     * Pass true if this is an upgrade from a monthly subscription to early subscription;
     * only for App Store
     */
    readonly is_upgrade?: boolean,
  }

  export type storePaymentPurposePremiumGift$Input = {
    /** The user gifting Telegram Premium to another user */
    readonly _: 'storePaymentPurposePremiumGift',
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Identifiers of the user which will receive Telegram Premium */
    readonly user_id?: number,
    /**
     * Text to show along with the gift codes; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    readonly text?: formattedText$Input,
  }

  export type storePaymentPurposePremiumGiftCodes$Input = {
    /** The user boosting a chat by creating Telegram Premium gift codes for other users */
    readonly _: 'storePaymentPurposePremiumGiftCodes',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the users for duration of the Premium subscription and which is administered
     * by the user
     */
    readonly boosted_chat_id?: number,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Identifiers of the users which can activate the gift codes */
    readonly user_ids?: ReadonlyArray<number>,
    /**
     * Text to show along with the gift codes; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    readonly text?: formattedText$Input,
  }

  export type storePaymentPurposePremiumGiveaway$Input = {
    /** The user creating a Telegram Premium giveaway */
    readonly _: 'storePaymentPurposePremiumGiveaway',
    /** Giveaway parameters */
    readonly parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
  }

  export type storePaymentPurposeStarGiveaway$Input = {
    /** The user creating a Telegram Star giveaway */
    readonly _: 'storePaymentPurposeStarGiveaway',
    /** Giveaway parameters */
    readonly parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** The number of users to receive Telegram Stars */
    readonly winner_count?: number,
    /** The number of Telegram Stars to be distributed through the giveaway */
    readonly star_count?: number,
  }

  export type storePaymentPurposeStars$Input = {
    /** The user buying Telegram Stars */
    readonly _: 'storePaymentPurposeStars',
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Number of bought Telegram Stars */
    readonly star_count?: number,
  }

  export type storePaymentPurposeGiftedStars$Input = {
    /** The user buying Telegram Stars for other users */
    readonly _: 'storePaymentPurposeGiftedStars',
    /** Identifier of the user to which Telegram Stars are gifted */
    readonly user_id?: number,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Number of bought Telegram Stars */
    readonly star_count?: number,
  }

  export type storeTransactionAppStore$Input = {
    /** A purchase through App Store */
    readonly _: 'storeTransactionAppStore',
    /** App Store receipt */
    readonly receipt?: string /* base64 */,
  }

  export type storeTransactionGooglePlay$Input = {
    /** A purchase through Google Play */
    readonly _: 'storeTransactionGooglePlay',
    /** Application package name */
    readonly package_name?: string,
    /** Identifier of the purchased store product */
    readonly store_product_id?: string,
    /** Google Play purchase token */
    readonly purchase_token?: string,
  }

  export type telegramPaymentPurposePremiumGift$Input = {
    /** The user gifting Telegram Premium to another user */
    readonly _: 'telegramPaymentPurposePremiumGift',
    /**
     * ISO 4217 currency code of the payment currency, or "XTR" for payments in Telegram
     * Stars
     */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Identifier of the user which will receive Telegram Premium */
    readonly user_id?: number,
    /** Number of months the Telegram Premium subscription will be active for the user */
    readonly month_count?: number,
    /**
     * Text to show to the user receiving Telegram Premium; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    readonly text?: formattedText$Input,
  }

  export type telegramPaymentPurposePremiumGiftCodes$Input = {
    /** The user boosting a chat by creating Telegram Premium gift codes for other users */
    readonly _: 'telegramPaymentPurposePremiumGiftCodes',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by the users for duration of the Premium subscription and which is administered
     * by the user
     */
    readonly boosted_chat_id?: number,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Identifiers of the users which can activate the gift codes */
    readonly user_ids?: ReadonlyArray<number>,
    /** Number of months the Telegram Premium subscription will be active for the users */
    readonly month_count?: number,
    /**
     * Text to show along with the gift codes; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    readonly text?: formattedText$Input,
  }

  export type telegramPaymentPurposePremiumGiveaway$Input = {
    /** The user creating a Telegram Premium giveaway */
    readonly _: 'telegramPaymentPurposePremiumGiveaway',
    /** Giveaway parameters */
    readonly parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Number of users which will be able to activate the gift codes */
    readonly winner_count?: number,
    /** Number of months the Telegram Premium subscription will be active for the users */
    readonly month_count?: number,
  }

  export type telegramPaymentPurposeStars$Input = {
    /** The user buying Telegram Stars */
    readonly _: 'telegramPaymentPurposeStars',
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Number of bought Telegram Stars */
    readonly star_count?: number,
  }

  export type telegramPaymentPurposeGiftedStars$Input = {
    /** The user buying Telegram Stars for other users */
    readonly _: 'telegramPaymentPurposeGiftedStars',
    /** Identifier of the user to which Telegram Stars are gifted */
    readonly user_id?: number,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** Number of bought Telegram Stars */
    readonly star_count?: number,
  }

  export type telegramPaymentPurposeStarGiveaway$Input = {
    /** The user creating a Telegram Star giveaway */
    readonly _: 'telegramPaymentPurposeStarGiveaway',
    /** Giveaway parameters */
    readonly parameters?: giveawayParameters$Input,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
    /** The number of users to receive Telegram Stars */
    readonly winner_count?: number,
    /** The number of Telegram Stars to be distributed through the giveaway */
    readonly star_count?: number,
  }

  export type telegramPaymentPurposeJoinChat$Input = {
    /** The user joins a chat and subscribes to regular payments in Telegram Stars */
    readonly _: 'telegramPaymentPurposeJoinChat',
    /** Invite link to use */
    readonly invite_link?: string,
  }

  export type deviceTokenFirebaseCloudMessaging$Input = {
    /** A token for Firebase Cloud Messaging */
    readonly _: 'deviceTokenFirebaseCloudMessaging',
    /** Device registration token; may be empty to deregister a device */
    readonly token?: string,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type deviceTokenApplePush$Input = {
    /** A token for Apple Push Notification service */
    readonly _: 'deviceTokenApplePush',
    /** Device token; may be empty to deregister a device */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
  }

  export type deviceTokenApplePushVoIP$Input = {
    /** A token for Apple Push Notification service VoIP notifications */
    readonly _: 'deviceTokenApplePushVoIP',
    /** Device token; may be empty to deregister a device */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type deviceTokenWindowsPush$Input = {
    /** A token for Windows Push Notification Services */
    readonly _: 'deviceTokenWindowsPush',
    /**
     * The access token that will be used to send notifications; may be empty to deregister
     * a device
     */
    readonly access_token?: string,
  }

  export type deviceTokenMicrosoftPush$Input = {
    /** A token for Microsoft Push Notification Service */
    readonly _: 'deviceTokenMicrosoftPush',
    /** Push notification channel URI; may be empty to deregister a device */
    readonly channel_uri?: string,
  }

  export type deviceTokenMicrosoftPushVoIP$Input = {
    /** A token for Microsoft Push Notification Service VoIP channel */
    readonly _: 'deviceTokenMicrosoftPushVoIP',
    /** Push notification channel URI; may be empty to deregister a device */
    readonly channel_uri?: string,
  }

  export type deviceTokenWebPush$Input = {
    /** A token for web Push API */
    readonly _: 'deviceTokenWebPush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    readonly endpoint?: string,
    /** Base64url-encoded P-256 elliptic curve Diffie-Hellman public key */
    readonly p256dh_base64url?: string,
    /** Base64url-encoded authentication secret */
    readonly auth_base64url?: string,
  }

  export type deviceTokenSimplePush$Input = {
    /** A token for Simple Push API for Firefox OS */
    readonly _: 'deviceTokenSimplePush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    readonly endpoint?: string,
  }

  export type deviceTokenUbuntuPush$Input = {
    /** A token for Ubuntu Push Client service */
    readonly _: 'deviceTokenUbuntuPush',
    /** Token; may be empty to deregister a device */
    readonly token?: string,
  }

  export type deviceTokenBlackBerryPush$Input = {
    /** A token for BlackBerry Push Service */
    readonly _: 'deviceTokenBlackBerryPush',
    /** Token; may be empty to deregister a device */
    readonly token?: string,
  }

  export type deviceTokenTizenPush$Input = {
    /** A token for Tizen Push Service */
    readonly _: 'deviceTokenTizenPush',
    /** Push service registration identifier; may be empty to deregister a device */
    readonly reg_id?: string,
  }

  export type deviceTokenHuaweiPush$Input = {
    /** A token for HUAWEI Push Service */
    readonly _: 'deviceTokenHuaweiPush',
    /** Device registration token; may be empty to deregister a device */
    readonly token?: string,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type pushReceiverId = {
    /**
     * Contains a globally unique push receiver identifier, which can be used to identify
     * which account has received a push notification
     */
    _: 'pushReceiverId',
    /** The globally unique identifier of push notification subscription */
    id: string,
  }

  export type backgroundFillSolid = {
    /** Describes a solid fill of a background */
    _: 'backgroundFillSolid',
    /** A color of the background in the RGB format */
    color: number,
  }

  export type backgroundFillSolid$Input = {
    /** Describes a solid fill of a background */
    readonly _: 'backgroundFillSolid',
    /** A color of the background in the RGB format */
    readonly color?: number,
  }

  export type backgroundFillGradient = {
    /** Describes a gradient fill of a background */
    _: 'backgroundFillGradient',
    /** A top color of the background in the RGB format */
    top_color: number,
    /** A bottom color of the background in the RGB format */
    bottom_color: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be
     * divisible by 45
     */
    rotation_angle: number,
  }

  export type backgroundFillGradient$Input = {
    /** Describes a gradient fill of a background */
    readonly _: 'backgroundFillGradient',
    /** A top color of the background in the RGB format */
    readonly top_color?: number,
    /** A bottom color of the background in the RGB format */
    readonly bottom_color?: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be
     * divisible by 45
     */
    readonly rotation_angle?: number,
  }

  export type backgroundFillFreeformGradient = {
    /** Describes a freeform gradient fill of a background */
    _: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradient in the RGB format */
    colors: Array<number>,
  }

  export type backgroundFillFreeformGradient$Input = {
    /** Describes a freeform gradient fill of a background */
    readonly _: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradient in the RGB format */
    readonly colors?: ReadonlyArray<number>,
  }

  export type backgroundTypeWallpaper = {
    /** A wallpaper in JPEG format */
    _: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    is_blurred: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  }

  export type backgroundTypeWallpaper$Input = {
    /** A wallpaper in JPEG format */
    readonly _: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    readonly is_blurred?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    readonly is_moving?: boolean,
  }

  export type backgroundTypePattern = {
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    _: 'backgroundTypePattern',
    /** Fill of the background */
    fill: BackgroundFill,
    /** Intensity of the pattern when it is shown above the filled background; 0-100 */
    intensity: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    is_inverted: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  }

  export type backgroundTypePattern$Input = {
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    readonly _: 'backgroundTypePattern',
    /** Fill of the background */
    readonly fill?: BackgroundFill$Input,
    /** Intensity of the pattern when it is shown above the filled background; 0-100 */
    readonly intensity?: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    readonly is_inverted?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    readonly is_moving?: boolean,
  }

  export type backgroundTypeFill = {
    /** A filled background */
    _: 'backgroundTypeFill',
    /** The background fill */
    fill: BackgroundFill,
  }

  export type backgroundTypeFill$Input = {
    /** A filled background */
    readonly _: 'backgroundTypeFill',
    /** The background fill */
    readonly fill?: BackgroundFill$Input,
  }

  export type backgroundTypeChatTheme = {
    /** A background from a chat theme; can be used only as a chat background in channels */
    _: 'backgroundTypeChatTheme',
    /** Name of the chat theme */
    theme_name: string,
  }

  export type backgroundTypeChatTheme$Input = {
    /** A background from a chat theme; can be used only as a chat background in channels */
    readonly _: 'backgroundTypeChatTheme',
    /** Name of the chat theme */
    readonly theme_name?: string,
  }

  export type inputBackgroundLocal$Input = {
    /** A background from a local file */
    readonly _: 'inputBackgroundLocal',
    /**
     * Background file to use. Only inputFileLocal and inputFileGenerated are supported.
     * The file must be in JPEG format for wallpapers and in PNG format for patterns
     */
    readonly background?: InputFile$Input,
  }

  export type inputBackgroundRemote$Input = {
    /** A background from the server */
    readonly _: 'inputBackgroundRemote',
    /** The background identifier */
    readonly background_id?: number | string,
  }

  export type inputBackgroundPrevious$Input = {
    /** A background previously set in the chat; for chat backgrounds only */
    readonly _: 'inputBackgroundPrevious',
    /** Identifier of the message with the background */
    readonly message_id?: number,
  }

  export type chatTheme = {
    /** Describes a chat theme */
    _: 'chatTheme',
    /** Theme name */
    name: string,
    /** Theme settings for a light chat theme */
    light_settings: themeSettings,
    /** Theme settings for a dark chat theme */
    dark_settings: themeSettings,
  }

  export type timeZone = {
    /** Describes a time zone */
    _: 'timeZone',
    /** Unique time zone identifier */
    id: string,
    /** Time zone name */
    name: string,
    /** Current UTC time offset for the time zone */
    utc_time_offset: number,
  }

  export type timeZones = {
    /** Contains a list of time zones */
    _: 'timeZones',
    /** A list of time zones */
    time_zones: Array<timeZone>,
  }

  export type hashtags = {
    /** Contains a list of hashtags */
    _: 'hashtags',
    /** A list of hashtags */
    hashtags: Array<string>,
  }

  export type canPostStoryResultOk = {
    /** A story can be sent */
    _: 'canPostStoryResultOk',
    /** Number of stories that can be posted by the user */
    story_count: number,
  }

  export type canPostStoryResultPremiumNeeded = {
    /** The user must subscribe to Telegram Premium to be able to post stories */
    _: 'canPostStoryResultPremiumNeeded',
  }

  export type canPostStoryResultBoostNeeded = {
    /**
     * The chat must be boosted first by Telegram Premium subscribers to post more
     * stories. Call getChatBoostStatus to get current boost status of the chat
     */
    _: 'canPostStoryResultBoostNeeded',
  }

  export type canPostStoryResultActiveStoryLimitExceeded = {
    /**
     * The limit for the number of active stories exceeded. The user can buy Telegram
     * Premium, delete an active story, or wait for the oldest story to expire
     */
    _: 'canPostStoryResultActiveStoryLimitExceeded',
  }

  export type canPostStoryResultWeeklyLimitExceeded = {
    /**
     * The weekly limit for the number of posted stories exceeded. The user needs to
     * buy Telegram Premium or wait specified time
     */
    _: 'canPostStoryResultWeeklyLimitExceeded',
    /** Time left before the user can post the next story */
    retry_after: number,
  }

  export type canPostStoryResultMonthlyLimitExceeded = {
    /**
     * The monthly limit for the number of posted stories exceeded. The user needs
     * to buy Telegram Premium or wait specified time
     */
    _: 'canPostStoryResultMonthlyLimitExceeded',
    /** Time left before the user can post the next story */
    retry_after: number,
  }

  export type canTransferOwnershipResultOk = {
    /** The session can be used */
    _: 'canTransferOwnershipResultOk',
  }

  export type canTransferOwnershipResultPasswordNeeded = {
    /** The 2-step verification needs to be enabled first */
    _: 'canTransferOwnershipResultPasswordNeeded',
  }

  export type canTransferOwnershipResultPasswordTooFresh = {
    /** The 2-step verification was enabled recently, user needs to wait */
    _: 'canTransferOwnershipResultPasswordTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  }

  export type canTransferOwnershipResultSessionTooFresh = {
    /** The session was created recently, user needs to wait */
    _: 'canTransferOwnershipResultSessionTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  }

  export type checkChatUsernameResultOk = {
    /** The username can be set */
    _: 'checkChatUsernameResultOk',
  }

  export type checkChatUsernameResultUsernameInvalid = {
    /** The username is invalid */
    _: 'checkChatUsernameResultUsernameInvalid',
  }

  export type checkChatUsernameResultUsernameOccupied = {
    /** The username is occupied */
    _: 'checkChatUsernameResultUsernameOccupied',
  }

  export type checkChatUsernameResultUsernamePurchasable = {
    /**
     * The username can be purchased at https://fragment.com. Information about the
     * username can be received using getCollectibleItemInfo
     */
    _: 'checkChatUsernameResultUsernamePurchasable',
  }

  export type checkChatUsernameResultPublicChatsTooMany = {
    /**
     * The user has too many chats with username, one of them must be made private
     * first
     */
    _: 'checkChatUsernameResultPublicChatsTooMany',
  }

  export type checkChatUsernameResultPublicGroupsUnavailable = {
    /** The user can't be a member of a public supergroup */
    _: 'checkChatUsernameResultPublicGroupsUnavailable',
  }

  export type checkStickerSetNameResultOk = {
    /** The name can be set */
    _: 'checkStickerSetNameResultOk',
  }

  export type checkStickerSetNameResultNameInvalid = {
    /** The name is invalid */
    _: 'checkStickerSetNameResultNameInvalid',
  }

  export type checkStickerSetNameResultNameOccupied = {
    /** The name is occupied */
    _: 'checkStickerSetNameResultNameOccupied',
  }

  export type resetPasswordResultOk = {
    /** The password was reset */
    _: 'resetPasswordResultOk',
  }

  export type resetPasswordResultPending = {
    /** The password reset request is pending */
    _: 'resetPasswordResultPending',
    /**
     * Point in time (Unix timestamp) after which the password can be reset immediately
     * using resetPassword
     */
    pending_reset_date: number,
  }

  export type resetPasswordResultDeclined = {
    /** The password reset request was declined */
    _: 'resetPasswordResultDeclined',
    /** Point in time (Unix timestamp) when the password reset can be retried */
    retry_date: number,
  }

  export type messageFileTypePrivate = {
    /** The messages were exported from a private chat */
    _: 'messageFileTypePrivate',
    /** Name of the other party; may be empty if unrecognized */
    name: string,
  }

  export type messageFileTypeGroup = {
    /** The messages were exported from a group chat */
    _: 'messageFileTypeGroup',
    /** Title of the group chat; may be empty if unrecognized */
    title: string,
  }

  export type messageFileTypeUnknown = {
    /** The messages were exported from a chat of unknown type */
    _: 'messageFileTypeUnknown',
  }

  export type pushMessageContentHidden = {
    /** A general message with hidden content */
    _: 'pushMessageContentHidden',
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentAnimation = {
    /** An animation message (GIF-style). */
    _: 'pushMessageContentAnimation',
    /** Message content; may be null */
    animation?: animation,
    /** Animation caption */
    caption: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentAudio = {
    /** An audio message */
    _: 'pushMessageContentAudio',
    /** Message content; may be null */
    audio?: audio,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentContact = {
    /** A message with a user contact */
    _: 'pushMessageContentContact',
    /** Contact's name */
    name: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentContactRegistered = {
    /** A contact has registered with Telegram */
    _: 'pushMessageContentContactRegistered',
  }

  export type pushMessageContentDocument = {
    /** A document message (a general file) */
    _: 'pushMessageContentDocument',
    /** Message content; may be null */
    document?: document,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentGame = {
    /** A message with a game */
    _: 'pushMessageContentGame',
    /** Game title, empty for pinned game message */
    title: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentGameScore = {
    /** A new high score was achieved in a game */
    _: 'pushMessageContentGameScore',
    /** Game title, empty for pinned message */
    title: string,
    /** New score, 0 for pinned message */
    score: number,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentInvoice = {
    /** A message with an invoice from a bot */
    _: 'pushMessageContentInvoice',
    /** Product price */
    price: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentLocation = {
    /** A message with a location */
    _: 'pushMessageContentLocation',
    /** True, if the location is live */
    is_live: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPaidMedia = {
    /** A message with paid media */
    _: 'pushMessageContentPaidMedia',
    /**
     * Number of Telegram Stars needed to buy access to the media in the message; 0
     * for pinned message
     */
    star_count: number,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPhoto = {
    /** A photo message */
    _: 'pushMessageContentPhoto',
    /** Message content; may be null */
    photo?: photo,
    /** Photo caption */
    caption: string,
    /** True, if the photo is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPoll = {
    /** A message with a poll */
    _: 'pushMessageContentPoll',
    /** Poll question */
    question: string,
    /** True, if the poll is regular and not in quiz mode */
    is_regular: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPremiumGiftCode = {
    /** A message with a Telegram Premium gift code created for the user */
    _: 'pushMessageContentPremiumGiftCode',
    /**
     * Number of months the Telegram Premium subscription will be active after code
     * activation
     */
    month_count: number,
  }

  export type pushMessageContentGiveaway = {
    /** A message with a giveaway */
    _: 'pushMessageContentGiveaway',
    /** Number of users which will receive giveaway prizes; 0 for pinned message */
    winner_count: number,
    /** Prize of the giveaway; may be null for pinned message */
    prize?: GiveawayPrize,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentGift = {
    /** A message with a gift */
    _: 'pushMessageContentGift',
    /** Number of Telegram Stars that sender paid for the gift */
    star_count: number,
  }

  export type pushMessageContentUpgradedGift = {
    /** A message with an upgraded gift */
    _: 'pushMessageContentUpgradedGift',
    /**
     * True, if the gift was obtained by upgrading of a previously received gift; otherwise,
     * this is a transferred or resold gift
     */
    is_upgrade: boolean,
  }

  export type pushMessageContentScreenshotTaken = {
    /** A screenshot of a message in the chat has been taken */
    _: 'pushMessageContentScreenshotTaken',
  }

  export type pushMessageContentSticker = {
    /** A message with a sticker */
    _: 'pushMessageContentSticker',
    /** Message content; may be null */
    sticker?: sticker,
    /** Emoji corresponding to the sticker; may be empty */
    emoji: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentStory = {
    /** A message with a story */
    _: 'pushMessageContentStory',
    /** True, if the user was mentioned in the story */
    is_mention: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentText = {
    /** A text message */
    _: 'pushMessageContentText',
    /** Message text */
    text: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentChecklist = {
    /** A message with a checklist */
    _: 'pushMessageContentChecklist',
    /** Checklist title */
    title: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVideo = {
    /** A video message */
    _: 'pushMessageContentVideo',
    /** Message content; may be null */
    video?: video,
    /** Video caption */
    caption: string,
    /** True, if the video is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVideoNote = {
    /** A video note message */
    _: 'pushMessageContentVideoNote',
    /** Message content; may be null */
    video_note?: videoNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVoiceNote = {
    /** A voice note message */
    _: 'pushMessageContentVoiceNote',
    /** Message content; may be null */
    voice_note?: voiceNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentBasicGroupChatCreate = {
    /** A newly created basic group */
    _: 'pushMessageContentBasicGroupChatCreate',
  }

  export type pushMessageContentVideoChatStarted = {
    /** A video chat or live stream was started */
    _: 'pushMessageContentVideoChatStarted',
  }

  export type pushMessageContentVideoChatEnded = {
    /** A video chat or live stream has ended */
    _: 'pushMessageContentVideoChatEnded',
  }

  export type pushMessageContentInviteVideoChatParticipants = {
    /** An invitation of participants to a video chat or live stream */
    _: 'pushMessageContentInviteVideoChatParticipants',
    /** True, if the current user was invited to the video chat or the live stream */
    is_current_user: boolean,
  }

  export type pushMessageContentChatAddMembers = {
    /** New chat members were invited to a group */
    _: 'pushMessageContentChatAddMembers',
    /** Name of the added member */
    member_name: string,
    /** True, if the current user was added to the group */
    is_current_user: boolean,
    /** True, if the user has returned to the group themselves */
    is_returned: boolean,
  }

  export type pushMessageContentChatChangePhoto = {
    /** A chat photo was edited */
    _: 'pushMessageContentChatChangePhoto',
  }

  export type pushMessageContentChatChangeTitle = {
    /** A chat title was edited */
    _: 'pushMessageContentChatChangeTitle',
    /** New chat title */
    title: string,
  }

  export type pushMessageContentChatSetBackground = {
    /** A chat background was edited */
    _: 'pushMessageContentChatSetBackground',
    /** True, if the set background is the same as the background of the current user */
    is_same: boolean,
  }

  export type pushMessageContentChatSetTheme = {
    /** A chat theme was edited */
    _: 'pushMessageContentChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme
     * was reset to the default one
     */
    theme_name: string,
  }

  export type pushMessageContentChatDeleteMember = {
    /** A chat member was deleted */
    _: 'pushMessageContentChatDeleteMember',
    /** Name of the deleted member */
    member_name: string,
    /** True, if the current user was deleted from the group */
    is_current_user: boolean,
    /** True, if the user has left the group themselves */
    is_left: boolean,
  }

  export type pushMessageContentChatJoinByLink = {
    /** A new member joined the chat via an invite link */
    _: 'pushMessageContentChatJoinByLink',
  }

  export type pushMessageContentChatJoinByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'pushMessageContentChatJoinByRequest',
  }

  export type pushMessageContentRecurringPayment = {
    /** A new recurring payment was made by the current user */
    _: 'pushMessageContentRecurringPayment',
    /** The paid amount */
    amount: string,
  }

  export type pushMessageContentSuggestProfilePhoto = {
    /** A profile photo was suggested to the user */
    _: 'pushMessageContentSuggestProfilePhoto',
  }

  export type pushMessageContentProximityAlertTriggered = {
    /** A user in the chat came within proximity alert range from the current user */
    _: 'pushMessageContentProximityAlertTriggered',
    /** The distance to the user */
    distance: number,
  }

  export type pushMessageContentChecklistTasksAdded = {
    /** Some tasks were added to a checklist */
    _: 'pushMessageContentChecklistTasksAdded',
    /** Number of added tasks */
    task_count: number,
  }

  export type pushMessageContentChecklistTasksDone = {
    /** Some tasks from a checklist were marked as done or not done */
    _: 'pushMessageContentChecklistTasksDone',
    /** Number of changed tasks */
    task_count: number,
  }

  export type pushMessageContentMessageForwards = {
    /** A forwarded messages */
    _: 'pushMessageContentMessageForwards',
    /** Number of forwarded messages */
    total_count: number,
  }

  export type pushMessageContentMediaAlbum = {
    /** A media album */
    _: 'pushMessageContentMediaAlbum',
    /** Number of messages in the album */
    total_count: number,
    /** True, if the album has at least one photo */
    has_photos: boolean,
    /** True, if the album has at least one video file */
    has_videos: boolean,
    /** True, if the album has at least one audio file */
    has_audios: boolean,
    /** True, if the album has at least one document */
    has_documents: boolean,
  }

  export type notificationTypeNewMessage = {
    /** New message was received */
    _: 'notificationTypeNewMessage',
    /** The message */
    message: message,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
  }

  export type notificationTypeNewSecretChat = {
    /** New secret chat was created */
    _: 'notificationTypeNewSecretChat',
  }

  export type notificationTypeNewCall = {
    /** New call was received */
    _: 'notificationTypeNewCall',
    /** Call identifier */
    call_id: number,
  }

  export type notificationTypeNewPushMessage = {
    /** New message was received through a push notification */
    _: 'notificationTypeNewPushMessage',
    /**
     * The message identifier. The message will not be available in the chat history,
     * but the identifier can be used in viewMessages, or as a message to be replied
     * in the same chat
     */
    message_id: number,
    /** Identifier of the sender of the message. Corresponding user or chat may be inaccessible */
    sender_id: MessageSender,
    /** Name of the sender */
    sender_name: string,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** Push message content */
    content: PushMessageContent,
  }

  export type notificationGroupTypeMessages = {
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with ordinary unread messages
     */
    _: 'notificationGroupTypeMessages',
  }

  export type notificationGroupTypeMentions = {
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with unread mentions of the current user, replies to their messages, or a pinned
     * message
     */
    _: 'notificationGroupTypeMentions',
  }

  export type notificationGroupTypeSecretChat = {
    /** A group containing a notification of type notificationTypeNewSecretChat */
    _: 'notificationGroupTypeSecretChat',
  }

  export type notificationGroupTypeCalls = {
    /** A group containing notifications of type notificationTypeNewCall */
    _: 'notificationGroupTypeCalls',
  }

  export type notificationSound = {
    /** Describes a notification sound in MP3 format */
    _: 'notificationSound',
    /** Unique identifier of the notification sound */
    id: string,
    /** Duration of the sound, in seconds */
    duration: number,
    /** Point in time (Unix timestamp) when the sound was created */
    date: number,
    /** Title of the notification sound */
    title: string,
    /** Arbitrary data, defined while the sound was uploaded */
    data: string,
    /** File containing the sound */
    sound: file,
  }

  export type notificationSounds = {
    /** Contains a list of notification sounds */
    _: 'notificationSounds',
    /** A list of notification sounds */
    notification_sounds: Array<notificationSound>,
  }

  export type notification = {
    /** Contains information about a notification */
    _: 'notification',
    /** Unique persistent identifier of this notification */
    id: number,
    /** Notification date */
    date: number,
    /** True, if the notification was explicitly sent without sound */
    is_silent: boolean,
    /** Notification type */
    type: NotificationType,
  }

  export type notificationGroup = {
    /** Describes a group of notifications */
    _: 'notificationGroup',
    /** Unique persistent auto-incremented from 1 identifier of the notification group */
    id: number,
    /** Type of the group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Total number of active notifications in the group */
    total_count: number,
    /** The list of active notifications */
    notifications: Array<notification>,
  }

  export type optionValueBoolean = {
    /** Represents a boolean option */
    _: 'optionValueBoolean',
    /** The value of the option */
    value: boolean,
  }

  export type optionValueBoolean$Input = {
    /** Represents a boolean option */
    readonly _: 'optionValueBoolean',
    /** The value of the option */
    readonly value?: boolean,
  }

  export type optionValueEmpty = {
    /** Represents an unknown option or an option which has a default value */
    _: 'optionValueEmpty',
  }

  export type optionValueEmpty$Input = {
    /** Represents an unknown option or an option which has a default value */
    readonly _: 'optionValueEmpty',
  }

  export type optionValueInteger = {
    /** Represents an integer option */
    _: 'optionValueInteger',
    /** The value of the option */
    value: string,
  }

  export type optionValueInteger$Input = {
    /** Represents an integer option */
    readonly _: 'optionValueInteger',
    /** The value of the option */
    readonly value?: number | string,
  }

  export type optionValueString = {
    /** Represents a string option */
    _: 'optionValueString',
    /** The value of the option */
    value: string,
  }

  export type optionValueString$Input = {
    /** Represents a string option */
    readonly _: 'optionValueString',
    /** The value of the option */
    readonly value?: string,
  }

  export type jsonObjectMember = {
    /** Represents one member of a JSON object */
    _: 'jsonObjectMember',
    /** Member's key */
    key: string,
    /** Member's value */
    value: JsonValue,
  }

  export type jsonObjectMember$Input = {
    /** Represents one member of a JSON object */
    readonly _: 'jsonObjectMember',
    /** Member's key */
    readonly key?: string,
    /** Member's value */
    readonly value?: JsonValue$Input,
  }

  export type jsonValueNull = {
    /** Represents a null JSON value */
    _: 'jsonValueNull',
  }

  export type jsonValueNull$Input = {
    /** Represents a null JSON value */
    readonly _: 'jsonValueNull',
  }

  export type jsonValueBoolean = {
    /** Represents a boolean JSON value */
    _: 'jsonValueBoolean',
    /** The value */
    value: boolean,
  }

  export type jsonValueBoolean$Input = {
    /** Represents a boolean JSON value */
    readonly _: 'jsonValueBoolean',
    /** The value */
    readonly value?: boolean,
  }

  export type jsonValueNumber = {
    /** Represents a numeric JSON value */
    _: 'jsonValueNumber',
    /** The value */
    value: number,
  }

  export type jsonValueNumber$Input = {
    /** Represents a numeric JSON value */
    readonly _: 'jsonValueNumber',
    /** The value */
    readonly value?: number,
  }

  export type jsonValueString = {
    /** Represents a string JSON value */
    _: 'jsonValueString',
    /** The value */
    value: string,
  }

  export type jsonValueString$Input = {
    /** Represents a string JSON value */
    readonly _: 'jsonValueString',
    /** The value */
    readonly value?: string,
  }

  export type jsonValueArray = {
    /** Represents a JSON array */
    _: 'jsonValueArray',
    /** The list of array elements */
    values: Array<JsonValue>,
  }

  export type jsonValueArray$Input = {
    /** Represents a JSON array */
    readonly _: 'jsonValueArray',
    /** The list of array elements */
    readonly values?: ReadonlyArray<JsonValue$Input>,
  }

  export type jsonValueObject = {
    /** Represents a JSON object */
    _: 'jsonValueObject',
    /** The list of object members */
    members: Array<jsonObjectMember>,
  }

  export type jsonValueObject$Input = {
    /** Represents a JSON object */
    readonly _: 'jsonValueObject',
    /** The list of object members */
    readonly members?: ReadonlyArray<jsonObjectMember$Input>,
  }

  export type storyPrivacySettingsEveryone = {
    /** The story can be viewed by everyone */
    _: 'storyPrivacySettingsEveryone',
    /**
     * Identifiers of the users that can't see the story; always unknown and empty
     * for non-owned stories
     */
    except_user_ids: Array<number>,
  }

  export type storyPrivacySettingsEveryone$Input = {
    /** The story can be viewed by everyone */
    readonly _: 'storyPrivacySettingsEveryone',
    /**
     * Identifiers of the users that can't see the story; always unknown and empty
     * for non-owned stories
     */
    readonly except_user_ids?: ReadonlyArray<number>,
  }

  export type storyPrivacySettingsContacts = {
    /** The story can be viewed by all contacts except chosen users */
    _: 'storyPrivacySettingsContacts',
    /**
     * User identifiers of the contacts that can't see the story; always unknown and
     * empty for non-owned stories
     */
    except_user_ids: Array<number>,
  }

  export type storyPrivacySettingsContacts$Input = {
    /** The story can be viewed by all contacts except chosen users */
    readonly _: 'storyPrivacySettingsContacts',
    /**
     * User identifiers of the contacts that can't see the story; always unknown and
     * empty for non-owned stories
     */
    readonly except_user_ids?: ReadonlyArray<number>,
  }

  export type storyPrivacySettingsCloseFriends = {
    /** The story can be viewed by all close friends */
    _: 'storyPrivacySettingsCloseFriends',
  }

  export type storyPrivacySettingsCloseFriends$Input = {
    /** The story can be viewed by all close friends */
    readonly _: 'storyPrivacySettingsCloseFriends',
  }

  export type storyPrivacySettingsSelectedUsers = {
    /** The story can be viewed by certain specified users */
    _: 'storyPrivacySettingsSelectedUsers',
    /** Identifiers of the users; always unknown and empty for non-owned stories */
    user_ids: Array<number>,
  }

  export type storyPrivacySettingsSelectedUsers$Input = {
    /** The story can be viewed by certain specified users */
    readonly _: 'storyPrivacySettingsSelectedUsers',
    /** Identifiers of the users; always unknown and empty for non-owned stories */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleAllowAll = {
    /** A rule to allow all users to do something */
    _: 'userPrivacySettingRuleAllowAll',
  }

  export type userPrivacySettingRuleAllowAll$Input = {
    /** A rule to allow all users to do something */
    readonly _: 'userPrivacySettingRuleAllowAll',
  }

  export type userPrivacySettingRuleAllowContacts = {
    /** A rule to allow all contacts of the user to do something */
    _: 'userPrivacySettingRuleAllowContacts',
  }

  export type userPrivacySettingRuleAllowContacts$Input = {
    /** A rule to allow all contacts of the user to do something */
    readonly _: 'userPrivacySettingRuleAllowContacts',
  }

  export type userPrivacySettingRuleAllowBots = {
    /** A rule to allow all bots to do something */
    _: 'userPrivacySettingRuleAllowBots',
  }

  export type userPrivacySettingRuleAllowBots$Input = {
    /** A rule to allow all bots to do something */
    readonly _: 'userPrivacySettingRuleAllowBots',
  }

  export type userPrivacySettingRuleAllowPremiumUsers = {
    /**
     * A rule to allow all Premium Users to do something; currently, allowed only for
     * userPrivacySettingAllowChatInvites
     */
    _: 'userPrivacySettingRuleAllowPremiumUsers',
  }

  export type userPrivacySettingRuleAllowPremiumUsers$Input = {
    /**
     * A rule to allow all Premium Users to do something; currently, allowed only for
     * userPrivacySettingAllowChatInvites
     */
    readonly _: 'userPrivacySettingRuleAllowPremiumUsers',
  }

  export type userPrivacySettingRuleAllowUsers = {
    /** A rule to allow certain specified users to do something */
    _: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  }

  export type userPrivacySettingRuleAllowUsers$Input = {
    /** A rule to allow certain specified users to do something */
    readonly _: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleAllowChatMembers = {
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    _: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  }

  export type userPrivacySettingRuleAllowChatMembers$Input = {
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    readonly _: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleRestrictAll = {
    /** A rule to restrict all users from doing something */
    _: 'userPrivacySettingRuleRestrictAll',
  }

  export type userPrivacySettingRuleRestrictAll$Input = {
    /** A rule to restrict all users from doing something */
    readonly _: 'userPrivacySettingRuleRestrictAll',
  }

  export type userPrivacySettingRuleRestrictContacts = {
    /** A rule to restrict all contacts of the user from doing something */
    _: 'userPrivacySettingRuleRestrictContacts',
  }

  export type userPrivacySettingRuleRestrictContacts$Input = {
    /** A rule to restrict all contacts of the user from doing something */
    readonly _: 'userPrivacySettingRuleRestrictContacts',
  }

  export type userPrivacySettingRuleRestrictBots = {
    /** A rule to restrict all bots from doing something */
    _: 'userPrivacySettingRuleRestrictBots',
  }

  export type userPrivacySettingRuleRestrictBots$Input = {
    /** A rule to restrict all bots from doing something */
    readonly _: 'userPrivacySettingRuleRestrictBots',
  }

  export type userPrivacySettingRuleRestrictUsers = {
    /** A rule to restrict all specified users from doing something */
    _: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  }

  export type userPrivacySettingRuleRestrictUsers$Input = {
    /** A rule to restrict all specified users from doing something */
    readonly _: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleRestrictChatMembers = {
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    _: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  }

  export type userPrivacySettingRuleRestrictChatMembers$Input = {
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    readonly _: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRules = {
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    _: 'userPrivacySettingRules',
    /** A list of rules */
    rules: Array<UserPrivacySettingRule>,
  }

  export type userPrivacySettingRules$Input = {
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    readonly _: 'userPrivacySettingRules',
    /** A list of rules */
    readonly rules?: ReadonlyArray<UserPrivacySettingRule$Input>,
  }

  export type userPrivacySettingShowStatus = {
    /** A privacy setting for managing whether the user's online status is visible */
    _: 'userPrivacySettingShowStatus',
  }

  export type userPrivacySettingShowStatus$Input = {
    /** A privacy setting for managing whether the user's online status is visible */
    readonly _: 'userPrivacySettingShowStatus',
  }

  export type userPrivacySettingShowProfilePhoto = {
    /** A privacy setting for managing whether the user's profile photo is visible */
    _: 'userPrivacySettingShowProfilePhoto',
  }

  export type userPrivacySettingShowProfilePhoto$Input = {
    /** A privacy setting for managing whether the user's profile photo is visible */
    readonly _: 'userPrivacySettingShowProfilePhoto',
  }

  export type userPrivacySettingShowLinkInForwardedMessages = {
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    _: 'userPrivacySettingShowLinkInForwardedMessages',
  }

  export type userPrivacySettingShowLinkInForwardedMessages$Input = {
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    readonly _: 'userPrivacySettingShowLinkInForwardedMessages',
  }

  export type userPrivacySettingShowPhoneNumber = {
    /** A privacy setting for managing whether the user's phone number is visible */
    _: 'userPrivacySettingShowPhoneNumber',
  }

  export type userPrivacySettingShowPhoneNumber$Input = {
    /** A privacy setting for managing whether the user's phone number is visible */
    readonly _: 'userPrivacySettingShowPhoneNumber',
  }

  export type userPrivacySettingShowBio = {
    /** A privacy setting for managing whether the user's bio is visible */
    _: 'userPrivacySettingShowBio',
  }

  export type userPrivacySettingShowBio$Input = {
    /** A privacy setting for managing whether the user's bio is visible */
    readonly _: 'userPrivacySettingShowBio',
  }

  export type userPrivacySettingShowBirthdate = {
    /** A privacy setting for managing whether the user's birthdate is visible */
    _: 'userPrivacySettingShowBirthdate',
  }

  export type userPrivacySettingShowBirthdate$Input = {
    /** A privacy setting for managing whether the user's birthdate is visible */
    readonly _: 'userPrivacySettingShowBirthdate',
  }

  export type userPrivacySettingAllowChatInvites = {
    /** A privacy setting for managing whether the user can be invited to chats */
    _: 'userPrivacySettingAllowChatInvites',
  }

  export type userPrivacySettingAllowChatInvites$Input = {
    /** A privacy setting for managing whether the user can be invited to chats */
    readonly _: 'userPrivacySettingAllowChatInvites',
  }

  export type userPrivacySettingAllowCalls = {
    /** A privacy setting for managing whether the user can be called */
    _: 'userPrivacySettingAllowCalls',
  }

  export type userPrivacySettingAllowCalls$Input = {
    /** A privacy setting for managing whether the user can be called */
    readonly _: 'userPrivacySettingAllowCalls',
  }

  export type userPrivacySettingAllowPeerToPeerCalls = {
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    _: 'userPrivacySettingAllowPeerToPeerCalls',
  }

  export type userPrivacySettingAllowPeerToPeerCalls$Input = {
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    readonly _: 'userPrivacySettingAllowPeerToPeerCalls',
  }

  export type userPrivacySettingAllowFindingByPhoneNumber = {
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    _: 'userPrivacySettingAllowFindingByPhoneNumber',
  }

  export type userPrivacySettingAllowFindingByPhoneNumber$Input = {
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    readonly _: 'userPrivacySettingAllowFindingByPhoneNumber',
  }

  export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages = {
    /**
     * A privacy setting for managing whether the user can receive voice and video
     * messages in private chats; for Telegram Premium users only
     */
    _: 'userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages',
  }

  export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input = {
    /**
     * A privacy setting for managing whether the user can receive voice and video
     * messages in private chats; for Telegram Premium users only
     */
    readonly _: 'userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages',
  }

  export type userPrivacySettingAutosaveGifts = {
    /**
     * A privacy setting for managing whether received gifts are automatically shown
     * on the user's profile page
     */
    _: 'userPrivacySettingAutosaveGifts',
  }

  export type userPrivacySettingAutosaveGifts$Input = {
    /**
     * A privacy setting for managing whether received gifts are automatically shown
     * on the user's profile page
     */
    readonly _: 'userPrivacySettingAutosaveGifts',
  }

  export type userPrivacySettingAllowUnpaidMessages = {
    /**
     * A privacy setting for managing whether the user can receive messages without
     * additional payment
     */
    _: 'userPrivacySettingAllowUnpaidMessages',
  }

  export type userPrivacySettingAllowUnpaidMessages$Input = {
    /**
     * A privacy setting for managing whether the user can receive messages without
     * additional payment
     */
    readonly _: 'userPrivacySettingAllowUnpaidMessages',
  }

  export type readDatePrivacySettings = {
    /**
     * Contains privacy settings for message read date in private chats. Read dates
     * are always shown to the users that can see online status of the current user
     * regardless of this setting
     */
    _: 'readDatePrivacySettings',
    /**
     * True, if message read date is shown to other users in private chats. If false
     * and the current user isn't a Telegram Premium user, then they will not be able
     * to see other's message read date
     */
    show_read_date: boolean,
  }

  export type readDatePrivacySettings$Input = {
    /**
     * Contains privacy settings for message read date in private chats. Read dates
     * are always shown to the users that can see online status of the current user
     * regardless of this setting
     */
    readonly _: 'readDatePrivacySettings',
    /**
     * True, if message read date is shown to other users in private chats. If false
     * and the current user isn't a Telegram Premium user, then they will not be able
     * to see other's message read date
     */
    readonly show_read_date?: boolean,
  }

  export type newChatPrivacySettings = {
    /** Contains privacy settings for chats with non-contacts */
    _: 'newChatPrivacySettings',
    /**
     * True, if non-contacts users are able to write first to the current user. Telegram
     * Premium subscribers are able to write first regardless of this setting
     */
    allow_new_chats_from_unknown_users: boolean,
    /**
     * Number of Telegram Stars that must be paid for every incoming private message
     * by non-contacts; 0-getOption("paid_message_star_count_max"). If positive, then
     * allow_new_chats_from_unknown_users must be true. The current user will receive
     * getOption("paid_message_earnings_per_mille") Telegram Stars for each 1000 Telegram
     * Stars paid for message sending. Can be positive, only if getOption("can_enable_paid_messages")
     * is true
     */
    incoming_paid_message_star_count: number,
  }

  export type newChatPrivacySettings$Input = {
    /** Contains privacy settings for chats with non-contacts */
    readonly _: 'newChatPrivacySettings',
    /**
     * True, if non-contacts users are able to write first to the current user. Telegram
     * Premium subscribers are able to write first regardless of this setting
     */
    readonly allow_new_chats_from_unknown_users?: boolean,
    /**
     * Number of Telegram Stars that must be paid for every incoming private message
     * by non-contacts; 0-getOption("paid_message_star_count_max"). If positive, then
     * allow_new_chats_from_unknown_users must be true. The current user will receive
     * getOption("paid_message_earnings_per_mille") Telegram Stars for each 1000 Telegram
     * Stars paid for message sending. Can be positive, only if getOption("can_enable_paid_messages")
     * is true
     */
    readonly incoming_paid_message_star_count?: number,
  }

  export type canSendMessageToUserResultOk = {
    /** The user can be messaged */
    _: 'canSendMessageToUserResultOk',
  }

  export type canSendMessageToUserResultUserHasPaidMessages = {
    /** The user can be messaged, but the messages are paid */
    _: 'canSendMessageToUserResultUserHasPaidMessages',
    /**
     * Number of Telegram Stars that must be paid by the current user for each sent
     * message to the user
     */
    outgoing_paid_message_star_count: number,
  }

  export type canSendMessageToUserResultUserIsDeleted = {
    /** The user can't be messaged, because they are deleted or unknown */
    _: 'canSendMessageToUserResultUserIsDeleted',
  }

  export type canSendMessageToUserResultUserRestrictsNewChats = {
    /** The user can't be messaged, because they restrict new chats with non-contacts */
    _: 'canSendMessageToUserResultUserRestrictsNewChats',
  }

  export type accountTtl = {
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    _: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-730 days
     */
    days: number,
  }

  export type accountTtl$Input = {
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    readonly _: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-730 days
     */
    readonly days?: number,
  }

  export type messageAutoDeleteTime = {
    /** Contains default auto-delete timer setting for new chats */
    _: 'messageAutoDeleteTime',
    /** Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically */
    time: number,
  }

  export type messageAutoDeleteTime$Input = {
    /** Contains default auto-delete timer setting for new chats */
    readonly _: 'messageAutoDeleteTime',
    /** Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically */
    readonly time?: number,
  }

  export type sessionTypeAndroid = {
    /** The session is running on an Android device */
    _: 'sessionTypeAndroid',
  }

  export type sessionTypeApple = {
    /** The session is running on a generic Apple device */
    _: 'sessionTypeApple',
  }

  export type sessionTypeBrave = {
    /** The session is running on the Brave browser */
    _: 'sessionTypeBrave',
  }

  export type sessionTypeChrome = {
    /** The session is running on the Chrome browser */
    _: 'sessionTypeChrome',
  }

  export type sessionTypeEdge = {
    /** The session is running on the Edge browser */
    _: 'sessionTypeEdge',
  }

  export type sessionTypeFirefox = {
    /** The session is running on the Firefox browser */
    _: 'sessionTypeFirefox',
  }

  export type sessionTypeIpad = {
    /** The session is running on an iPad device */
    _: 'sessionTypeIpad',
  }

  export type sessionTypeIphone = {
    /** The session is running on an iPhone device */
    _: 'sessionTypeIphone',
  }

  export type sessionTypeLinux = {
    /** The session is running on a Linux device */
    _: 'sessionTypeLinux',
  }

  export type sessionTypeMac = {
    /** The session is running on a Mac device */
    _: 'sessionTypeMac',
  }

  export type sessionTypeOpera = {
    /** The session is running on the Opera browser */
    _: 'sessionTypeOpera',
  }

  export type sessionTypeSafari = {
    /** The session is running on the Safari browser */
    _: 'sessionTypeSafari',
  }

  export type sessionTypeUbuntu = {
    /** The session is running on an Ubuntu device */
    _: 'sessionTypeUbuntu',
  }

  export type sessionTypeUnknown = {
    /** The session is running on an unknown type of device */
    _: 'sessionTypeUnknown',
  }

  export type sessionTypeVivaldi = {
    /** The session is running on the Vivaldi browser */
    _: 'sessionTypeVivaldi',
  }

  export type sessionTypeWindows = {
    /** The session is running on a Windows device */
    _: 'sessionTypeWindows',
  }

  export type sessionTypeXbox = {
    /** The session is running on an Xbox console */
    _: 'sessionTypeXbox',
  }

  export type session = {
    /**
     * Contains information about one session in a Telegram application used by the
     * current user. Sessions must be shown to the user in the returned order
     */
    _: 'session',
    /** Session identifier */
    id: string,
    /** True, if this session is the current session */
    is_current: boolean,
    /**
     * True, if a 2-step verification password is needed to complete authorization
     * of the session
     */
    is_password_pending: boolean,
    /** True, if the session wasn't confirmed from another session */
    is_unconfirmed: boolean,
    /** True, if incoming secret chats can be accepted by the session */
    can_accept_secret_chats: boolean,
    /** True, if incoming calls can be accepted by the session */
    can_accept_calls: boolean,
    /**
     * Session type based on the system and application version, which can be used
     * to display a corresponding icon
     */
    type: SessionType,
    /** Telegram API identifier, as provided by the application */
    api_id: number,
    /** Name of the application, as provided by the application */
    application_name: string,
    /** The version of the application, as provided by the application */
    application_version: string,
    /**
     * True, if the application is an official application or uses the api_id of an
     * official application
     */
    is_official_application: boolean,
    /**
     * Model of the device the application has been run or is running on, as provided
     * by the application
     */
    device_model: string,
    /**
     * Operating system the application has been run or is running on, as provided
     * by the application
     */
    platform: string,
    /**
     * Version of the operating system the application has been run or is running on,
     * as provided by the application
     */
    system_version: string,
    /** Point in time (Unix timestamp) when the user has logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when the session was last used */
    last_active_date: number,
    /** IP address from which the session was created, in human-readable format */
    ip_address: string,
    /**
     * A human-readable description of the location from which the session was created,
     * based on the IP address
     */
    location: string,
  }

  export type sessions = {
    /** Contains a list of sessions */
    _: 'sessions',
    /** List of sessions */
    sessions: Array<session>,
    /**
     * Number of days of inactivity before sessions will automatically be terminated;
     * 1-366 days
     */
    inactive_session_ttl_days: number,
  }

  export type unconfirmedSession = {
    /** Contains information about an unconfirmed session */
    _: 'unconfirmedSession',
    /** Session identifier */
    id: string,
    /** Point in time (Unix timestamp) when the user has logged in */
    log_in_date: number,
    /**
     * Model of the device that was used for the session creation, as provided by the
     * application
     */
    device_model: string,
    /**
     * A human-readable description of the location from which the session was created,
     * based on the IP address
     */
    location: string,
  }

  export type connectedWebsite = {
    /** Contains information about one website the current user is logged in with Telegram */
    _: 'connectedWebsite',
    /** Website identifier */
    id: string,
    /** The domain name of the website */
    domain_name: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /** The version of a browser used to log in */
    browser: string,
    /** Operating system the browser is running on */
    platform: string,
    /** Point in time (Unix timestamp) when the user was logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when obtained authorization was last used */
    last_active_date: number,
    /** IP address from which the user was logged in, in human-readable format */
    ip_address: string,
    /**
     * Human-readable description of a country and a region from which the user was
     * logged in, based on the IP address
     */
    location: string,
  }

  export type connectedWebsites = {
    /** Contains a list of websites the current user is logged in with Telegram */
    _: 'connectedWebsites',
    /** List of connected websites */
    websites: Array<connectedWebsite>,
  }

  export type reportReasonSpam$Input = {
    /** The chat contains spam messages */
    readonly _: 'reportReasonSpam',
  }

  export type reportReasonViolence$Input = {
    /** The chat promotes violence */
    readonly _: 'reportReasonViolence',
  }

  export type reportReasonPornography$Input = {
    /** The chat contains pornographic messages */
    readonly _: 'reportReasonPornography',
  }

  export type reportReasonChildAbuse$Input = {
    /** The chat has child abuse related content */
    readonly _: 'reportReasonChildAbuse',
  }

  export type reportReasonCopyright$Input = {
    /** The chat contains copyrighted content */
    readonly _: 'reportReasonCopyright',
  }

  export type reportReasonUnrelatedLocation$Input = {
    /** The location-based chat is unrelated to its stated location */
    readonly _: 'reportReasonUnrelatedLocation',
  }

  export type reportReasonFake$Input = {
    /** The chat represents a fake account */
    readonly _: 'reportReasonFake',
  }

  export type reportReasonIllegalDrugs$Input = {
    /** The chat has illegal drugs related content */
    readonly _: 'reportReasonIllegalDrugs',
  }

  export type reportReasonPersonalDetails$Input = {
    /** The chat contains messages with personal details */
    readonly _: 'reportReasonPersonalDetails',
  }

  export type reportReasonCustom$Input = {
    /** A custom reason provided by the user */
    readonly _: 'reportReasonCustom',
  }

  export type reportChatResultOk = {
    /** The chat was reported successfully */
    _: 'reportChatResultOk',
  }

  export type reportChatResultOptionRequired = {
    /**
     * The user must choose an option to report the chat and repeat request with the
     * chosen option
     */
    _: 'reportChatResultOptionRequired',
    /** Title for the option choice */
    title: string,
    /** List of available options */
    options: Array<reportOption>,
  }

  export type reportChatResultTextRequired = {
    /** The user must add additional text details to the report */
    _: 'reportChatResultTextRequired',
    /** Option identifier for the next reportChat request */
    option_id: string /* base64 */,
    /** True, if the user can skip text adding */
    is_optional: boolean,
  }

  export type reportChatResultMessagesRequired = {
    /**
     * The user must choose messages to report and repeat the reportChat request with
     * the chosen messages
     */
    _: 'reportChatResultMessagesRequired',
  }

  export type reportStoryResultOk = {
    /** The story was reported successfully */
    _: 'reportStoryResultOk',
  }

  export type reportStoryResultOptionRequired = {
    /**
     * The user must choose an option to report the story and repeat request with the
     * chosen option
     */
    _: 'reportStoryResultOptionRequired',
    /** Title for the option choice */
    title: string,
    /** List of available options */
    options: Array<reportOption>,
  }

  export type reportStoryResultTextRequired = {
    /** The user must add additional text details to the report */
    _: 'reportStoryResultTextRequired',
    /** Option identifier for the next reportStory request */
    option_id: string /* base64 */,
    /** True, if the user can skip text adding */
    is_optional: boolean,
  }

  export type internalLinkTypeActiveSessions = {
    /**
     * The link is a link to the Devices section of the application. Use getActiveSessions
     * to get the list of active sessions and show them to the user
     */
    _: 'internalLinkTypeActiveSessions',
  }

  export type internalLinkTypeActiveSessions$Input = {
    /**
     * The link is a link to the Devices section of the application. Use getActiveSessions
     * to get the list of active sessions and show them to the user
     */
    readonly _: 'internalLinkTypeActiveSessions',
  }

  export type internalLinkTypeAttachmentMenuBot = {
    /**
     * The link is a link to an attachment menu bot to be opened in the specified or
     * a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to attachment menu, then show a disclaimer about
     * Mini Apps being third-party applications, ask the user to accept their Terms
     * of service and confirm adding the bot to side and attachment menu. If the user
     * accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. If the attachment menu bot can't be used in the opened chat,
     * show an error to the user. If the bot is added to attachment menu and can be
     * used in the chat, then use openWebApp with the given URL
     */
    _: 'internalLinkTypeAttachmentMenuBot',
    /** Target chat to be opened */
    target_chat: TargetChat,
    /** Username of the bot */
    bot_username: string,
    /** URL to be passed to openWebApp */
    url: string,
  }

  export type internalLinkTypeAttachmentMenuBot$Input = {
    /**
     * The link is a link to an attachment menu bot to be opened in the specified or
     * a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to attachment menu, then show a disclaimer about
     * Mini Apps being third-party applications, ask the user to accept their Terms
     * of service and confirm adding the bot to side and attachment menu. If the user
     * accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. If the attachment menu bot can't be used in the opened chat,
     * show an error to the user. If the bot is added to attachment menu and can be
     * used in the chat, then use openWebApp with the given URL
     */
    readonly _: 'internalLinkTypeAttachmentMenuBot',
    /** Target chat to be opened */
    readonly target_chat?: TargetChat$Input,
    /** Username of the bot */
    readonly bot_username?: string,
    /** URL to be passed to openWebApp */
    readonly url?: string,
  }

  export type internalLinkTypeAuthenticationCode = {
    /**
     * The link contains an authentication code. Call checkAuthenticationCode with
     * the code if the current authorization state is authorizationStateWaitCode
     */
    _: 'internalLinkTypeAuthenticationCode',
    /** The authentication code */
    code: string,
  }

  export type internalLinkTypeAuthenticationCode$Input = {
    /**
     * The link contains an authentication code. Call checkAuthenticationCode with
     * the code if the current authorization state is authorizationStateWaitCode
     */
    readonly _: 'internalLinkTypeAuthenticationCode',
    /** The authentication code */
    readonly code?: string,
  }

  export type internalLinkTypeBackground = {
    /**
     * The link is a link to a background. Call searchBackground with the given background
     * name to process the link. If background is found and the user wants to apply
     * it, then call setDefaultBackground
     */
    _: 'internalLinkTypeBackground',
    /** Name of the background */
    background_name: string,
  }

  export type internalLinkTypeBackground$Input = {
    /**
     * The link is a link to a background. Call searchBackground with the given background
     * name to process the link. If background is found and the user wants to apply
     * it, then call setDefaultBackground
     */
    readonly _: 'internalLinkTypeBackground',
    /** Name of the background */
    readonly background_name?: string,
  }

  export type internalLinkTypeBotAddToChannel = {
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a channel
     * chat as an administrator. Call searchPublicChat with the given bot username
     * and check that the user is a bot, ask the current user to select a channel chat
     * to add the bot to as an administrator. Then, call getChatMember to receive the
     * current bot rights in the chat and if the bot already is an administrator, check
     * that the current user can edit its administrator rights and combine received
     * rights with the requested administrator rights. Then, show confirmation box
     * to the user, and call setChatMemberStatus with the chosen chat and confirmed
     * rights
     */
    _: 'internalLinkTypeBotAddToChannel',
    /** Username of the bot */
    bot_username: string,
    /** Expected administrator rights for the bot */
    administrator_rights: chatAdministratorRights,
  }

  export type internalLinkTypeBotAddToChannel$Input = {
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a channel
     * chat as an administrator. Call searchPublicChat with the given bot username
     * and check that the user is a bot, ask the current user to select a channel chat
     * to add the bot to as an administrator. Then, call getChatMember to receive the
     * current bot rights in the chat and if the bot already is an administrator, check
     * that the current user can edit its administrator rights and combine received
     * rights with the requested administrator rights. Then, show confirmation box
     * to the user, and call setChatMemberStatus with the chosen chat and confirmed
     * rights
     */
    readonly _: 'internalLinkTypeBotAddToChannel',
    /** Username of the bot */
    readonly bot_username?: string,
    /** Expected administrator rights for the bot */
    readonly administrator_rights?: chatAdministratorRights$Input,
  }

  export type internalLinkTypeBotStart = {
    /**
     * The link is a link to a chat with a Telegram bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot, show START button in the
     * chat with the bot, and then call sendBotStartMessage with the given start parameter
     * after the button is pressed
     */
    _: 'internalLinkTypeBotStart',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
    /**
     * True, if sendBotStartMessage must be called automatically without showing the
     * START button
     */
    autostart: boolean,
  }

  export type internalLinkTypeBotStart$Input = {
    /**
     * The link is a link to a chat with a Telegram bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot, show START button in the
     * chat with the bot, and then call sendBotStartMessage with the given start parameter
     * after the button is pressed
     */
    readonly _: 'internalLinkTypeBotStart',
    /** Username of the bot */
    readonly bot_username?: string,
    /** The parameter to be passed to sendBotStartMessage */
    readonly start_parameter?: string,
    /**
     * True, if sendBotStartMessage must be called automatically without showing the
     * START button
     */
    readonly autostart?: boolean,
  }

  export type internalLinkTypeBotStartInGroup = {
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a group
     * chat. Call searchPublicChat with the given bot username, check that the user
     * is a bot and can be added to groups, ask the current user to select a basic
     * group or a supergroup chat to add the bot to, taking into account that bots
     * can be added to a public supergroup only by administrators of the supergroup.
     * If administrator rights are provided by the link, call getChatMember to receive
     * the current bot rights in the chat and if the bot already is an administrator,
     * check that the current user can edit its administrator rights, combine received
     * rights with the requested administrator rights, show confirmation box to the
     * user, and call setChatMemberStatus with the chosen chat and confirmed administrator
     * rights. Before call to setChatMemberStatus it may be required to upgrade the
     * chosen basic group chat to a supergroup chat. Then, if start_parameter isn't
     * empty, call sendBotStartMessage with the given start parameter and the chosen
     * chat; otherwise, just send /start message with bot's username added to the chat
     */
    _: 'internalLinkTypeBotStartInGroup',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
    /** Expected administrator rights for the bot; may be null */
    administrator_rights?: chatAdministratorRights,
  }

  export type internalLinkTypeBotStartInGroup$Input = {
    /**
     * The link is a link to a Telegram bot, which is expected to be added to a group
     * chat. Call searchPublicChat with the given bot username, check that the user
     * is a bot and can be added to groups, ask the current user to select a basic
     * group or a supergroup chat to add the bot to, taking into account that bots
     * can be added to a public supergroup only by administrators of the supergroup.
     * If administrator rights are provided by the link, call getChatMember to receive
     * the current bot rights in the chat and if the bot already is an administrator,
     * check that the current user can edit its administrator rights, combine received
     * rights with the requested administrator rights, show confirmation box to the
     * user, and call setChatMemberStatus with the chosen chat and confirmed administrator
     * rights. Before call to setChatMemberStatus it may be required to upgrade the
     * chosen basic group chat to a supergroup chat. Then, if start_parameter isn't
     * empty, call sendBotStartMessage with the given start parameter and the chosen
     * chat; otherwise, just send /start message with bot's username added to the chat
     */
    readonly _: 'internalLinkTypeBotStartInGroup',
    /** Username of the bot */
    readonly bot_username?: string,
    /** The parameter to be passed to sendBotStartMessage */
    readonly start_parameter?: string,
    /** Expected administrator rights for the bot; may be null */
    readonly administrator_rights?: chatAdministratorRights$Input,
  }

  export type internalLinkTypeBusinessChat = {
    /**
     * The link is a link to a business chat. Use getBusinessChatLinkInfo with the
     * provided link name to get information about the link, then open received private
     * chat and replace chat draft with the provided text
     */
    _: 'internalLinkTypeBusinessChat',
    /** Name of the link */
    link_name: string,
  }

  export type internalLinkTypeBusinessChat$Input = {
    /**
     * The link is a link to a business chat. Use getBusinessChatLinkInfo with the
     * provided link name to get information about the link, then open received private
     * chat and replace chat draft with the provided text
     */
    readonly _: 'internalLinkTypeBusinessChat',
    /** Name of the link */
    readonly link_name?: string,
  }

  export type internalLinkTypeBuyStars = {
    /** The link is a link to the Telegram Star purchase section of the application */
    _: 'internalLinkTypeBuyStars',
    /** The number of Telegram Stars that must be owned by the user */
    star_count: number,
    /**
     * Purpose of Telegram Star purchase. Arbitrary string specified by the server,
     * for example, "subs" if the Telegram Stars are required to extend channel subscriptions
     */
    purpose: string,
  }

  export type internalLinkTypeBuyStars$Input = {
    /** The link is a link to the Telegram Star purchase section of the application */
    readonly _: 'internalLinkTypeBuyStars',
    /** The number of Telegram Stars that must be owned by the user */
    readonly star_count?: number,
    /**
     * Purpose of Telegram Star purchase. Arbitrary string specified by the server,
     * for example, "subs" if the Telegram Stars are required to extend channel subscriptions
     */
    readonly purpose?: string,
  }

  export type internalLinkTypeChangePhoneNumber = {
    /** The link is a link to the change phone number section of the application */
    _: 'internalLinkTypeChangePhoneNumber',
  }

  export type internalLinkTypeChangePhoneNumber$Input = {
    /** The link is a link to the change phone number section of the application */
    readonly _: 'internalLinkTypeChangePhoneNumber',
  }

  export type internalLinkTypeChatAffiliateProgram = {
    /**
     * The link is an affiliate program link. Call searchChatAffiliateProgram with
     * the given username and referrer to process the link
     */
    _: 'internalLinkTypeChatAffiliateProgram',
    /** Username to be passed to searchChatAffiliateProgram */
    username: string,
    /** Referrer to be passed to searchChatAffiliateProgram */
    referrer: string,
  }

  export type internalLinkTypeChatAffiliateProgram$Input = {
    /**
     * The link is an affiliate program link. Call searchChatAffiliateProgram with
     * the given username and referrer to process the link
     */
    readonly _: 'internalLinkTypeChatAffiliateProgram',
    /** Username to be passed to searchChatAffiliateProgram */
    readonly username?: string,
    /** Referrer to be passed to searchChatAffiliateProgram */
    readonly referrer?: string,
  }

  export type internalLinkTypeChatBoost = {
    /**
     * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with
     * the given URL to process the link. If the chat is found, then call getChatBoostStatus
     * and getAvailableChatBoostSlots to get the current boost status and check whether
     * the chat can be boosted. If the user wants to boost the chat and the chat can
     * be boosted, then call boostChat
     */
    _: 'internalLinkTypeChatBoost',
    /** URL to be passed to getChatBoostLinkInfo */
    url: string,
  }

  export type internalLinkTypeChatBoost$Input = {
    /**
     * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with
     * the given URL to process the link. If the chat is found, then call getChatBoostStatus
     * and getAvailableChatBoostSlots to get the current boost status and check whether
     * the chat can be boosted. If the user wants to boost the chat and the chat can
     * be boosted, then call boostChat
     */
    readonly _: 'internalLinkTypeChatBoost',
    /** URL to be passed to getChatBoostLinkInfo */
    readonly url?: string,
  }

  export type internalLinkTypeChatFolderInvite = {
    /**
     * The link is an invite link to a chat folder. Call checkChatFolderInviteLink
     * with the given invite link to process the link. If the link is valid and the
     * user wants to join the chat folder, then call addChatFolderByInviteLink
     */
    _: 'internalLinkTypeChatFolderInvite',
    /** Internal representation of the invite link */
    invite_link: string,
  }

  export type internalLinkTypeChatFolderInvite$Input = {
    /**
     * The link is an invite link to a chat folder. Call checkChatFolderInviteLink
     * with the given invite link to process the link. If the link is valid and the
     * user wants to join the chat folder, then call addChatFolderByInviteLink
     */
    readonly _: 'internalLinkTypeChatFolderInvite',
    /** Internal representation of the invite link */
    readonly invite_link?: string,
  }

  export type internalLinkTypeChatFolderSettings = {
    /** The link is a link to the folder section of the application settings */
    _: 'internalLinkTypeChatFolderSettings',
  }

  export type internalLinkTypeChatFolderSettings$Input = {
    /** The link is a link to the folder section of the application settings */
    readonly _: 'internalLinkTypeChatFolderSettings',
  }

  export type internalLinkTypeChatInvite = {
    /**
     * The link is a chat invite link. Call checkChatInviteLink with the given invite
     * link to process the link. If the link is valid and the user wants to join the
     * chat, then call joinChatByInviteLink
     */
    _: 'internalLinkTypeChatInvite',
    /** Internal representation of the invite link */
    invite_link: string,
  }

  export type internalLinkTypeChatInvite$Input = {
    /**
     * The link is a chat invite link. Call checkChatInviteLink with the given invite
     * link to process the link. If the link is valid and the user wants to join the
     * chat, then call joinChatByInviteLink
     */
    readonly _: 'internalLinkTypeChatInvite',
    /** Internal representation of the invite link */
    readonly invite_link?: string,
  }

  export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings = {
    /**
     * The link is a link to the default message auto-delete timer settings section
     * of the application settings
     */
    _: 'internalLinkTypeDefaultMessageAutoDeleteTimerSettings',
  }

  export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input = {
    /**
     * The link is a link to the default message auto-delete timer settings section
     * of the application settings
     */
    readonly _: 'internalLinkTypeDefaultMessageAutoDeleteTimerSettings',
  }

  export type internalLinkTypeEditProfileSettings = {
    /** The link is a link to the edit profile section of the application settings */
    _: 'internalLinkTypeEditProfileSettings',
  }

  export type internalLinkTypeEditProfileSettings$Input = {
    /** The link is a link to the edit profile section of the application settings */
    readonly _: 'internalLinkTypeEditProfileSettings',
  }

  export type internalLinkTypeGame = {
    /**
     * The link is a link to a game. Call searchPublicChat with the given bot username,
     * check that the user is a bot, ask the current user to select a chat to send
     * the game, and then call sendMessage with inputMessageGame
     */
    _: 'internalLinkTypeGame',
    /** Username of the bot that owns the game */
    bot_username: string,
    /** Short name of the game */
    game_short_name: string,
  }

  export type internalLinkTypeGame$Input = {
    /**
     * The link is a link to a game. Call searchPublicChat with the given bot username,
     * check that the user is a bot, ask the current user to select a chat to send
     * the game, and then call sendMessage with inputMessageGame
     */
    readonly _: 'internalLinkTypeGame',
    /** Username of the bot that owns the game */
    readonly bot_username?: string,
    /** Short name of the game */
    readonly game_short_name?: string,
  }

  export type internalLinkTypeGroupCall = {
    /**
     * The link is a link to a group call that isn't bound to a chat. Use getGroupCallParticipants
     * to get the list of group call participants and show them on the join group call
     * screen. Call joinGroupCall with the given invite_link to join the call
     */
    _: 'internalLinkTypeGroupCall',
    /** Internal representation of the invite link */
    invite_link: string,
  }

  export type internalLinkTypeGroupCall$Input = {
    /**
     * The link is a link to a group call that isn't bound to a chat. Use getGroupCallParticipants
     * to get the list of group call participants and show them on the join group call
     * screen. Call joinGroupCall with the given invite_link to join the call
     */
    readonly _: 'internalLinkTypeGroupCall',
    /** Internal representation of the invite link */
    readonly invite_link?: string,
  }

  export type internalLinkTypeInstantView = {
    /**
     * The link must be opened in an Instant View. Call getWebPageInstantView with
     * the given URL to process the link. If Instant View is found, then show it, otherwise,
     * open the fallback URL in an external browser
     */
    _: 'internalLinkTypeInstantView',
    /** URL to be passed to getWebPageInstantView */
    url: string,
    /** An URL to open if getWebPageInstantView fails */
    fallback_url: string,
  }

  export type internalLinkTypeInstantView$Input = {
    /**
     * The link must be opened in an Instant View. Call getWebPageInstantView with
     * the given URL to process the link. If Instant View is found, then show it, otherwise,
     * open the fallback URL in an external browser
     */
    readonly _: 'internalLinkTypeInstantView',
    /** URL to be passed to getWebPageInstantView */
    readonly url?: string,
    /** An URL to open if getWebPageInstantView fails */
    readonly fallback_url?: string,
  }

  export type internalLinkTypeInvoice = {
    /**
     * The link is a link to an invoice. Call getPaymentForm with the given invoice
     * name to process the link
     */
    _: 'internalLinkTypeInvoice',
    /** Name of the invoice */
    invoice_name: string,
  }

  export type internalLinkTypeInvoice$Input = {
    /**
     * The link is a link to an invoice. Call getPaymentForm with the given invoice
     * name to process the link
     */
    readonly _: 'internalLinkTypeInvoice',
    /** Name of the invoice */
    readonly invoice_name?: string,
  }

  export type internalLinkTypeLanguagePack = {
    /**
     * The link is a link to a language pack. Call getLanguagePackInfo with the given
     * language pack identifier to process the link. If the language pack is found
     * and the user wants to apply it, then call setOption for the option "language_pack_id"
     */
    _: 'internalLinkTypeLanguagePack',
    /** Language pack identifier */
    language_pack_id: string,
  }

  export type internalLinkTypeLanguagePack$Input = {
    /**
     * The link is a link to a language pack. Call getLanguagePackInfo with the given
     * language pack identifier to process the link. If the language pack is found
     * and the user wants to apply it, then call setOption for the option "language_pack_id"
     */
    readonly _: 'internalLinkTypeLanguagePack',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type internalLinkTypeLanguageSettings = {
    /** The link is a link to the language section of the application settings */
    _: 'internalLinkTypeLanguageSettings',
  }

  export type internalLinkTypeLanguageSettings$Input = {
    /** The link is a link to the language section of the application settings */
    readonly _: 'internalLinkTypeLanguageSettings',
  }

  export type internalLinkTypeMainWebApp = {
    /**
     * The link is a link to the main Web App of a bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot and has the main Web App.
     * If the bot can be added to attachment menu, then use getAttachmentMenuBot to
     * receive information about the bot, then if the bot isn't added to side menu,
     * show a disclaimer about Mini Apps being third-party applications, ask the user
     * to accept their Terms of service and confirm adding the bot to side and attachment
     * menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, use getMainWebApp with the given start parameter and mode
     * and open the returned URL as a Web App
     */
    _: 'internalLinkTypeMainWebApp',
    /** Username of the bot */
    bot_username: string,
    /** Start parameter to be passed to getMainWebApp */
    start_parameter: string,
    /** The mode to be passed to getMainWebApp */
    mode: WebAppOpenMode,
  }

  export type internalLinkTypeMainWebApp$Input = {
    /**
     * The link is a link to the main Web App of a bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot and has the main Web App.
     * If the bot can be added to attachment menu, then use getAttachmentMenuBot to
     * receive information about the bot, then if the bot isn't added to side menu,
     * show a disclaimer about Mini Apps being third-party applications, ask the user
     * to accept their Terms of service and confirm adding the bot to side and attachment
     * menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, use getMainWebApp with the given start parameter and mode
     * and open the returned URL as a Web App
     */
    readonly _: 'internalLinkTypeMainWebApp',
    /** Username of the bot */
    readonly bot_username?: string,
    /** Start parameter to be passed to getMainWebApp */
    readonly start_parameter?: string,
    /** The mode to be passed to getMainWebApp */
    readonly mode?: WebAppOpenMode$Input,
  }

  export type internalLinkTypeMessage = {
    /**
     * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo
     * with the given URL to process the link, and then open received forum topic or
     * chat and show the message there
     */
    _: 'internalLinkTypeMessage',
    /** URL to be passed to getMessageLinkInfo */
    url: string,
  }

  export type internalLinkTypeMessage$Input = {
    /**
     * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo
     * with the given URL to process the link, and then open received forum topic or
     * chat and show the message there
     */
    readonly _: 'internalLinkTypeMessage',
    /** URL to be passed to getMessageLinkInfo */
    readonly url?: string,
  }

  export type internalLinkTypeMessageDraft = {
    /**
     * The link contains a message draft text. A share screen needs to be shown to
     * the user, then the chosen chat must be opened and the text is added to the input
     * field
     */
    _: 'internalLinkTypeMessageDraft',
    /** Message draft text */
    text: formattedText,
    /**
     * True, if the first line of the text contains a link. If true, the input field
     * needs to be focused and the text after the link must be selected
     */
    contains_link: boolean,
  }

  export type internalLinkTypeMessageDraft$Input = {
    /**
     * The link contains a message draft text. A share screen needs to be shown to
     * the user, then the chosen chat must be opened and the text is added to the input
     * field
     */
    readonly _: 'internalLinkTypeMessageDraft',
    /** Message draft text */
    readonly text?: formattedText$Input,
    /**
     * True, if the first line of the text contains a link. If true, the input field
     * needs to be focused and the text after the link must be selected
     */
    readonly contains_link?: boolean,
  }

  export type internalLinkTypeMyStars = {
    /**
     * The link is a link to the screen with information about Telegram Star balance
     * and transactions of the current user
     */
    _: 'internalLinkTypeMyStars',
  }

  export type internalLinkTypeMyStars$Input = {
    /**
     * The link is a link to the screen with information about Telegram Star balance
     * and transactions of the current user
     */
    readonly _: 'internalLinkTypeMyStars',
  }

  export type internalLinkTypePassportDataRequest = {
    /**
     * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
     * with the given parameters to process the link if the link was received from
     * outside of the application; otherwise, ignore it
     */
    _: 'internalLinkTypePassportDataRequest',
    /**
     * User identifier of the service's bot; the corresponding user may be unknown
     * yet
     */
    bot_user_id: number,
    /** Telegram Passport element types requested by the service */
    scope: string,
    /** Service's public key */
    public_key: string,
    /** Unique request identifier provided by the service */
    nonce: string,
    /**
     * An HTTP URL to open once the request is finished, canceled, or failed with the
     * parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=...
     * respectively. If empty, then onActivityResult method must be used to return
     * response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel
     * must be opened otherwise
     */
    callback_url: string,
  }

  export type internalLinkTypePassportDataRequest$Input = {
    /**
     * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
     * with the given parameters to process the link if the link was received from
     * outside of the application; otherwise, ignore it
     */
    readonly _: 'internalLinkTypePassportDataRequest',
    /**
     * User identifier of the service's bot; the corresponding user may be unknown
     * yet
     */
    readonly bot_user_id?: number,
    /** Telegram Passport element types requested by the service */
    readonly scope?: string,
    /** Service's public key */
    readonly public_key?: string,
    /** Unique request identifier provided by the service */
    readonly nonce?: string,
    /**
     * An HTTP URL to open once the request is finished, canceled, or failed with the
     * parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=...
     * respectively. If empty, then onActivityResult method must be used to return
     * response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel
     * must be opened otherwise
     */
    readonly callback_url?: string,
  }

  export type internalLinkTypePhoneNumberConfirmation = {
    /**
     * The link can be used to confirm ownership of a phone number to prevent account
     * deletion. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership
     * with the given hash to process the link. If succeeded, call checkPhoneNumberCode
     * to check entered by the user code, or resendPhoneNumberCode to resend it
     */
    _: 'internalLinkTypePhoneNumberConfirmation',
    /** Hash value from the link */
    hash: string,
    /** Phone number value from the link */
    phone_number: string,
  }

  export type internalLinkTypePhoneNumberConfirmation$Input = {
    /**
     * The link can be used to confirm ownership of a phone number to prevent account
     * deletion. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership
     * with the given hash to process the link. If succeeded, call checkPhoneNumberCode
     * to check entered by the user code, or resendPhoneNumberCode to resend it
     */
    readonly _: 'internalLinkTypePhoneNumberConfirmation',
    /** Hash value from the link */
    readonly hash?: string,
    /** Phone number value from the link */
    readonly phone_number?: string,
  }

  export type internalLinkTypePremiumFeatures = {
    /**
     * The link is a link to the Premium features screen of the application from which
     * the user can subscribe to Telegram Premium. Call getPremiumFeatures with the
     * given referrer to process the link
     */
    _: 'internalLinkTypePremiumFeatures',
    /** Referrer specified in the link */
    referrer: string,
  }

  export type internalLinkTypePremiumFeatures$Input = {
    /**
     * The link is a link to the Premium features screen of the application from which
     * the user can subscribe to Telegram Premium. Call getPremiumFeatures with the
     * given referrer to process the link
     */
    readonly _: 'internalLinkTypePremiumFeatures',
    /** Referrer specified in the link */
    readonly referrer?: string,
  }

  export type internalLinkTypePremiumGift = {
    /**
     * The link is a link to the screen for gifting Telegram Premium subscriptions
     * to friends via inputInvoiceTelegram with telegramPaymentPurposePremiumGift payments
     * or in-store purchases
     */
    _: 'internalLinkTypePremiumGift',
    /** Referrer specified in the link */
    referrer: string,
  }

  export type internalLinkTypePremiumGift$Input = {
    /**
     * The link is a link to the screen for gifting Telegram Premium subscriptions
     * to friends via inputInvoiceTelegram with telegramPaymentPurposePremiumGift payments
     * or in-store purchases
     */
    readonly _: 'internalLinkTypePremiumGift',
    /** Referrer specified in the link */
    readonly referrer?: string,
  }

  export type internalLinkTypePremiumGiftCode = {
    /**
     * The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode
     * with the given code to process the link. If the code is valid and the user wants
     * to apply it, then call applyPremiumGiftCode
     */
    _: 'internalLinkTypePremiumGiftCode',
    /** The Telegram Premium gift code */
    code: string,
  }

  export type internalLinkTypePremiumGiftCode$Input = {
    /**
     * The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode
     * with the given code to process the link. If the code is valid and the user wants
     * to apply it, then call applyPremiumGiftCode
     */
    readonly _: 'internalLinkTypePremiumGiftCode',
    /** The Telegram Premium gift code */
    readonly code?: string,
  }

  export type internalLinkTypePrivacyAndSecuritySettings = {
    /** The link is a link to the privacy and security section of the application settings */
    _: 'internalLinkTypePrivacyAndSecuritySettings',
  }

  export type internalLinkTypePrivacyAndSecuritySettings$Input = {
    /** The link is a link to the privacy and security section of the application settings */
    readonly _: 'internalLinkTypePrivacyAndSecuritySettings',
  }

  export type internalLinkTypeProxy = {
    /**
     * The link is a link to a proxy. Call addProxy with the given parameters to process
     * the link and add the proxy
     */
    _: 'internalLinkTypeProxy',
    /** Proxy server domain or IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Type of the proxy */
    type: ProxyType,
  }

  export type internalLinkTypeProxy$Input = {
    /**
     * The link is a link to a proxy. Call addProxy with the given parameters to process
     * the link and add the proxy
     */
    readonly _: 'internalLinkTypeProxy',
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Type of the proxy */
    readonly type?: ProxyType$Input,
  }

  export type internalLinkTypePublicChat = {
    /**
     * The link is a link to a chat by its username. Call searchPublicChat with the
     * given chat username to process the link. If the chat is found, open its profile
     * information screen or the chat itself. If draft text isn't empty and the chat
     * is a private chat with a regular user, then put the draft text in the input
     * field
     */
    _: 'internalLinkTypePublicChat',
    /** Username of the chat */
    chat_username: string,
    /** Draft text for message to send in the chat */
    draft_text: string,
    /**
     * True, if chat profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    open_profile: boolean,
  }

  export type internalLinkTypePublicChat$Input = {
    /**
     * The link is a link to a chat by its username. Call searchPublicChat with the
     * given chat username to process the link. If the chat is found, open its profile
     * information screen or the chat itself. If draft text isn't empty and the chat
     * is a private chat with a regular user, then put the draft text in the input
     * field
     */
    readonly _: 'internalLinkTypePublicChat',
    /** Username of the chat */
    readonly chat_username?: string,
    /** Draft text for message to send in the chat */
    readonly draft_text?: string,
    /**
     * True, if chat profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    readonly open_profile?: boolean,
  }

  export type internalLinkTypeQrCodeAuthentication = {
    /**
     * The link can be used to login the current user on another device, but it must
     * be scanned from QR-code using in-app camera. An alert similar to "This code
     * can be used to allow someone to log in to your Telegram account. To confirm
     * Telegram login, please go to Settings > Devices > Scan QR and scan the code"
     * needs to be shown
     */
    _: 'internalLinkTypeQrCodeAuthentication',
  }

  export type internalLinkTypeQrCodeAuthentication$Input = {
    /**
     * The link can be used to login the current user on another device, but it must
     * be scanned from QR-code using in-app camera. An alert similar to "This code
     * can be used to allow someone to log in to your Telegram account. To confirm
     * Telegram login, please go to Settings > Devices > Scan QR and scan the code"
     * needs to be shown
     */
    readonly _: 'internalLinkTypeQrCodeAuthentication',
  }

  export type internalLinkTypeRestorePurchases = {
    /**
     * The link forces restore of App Store purchases when opened. For official iOS
     * application only
     */
    _: 'internalLinkTypeRestorePurchases',
  }

  export type internalLinkTypeRestorePurchases$Input = {
    /**
     * The link forces restore of App Store purchases when opened. For official iOS
     * application only
     */
    readonly _: 'internalLinkTypeRestorePurchases',
  }

  export type internalLinkTypeSettings = {
    /** The link is a link to application settings */
    _: 'internalLinkTypeSettings',
  }

  export type internalLinkTypeSettings$Input = {
    /** The link is a link to application settings */
    readonly _: 'internalLinkTypeSettings',
  }

  export type internalLinkTypeStickerSet = {
    /**
     * The link is a link to a sticker set. Call searchStickerSet with the given sticker
     * set name to process the link and show the sticker set. If the sticker set is
     * found and the user wants to add it, then call changeStickerSet
     */
    _: 'internalLinkTypeStickerSet',
    /** Name of the sticker set */
    sticker_set_name: string,
    /** True, if the sticker set is expected to contain custom emoji */
    expect_custom_emoji: boolean,
  }

  export type internalLinkTypeStickerSet$Input = {
    /**
     * The link is a link to a sticker set. Call searchStickerSet with the given sticker
     * set name to process the link and show the sticker set. If the sticker set is
     * found and the user wants to add it, then call changeStickerSet
     */
    readonly _: 'internalLinkTypeStickerSet',
    /** Name of the sticker set */
    readonly sticker_set_name?: string,
    /** True, if the sticker set is expected to contain custom emoji */
    readonly expect_custom_emoji?: boolean,
  }

  export type internalLinkTypeStory = {
    /**
     * The link is a link to a story. Call searchPublicChat with the given poster username,
     * then call getStory with the received chat identifier and the given story identifier,
     * then show the story if received
     */
    _: 'internalLinkTypeStory',
    /** Username of the poster of the story */
    story_poster_username: string,
    /** Story identifier */
    story_id: number,
  }

  export type internalLinkTypeStory$Input = {
    /**
     * The link is a link to a story. Call searchPublicChat with the given poster username,
     * then call getStory with the received chat identifier and the given story identifier,
     * then show the story if received
     */
    readonly _: 'internalLinkTypeStory',
    /** Username of the poster of the story */
    readonly story_poster_username?: string,
    /** Story identifier */
    readonly story_id?: number,
  }

  export type internalLinkTypeTheme = {
    /** The link is a link to a cloud theme. TDLib has no theme support yet */
    _: 'internalLinkTypeTheme',
    /** Name of the theme */
    theme_name: string,
  }

  export type internalLinkTypeTheme$Input = {
    /** The link is a link to a cloud theme. TDLib has no theme support yet */
    readonly _: 'internalLinkTypeTheme',
    /** Name of the theme */
    readonly theme_name?: string,
  }

  export type internalLinkTypeThemeSettings = {
    /** The link is a link to the theme section of the application settings */
    _: 'internalLinkTypeThemeSettings',
  }

  export type internalLinkTypeThemeSettings$Input = {
    /** The link is a link to the theme section of the application settings */
    readonly _: 'internalLinkTypeThemeSettings',
  }

  export type internalLinkTypeUnknownDeepLink = {
    /** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
    _: 'internalLinkTypeUnknownDeepLink',
    /** Link to be passed to getDeepLinkInfo */
    link: string,
  }

  export type internalLinkTypeUnknownDeepLink$Input = {
    /** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
    readonly _: 'internalLinkTypeUnknownDeepLink',
    /** Link to be passed to getDeepLinkInfo */
    readonly link?: string,
  }

  export type internalLinkTypeUnsupportedProxy = {
    /** The link is a link to an unsupported proxy. An alert can be shown to the user */
    _: 'internalLinkTypeUnsupportedProxy',
  }

  export type internalLinkTypeUnsupportedProxy$Input = {
    /** The link is a link to an unsupported proxy. An alert can be shown to the user */
    readonly _: 'internalLinkTypeUnsupportedProxy',
  }

  export type internalLinkTypeUpgradedGift = {
    /**
     * The link is a link to an upgraded gift. Call getUpgradedGift with the given
     * name to process the link
     */
    _: 'internalLinkTypeUpgradedGift',
    /** Name of the unique gift */
    name: string,
  }

  export type internalLinkTypeUpgradedGift$Input = {
    /**
     * The link is a link to an upgraded gift. Call getUpgradedGift with the given
     * name to process the link
     */
    readonly _: 'internalLinkTypeUpgradedGift',
    /** Name of the unique gift */
    readonly name?: string,
  }

  export type internalLinkTypeUserPhoneNumber = {
    /**
     * The link is a link to a user by its phone number. Call searchUserByPhoneNumber
     * with the given phone number to process the link. If the user is found, then
     * call createPrivateChat and open user's profile information screen or the chat
     * itself. If draft text isn't empty, then put the draft text in the input field
     */
    _: 'internalLinkTypeUserPhoneNumber',
    /** Phone number of the user */
    phone_number: string,
    /** Draft text for message to send in the chat */
    draft_text: string,
    /**
     * True, if user's profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    open_profile: boolean,
  }

  export type internalLinkTypeUserPhoneNumber$Input = {
    /**
     * The link is a link to a user by its phone number. Call searchUserByPhoneNumber
     * with the given phone number to process the link. If the user is found, then
     * call createPrivateChat and open user's profile information screen or the chat
     * itself. If draft text isn't empty, then put the draft text in the input field
     */
    readonly _: 'internalLinkTypeUserPhoneNumber',
    /** Phone number of the user */
    readonly phone_number?: string,
    /** Draft text for message to send in the chat */
    readonly draft_text?: string,
    /**
     * True, if user's profile information screen must be opened; otherwise, the chat
     * itself must be opened
     */
    readonly open_profile?: boolean,
  }

  export type internalLinkTypeUserToken = {
    /**
     * The link is a link to a user by a temporary token. Call searchUserByToken with
     * the given token to process the link. If the user is found, then call createPrivateChat
     * and open the chat
     */
    _: 'internalLinkTypeUserToken',
    /** The token */
    token: string,
  }

  export type internalLinkTypeUserToken$Input = {
    /**
     * The link is a link to a user by a temporary token. Call searchUserByToken with
     * the given token to process the link. If the user is found, then call createPrivateChat
     * and open the chat
     */
    readonly _: 'internalLinkTypeUserToken',
    /** The token */
    readonly token?: string,
  }

  export type internalLinkTypeVideoChat = {
    /**
     * The link is a link to a video chat. Call searchPublicChat with the given chat
     * username, and then joinVideoChat with the given invite hash to process the link
     */
    _: 'internalLinkTypeVideoChat',
    /** Username of the chat with the video chat */
    chat_username: string,
    /**
     * If non-empty, invite hash to be used to join the video chat without being muted
     * by administrators
     */
    invite_hash: string,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    is_live_stream: boolean,
  }

  export type internalLinkTypeVideoChat$Input = {
    /**
     * The link is a link to a video chat. Call searchPublicChat with the given chat
     * username, and then joinVideoChat with the given invite hash to process the link
     */
    readonly _: 'internalLinkTypeVideoChat',
    /** Username of the chat with the video chat */
    readonly chat_username?: string,
    /**
     * If non-empty, invite hash to be used to join the video chat without being muted
     * by administrators
     */
    readonly invite_hash?: string,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    readonly is_live_stream?: boolean,
  }

  export type internalLinkTypeWebApp = {
    /**
     * The link is a link to a Web App. Call searchPublicChat with the given bot username,
     * check that the user is a bot. If the bot is restricted for the current user,
     * then show an error message. Otherwise, call searchWebApp with the received bot
     * and the given web_app_short_name. Process received foundWebApp by showing a
     * confirmation dialog if needed. If the bot can be added to attachment or side
     * menu, but isn't added yet, then show a disclaimer about Mini Apps being third-party
     * applications instead of the dialog and ask the user to accept their Terms of
     * service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web
     * App
     */
    _: 'internalLinkTypeWebApp',
    /** Username of the bot that owns the Web App */
    bot_username: string,
    /** Short name of the Web App */
    web_app_short_name: string,
    /** Start parameter to be passed to getWebAppLinkUrl */
    start_parameter: string,
    /** The mode in which the Web App must be opened */
    mode: WebAppOpenMode,
  }

  export type internalLinkTypeWebApp$Input = {
    /**
     * The link is a link to a Web App. Call searchPublicChat with the given bot username,
     * check that the user is a bot. If the bot is restricted for the current user,
     * then show an error message. Otherwise, call searchWebApp with the received bot
     * and the given web_app_short_name. Process received foundWebApp by showing a
     * confirmation dialog if needed. If the bot can be added to attachment or side
     * menu, but isn't added yet, then show a disclaimer about Mini Apps being third-party
     * applications instead of the dialog and ask the user to accept their Terms of
     * service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web
     * App
     */
    readonly _: 'internalLinkTypeWebApp',
    /** Username of the bot that owns the Web App */
    readonly bot_username?: string,
    /** Short name of the Web App */
    readonly web_app_short_name?: string,
    /** Start parameter to be passed to getWebAppLinkUrl */
    readonly start_parameter?: string,
    /** The mode in which the Web App must be opened */
    readonly mode?: WebAppOpenMode$Input,
  }

  export type messageLink = {
    /** Contains an HTTPS link to a message in a supergroup or channel, or a forum topic */
    _: 'messageLink',
    /** The link */
    link: string,
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
  }

  export type messageLinkInfo = {
    /** Contains information about a link to a message or a forum topic in a chat */
    _: 'messageLinkInfo',
    /** True, if the link is a public link for a message or a forum topic in a chat */
    is_public: boolean,
    /** If found, identifier of the chat to which the link points, 0 otherwise */
    chat_id: number,
    /**
     * If found, identifier of the message thread in which to open the message, or
     * a forum topic to open if the message is missing
     */
    message_thread_id: number,
    /** If found, the linked message; may be null */
    message?: message,
    /**
     * Timestamp from which the video/audio/video note/voice note/story playing must
     * start, in seconds; 0 if not specified. The media can be in the message content
     * or in its link preview
     */
    media_timestamp: number,
    /** True, if the whole media album to which the message belongs is linked */
    for_album: boolean,
  }

  export type chatBoostLink = {
    /** Contains an HTTPS link to boost a chat */
    _: 'chatBoostLink',
    /** The link */
    link: string,
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
  }

  export type chatBoostLinkInfo = {
    /** Contains information about a link to boost a chat */
    _: 'chatBoostLinkInfo',
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
    /** Identifier of the chat to which the link points; 0 if the chat isn't found */
    chat_id: number,
  }

  export type blockListMain = {
    /**
     * The main block list that disallows writing messages to the current user, receiving
     * their status and photo, viewing of stories, and some other actions
     */
    _: 'blockListMain',
  }

  export type blockListMain$Input = {
    /**
     * The main block list that disallows writing messages to the current user, receiving
     * their status and photo, viewing of stories, and some other actions
     */
    readonly _: 'blockListMain',
  }

  export type blockListStories = {
    /** The block list that disallows viewing of stories of the current user */
    _: 'blockListStories',
  }

  export type blockListStories$Input = {
    /** The block list that disallows viewing of stories of the current user */
    readonly _: 'blockListStories',
  }

  export type fileTypeNone = {
    /** The data is not a file */
    _: 'fileTypeNone',
  }

  export type fileTypeNone$Input = {
    /** The data is not a file */
    readonly _: 'fileTypeNone',
  }

  export type fileTypeAnimation = {
    /** The file is an animation */
    _: 'fileTypeAnimation',
  }

  export type fileTypeAnimation$Input = {
    /** The file is an animation */
    readonly _: 'fileTypeAnimation',
  }

  export type fileTypeAudio = {
    /** The file is an audio file */
    _: 'fileTypeAudio',
  }

  export type fileTypeAudio$Input = {
    /** The file is an audio file */
    readonly _: 'fileTypeAudio',
  }

  export type fileTypeDocument = {
    /** The file is a document */
    _: 'fileTypeDocument',
  }

  export type fileTypeDocument$Input = {
    /** The file is a document */
    readonly _: 'fileTypeDocument',
  }

  export type fileTypeNotificationSound = {
    /** The file is a notification sound */
    _: 'fileTypeNotificationSound',
  }

  export type fileTypeNotificationSound$Input = {
    /** The file is a notification sound */
    readonly _: 'fileTypeNotificationSound',
  }

  export type fileTypePhoto = {
    /** The file is a photo */
    _: 'fileTypePhoto',
  }

  export type fileTypePhoto$Input = {
    /** The file is a photo */
    readonly _: 'fileTypePhoto',
  }

  export type fileTypePhotoStory = {
    /** The file is a photo published as a story */
    _: 'fileTypePhotoStory',
  }

  export type fileTypePhotoStory$Input = {
    /** The file is a photo published as a story */
    readonly _: 'fileTypePhotoStory',
  }

  export type fileTypeProfilePhoto = {
    /** The file is a profile photo */
    _: 'fileTypeProfilePhoto',
  }

  export type fileTypeProfilePhoto$Input = {
    /** The file is a profile photo */
    readonly _: 'fileTypeProfilePhoto',
  }

  export type fileTypeSecret = {
    /** The file was sent to a secret chat (the file type is not known to the server) */
    _: 'fileTypeSecret',
  }

  export type fileTypeSecret$Input = {
    /** The file was sent to a secret chat (the file type is not known to the server) */
    readonly _: 'fileTypeSecret',
  }

  export type fileTypeSecretThumbnail = {
    /** The file is a thumbnail of a file from a secret chat */
    _: 'fileTypeSecretThumbnail',
  }

  export type fileTypeSecretThumbnail$Input = {
    /** The file is a thumbnail of a file from a secret chat */
    readonly _: 'fileTypeSecretThumbnail',
  }

  export type fileTypeSecure = {
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    _: 'fileTypeSecure',
  }

  export type fileTypeSecure$Input = {
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    readonly _: 'fileTypeSecure',
  }

  export type fileTypeSelfDestructingPhoto = {
    /** The file is a self-destructing photo in a private chat */
    _: 'fileTypeSelfDestructingPhoto',
  }

  export type fileTypeSelfDestructingPhoto$Input = {
    /** The file is a self-destructing photo in a private chat */
    readonly _: 'fileTypeSelfDestructingPhoto',
  }

  export type fileTypeSelfDestructingVideo = {
    /** The file is a self-destructing video in a private chat */
    _: 'fileTypeSelfDestructingVideo',
  }

  export type fileTypeSelfDestructingVideo$Input = {
    /** The file is a self-destructing video in a private chat */
    readonly _: 'fileTypeSelfDestructingVideo',
  }

  export type fileTypeSelfDestructingVideoNote = {
    /** The file is a self-destructing video note in a private chat */
    _: 'fileTypeSelfDestructingVideoNote',
  }

  export type fileTypeSelfDestructingVideoNote$Input = {
    /** The file is a self-destructing video note in a private chat */
    readonly _: 'fileTypeSelfDestructingVideoNote',
  }

  export type fileTypeSelfDestructingVoiceNote = {
    /** The file is a self-destructing voice note in a private chat */
    _: 'fileTypeSelfDestructingVoiceNote',
  }

  export type fileTypeSelfDestructingVoiceNote$Input = {
    /** The file is a self-destructing voice note in a private chat */
    readonly _: 'fileTypeSelfDestructingVoiceNote',
  }

  export type fileTypeSticker = {
    /** The file is a sticker */
    _: 'fileTypeSticker',
  }

  export type fileTypeSticker$Input = {
    /** The file is a sticker */
    readonly _: 'fileTypeSticker',
  }

  export type fileTypeThumbnail = {
    /** The file is a thumbnail of another file */
    _: 'fileTypeThumbnail',
  }

  export type fileTypeThumbnail$Input = {
    /** The file is a thumbnail of another file */
    readonly _: 'fileTypeThumbnail',
  }

  export type fileTypeUnknown = {
    /** The file type is not yet known */
    _: 'fileTypeUnknown',
  }

  export type fileTypeUnknown$Input = {
    /** The file type is not yet known */
    readonly _: 'fileTypeUnknown',
  }

  export type fileTypeVideo = {
    /** The file is a video */
    _: 'fileTypeVideo',
  }

  export type fileTypeVideo$Input = {
    /** The file is a video */
    readonly _: 'fileTypeVideo',
  }

  export type fileTypeVideoNote = {
    /** The file is a video note */
    _: 'fileTypeVideoNote',
  }

  export type fileTypeVideoNote$Input = {
    /** The file is a video note */
    readonly _: 'fileTypeVideoNote',
  }

  export type fileTypeVideoStory = {
    /** The file is a video published as a story */
    _: 'fileTypeVideoStory',
  }

  export type fileTypeVideoStory$Input = {
    /** The file is a video published as a story */
    readonly _: 'fileTypeVideoStory',
  }

  export type fileTypeVoiceNote = {
    /** The file is a voice note */
    _: 'fileTypeVoiceNote',
  }

  export type fileTypeVoiceNote$Input = {
    /** The file is a voice note */
    readonly _: 'fileTypeVoiceNote',
  }

  export type fileTypeWallpaper = {
    /** The file is a wallpaper or a background pattern */
    _: 'fileTypeWallpaper',
  }

  export type fileTypeWallpaper$Input = {
    /** The file is a wallpaper or a background pattern */
    readonly _: 'fileTypeWallpaper',
  }

  export type storageStatisticsByFileType = {
    /** Contains the storage usage statistics for a specific file type */
    _: 'storageStatisticsByFileType',
    /** File type */
    file_type: FileType,
    /** Total size of the files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
  }

  export type storageStatisticsByChat = {
    /** Contains the storage usage statistics for a specific chat */
    _: 'storageStatisticsByChat',
    /** Chat identifier; 0 if none */
    chat_id: number,
    /** Total size of the files in the chat, in bytes */
    size: number,
    /** Total number of files in the chat */
    count: number,
    /** Statistics split by file types */
    by_file_type: Array<storageStatisticsByFileType>,
  }

  export type storageStatistics = {
    /** Contains the exact storage usage statistics split by chats and file type */
    _: 'storageStatistics',
    /** Total size of files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
    /** Statistics split by chats */
    by_chat: Array<storageStatisticsByChat>,
  }

  export type storageStatisticsFast = {
    /**
     * Contains approximate storage usage statistics, excluding files of unknown file
     * type
     */
    _: 'storageStatisticsFast',
    /** Approximate total size of files, in bytes */
    files_size: number,
    /** Approximate number of files */
    file_count: number,
    /** Size of the database */
    database_size: number,
    /** Size of the language pack database */
    language_pack_database_size: number,
    /** Size of the TDLib internal log */
    log_size: number,
  }

  export type databaseStatistics = {
    /** Contains database statistics */
    _: 'databaseStatistics',
    /** Database statistics in an unspecified human-readable format */
    statistics: string,
  }

  export type networkTypeNone = {
    /** The network is not available */
    _: 'networkTypeNone',
  }

  export type networkTypeNone$Input = {
    /** The network is not available */
    readonly _: 'networkTypeNone',
  }

  export type networkTypeMobile = {
    /** A mobile network */
    _: 'networkTypeMobile',
  }

  export type networkTypeMobile$Input = {
    /** A mobile network */
    readonly _: 'networkTypeMobile',
  }

  export type networkTypeMobileRoaming = {
    /** A mobile roaming network */
    _: 'networkTypeMobileRoaming',
  }

  export type networkTypeMobileRoaming$Input = {
    /** A mobile roaming network */
    readonly _: 'networkTypeMobileRoaming',
  }

  export type networkTypeWiFi = {
    /** A Wi-Fi network */
    _: 'networkTypeWiFi',
  }

  export type networkTypeWiFi$Input = {
    /** A Wi-Fi network */
    readonly _: 'networkTypeWiFi',
  }

  export type networkTypeOther = {
    /** A different network type (e.g., Ethernet network) */
    _: 'networkTypeOther',
  }

  export type networkTypeOther$Input = {
    /** A different network type (e.g., Ethernet network) */
    readonly _: 'networkTypeOther',
  }

  export type networkStatisticsEntryFile = {
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    _: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    file_type: FileType,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
  }

  export type networkStatisticsEntryFile$Input = {
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    readonly _: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    readonly file_type?: FileType$Input,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    readonly network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    readonly sent_bytes?: number,
    /** Total number of bytes received */
    readonly received_bytes?: number,
  }

  export type networkStatisticsEntryCall = {
    /** Contains information about the total amount of data that was used for calls */
    _: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
    /** Total call duration, in seconds */
    duration: number,
  }

  export type networkStatisticsEntryCall$Input = {
    /** Contains information about the total amount of data that was used for calls */
    readonly _: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    readonly network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    readonly sent_bytes?: number,
    /** Total number of bytes received */
    readonly received_bytes?: number,
    /** Total call duration, in seconds */
    readonly duration?: number,
  }

  export type networkStatistics = {
    /** A full list of available network statistic entries */
    _: 'networkStatistics',
    /** Point in time (Unix timestamp) from which the statistics are collected */
    since_date: number,
    /** Network statistics entries */
    entries: Array<NetworkStatisticsEntry>,
  }

  export type autoDownloadSettings = {
    /** Contains auto-download settings */
    _: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    is_auto_download_enabled: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    max_photo_file_size: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    max_video_file_size: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    max_other_file_size: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    video_upload_bitrate: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    preload_large_videos: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    preload_next_audio: boolean,
    /** True, if stories needs to be preloaded */
    preload_stories: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    use_less_data_for_calls: boolean,
  }

  export type autoDownloadSettings$Input = {
    /** Contains auto-download settings */
    readonly _: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    readonly is_auto_download_enabled?: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    readonly max_photo_file_size?: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    readonly max_video_file_size?: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    readonly max_other_file_size?: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    readonly video_upload_bitrate?: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    readonly preload_large_videos?: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    readonly preload_next_audio?: boolean,
    /** True, if stories needs to be preloaded */
    readonly preload_stories?: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    readonly use_less_data_for_calls?: boolean,
  }

  export type autoDownloadSettingsPresets = {
    /** Contains auto-download settings presets for the current user */
    _: 'autoDownloadSettingsPresets',
    /** Preset with lowest settings; expected to be used by default when roaming */
    low: autoDownloadSettings,
    /**
     * Preset with medium settings; expected to be used by default when using mobile
     * data
     */
    medium: autoDownloadSettings,
    /**
     * Preset with highest settings; expected to be used by default when connected
     * on Wi-Fi
     */
    high: autoDownloadSettings,
  }

  export type autosaveSettingsScopePrivateChats = {
    /** Autosave settings applied to all private chats without chat-specific settings */
    _: 'autosaveSettingsScopePrivateChats',
  }

  export type autosaveSettingsScopePrivateChats$Input = {
    /** Autosave settings applied to all private chats without chat-specific settings */
    readonly _: 'autosaveSettingsScopePrivateChats',
  }

  export type autosaveSettingsScopeGroupChats = {
    /**
     * Autosave settings applied to all basic group and supergroup chats without chat-specific
     * settings
     */
    _: 'autosaveSettingsScopeGroupChats',
  }

  export type autosaveSettingsScopeGroupChats$Input = {
    /**
     * Autosave settings applied to all basic group and supergroup chats without chat-specific
     * settings
     */
    readonly _: 'autosaveSettingsScopeGroupChats',
  }

  export type autosaveSettingsScopeChannelChats = {
    /** Autosave settings applied to all channel chats without chat-specific settings */
    _: 'autosaveSettingsScopeChannelChats',
  }

  export type autosaveSettingsScopeChannelChats$Input = {
    /** Autosave settings applied to all channel chats without chat-specific settings */
    readonly _: 'autosaveSettingsScopeChannelChats',
  }

  export type autosaveSettingsScopeChat = {
    /** Autosave settings applied to a chat */
    _: 'autosaveSettingsScopeChat',
    /** Chat identifier */
    chat_id: number,
  }

  export type autosaveSettingsScopeChat$Input = {
    /** Autosave settings applied to a chat */
    readonly _: 'autosaveSettingsScopeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type scopeAutosaveSettings = {
    /** Contains autosave settings for an autosave settings scope */
    _: 'scopeAutosaveSettings',
    /** True, if photo autosave is enabled */
    autosave_photos: boolean,
    /** True, if video autosave is enabled */
    autosave_videos: boolean,
    /** The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB */
    max_video_file_size: number,
  }

  export type scopeAutosaveSettings$Input = {
    /** Contains autosave settings for an autosave settings scope */
    readonly _: 'scopeAutosaveSettings',
    /** True, if photo autosave is enabled */
    readonly autosave_photos?: boolean,
    /** True, if video autosave is enabled */
    readonly autosave_videos?: boolean,
    /** The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB */
    readonly max_video_file_size?: number,
  }

  export type autosaveSettingsException = {
    /**
     * Contains autosave settings for a chat, which overrides default settings for
     * the corresponding scope
     */
    _: 'autosaveSettingsException',
    /** Chat identifier */
    chat_id: number,
    /** Autosave settings for the chat */
    settings: scopeAutosaveSettings,
  }

  export type autosaveSettings = {
    /** Describes autosave settings */
    _: 'autosaveSettings',
    /** Default autosave settings for private chats */
    private_chat_settings: scopeAutosaveSettings,
    /** Default autosave settings for basic group and supergroup chats */
    group_settings: scopeAutosaveSettings,
    /** Default autosave settings for channel chats */
    channel_settings: scopeAutosaveSettings,
    /** Autosave settings for specific chats */
    exceptions: Array<autosaveSettingsException>,
  }

  export type connectionStateWaitingForNetwork = {
    /**
     * Waiting for the network to become available. Use setNetworkType to change the
     * available network type
     */
    _: 'connectionStateWaitingForNetwork',
  }

  export type connectionStateConnectingToProxy = {
    /** Establishing a connection with a proxy server */
    _: 'connectionStateConnectingToProxy',
  }

  export type connectionStateConnecting = {
    /** Establishing a connection to the Telegram servers */
    _: 'connectionStateConnecting',
  }

  export type connectionStateUpdating = {
    /** Downloading data expected to be received while the application was offline */
    _: 'connectionStateUpdating',
  }

  export type connectionStateReady = {
    /** There is a working connection to the Telegram servers */
    _: 'connectionStateReady',
  }

  export type topChatCategoryUsers$Input = {
    /** A category containing frequently used private chats with non-bot users */
    readonly _: 'topChatCategoryUsers',
  }

  export type topChatCategoryBots$Input = {
    /** A category containing frequently used private chats with bot users */
    readonly _: 'topChatCategoryBots',
  }

  export type topChatCategoryGroups$Input = {
    /** A category containing frequently used basic groups and supergroups */
    readonly _: 'topChatCategoryGroups',
  }

  export type topChatCategoryChannels$Input = {
    /** A category containing frequently used channels */
    readonly _: 'topChatCategoryChannels',
  }

  export type topChatCategoryInlineBots$Input = {
    /**
     * A category containing frequently used chats with inline bots sorted by their
     * usage in inline mode
     */
    readonly _: 'topChatCategoryInlineBots',
  }

  export type topChatCategoryWebAppBots$Input = {
    /** A category containing frequently used chats with bots, which Web Apps were opened */
    readonly _: 'topChatCategoryWebAppBots',
  }

  export type topChatCategoryCalls$Input = {
    /** A category containing frequently used chats used for calls */
    readonly _: 'topChatCategoryCalls',
  }

  export type topChatCategoryForwardChats$Input = {
    /** A category containing frequently used chats used to forward messages */
    readonly _: 'topChatCategoryForwardChats',
  }

  export type foundPosition = {
    /** Contains 0-based match position */
    _: 'foundPosition',
    /** The position of the match */
    position: number,
  }

  export type foundPositions = {
    /** Contains 0-based positions of matched objects */
    _: 'foundPositions',
    /** Total number of matched objects */
    total_count: number,
    /** The positions of the matched objects */
    positions: Array<number>,
  }

  export type tMeUrlTypeUser = {
    /** A URL linking to a user */
    _: 'tMeUrlTypeUser',
    /** Identifier of the user */
    user_id: number,
  }

  export type tMeUrlTypeSupergroup = {
    /** A URL linking to a public supergroup or channel */
    _: 'tMeUrlTypeSupergroup',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
  }

  export type tMeUrlTypeChatInvite = {
    /** A chat invite link */
    _: 'tMeUrlTypeChatInvite',
    /** Information about the chat invite link */
    info: chatInviteLinkInfo,
  }

  export type tMeUrlTypeStickerSet = {
    /** A URL linking to a sticker set */
    _: 'tMeUrlTypeStickerSet',
    /** Identifier of the sticker set */
    sticker_set_id: string,
  }

  export type tMeUrl = {
    /** Represents a URL linking to an internal Telegram entity */
    _: 'tMeUrl',
    /** URL */
    url: string,
    /** Type of the URL */
    type: TMeUrlType,
  }

  export type tMeUrls = {
    /** Contains a list of t.me URLs */
    _: 'tMeUrls',
    /** List of URLs */
    urls: Array<tMeUrl>,
  }

  export type suggestedActionEnableArchiveAndMuteNewChats = {
    /**
     * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting
     * in archiveChatListSettings
     */
    _: 'suggestedActionEnableArchiveAndMuteNewChats',
  }

  export type suggestedActionEnableArchiveAndMuteNewChats$Input = {
    /**
     * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting
     * in archiveChatListSettings
     */
    readonly _: 'suggestedActionEnableArchiveAndMuteNewChats',
  }

  export type suggestedActionCheckPassword = {
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    _: 'suggestedActionCheckPassword',
  }

  export type suggestedActionCheckPassword$Input = {
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    readonly _: 'suggestedActionCheckPassword',
  }

  export type suggestedActionCheckPhoneNumber = {
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    _: 'suggestedActionCheckPhoneNumber',
  }

  export type suggestedActionCheckPhoneNumber$Input = {
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    readonly _: 'suggestedActionCheckPhoneNumber',
  }

  export type suggestedActionViewChecksHint = {
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    _: 'suggestedActionViewChecksHint',
  }

  export type suggestedActionViewChecksHint$Input = {
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    readonly _: 'suggestedActionViewChecksHint',
  }

  export type suggestedActionConvertToBroadcastGroup = {
    /** Suggests the user to convert specified supergroup to a broadcast group */
    _: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    supergroup_id: number,
  }

  export type suggestedActionConvertToBroadcastGroup$Input = {
    /** Suggests the user to convert specified supergroup to a broadcast group */
    readonly _: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
  }

  export type suggestedActionSetPassword = {
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    _: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password; if 0, then the user is advised to set the password for security
     * reasons
     */
    authorization_delay: number,
  }

  export type suggestedActionSetPassword$Input = {
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    readonly _: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password; if 0, then the user is advised to set the password for security
     * reasons
     */
    readonly authorization_delay?: number,
  }

  export type suggestedActionUpgradePremium = {
    /**
     * Suggests the user to upgrade the Premium subscription from monthly payments
     * to annual payments
     */
    _: 'suggestedActionUpgradePremium',
  }

  export type suggestedActionUpgradePremium$Input = {
    /**
     * Suggests the user to upgrade the Premium subscription from monthly payments
     * to annual payments
     */
    readonly _: 'suggestedActionUpgradePremium',
  }

  export type suggestedActionRestorePremium = {
    /** Suggests the user to restore a recently expired Premium subscription */
    _: 'suggestedActionRestorePremium',
  }

  export type suggestedActionRestorePremium$Input = {
    /** Suggests the user to restore a recently expired Premium subscription */
    readonly _: 'suggestedActionRestorePremium',
  }

  export type suggestedActionSubscribeToAnnualPremium = {
    /** Suggests the user to subscribe to the Premium subscription with annual payments */
    _: 'suggestedActionSubscribeToAnnualPremium',
  }

  export type suggestedActionSubscribeToAnnualPremium$Input = {
    /** Suggests the user to subscribe to the Premium subscription with annual payments */
    readonly _: 'suggestedActionSubscribeToAnnualPremium',
  }

  export type suggestedActionGiftPremiumForChristmas = {
    /** Suggests the user to gift Telegram Premium to friends for Christmas */
    _: 'suggestedActionGiftPremiumForChristmas',
  }

  export type suggestedActionGiftPremiumForChristmas$Input = {
    /** Suggests the user to gift Telegram Premium to friends for Christmas */
    readonly _: 'suggestedActionGiftPremiumForChristmas',
  }

  export type suggestedActionSetBirthdate = {
    /** Suggests the user to set birthdate */
    _: 'suggestedActionSetBirthdate',
  }

  export type suggestedActionSetBirthdate$Input = {
    /** Suggests the user to set birthdate */
    readonly _: 'suggestedActionSetBirthdate',
  }

  export type suggestedActionSetProfilePhoto = {
    /** Suggests the user to set profile photo */
    _: 'suggestedActionSetProfilePhoto',
  }

  export type suggestedActionSetProfilePhoto$Input = {
    /** Suggests the user to set profile photo */
    readonly _: 'suggestedActionSetProfilePhoto',
  }

  export type suggestedActionExtendPremium = {
    /** Suggests the user to extend their expiring Telegram Premium subscription */
    _: 'suggestedActionExtendPremium',
    /** A URL for managing Telegram Premium subscription */
    manage_premium_subscription_url: string,
  }

  export type suggestedActionExtendPremium$Input = {
    /** Suggests the user to extend their expiring Telegram Premium subscription */
    readonly _: 'suggestedActionExtendPremium',
    /** A URL for managing Telegram Premium subscription */
    readonly manage_premium_subscription_url?: string,
  }

  export type suggestedActionExtendStarSubscriptions = {
    /**
     * Suggests the user to extend their expiring Telegram Star subscriptions. Call
     * getStarSubscriptions with only_expiring == true to get the number of expiring
     * subscriptions and the number of required to buy Telegram Stars
     */
    _: 'suggestedActionExtendStarSubscriptions',
  }

  export type suggestedActionExtendStarSubscriptions$Input = {
    /**
     * Suggests the user to extend their expiring Telegram Star subscriptions. Call
     * getStarSubscriptions with only_expiring == true to get the number of expiring
     * subscriptions and the number of required to buy Telegram Stars
     */
    readonly _: 'suggestedActionExtendStarSubscriptions',
  }

  export type suggestedActionCustom = {
    /** A custom suggestion to be shown at the top of the chat list */
    _: 'suggestedActionCustom',
    /** Unique name of the suggestion */
    name: string,
    /** Title of the suggestion */
    title: formattedText,
    /** Description of the suggestion */
    description: formattedText,
    /** The link to open when the suggestion is clicked */
    url: string,
  }

  export type suggestedActionCustom$Input = {
    /** A custom suggestion to be shown at the top of the chat list */
    readonly _: 'suggestedActionCustom',
    /** Unique name of the suggestion */
    readonly name?: string,
    /** Title of the suggestion */
    readonly title?: formattedText$Input,
    /** Description of the suggestion */
    readonly description?: formattedText$Input,
    /** The link to open when the suggestion is clicked */
    readonly url?: string,
  }

  export type count = {
    /** Contains a counter */
    _: 'count',
    /** Count */
    count: number,
  }

  export type text = {
    /** Contains some text */
    _: 'text',
    /** Text */
    text: string,
  }

  export type data = {
    /** Contains some binary data */
    _: 'data',
    /** Data */
    data: string /* base64 */,
  }

  export type seconds = {
    /** Contains a value representing a number of seconds */
    _: 'seconds',
    /** Number of seconds */
    seconds: number,
  }

  export type fileDownloadedPrefixSize = {
    /** Contains size of downloaded prefix of a file */
    _: 'fileDownloadedPrefixSize',
    /** The prefix size, in bytes */
    size: number,
  }

  export type starCount = {
    /** Contains a number of Telegram Stars */
    _: 'starCount',
    /** Number of Telegram Stars */
    star_count: number,
  }

  export type deepLinkInfo = {
    /** Contains information about a tg: deep link */
    _: 'deepLinkInfo',
    /** Text to be shown to the user */
    text: formattedText,
    /** True, if the user must be asked to update the application */
    need_update_application: boolean,
  }

  export type textParseModeMarkdown$Input = {
    /** The text uses Markdown-style formatting */
    readonly _: 'textParseModeMarkdown',
    /**
     * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 -
     * Telegram Bot API "MarkdownV2" parse mode
     */
    readonly version?: number,
  }

  export type textParseModeHTML$Input = {
    /**
     * The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse
     * mode
     */
    readonly _: 'textParseModeHTML',
  }

  export type proxyTypeSocks5 = {
    /** A SOCKS5 proxy server */
    _: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
  }

  export type proxyTypeSocks5$Input = {
    /** A SOCKS5 proxy server */
    readonly _: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    readonly username?: string,
    /** Password for logging in; may be empty */
    readonly password?: string,
  }

  export type proxyTypeHttp = {
    /** A HTTP transparent proxy server */
    _: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    http_only: boolean,
  }

  export type proxyTypeHttp$Input = {
    /** A HTTP transparent proxy server */
    readonly _: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    readonly username?: string,
    /** Password for logging in; may be empty */
    readonly password?: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    readonly http_only?: boolean,
  }

  export type proxyTypeMtproto = {
    /** An MTProto proxy server */
    _: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    secret: string,
  }

  export type proxyTypeMtproto$Input = {
    /** An MTProto proxy server */
    readonly _: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    readonly secret?: string,
  }

  export type proxy = {
    /** Contains information about a proxy server */
    _: 'proxy',
    /** Unique identifier of the proxy */
    id: number,
    /** Proxy server domain or IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Point in time (Unix timestamp) when the proxy was last used; 0 if never */
    last_used_date: number,
    /** True, if the proxy is enabled now */
    is_enabled: boolean,
    /** Type of the proxy */
    type: ProxyType,
  }

  export type proxies = {
    /** Represents a list of proxy servers */
    _: 'proxies',
    /** List of proxy servers */
    proxies: Array<proxy>,
  }

  export type inputSticker$Input = {
    /** A sticker to be added to a sticker set */
    readonly _: 'inputSticker',
    /**
     * File with the sticker; must fit in a 512x512 square. For WEBP stickers the file
     * must be in WEBP or PNG format, which will be converted to WEBP server-side.
     * See https://core.telegram.org/animated_stickers#technical-requirements for technical
     * requirements
     */
    readonly sticker?: InputFile$Input,
    /** Format of the sticker */
    readonly format?: StickerFormat$Input,
    /** String with 1-20 emoji corresponding to the sticker */
    readonly emojis?: string,
    /** Position where the mask is placed; pass null if not specified */
    readonly mask_position?: maskPosition$Input,
    /**
     * List of up to 20 keywords with total length up to 64 characters, which can be
     * used to find the sticker
     */
    readonly keywords?: ReadonlyArray<string>,
  }

  export type dateRange = {
    /** Represents a date range */
    _: 'dateRange',
    /** Point in time (Unix timestamp) at which the date range begins */
    start_date: number,
    /** Point in time (Unix timestamp) at which the date range ends */
    end_date: number,
  }

  export type statisticalValue = {
    /** A value with information about its recent changes */
    _: 'statisticalValue',
    /** The current value */
    value: number,
    /** The value for the previous day */
    previous_value: number,
    /** The growth rate of the value, as a percentage */
    growth_rate_percentage: number,
  }

  export type statisticalGraphData = {
    /** A graph data */
    _: 'statisticalGraphData',
    /** Graph data in JSON format */
    json_data: string,
    /** If non-empty, a token which can be used to receive a zoomed in graph */
    zoom_token: string,
  }

  export type statisticalGraphAsync = {
    /** The graph data to be asynchronously loaded through getStatisticalGraph */
    _: 'statisticalGraphAsync',
    /** The token to use for data loading */
    token: string,
  }

  export type statisticalGraphError = {
    /** An error message to be shown to the user instead of the graph */
    _: 'statisticalGraphError',
    /** The error message */
    error_message: string,
  }

  export type chatStatisticsObjectTypeMessage = {
    /** Describes a message sent in the chat */
    _: 'chatStatisticsObjectTypeMessage',
    /** Message identifier */
    message_id: number,
  }

  export type chatStatisticsObjectTypeStory = {
    /** Describes a story posted on behalf of the chat */
    _: 'chatStatisticsObjectTypeStory',
    /** Story identifier */
    story_id: number,
  }

  export type chatStatisticsInteractionInfo = {
    /**
     * Contains statistics about interactions with a message sent in the chat or a
     * story posted on behalf of the chat
     */
    _: 'chatStatisticsInteractionInfo',
    /** Type of the object */
    object_type: ChatStatisticsObjectType,
    /** Number of times the object was viewed */
    view_count: number,
    /** Number of times the object was forwarded */
    forward_count: number,
    /** Number of times reactions were added to the object */
    reaction_count: number,
  }

  export type chatStatisticsMessageSenderInfo = {
    /** Contains statistics about messages sent by a user */
    _: 'chatStatisticsMessageSenderInfo',
    /** User identifier */
    user_id: number,
    /** Number of sent messages */
    sent_message_count: number,
    /** Average number of characters in sent messages; 0 if unknown */
    average_character_count: number,
  }

  export type chatStatisticsAdministratorActionsInfo = {
    /** Contains statistics about administrator actions done by a user */
    _: 'chatStatisticsAdministratorActionsInfo',
    /** Administrator user identifier */
    user_id: number,
    /** Number of messages deleted by the administrator */
    deleted_message_count: number,
    /** Number of users banned by the administrator */
    banned_user_count: number,
    /** Number of users restricted by the administrator */
    restricted_user_count: number,
  }

  export type chatStatisticsInviterInfo = {
    /** Contains statistics about number of new members invited by a user */
    _: 'chatStatisticsInviterInfo',
    /** User identifier */
    user_id: number,
    /** Number of new members invited by the user */
    added_member_count: number,
  }

  export type chatStatisticsSupergroup = {
    /** A detailed statistics about a supergroup chat */
    _: 'chatStatisticsSupergroup',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Number of messages sent to the chat */
    message_count: statisticalValue,
    /** Number of users who viewed messages in the chat */
    viewer_count: statisticalValue,
    /** Number of users who sent messages to the chat */
    sender_count: statisticalValue,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing distribution of active users per language */
    language_graph: StatisticalGraph,
    /** A graph containing distribution of sent messages by content type */
    message_content_graph: StatisticalGraph,
    /** A graph containing number of different actions in the chat */
    action_graph: StatisticalGraph,
    /** A graph containing distribution of message views per hour */
    day_graph: StatisticalGraph,
    /** A graph containing distribution of message views per day of week */
    week_graph: StatisticalGraph,
    /** List of users sent most messages in the last week */
    top_senders: Array<chatStatisticsMessageSenderInfo>,
    /** List of most active administrators in the last week */
    top_administrators: Array<chatStatisticsAdministratorActionsInfo>,
    /** List of most active inviters of new members in the last week */
    top_inviters: Array<chatStatisticsInviterInfo>,
  }

  export type chatStatisticsChannel = {
    /** A detailed statistics about a channel chat */
    _: 'chatStatisticsChannel',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Mean number of times the recently sent messages were viewed */
    mean_message_view_count: statisticalValue,
    /** Mean number of times the recently sent messages were shared */
    mean_message_share_count: statisticalValue,
    /** Mean number of times reactions were added to the recently sent messages */
    mean_message_reaction_count: statisticalValue,
    /** Mean number of times the recently posted stories were viewed */
    mean_story_view_count: statisticalValue,
    /** Mean number of times the recently posted stories were shared */
    mean_story_share_count: statisticalValue,
    /** Mean number of times reactions were added to the recently posted stories */
    mean_story_reaction_count: statisticalValue,
    /** A percentage of users with enabled notifications for the chat; 0-100 */
    enabled_notifications_percentage: number,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of members muted and unmuted the chat */
    mute_graph: StatisticalGraph,
    /** A graph containing number of message views in a given hour in the last two weeks */
    view_count_by_hour_graph: StatisticalGraph,
    /** A graph containing number of message views per source */
    view_count_by_source_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing number of users viewed chat messages per language */
    language_graph: StatisticalGraph,
    /** A graph containing number of chat message views and shares */
    message_interaction_graph: StatisticalGraph,
    /** A graph containing number of reactions on messages */
    message_reaction_graph: StatisticalGraph,
    /** A graph containing number of story views and shares */
    story_interaction_graph: StatisticalGraph,
    /** A graph containing number of reactions on stories */
    story_reaction_graph: StatisticalGraph,
    /** A graph containing number of views of associated with the chat instant views */
    instant_view_interaction_graph: StatisticalGraph,
    /**
     * Detailed statistics about number of views and shares of recently sent messages
     * and posted stories
     */
    recent_interactions: Array<chatStatisticsInteractionInfo>,
  }

  export type chatRevenueAmount = {
    /** Contains information about revenue earned from sponsored messages in a chat */
    _: 'chatRevenueAmount',
    /** Cryptocurrency in which revenue is calculated */
    cryptocurrency: string,
    /** Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency */
    total_amount: string,
    /**
     * Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units
     * of the cryptocurrency
     */
    balance_amount: string,
    /**
     * Amount of the cryptocurrency available for withdrawal, in the smallest units
     * of the cryptocurrency
     */
    available_amount: string,
    /** True, if Telegram Stars can be withdrawn now or later */
    withdrawal_enabled: boolean,
  }

  export type chatRevenueStatistics = {
    /** A detailed statistics about revenue earned from sponsored messages in a chat */
    _: 'chatRevenueStatistics',
    /** A graph containing amount of revenue in a given hour */
    revenue_by_hour_graph: StatisticalGraph,
    /** A graph containing amount of revenue */
    revenue_graph: StatisticalGraph,
    /** Amount of earned revenue */
    revenue_amount: chatRevenueAmount,
    /**
     * Current conversion rate of the cryptocurrency in which revenue is calculated
     * to USD
     */
    usd_rate: number,
  }

  export type messageStatistics = {
    /** A detailed statistics about a message */
    _: 'messageStatistics',
    /** A graph containing number of message views and shares */
    message_interaction_graph: StatisticalGraph,
    /** A graph containing number of message reactions */
    message_reaction_graph: StatisticalGraph,
  }

  export type storyStatistics = {
    /** A detailed statistics about a story */
    _: 'storyStatistics',
    /** A graph containing number of story views and shares */
    story_interaction_graph: StatisticalGraph,
    /** A graph containing number of story reactions */
    story_reaction_graph: StatisticalGraph,
  }

  export type revenueWithdrawalStatePending = {
    /** Withdrawal is pending */
    _: 'revenueWithdrawalStatePending',
  }

  export type revenueWithdrawalStateSucceeded = {
    /** Withdrawal succeeded */
    _: 'revenueWithdrawalStateSucceeded',
    /** Point in time (Unix timestamp) when the withdrawal was completed */
    date: number,
    /** The URL where the withdrawal transaction can be viewed */
    url: string,
  }

  export type revenueWithdrawalStateFailed = {
    /** Withdrawal failed */
    _: 'revenueWithdrawalStateFailed',
  }

  export type chatRevenueTransactionTypeEarnings = {
    /** Describes earnings from sponsored messages in a chat in some time frame */
    _: 'chatRevenueTransactionTypeEarnings',
    /** Point in time (Unix timestamp) when the earnings started */
    start_date: number,
    /** Point in time (Unix timestamp) when the earnings ended */
    end_date: number,
  }

  export type chatRevenueTransactionTypeWithdrawal = {
    /** Describes a withdrawal of earnings */
    _: 'chatRevenueTransactionTypeWithdrawal',
    /** Point in time (Unix timestamp) when the earnings withdrawal started */
    withdrawal_date: number,
    /** Name of the payment provider */
    provider: string,
    /** State of the withdrawal */
    state: RevenueWithdrawalState,
  }

  export type chatRevenueTransactionTypeRefund = {
    /** Describes a refund for failed withdrawal of earnings */
    _: 'chatRevenueTransactionTypeRefund',
    /** Point in time (Unix timestamp) when the transaction was refunded */
    refund_date: number,
    /** Name of the payment provider */
    provider: string,
  }

  export type chatRevenueTransaction = {
    /** Contains a chat revenue transactions */
    _: 'chatRevenueTransaction',
    /** Cryptocurrency in which revenue is calculated */
    cryptocurrency: string,
    /** The withdrawn amount, in the smallest units of the cryptocurrency */
    cryptocurrency_amount: string,
    /** Type of the transaction */
    type: ChatRevenueTransactionType,
  }

  export type chatRevenueTransactions = {
    /** Contains a list of chat revenue transactions */
    _: 'chatRevenueTransactions',
    /** Total number of transactions */
    total_count: number,
    /** List of transactions */
    transactions: Array<chatRevenueTransaction>,
  }

  export type starRevenueStatus = {
    /** Contains information about Telegram Stars earned by a bot or a chat */
    _: 'starRevenueStatus',
    /** Total amount of Telegram Stars earned */
    total_amount: starAmount,
    /** The amount of Telegram Stars that aren't withdrawn yet */
    current_amount: starAmount,
    /** The amount of Telegram Stars that are available for withdrawal */
    available_amount: starAmount,
    /** True, if Telegram Stars can be withdrawn now or later */
    withdrawal_enabled: boolean,
    /**
     * Time left before the next withdrawal can be started, in seconds; 0 if withdrawal
     * can be started now
     */
    next_withdrawal_in: number,
  }

  export type starRevenueStatistics = {
    /** A detailed statistics about Telegram Stars earned by a bot or a chat */
    _: 'starRevenueStatistics',
    /** A graph containing amount of revenue in a given day */
    revenue_by_day_graph: StatisticalGraph,
    /** Telegram Star revenue status */
    status: starRevenueStatus,
    /** Current conversion rate of a Telegram Star to USD */
    usd_rate: number,
  }

  export type point = {
    /** A point on a Cartesian plane */
    _: 'point',
    /** The point's first coordinate */
    x: number,
    /** The point's second coordinate */
    y: number,
  }

  export type vectorPathCommandLine = {
    /** A straight line to a given point */
    _: 'vectorPathCommandLine',
    /** The end point of the straight line */
    end_point: point,
  }

  export type vectorPathCommandCubicBezierCurve = {
    /** A cubic Bézier curve to a given point */
    _: 'vectorPathCommandCubicBezierCurve',
    /** The start control point of the curve */
    start_control_point: point,
    /** The end control point of the curve */
    end_control_point: point,
    /** The end point of the curve */
    end_point: point,
  }

  export type botCommandScopeDefault$Input = {
    /** A scope covering all users */
    readonly _: 'botCommandScopeDefault',
  }

  export type botCommandScopeAllPrivateChats$Input = {
    /** A scope covering all private chats */
    readonly _: 'botCommandScopeAllPrivateChats',
  }

  export type botCommandScopeAllGroupChats$Input = {
    /** A scope covering all group and supergroup chats */
    readonly _: 'botCommandScopeAllGroupChats',
  }

  export type botCommandScopeAllChatAdministrators$Input = {
    /** A scope covering all group and supergroup chat administrators */
    readonly _: 'botCommandScopeAllChatAdministrators',
  }

  export type botCommandScopeChat$Input = {
    /** A scope covering all members of a chat */
    readonly _: 'botCommandScopeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type botCommandScopeChatAdministrators$Input = {
    /** A scope covering all administrators of a chat */
    readonly _: 'botCommandScopeChatAdministrators',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type botCommandScopeChatMember$Input = {
    /** A scope covering a member of a chat */
    readonly _: 'botCommandScopeChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** User identifier */
    readonly user_id?: number,
  }

  export type phoneNumberCodeTypeChange$Input = {
    /**
     * Checks ownership of a new phone number to change the user's authentication phone
     * number; for official Android and iOS applications only
     */
    readonly _: 'phoneNumberCodeTypeChange',
  }

  export type phoneNumberCodeTypeVerify$Input = {
    /** Verifies ownership of a phone number to be added to the user's Telegram Passport */
    readonly _: 'phoneNumberCodeTypeVerify',
  }

  export type phoneNumberCodeTypeConfirmOwnership$Input = {
    /**
     * Confirms ownership of a phone number to prevent account deletion while handling
     * links of the type internalLinkTypePhoneNumberConfirmation
     */
    readonly _: 'phoneNumberCodeTypeConfirmOwnership',
    /** Hash value from the link */
    readonly hash?: string,
  }

  export type updateAuthorizationState = {
    /** The user authorization state has changed */
    _: 'updateAuthorizationState',
    /** New authorization state */
    authorization_state: AuthorizationState,
  }

  export type updateNewMessage = {
    /** A new message was received; can also be an outgoing message */
    _: 'updateNewMessage',
    /** The new message */
    message: message,
  }

  export type updateMessageSendAcknowledged = {
    /**
     * A request to send a message has reached the Telegram server. This doesn't mean
     * that the message will be sent successfully. This update is sent only if the
     * option "use_quick_ack" is set to true. This update may be sent multiple times
     * for the same message
     */
    _: 'updateMessageSendAcknowledged',
    /** The chat identifier of the sent message */
    chat_id: number,
    /** A temporary message identifier */
    message_id: number,
  }

  export type updateMessageSendSucceeded = {
    /** A message has been successfully sent */
    _: 'updateMessageSendSucceeded',
    /**
     * The sent message. Almost any field of the new message can be different from
     * the corresponding field of the original message. For example, the field scheduling_state
     * may change, making the message scheduled, or non-scheduled
     */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
  }

  export type updateMessageSendFailed = {
    /**
     * A message failed to send. Be aware that some messages being sent can be irrecoverably
     * deleted, in which case updateDeleteMessages will be received instead of this
     * update
     */
    _: 'updateMessageSendFailed',
    /** The failed to send message */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
    /** The cause of the message sending failure */
    error: error,
  }

  export type updateMessageContent = {
    /** The message content has changed */
    _: 'updateMessageContent',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New message content */
    new_content: MessageContent,
  }

  export type updateMessageEdited = {
    /**
     * A message was edited. Changes in the message content will come in a separate
     * updateMessageContent
     */
    _: 'updateMessageEdited',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was edited */
    edit_date: number,
    /** New message reply markup; may be null */
    reply_markup?: ReplyMarkup,
  }

  export type updateMessageIsPinned = {
    /** The message pinned state was changed */
    _: 'updateMessageIsPinned',
    /** Chat identifier */
    chat_id: number,
    /** The message identifier */
    message_id: number,
    /** True, if the message is pinned */
    is_pinned: boolean,
  }

  export type updateMessageInteractionInfo = {
    /** The information about interactions with a message has changed */
    _: 'updateMessageInteractionInfo',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New information about interactions with the message; may be null */
    interaction_info?: messageInteractionInfo,
  }

  export type updateMessageContentOpened = {
    /**
     * The message content was opened. Updates voice note messages to "listened", video
     * note messages to "viewed" and starts the self-destruct timer
     */
    _: 'updateMessageContentOpened',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
  }

  export type updateMessageMentionRead = {
    /** A message with an unread mention was read */
    _: 'updateMessageMentionRead',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new number of unread mention messages left in the chat */
    unread_mention_count: number,
  }

  export type updateMessageUnreadReactions = {
    /** The list of unread reactions added to a message was changed */
    _: 'updateMessageUnreadReactions',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new list of unread reactions */
    unread_reactions: Array<unreadReaction>,
    /** The new number of messages with unread reactions left in the chat */
    unread_reaction_count: number,
  }

  export type updateMessageFactCheck = {
    /** A fact-check added to a message was changed */
    _: 'updateMessageFactCheck',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new fact-check */
    fact_check: factCheck,
  }

  export type updateMessageLiveLocationViewed = {
    /**
     * A message with a live location was viewed. When the update is received, the
     * application is expected to update the live location
     */
    _: 'updateMessageLiveLocationViewed',
    /** Identifier of the chat with the live location message */
    chat_id: number,
    /** Identifier of the message with live location */
    message_id: number,
  }

  export type updateVideoPublished = {
    /**
     * An automatically scheduled message with video has been successfully sent after
     * conversion
     */
    _: 'updateVideoPublished',
    /** Identifier of the chat with the message */
    chat_id: number,
    /** Identifier of the sent message */
    message_id: number,
  }

  export type updateNewChat = {
    /**
     * A new chat has been loaded/created. This update is guaranteed to come before
     * the chat identifier is returned to the application. The chat field changes will
     * be reported through separate updates
     */
    _: 'updateNewChat',
    /** The chat */
    chat: chat,
  }

  export type updateChatTitle = {
    /** The title of a chat was changed */
    _: 'updateChatTitle',
    /** Chat identifier */
    chat_id: number,
    /** The new chat title */
    title: string,
  }

  export type updateChatPhoto = {
    /** A chat photo was changed */
    _: 'updateChatPhoto',
    /** Chat identifier */
    chat_id: number,
    /** The new chat photo; may be null */
    photo?: chatPhotoInfo,
  }

  export type updateChatAccentColors = {
    /** Chat accent colors have changed */
    _: 'updateChatAccentColors',
    /** Chat identifier */
    chat_id: number,
    /** The new chat accent color identifier */
    accent_color_id: number,
    /**
     * The new identifier of a custom emoji to be shown on the reply header and link
     * preview background; 0 if none
     */
    background_custom_emoji_id: string,
    /** The new chat profile accent color identifier; -1 if none */
    profile_accent_color_id: number,
    /**
     * The new identifier of a custom emoji to be shown on the profile background;
     * 0 if none
     */
    profile_background_custom_emoji_id: string,
  }

  export type updateChatPermissions = {
    /** Chat permissions were changed */
    _: 'updateChatPermissions',
    /** Chat identifier */
    chat_id: number,
    /** The new chat permissions */
    permissions: chatPermissions,
  }

  export type updateChatLastMessage = {
    /** The last message of a chat was changed */
    _: 'updateChatLastMessage',
    /** Chat identifier */
    chat_id: number,
    /**
     * The new last message in the chat; may be null if the last message became unknown.
     * While the last message is unknown, new messages can be added to the chat without
     * corresponding updateNewMessage update
     */
    last_message?: message,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  }

  export type updateChatPosition = {
    /**
     * The position of a chat in a chat list has changed. An updateChatLastMessage
     * or updateChatDraftMessage update might be sent instead of the update
     */
    _: 'updateChatPosition',
    /** Chat identifier */
    chat_id: number,
    /**
     * New chat position. If new order is 0, then the chat needs to be removed from
     * the list
     */
    position: chatPosition,
  }

  export type updateChatAddedToList = {
    /** A chat was added to a chat list */
    _: 'updateChatAddedToList',
    /** Chat identifier */
    chat_id: number,
    /** The chat list to which the chat was added */
    chat_list: ChatList,
  }

  export type updateChatRemovedFromList = {
    /** A chat was removed from a chat list */
    _: 'updateChatRemovedFromList',
    /** Chat identifier */
    chat_id: number,
    /** The chat list from which the chat was removed */
    chat_list: ChatList,
  }

  export type updateChatReadInbox = {
    /** Incoming messages were read or the number of unread messages has been changed */
    _: 'updateChatReadInbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** The number of unread messages left in the chat */
    unread_count: number,
  }

  export type updateChatReadOutbox = {
    /** Outgoing messages were read */
    _: 'updateChatReadOutbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of last read outgoing message */
    last_read_outbox_message_id: number,
  }

  export type updateChatActionBar = {
    /** The chat action bar was changed */
    _: 'updateChatActionBar',
    /** Chat identifier */
    chat_id: number,
    /** The new value of the action bar; may be null */
    action_bar?: ChatActionBar,
  }

  export type updateChatBusinessBotManageBar = {
    /** The bar for managing business bot was changed in a chat */
    _: 'updateChatBusinessBotManageBar',
    /** Chat identifier */
    chat_id: number,
    /** The new value of the business bot manage bar; may be null */
    business_bot_manage_bar?: businessBotManageBar,
  }

  export type updateChatAvailableReactions = {
    /** The chat available reactions were changed */
    _: 'updateChatAvailableReactions',
    /** Chat identifier */
    chat_id: number,
    /** The new reactions, available in the chat */
    available_reactions: ChatAvailableReactions,
  }

  export type updateChatDraftMessage = {
    /**
     * A chat draft has changed. Be aware that the update may come in the currently
     * opened chat but with old content of the draft. If the user has changed the content
     * of the draft, this update mustn't be applied
     */
    _: 'updateChatDraftMessage',
    /** Chat identifier */
    chat_id: number,
    /** The new draft message; may be null if none */
    draft_message?: draftMessage,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  }

  export type updateChatEmojiStatus = {
    /** Chat emoji status has changed */
    _: 'updateChatEmojiStatus',
    /** Chat identifier */
    chat_id: number,
    /** The new chat emoji status; may be null */
    emoji_status?: emojiStatus,
  }

  export type updateChatMessageSender = {
    /** The message sender that is selected to send messages in a chat has changed */
    _: 'updateChatMessageSender',
    /** Chat identifier */
    chat_id: number,
    /**
     * New value of message_sender_id; may be null if the user can't change message
     * sender
     */
    message_sender_id?: MessageSender,
  }

  export type updateChatMessageAutoDeleteTime = {
    /** The message auto-delete or self-destruct timer setting for a chat was changed */
    _: 'updateChatMessageAutoDeleteTime',
    /** Chat identifier */
    chat_id: number,
    /** New value of message_auto_delete_time */
    message_auto_delete_time: number,
  }

  export type updateChatNotificationSettings = {
    /** Notification settings for a chat were changed */
    _: 'updateChatNotificationSettings',
    /** Chat identifier */
    chat_id: number,
    /** The new notification settings */
    notification_settings: chatNotificationSettings,
  }

  export type updateChatPendingJoinRequests = {
    /** The chat pending join requests were changed */
    _: 'updateChatPendingJoinRequests',
    /** Chat identifier */
    chat_id: number,
    /** The new data about pending join requests; may be null */
    pending_join_requests?: chatJoinRequestsInfo,
  }

  export type updateChatReplyMarkup = {
    /**
     * The default chat reply markup was changed. Can occur because new messages with
     * reply markup were received or because an old reply markup was hidden by the
     * user
     */
    _: 'updateChatReplyMarkup',
    /** Chat identifier */
    chat_id: number,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
  }

  export type updateChatBackground = {
    /** The chat background was changed */
    _: 'updateChatBackground',
    /** Chat identifier */
    chat_id: number,
    /** The new chat background; may be null if background was reset to default */
    background?: chatBackground,
  }

  export type updateChatTheme = {
    /** The chat theme was changed */
    _: 'updateChatTheme',
    /** Chat identifier */
    chat_id: number,
    /** The new name of the chat theme; may be empty if theme was reset to default */
    theme_name: string,
  }

  export type updateChatUnreadMentionCount = {
    /** The chat unread_mention_count has changed */
    _: 'updateChatUnreadMentionCount',
    /** Chat identifier */
    chat_id: number,
    /** The number of unread mention messages left in the chat */
    unread_mention_count: number,
  }

  export type updateChatUnreadReactionCount = {
    /** The chat unread_reaction_count has changed */
    _: 'updateChatUnreadReactionCount',
    /** Chat identifier */
    chat_id: number,
    /** The number of messages with unread reactions left in the chat */
    unread_reaction_count: number,
  }

  export type updateChatVideoChat = {
    /** A chat video chat state has changed */
    _: 'updateChatVideoChat',
    /** Chat identifier */
    chat_id: number,
    /** New value of video_chat */
    video_chat: videoChat,
  }

  export type updateChatDefaultDisableNotification = {
    /**
     * The value of the default disable_notification parameter, used when a message
     * is sent to the chat, was changed
     */
    _: 'updateChatDefaultDisableNotification',
    /** Chat identifier */
    chat_id: number,
    /** The new default_disable_notification value */
    default_disable_notification: boolean,
  }

  export type updateChatHasProtectedContent = {
    /** A chat content was allowed or restricted for saving */
    _: 'updateChatHasProtectedContent',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_protected_content */
    has_protected_content: boolean,
  }

  export type updateChatIsTranslatable = {
    /** Translation of chat messages was enabled or disabled */
    _: 'updateChatIsTranslatable',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_translatable */
    is_translatable: boolean,
  }

  export type updateChatIsMarkedAsUnread = {
    /** A chat was marked as unread or was read */
    _: 'updateChatIsMarkedAsUnread',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_marked_as_unread */
    is_marked_as_unread: boolean,
  }

  export type updateChatViewAsTopics = {
    /** A chat default appearance has changed */
    _: 'updateChatViewAsTopics',
    /** Chat identifier */
    chat_id: number,
    /** New value of view_as_topics */
    view_as_topics: boolean,
  }

  export type updateChatBlockList = {
    /** A chat was blocked or unblocked */
    _: 'updateChatBlockList',
    /** Chat identifier */
    chat_id: number,
    /** Block list to which the chat is added; may be null if none */
    block_list?: BlockList,
  }

  export type updateChatHasScheduledMessages = {
    /** A chat's has_scheduled_messages field has changed */
    _: 'updateChatHasScheduledMessages',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_scheduled_messages */
    has_scheduled_messages: boolean,
  }

  export type updateChatFolders = {
    /** The list of chat folders or a chat folder has changed */
    _: 'updateChatFolders',
    /** The new list of chat folders */
    chat_folders: Array<chatFolderInfo>,
    /** Position of the main chat list among chat folders, 0-based */
    main_chat_list_position: number,
    /** True, if folder tags are enabled */
    are_tags_enabled: boolean,
  }

  export type updateChatOnlineMemberCount = {
    /**
     * The number of online group members has changed. This update with non-zero number
     * of online group members is sent only for currently opened chats. There is no
     * guarantee that it is sent just after the number of online users has changed
     */
    _: 'updateChatOnlineMemberCount',
    /** Identifier of the chat */
    chat_id: number,
    /** New number of online members in the chat, or 0 if unknown */
    online_member_count: number,
  }

  export type updateSavedMessagesTopic = {
    /**
     * Basic information about a Saved Messages topic has changed. This update is guaranteed
     * to come before the topic identifier is returned to the application
     */
    _: 'updateSavedMessagesTopic',
    /** New data about the topic */
    topic: savedMessagesTopic,
  }

  export type updateSavedMessagesTopicCount = {
    /** Number of Saved Messages topics has changed */
    _: 'updateSavedMessagesTopicCount',
    /** Approximate total number of Saved Messages topics */
    topic_count: number,
  }

  export type updateDirectMessagesChatTopic = {
    /**
     * Basic information about a topic in a channel direct messages chat administered
     * by the current user has changed. This update is guaranteed to come before the
     * topic identifier is returned to the application
     */
    _: 'updateDirectMessagesChatTopic',
    /** New data about the topic */
    topic: directMessagesChatTopic,
  }

  export type updateTopicMessageCount = {
    /**
     * Number of messages in a topic has changed; for Saved Messages and channel direct
     * messages chat topics only
     */
    _: 'updateTopicMessageCount',
    /** Identifier of the chat in topic of which the number of messages has changed */
    chat_id: number,
    /** Identifier of the topic */
    topic_id: MessageTopic,
    /** Approximate number of messages in the topics */
    message_count: number,
  }

  export type updateQuickReplyShortcut = {
    /**
     * Basic information about a quick reply shortcut has changed. This update is guaranteed
     * to come before the quick shortcut name is returned to the application
     */
    _: 'updateQuickReplyShortcut',
    /** New data about the shortcut */
    shortcut: quickReplyShortcut,
  }

  export type updateQuickReplyShortcutDeleted = {
    /** A quick reply shortcut and all its messages were deleted */
    _: 'updateQuickReplyShortcutDeleted',
    /** The identifier of the deleted shortcut */
    shortcut_id: number,
  }

  export type updateQuickReplyShortcuts = {
    /** The list of quick reply shortcuts has changed */
    _: 'updateQuickReplyShortcuts',
    /** The new list of identifiers of quick reply shortcuts */
    shortcut_ids: Array<number>,
  }

  export type updateQuickReplyShortcutMessages = {
    /** The list of quick reply shortcut messages has changed */
    _: 'updateQuickReplyShortcutMessages',
    /** The identifier of the shortcut */
    shortcut_id: number,
    /**
     * The new list of quick reply messages for the shortcut in order from the first
     * to the last sent
     */
    messages: Array<quickReplyMessage>,
  }

  export type updateForumTopicInfo = {
    /** Basic information about a topic in a forum chat was changed */
    _: 'updateForumTopicInfo',
    /** New information about the topic */
    info: forumTopicInfo,
  }

  export type updateForumTopic = {
    /** Information about a topic in a forum chat was changed */
    _: 'updateForumTopic',
    /** Chat identifier */
    chat_id: number,
    /** Message thread identifier of the topic */
    message_thread_id: number,
    /** True, if the topic is pinned in the topic list */
    is_pinned: boolean,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the topic */
    unread_mention_count: number,
    /** Number of messages with unread reactions in the topic */
    unread_reaction_count: number,
    /** Notification settings for the topic */
    notification_settings: chatNotificationSettings,
  }

  export type updateScopeNotificationSettings = {
    /** Notification settings for some type of chats were updated */
    _: 'updateScopeNotificationSettings',
    /** Types of chats for which notification settings were updated */
    scope: NotificationSettingsScope,
    /** The new notification settings */
    notification_settings: scopeNotificationSettings,
  }

  export type updateReactionNotificationSettings = {
    /** Notification settings for reactions were updated */
    _: 'updateReactionNotificationSettings',
    /** The new notification settings */
    notification_settings: reactionNotificationSettings,
  }

  export type updateNotification = {
    /** A notification was changed */
    _: 'updateNotification',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** Changed notification */
    notification: notification,
  }

  export type updateNotificationGroup = {
    /** A list of active notifications in a notification group has changed */
    _: 'updateNotificationGroup',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** New type of the notification group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Chat identifier, which notification settings must be applied to the added notifications */
    notification_settings_chat_id: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    notification_sound_id: string,
    /**
     * Total number of unread notifications in the group, can be bigger than number
     * of active notifications
     */
    total_count: number,
    /** List of added group notifications, sorted by notification identifier */
    added_notifications: Array<notification>,
    /** Identifiers of removed group notifications, sorted by notification identifier */
    removed_notification_ids: Array<number>,
  }

  export type updateActiveNotifications = {
    /**
     * Contains active notifications that were shown on previous application launches.
     * This update is sent only if the message database is used. In that case it comes
     * once before any updateNotification and updateNotificationGroup update
     */
    _: 'updateActiveNotifications',
    /** Lists of active notification groups */
    groups: Array<notificationGroup>,
  }

  export type updateHavePendingNotifications = {
    /**
     * Describes whether there are some pending notification updates. Can be used to
     * prevent application from killing, while there are some pending notifications
     */
    _: 'updateHavePendingNotifications',
    /** True, if there are some delayed notification updates, which will be sent soon */
    have_delayed_notifications: boolean,
    /**
     * True, if there can be some yet unreceived notifications, which are being fetched
     * from the server
     */
    have_unreceived_notifications: boolean,
  }

  export type updateDeleteMessages = {
    /** Some messages were deleted */
    _: 'updateDeleteMessages',
    /** Chat identifier */
    chat_id: number,
    /** Identifiers of the deleted messages */
    message_ids: Array<number>,
    /**
     * True, if the messages are permanently deleted by a user (as opposed to just
     * becoming inaccessible)
     */
    is_permanent: boolean,
    /**
     * True, if the messages are deleted only from the cache and can possibly be retrieved
     * again in the future
     */
    from_cache: boolean,
  }

  export type updateChatAction = {
    /** A message sender activity in the chat has changed */
    _: 'updateChatAction',
    /** Chat identifier */
    chat_id: number,
    /** If not 0, the message thread identifier in which the action was performed */
    message_thread_id: number,
    /** Identifier of a message sender performing the action */
    sender_id: MessageSender,
    /** The action */
    action: ChatAction,
  }

  export type updateUserStatus = {
    /** The user went online or offline */
    _: 'updateUserStatus',
    /** User identifier */
    user_id: number,
    /** New status of the user */
    status: UserStatus,
  }

  export type updateUser = {
    /**
     * Some data of a user has changed. This update is guaranteed to come before the
     * user identifier is returned to the application
     */
    _: 'updateUser',
    /** New data about the user */
    user: user,
  }

  export type updateBasicGroup = {
    /**
     * Some data of a basic group has changed. This update is guaranteed to come before
     * the basic group identifier is returned to the application
     */
    _: 'updateBasicGroup',
    /** New data about the group */
    basic_group: basicGroup,
  }

  export type updateSupergroup = {
    /**
     * Some data of a supergroup or a channel has changed. This update is guaranteed
     * to come before the supergroup identifier is returned to the application
     */
    _: 'updateSupergroup',
    /** New data about the supergroup */
    supergroup: supergroup,
  }

  export type updateSecretChat = {
    /**
     * Some data of a secret chat has changed. This update is guaranteed to come before
     * the secret chat identifier is returned to the application
     */
    _: 'updateSecretChat',
    /** New data about the secret chat */
    secret_chat: secretChat,
  }

  export type updateUserFullInfo = {
    /** Some data in userFullInfo has been changed */
    _: 'updateUserFullInfo',
    /** User identifier */
    user_id: number,
    /** New full information about the user */
    user_full_info: userFullInfo,
  }

  export type updateBasicGroupFullInfo = {
    /** Some data in basicGroupFullInfo has been changed */
    _: 'updateBasicGroupFullInfo',
    /** Identifier of a basic group */
    basic_group_id: number,
    /** New full information about the group */
    basic_group_full_info: basicGroupFullInfo,
  }

  export type updateSupergroupFullInfo = {
    /** Some data in supergroupFullInfo has been changed */
    _: 'updateSupergroupFullInfo',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
    /** New full information about the supergroup */
    supergroup_full_info: supergroupFullInfo,
  }

  export type updateServiceNotification = {
    /**
     * A service notification from the server was received. Upon receiving this the
     * application must show a popup with the content of the notification
     */
    _: 'updateServiceNotification',
    /**
     * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel"
     * and "Log out" must be shown under notification; if user presses the second,
     * all local data must be destroyed using Destroy method
     */
    type: string,
    /** Notification content */
    content: MessageContent,
  }

  export type updateFile = {
    /** Information about a file was updated */
    _: 'updateFile',
    /** New data about the file */
    file: file,
  }

  export type updateFileGenerationStart = {
    /**
     * The file generation process needs to be started by the application. Use setFileGenerationProgress
     * and finishFileGeneration to generate the file
     */
    _: 'updateFileGenerationStart',
    /** Unique identifier for the generation process */
    generation_id: string,
    /** The original path specified by the application in inputFileGenerated */
    original_path: string,
    /**
     * The path to a file that must be created and where the new file must be generated
     * by the application. If the application has no access to the path, it can use
     * writeGeneratedFilePart to generate the file
     */
    destination_path: string,
    /**
     * If the conversion is "#url#" than original_path contains an HTTP/HTTPS URL of
     * a file that must be downloaded by the application. Otherwise, this is the conversion
     * specified by the application in inputFileGenerated
     */
    conversion: string,
  }

  export type updateFileGenerationStop = {
    /** File generation is no longer needed */
    _: 'updateFileGenerationStop',
    /** Unique identifier for the generation process */
    generation_id: string,
  }

  export type updateFileDownloads = {
    /** The state of the file download list has changed */
    _: 'updateFileDownloads',
    /** Total size of files in the file download list, in bytes */
    total_size: number,
    /** Total number of files in the file download list */
    total_count: number,
    /** Total downloaded size of files in the file download list, in bytes */
    downloaded_size: number,
  }

  export type updateFileAddedToDownloads = {
    /**
     * A file was added to the file download list. This update is sent only after file
     * download list is loaded for the first time
     */
    _: 'updateFileAddedToDownloads',
    /** The added file download */
    file_download: fileDownload,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  }

  export type updateFileDownload = {
    /**
     * A file download was changed. This update is sent only after file download list
     * is loaded for the first time
     */
    _: 'updateFileDownload',
    /** File identifier */
    file_id: number,
    /**
     * Point in time (Unix timestamp) when the file downloading was completed; 0 if
     * the file downloading isn't completed
     */
    complete_date: number,
    /** True, if downloading of the file is paused */
    is_paused: boolean,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  }

  export type updateFileRemovedFromDownloads = {
    /**
     * A file was removed from the file download list. This update is sent only after
     * file download list is loaded for the first time
     */
    _: 'updateFileRemovedFromDownloads',
    /** File identifier */
    file_id: number,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  }

  export type updateApplicationVerificationRequired = {
    /**
     * A request can't be completed unless application verification is performed; for
     * official mobile applications only. The method setApplicationVerificationToken
     * must be called once the verification is completed or failed
     */
    _: 'updateApplicationVerificationRequired',
    /** Unique identifier for the verification process */
    verification_id: number,
    /**
     * Unique base64url-encoded nonce for the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic)
     * for Android, or a unique string to compare with verify_nonce field from a push
     * notification for iOS
     */
    nonce: string,
    /** Cloud project number to pass to the Play Integrity API on Android */
    cloud_project_number: string,
  }

  export type updateApplicationRecaptchaVerificationRequired = {
    /**
     * A request can't be completed unless reCAPTCHA verification is performed; for
     * official mobile applications only. The method setApplicationVerificationToken
     * must be called once the verification is completed or failed
     */
    _: 'updateApplicationRecaptchaVerificationRequired',
    /** Unique identifier for the verification process */
    verification_id: number,
    /** The action for the check */
    action: string,
    /** Identifier of the reCAPTCHA key */
    recaptcha_key_id: string,
  }

  export type updateCall = {
    /** New call was created or information about a call was updated */
    _: 'updateCall',
    /** New data about a call */
    call: call,
  }

  export type updateGroupCall = {
    /** Information about a group call was updated */
    _: 'updateGroupCall',
    /** New data about the group call */
    group_call: groupCall,
  }

  export type updateGroupCallParticipant = {
    /**
     * Information about a group call participant was changed. The updates are sent
     * only after the group call is received through getGroupCall and only if the call
     * is joined or being joined
     */
    _: 'updateGroupCallParticipant',
    /** Identifier of the group call */
    group_call_id: number,
    /** New data about the participant */
    participant: groupCallParticipant,
  }

  export type updateGroupCallParticipants = {
    /**
     * The list of group call participants that can send and receive encrypted call
     * data has changed; for group calls not bound to a chat only
     */
    _: 'updateGroupCallParticipants',
    /** Identifier of the group call */
    group_call_id: number,
    /**
     * New list of group call participant user identifiers. The identifiers may be
     * invalid or the corresponding users may be unknown. The participants must be
     * shown in the list of group call participants even there is no information about
     * them
     */
    participant_user_ids: Array<string>,
  }

  export type updateGroupCallVerificationState = {
    /**
     * The verification state of an encrypted group call has changed; for group calls
     * not bound to a chat only
     */
    _: 'updateGroupCallVerificationState',
    /** Identifier of the group call */
    group_call_id: number,
    /**
     * The call state generation to which the emoji corresponds. If generation is different
     * for two users, then their emoji may be also different
     */
    generation: number,
    /**
     * Group call state fingerprint represented as 4 emoji; may be empty if the state
     * isn't verified yet
     */
    emojis: Array<string>,
  }

  export type updateNewCallSignalingData = {
    /** New call signaling data arrived */
    _: 'updateNewCallSignalingData',
    /** The call identifier */
    call_id: number,
    /** The data */
    data: string /* base64 */,
  }

  export type updateUserPrivacySettingRules = {
    /** Some privacy setting rules have been changed */
    _: 'updateUserPrivacySettingRules',
    /** The privacy setting */
    setting: UserPrivacySetting,
    /** New privacy rules */
    rules: userPrivacySettingRules,
  }

  export type updateUnreadMessageCount = {
    /**
     * Number of unread messages in a chat list has changed. This update is sent only
     * if the message database is used
     */
    _: 'updateUnreadMessageCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Total number of unread messages */
    unread_count: number,
    /** Total number of unread messages in unmuted chats */
    unread_unmuted_count: number,
  }

  export type updateUnreadChatCount = {
    /**
     * Number of unread chats, i.e. with unread messages or marked as unread, has changed.
     * This update is sent only if the message database is used
     */
    _: 'updateUnreadChatCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Approximate total number of chats in the chat list */
    total_count: number,
    /** Total number of unread chats */
    unread_count: number,
    /** Total number of unread unmuted chats */
    unread_unmuted_count: number,
    /** Total number of chats marked as unread */
    marked_as_unread_count: number,
    /** Total number of unmuted chats marked as unread */
    marked_as_unread_unmuted_count: number,
  }

  export type updateStory = {
    /** A story was changed */
    _: 'updateStory',
    /** The new information about the story */
    story: story,
  }

  export type updateStoryDeleted = {
    /** A story became inaccessible */
    _: 'updateStoryDeleted',
    /** Identifier of the chat that posted the story */
    story_poster_chat_id: number,
    /** Story identifier */
    story_id: number,
  }

  export type updateStoryPostSucceeded = {
    /** A story has been successfully posted */
    _: 'updateStoryPostSucceeded',
    /** The posted story */
    story: story,
    /** The previous temporary story identifier */
    old_story_id: number,
  }

  export type updateStoryPostFailed = {
    /**
     * A story failed to post. If the story posting is canceled, then updateStoryDeleted
     * will be received instead of this update
     */
    _: 'updateStoryPostFailed',
    /** The failed to post story */
    story: story,
    /** The cause of the story posting failure */
    error: error,
    /** Type of the error; may be null if unknown */
    error_type?: CanPostStoryResult,
  }

  export type updateChatActiveStories = {
    /** The list of active stories posted by a specific chat has changed */
    _: 'updateChatActiveStories',
    /** The new list of active stories */
    active_stories: chatActiveStories,
  }

  export type updateStoryListChatCount = {
    /** Number of chats in a story list has changed */
    _: 'updateStoryListChatCount',
    /** The story list */
    story_list: StoryList,
    /** Approximate total number of chats with active stories in the list */
    chat_count: number,
  }

  export type updateStoryStealthMode = {
    /** Story stealth mode settings have changed */
    _: 'updateStoryStealthMode',
    /** Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled */
    active_until_date: number,
    /**
     * Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if
     * there is no active cooldown
     */
    cooldown_until_date: number,
  }

  export type updateOption = {
    /** An option changed its value */
    _: 'updateOption',
    /** The option name */
    name: string,
    /** The new option value */
    value: OptionValue,
  }

  export type updateStickerSet = {
    /** A sticker set has changed */
    _: 'updateStickerSet',
    /** The sticker set */
    sticker_set: stickerSet,
  }

  export type updateInstalledStickerSets = {
    /** The list of installed sticker sets was updated */
    _: 'updateInstalledStickerSets',
    /** Type of the affected stickers */
    sticker_type: StickerType,
    /** The new list of installed ordinary sticker sets */
    sticker_set_ids: Array<string>,
  }

  export type updateTrendingStickerSets = {
    /** The list of trending sticker sets was updated or some of them were viewed */
    _: 'updateTrendingStickerSets',
    /** Type of the affected stickers */
    sticker_type: StickerType,
    /**
     * The prefix of the list of trending sticker sets with the newest trending sticker
     * sets
     */
    sticker_sets: trendingStickerSets,
  }

  export type updateRecentStickers = {
    /** The list of recently used stickers was updated */
    _: 'updateRecentStickers',
    /**
     * True, if the list of stickers attached to photo or video files was updated;
     * otherwise, the list of sent stickers is updated
     */
    is_attached: boolean,
    /** The new list of file identifiers of recently used stickers */
    sticker_ids: Array<number>,
  }

  export type updateFavoriteStickers = {
    /** The list of favorite stickers was updated */
    _: 'updateFavoriteStickers',
    /** The new list of file identifiers of favorite stickers */
    sticker_ids: Array<number>,
  }

  export type updateSavedAnimations = {
    /** The list of saved animations was updated */
    _: 'updateSavedAnimations',
    /** The new list of file identifiers of saved animations */
    animation_ids: Array<number>,
  }

  export type updateSavedNotificationSounds = {
    /**
     * The list of saved notification sounds was updated. This update may not be sent
     * until information about a notification sound was requested for the first time
     */
    _: 'updateSavedNotificationSounds',
    /** The new list of identifiers of saved notification sounds */
    notification_sound_ids: Array<string>,
  }

  export type updateDefaultBackground = {
    /** The default background has changed */
    _: 'updateDefaultBackground',
    /** True, if default background for dark theme has changed */
    for_dark_theme: boolean,
    /** The new default background; may be null */
    background?: background,
  }

  export type updateChatThemes = {
    /** The list of available chat themes has changed */
    _: 'updateChatThemes',
    /** The new list of chat themes */
    chat_themes: Array<chatTheme>,
  }

  export type updateAccentColors = {
    /** The list of supported accent colors has changed */
    _: 'updateAccentColors',
    /**
     * Information about supported colors; colors with identifiers 0 (red), 1 (orange),
     * 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported
     * and aren't included in the list. The exact colors for the accent colors with
     * identifiers 0-6 must be taken from the app theme
     */
    colors: Array<accentColor>,
    /**
     * The list of accent color identifiers, which can be set through setAccentColor
     * and setChatAccentColor. The colors must be shown in the specified order
     */
    available_accent_color_ids: Array<number>,
  }

  export type updateProfileAccentColors = {
    /** The list of supported accent colors for user profiles has changed */
    _: 'updateProfileAccentColors',
    /** Information about supported colors */
    colors: Array<profileAccentColor>,
    /**
     * The list of accent color identifiers, which can be set through setProfileAccentColor
     * and setChatProfileAccentColor. The colors must be shown in the specified order
     */
    available_accent_color_ids: Array<number>,
  }

  export type updateLanguagePackStrings = {
    /** Some language pack strings have been updated */
    _: 'updateLanguagePackStrings',
    /** Localization target to which the language pack belongs */
    localization_target: string,
    /** Identifier of the updated language pack */
    language_pack_id: string,
    /** List of changed language pack strings; empty if all strings have changed */
    strings: Array<languagePackString>,
  }

  export type updateConnectionState = {
    /**
     * The connection state has changed. This update must be used only to show a human-readable
     * description of the connection state
     */
    _: 'updateConnectionState',
    /** The new connection state */
    state: ConnectionState,
  }

  export type updateFreezeState = {
    /** The freeze state of the current user's account has changed */
    _: 'updateFreezeState',
    /** True, if the account is frozen */
    is_frozen: boolean,
    /**
     * Point in time (Unix timestamp) when the account was frozen; 0 if the account
     * isn't frozen
     */
    freezing_date: number,
    /**
     * Point in time (Unix timestamp) when the account will be deleted and can't be
     * unfrozen; 0 if the account isn't frozen
     */
    deletion_date: number,
    /** The link to open to send an appeal to unfreeze the account */
    appeal_link: string,
  }

  export type updateTermsOfService = {
    /**
     * New terms of service must be accepted by the user. If the terms of service are
     * declined, then the deleteAccount method must be called with the reason "Decline
     * ToS update"
     */
    _: 'updateTermsOfService',
    /** Identifier of the terms of service */
    terms_of_service_id: string,
    /** The new terms of service */
    terms_of_service: termsOfService,
  }

  export type updateUnconfirmedSession = {
    /** The first unconfirmed session has changed */
    _: 'updateUnconfirmedSession',
    /** The unconfirmed session; may be null if none */
    session?: unconfirmedSession,
  }

  export type updateAttachmentMenuBots = {
    /** The list of bots added to attachment or side menu has changed */
    _: 'updateAttachmentMenuBots',
    /** The new list of bots. The bots must not be shown on scheduled messages screen */
    bots: Array<attachmentMenuBot>,
  }

  export type updateWebAppMessageSent = {
    /** A message was sent by an opened Web App, so the Web App needs to be closed */
    _: 'updateWebAppMessageSent',
    /** Identifier of Web App launch */
    web_app_launch_id: string,
  }

  export type updateActiveEmojiReactions = {
    /** The list of active emoji reactions has changed */
    _: 'updateActiveEmojiReactions',
    /** The new list of active emoji reactions */
    emojis: Array<string>,
  }

  export type updateAvailableMessageEffects = {
    /** The list of available message effects has changed */
    _: 'updateAvailableMessageEffects',
    /** The new list of available message effects from emoji reactions */
    reaction_effect_ids: Array<string>,
    /** The new list of available message effects from Premium stickers */
    sticker_effect_ids: Array<string>,
  }

  export type updateDefaultReactionType = {
    /** The type of default reaction has changed */
    _: 'updateDefaultReactionType',
    /** The new type of the default reaction */
    reaction_type: ReactionType,
  }

  export type updateDefaultPaidReactionType = {
    /** The type of default paid reaction has changed */
    _: 'updateDefaultPaidReactionType',
    /** The new type of the default paid reaction */
    type: PaidReactionType,
  }

  export type updateSavedMessagesTags = {
    /** Tags used in Saved Messages or a Saved Messages topic have changed */
    _: 'updateSavedMessagesTags',
    /**
     * Identifier of Saved Messages topic which tags were changed; 0 if tags for the
     * whole chat has changed
     */
    saved_messages_topic_id: number,
    /** The new tags */
    tags: savedMessagesTags,
  }

  export type updateActiveLiveLocationMessages = {
    /**
     * The list of messages with active live location that need to be updated by the
     * application has changed. The list is persistent across application restarts
     * only if the message database is used
     */
    _: 'updateActiveLiveLocationMessages',
    /** The list of messages with active live locations */
    messages: Array<message>,
  }

  export type updateOwnedStarCount = {
    /** The number of Telegram Stars owned by the current user has changed */
    _: 'updateOwnedStarCount',
    /** The new amount of owned Telegram Stars */
    star_amount: starAmount,
  }

  export type updateChatRevenueAmount = {
    /**
     * The revenue earned from sponsored messages in a chat has changed. If chat revenue
     * screen is opened, then getChatRevenueTransactions may be called to fetch new
     * transactions
     */
    _: 'updateChatRevenueAmount',
    /** Identifier of the chat */
    chat_id: number,
    /** New amount of earned revenue */
    revenue_amount: chatRevenueAmount,
  }

  export type updateStarRevenueStatus = {
    /**
     * The Telegram Star revenue earned by a bot or a chat has changed. If Telegram
     * Star transaction screen of the chat is opened, then getStarTransactions may
     * be called to fetch new transactions
     */
    _: 'updateStarRevenueStatus',
    /** Identifier of the owner of the Telegram Stars */
    owner_id: MessageSender,
    /** New Telegram Star revenue status */
    status: starRevenueStatus,
  }

  export type updateSpeechRecognitionTrial = {
    /**
     * The parameters of speech recognition without Telegram Premium subscription has
     * changed
     */
    _: 'updateSpeechRecognitionTrial',
    /**
     * The maximum allowed duration of media for speech recognition without Telegram
     * Premium subscription, in seconds
     */
    max_media_duration: number,
    /** The total number of allowed speech recognitions per week; 0 if none */
    weekly_count: number,
    /** Number of left speech recognition attempts this week */
    left_count: number,
    /**
     * Point in time (Unix timestamp) when the weekly number of tries will reset; 0
     * if unknown
     */
    next_reset_date: number,
  }

  export type updateDiceEmojis = {
    /** The list of supported dice emojis has changed */
    _: 'updateDiceEmojis',
    /** The new list of supported dice emojis */
    emojis: Array<string>,
  }

  export type updateAnimatedEmojiMessageClicked = {
    /**
     * Some animated emoji message was clicked and a big animated sticker must be played
     * if the message is visible on the screen. chatActionWatchingAnimations with the
     * text of the message needs to be sent if the sticker is played
     */
    _: 'updateAnimatedEmojiMessageClicked',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The animated sticker to be played */
    sticker: sticker,
  }

  export type updateAnimationSearchParameters = {
    /**
     * The parameters of animation search through getOption("animation_search_bot_username")
     * bot has changed
     */
    _: 'updateAnimationSearchParameters',
    /** Name of the animation search provider */
    provider: string,
    /** The new list of emojis suggested for searching */
    emojis: Array<string>,
  }

  export type updateSuggestedActions = {
    /** The list of suggested to the user actions has changed */
    _: 'updateSuggestedActions',
    /** Added suggested actions */
    added_actions: Array<SuggestedAction>,
    /** Removed suggested actions */
    removed_actions: Array<SuggestedAction>,
  }

  export type updateSpeedLimitNotification = {
    /**
     * Download or upload file speed for the user was limited, but it can be restored
     * by subscription to Telegram Premium. The notification can be postponed until
     * a being downloaded or uploaded file is visible to the user. Use getOption("premium_download_speedup")
     * or getOption("premium_upload_speedup") to get expected speedup after subscription
     * to Telegram Premium
     */
    _: 'updateSpeedLimitNotification',
    /** True, if upload speed was limited; false, if download speed was limited */
    is_upload: boolean,
  }

  export type updateContactCloseBirthdays = {
    /**
     * The list of contacts that had birthdays recently or will have birthday soon
     * has changed
     */
    _: 'updateContactCloseBirthdays',
    /** List of contact users with close birthday */
    close_birthday_users: Array<closeBirthdayUser>,
  }

  export type updateAutosaveSettings = {
    /** Autosave settings for some type of chats were updated */
    _: 'updateAutosaveSettings',
    /** Type of chats for which autosave settings were updated */
    scope: AutosaveSettingsScope,
    /** The new autosave settings; may be null if the settings are reset to default */
    settings?: scopeAutosaveSettings,
  }

  export type updateBusinessConnection = {
    /** A business connection has changed; for bots only */
    _: 'updateBusinessConnection',
    /** New data about the connection */
    connection: businessConnection,
  }

  export type updateNewBusinessMessage = {
    /** A new message was added to a business account; for bots only */
    _: 'updateNewBusinessMessage',
    /** Unique identifier of the business connection */
    connection_id: string,
    /** The new message */
    message: businessMessage,
  }

  export type updateBusinessMessageEdited = {
    /** A message in a business account was edited; for bots only */
    _: 'updateBusinessMessageEdited',
    /** Unique identifier of the business connection */
    connection_id: string,
    /** The edited message */
    message: businessMessage,
  }

  export type updateBusinessMessagesDeleted = {
    /** Messages in a business account were deleted; for bots only */
    _: 'updateBusinessMessagesDeleted',
    /** Unique identifier of the business connection */
    connection_id: string,
    /** Identifier of a chat in the business account in which messages were deleted */
    chat_id: number,
    /** Unique message identifiers of the deleted messages */
    message_ids: Array<number>,
  }

  export type updateNewInlineQuery = {
    /** A new incoming inline query; for bots only */
    _: 'updateNewInlineQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** The type of the chat from which the query originated; may be null if unknown */
    chat_type?: ChatType,
    /** Text of the query */
    query: string,
    /** Offset of the first entry to return */
    offset: string,
  }

  export type updateNewChosenInlineResult = {
    /** The user has chosen a result of an inline query; for bots only */
    _: 'updateNewChosenInlineResult',
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** Text of the query */
    query: string,
    /** Identifier of the chosen result */
    result_id: string,
    /** Identifier of the sent inline message, if known */
    inline_message_id: string,
  }

  export type updateNewCallbackQuery = {
    /** A new incoming callback query; for bots only */
    _: 'updateNewCallbackQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the chat where the query was sent */
    chat_id: number,
    /** Identifier of the message from which the query originated */
    message_id: number,
    /** Identifier that uniquely corresponds to the chat to which the message was sent */
    chat_instance: string,
    /** Query payload */
    payload: CallbackQueryPayload,
  }

  export type updateNewInlineCallbackQuery = {
    /** A new incoming callback query from a message sent via a bot; for bots only */
    _: 'updateNewInlineCallbackQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the inline message from which the query originated */
    inline_message_id: string,
    /** An identifier uniquely corresponding to the chat a message was sent to */
    chat_instance: string,
    /** Query payload */
    payload: CallbackQueryPayload,
  }

  export type updateNewBusinessCallbackQuery = {
    /** A new incoming callback query from a business message; for bots only */
    _: 'updateNewBusinessCallbackQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Unique identifier of the business connection */
    connection_id: string,
    /** The message from the business account from which the query originated */
    message: businessMessage,
    /** An identifier uniquely corresponding to the chat a message was sent to */
    chat_instance: string,
    /** Query payload */
    payload: CallbackQueryPayload,
  }

  export type updateNewShippingQuery = {
    /**
     * A new incoming shipping query; for bots only. Only for invoices with flexible
     * price
     */
    _: 'updateNewShippingQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Invoice payload */
    invoice_payload: string,
    /** User shipping address */
    shipping_address: address,
  }

  export type updateNewPreCheckoutQuery = {
    /**
     * A new incoming pre-checkout query; for bots only. Contains full information
     * about a checkout
     */
    _: 'updateNewPreCheckoutQuery',
    /** Unique query identifier */
    id: string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Currency for the product price */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** Invoice payload */
    invoice_payload: string /* base64 */,
    /** Identifier of a shipping option chosen by the user; may be empty if not applicable */
    shipping_option_id: string,
    /** Information about the order; may be null */
    order_info?: orderInfo,
  }

  export type updateNewCustomEvent = {
    /** A new incoming event; for bots only */
    _: 'updateNewCustomEvent',
    /** A JSON-serialized event */
    event: string,
  }

  export type updateNewCustomQuery = {
    /** A new incoming query; for bots only */
    _: 'updateNewCustomQuery',
    /** The query identifier */
    id: string,
    /** JSON-serialized query data */
    data: string,
    /** Query timeout */
    timeout: number,
  }

  export type updatePoll = {
    /** A poll was updated; for bots only */
    _: 'updatePoll',
    /** New data about the poll */
    poll: poll,
  }

  export type updatePollAnswer = {
    /** A user changed the answer to a poll; for bots only */
    _: 'updatePollAnswer',
    /** Unique poll identifier */
    poll_id: string,
    /** Identifier of the message sender that changed the answer to the poll */
    voter_id: MessageSender,
    /** 0-based identifiers of answer options, chosen by the user */
    option_ids: Array<number>,
  }

  export type updateChatMember = {
    /** User rights changed in a chat; for bots only */
    _: 'updateChatMember',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the user, changing the rights */
    actor_user_id: number,
    /** Point in time (Unix timestamp) when the user rights were changed */
    date: number,
    /** If user has joined the chat using an invite link, the invite link; may be null */
    invite_link?: chatInviteLink,
    /**
     * True, if the user has joined the chat after sending a join request and being
     * approved by an administrator
     */
    via_join_request: boolean,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
    /** Previous chat member */
    old_chat_member: chatMember,
    /** New chat member */
    new_chat_member: chatMember,
  }

  export type updateNewChatJoinRequest = {
    /** A user sent a join request to a chat; for bots only */
    _: 'updateNewChatJoinRequest',
    /** Chat identifier */
    chat_id: number,
    /** Join request */
    request: chatJoinRequest,
    /** Chat identifier of the private chat with the user */
    user_chat_id: number,
    /** The invite link, which was used to send join request; may be null */
    invite_link?: chatInviteLink,
  }

  export type updateChatBoost = {
    /** A chat boost has changed; for bots only */
    _: 'updateChatBoost',
    /** Chat identifier */
    chat_id: number,
    /** New information about the boost */
    boost: chatBoost,
  }

  export type updateMessageReaction = {
    /** User changed its reactions on a message with public reactions; for bots only */
    _: 'updateMessageReaction',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Identifier of the user or chat that changed reactions */
    actor_id: MessageSender,
    /** Point in time (Unix timestamp) when the reactions were changed */
    date: number,
    /** Old list of chosen reactions */
    old_reaction_types: Array<ReactionType>,
    /** New list of chosen reactions */
    new_reaction_types: Array<ReactionType>,
  }

  export type updateMessageReactions = {
    /**
     * Reactions added to a message with anonymous reactions have changed; for bots
     * only
     */
    _: 'updateMessageReactions',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the reactions were changed */
    date: number,
    /** The list of reactions added to the message */
    reactions: Array<messageReaction>,
  }

  export type updatePaidMediaPurchased = {
    /** Paid media were purchased by a user; for bots only */
    _: 'updatePaidMediaPurchased',
    /** User identifier */
    user_id: number,
    /** Bot-specified payload for the paid media */
    payload: string,
  }

  export type updates = {
    /** Contains a list of updates */
    _: 'updates',
    /** List of updates */
    updates: Array<Update>,
  }

  export type logStreamDefault = {
    /** The log is written to stderr or an OS specific log */
    _: 'logStreamDefault',
  }

  export type logStreamDefault$Input = {
    /** The log is written to stderr or an OS specific log */
    readonly _: 'logStreamDefault',
  }

  export type logStreamFile = {
    /** The log is written to a file */
    _: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    path: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    max_file_size: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    redirect_stderr: boolean,
  }

  export type logStreamFile$Input = {
    /** The log is written to a file */
    readonly _: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    readonly path?: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    readonly max_file_size?: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    readonly redirect_stderr?: boolean,
  }

  export type logStreamEmpty = {
    /** The log is written nowhere */
    _: 'logStreamEmpty',
  }

  export type logStreamEmpty$Input = {
    /** The log is written nowhere */
    readonly _: 'logStreamEmpty',
  }

  export type logVerbosityLevel = {
    /** Contains a TDLib internal log verbosity level */
    _: 'logVerbosityLevel',
    /** Log verbosity level */
    verbosity_level: number,
  }

  export type logTags = {
    /** Contains a list of available TDLib internal log tags */
    _: 'logTags',
    /** List of log tags */
    tags: Array<string>,
  }

  export type userSupportInfo = {
    /** Contains custom information about the user */
    _: 'userSupportInfo',
    /** Information message */
    message: formattedText,
    /** Information author */
    author: string,
    /** Information change date */
    date: number,
  }

  export type testInt = {
    /** A simple object containing a number; for testing only */
    _: 'testInt',
    /** Number */
    value: number,
  }

  export type testInt$Input = {
    /** A simple object containing a number; for testing only */
    readonly _: 'testInt',
    /** Number */
    readonly value?: number,
  }

  export type testString = {
    /** A simple object containing a string; for testing only */
    _: 'testString',
    /** String */
    value: string,
  }

  export type testString$Input = {
    /** A simple object containing a string; for testing only */
    readonly _: 'testString',
    /** String */
    readonly value?: string,
  }

  export type testBytes = {
    /** A simple object containing a sequence of bytes; for testing only */
    _: 'testBytes',
    /** Bytes */
    value: string /* base64 */,
  }

  export type testVectorInt = {
    /** A simple object containing a vector of numbers; for testing only */
    _: 'testVectorInt',
    /** Vector of numbers */
    value: Array<number>,
  }

  export type testVectorIntObject = {
    /**
     * A simple object containing a vector of objects that hold a number; for testing
     * only
     */
    _: 'testVectorIntObject',
    /** Vector of objects */
    value: Array<testInt>,
  }

  export type testVectorString = {
    /** A simple object containing a vector of strings; for testing only */
    _: 'testVectorString',
    /** Vector of strings */
    value: Array<string>,
  }

  export type testVectorStringObject = {
    /**
     * A simple object containing a vector of objects that hold a string; for testing
     * only
     */
    _: 'testVectorStringObject',
    /** Vector of objects */
    value: Array<testString>,
  }

  export type getAuthorizationState = {
    /**
     * Returns the current authorization state. This is an offline method. For informational
     * purposes only. Use updateAuthorizationState instead to maintain the current
     * authorization state. Can be called before initialization
     */
    readonly _: 'getAuthorizationState',
  }

  export type setTdlibParameters = {
    /**
     * Sets the parameters for TDLib initialization. Works only when the current authorization
     * state is authorizationStateWaitTdlibParameters
     */
    readonly _: 'setTdlibParameters',
    /** Pass true to use Telegram test environment instead of the production environment */
    readonly use_test_dc?: boolean,
    /**
     * The path to the directory for the persistent database; if empty, the current
     * working directory will be used
     */
    readonly database_directory?: string,
    /**
     * The path to the directory for storing files; if empty, database_directory will
     * be used
     */
    readonly files_directory?: string,
    /**
     * Encryption key for the database. If the encryption key is invalid, then an error
     * with code 401 will be returned
     */
    readonly database_encryption_key?: string /* base64 */,
    /**
     * Pass true to keep information about downloaded and uploaded files between application
     * restarts
     */
    readonly use_file_database?: boolean,
    /**
     * Pass true to keep cache of users, basic groups, supergroups, channels and secret
     * chats between restarts. Implies use_file_database
     */
    readonly use_chat_info_database?: boolean,
    /** Pass true to keep cache of chats and messages between restarts. Implies use_chat_info_database */
    readonly use_message_database?: boolean,
    /** Pass true to enable support for secret chats */
    readonly use_secret_chats?: boolean,
    /** Application identifier for Telegram API access, which can be obtained at https://my.telegram.org */
    readonly api_id?: number,
    /**
     * Application identifier hash for Telegram API access, which can be obtained at
     * https://my.telegram.org
     */
    readonly api_hash?: string,
    /** IETF language tag of the user's operating system language; must be non-empty */
    readonly system_language_code?: string,
    /** Model of the device the application is being run on; must be non-empty */
    readonly device_model?: string,
    /**
     * Version of the operating system the application is being run on. If empty, the
     * version is automatically detected by TDLib
     */
    readonly system_version?: string,
    /** Application version; must be non-empty */
    readonly application_version?: string,
  }

  export type setAuthenticationPhoneNumber = {
    /**
     * Sets the phone number of the user and sends an authentication code to the user.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitPremiumPurchase, authorizationStateWaitEmailAddress,
     * authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration,
     * or authorizationStateWaitPassword
     */
    readonly _: 'setAuthenticationPhoneNumber',
    /** The phone number of the user, in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type checkAuthenticationPremiumPurchase = {
    /**
     * Checks whether an in-store purchase of Telegram Premium is possible before authorization.
     * Works only when the current authorization state is authorizationStateWaitPremiumPurchase
     */
    readonly _: 'checkAuthenticationPremiumPurchase',
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
  }

  export type setAuthenticationPremiumPurchaseTransaction = {
    /**
     * Informs server about an in-store purchase of Telegram Premium before authorization.
     * Works only when the current authorization state is authorizationStateWaitPremiumPurchase
     */
    readonly _: 'setAuthenticationPremiumPurchaseTransaction',
    /** Information about the transaction */
    readonly transaction?: StoreTransaction$Input,
    /**
     * Pass true if this is a restore of a Telegram Premium purchase; only for App
     * Store
     */
    readonly is_restore?: boolean,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
  }

  export type setAuthenticationEmailAddress = {
    /**
     * Sets the email address of the user and sends an authentication code to the email
     * address. Works only when the current authorization state is authorizationStateWaitEmailAddress
     */
    readonly _: 'setAuthenticationEmailAddress',
    /** The email address of the user */
    readonly email_address?: string,
  }

  export type resendAuthenticationCode = {
    /**
     * Resends an authentication code to the user. Works only when the current authorization
     * state is authorizationStateWaitCode, the next_code_type of the result is not
     * null and the server-specified timeout has passed, or when the current authorization
     * state is authorizationStateWaitEmailCode
     */
    readonly _: 'resendAuthenticationCode',
    /** Reason of code resending; pass null if unknown */
    readonly reason?: ResendCodeReason$Input,
  }

  export type checkAuthenticationEmailCode = {
    /**
     * Checks the authentication of an email address. Works only when the current authorization
     * state is authorizationStateWaitEmailCode
     */
    readonly _: 'checkAuthenticationEmailCode',
    /** Email address authentication to check */
    readonly code?: EmailAddressAuthentication$Input,
  }

  export type checkAuthenticationCode = {
    /**
     * Checks the authentication code. Works only when the current authorization state
     * is authorizationStateWaitCode
     */
    readonly _: 'checkAuthenticationCode',
    /** Authentication code to check */
    readonly code?: string,
  }

  export type requestQrCodeAuthentication = {
    /**
     * Requests QR code authentication by scanning a QR code on another logged in device.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitPremiumPurchase, authorizationStateWaitEmailAddress,
     * authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration,
     * or authorizationStateWaitPassword
     */
    readonly _: 'requestQrCodeAuthentication',
    /** List of user identifiers of other users currently using the application */
    readonly other_user_ids?: ReadonlyArray<number>,
  }

  export type registerUser = {
    /**
     * Finishes user registration. Works only when the current authorization state
     * is authorizationStateWaitRegistration
     */
    readonly _: 'registerUser',
    /** The first name of the user; 1-64 characters */
    readonly first_name?: string,
    /** The last name of the user; 0-64 characters */
    readonly last_name?: string,
    /**
     * Pass true to disable notification about the current user joining Telegram for
     * other users that added them to contact list
     */
    readonly disable_notification?: boolean,
  }

  export type resetAuthenticationEmailAddress = {
    /**
     * Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS"
     * if reset is still pending. Works only when the current authorization state is
     * authorizationStateWaitEmailCode and authorization_state.can_reset_email_address
     * == true
     */
    readonly _: 'resetAuthenticationEmailAddress',
  }

  export type checkAuthenticationPassword = {
    /**
     * Checks the 2-step verification password for correctness. Works only when the
     * current authorization state is authorizationStateWaitPassword
     */
    readonly _: 'checkAuthenticationPassword',
    /** The 2-step verification password to check */
    readonly password?: string,
  }

  export type requestAuthenticationPasswordRecovery = {
    /**
     * Requests to send a 2-step verification password recovery code to an email address
     * that was previously set up. Works only when the current authorization state
     * is authorizationStateWaitPassword
     */
    readonly _: 'requestAuthenticationPasswordRecovery',
  }

  export type checkAuthenticationPasswordRecoveryCode = {
    /**
     * Checks whether a 2-step verification password recovery code sent to an email
     * address is valid. Works only when the current authorization state is authorizationStateWaitPassword
     */
    readonly _: 'checkAuthenticationPasswordRecoveryCode',
    /** Recovery code to check */
    readonly recovery_code?: string,
  }

  export type recoverAuthenticationPassword = {
    /**
     * Recovers the 2-step verification password with a password recovery code sent
     * to an email address that was previously set up. Works only when the current
     * authorization state is authorizationStateWaitPassword
     */
    readonly _: 'recoverAuthenticationPassword',
    /** Recovery code to check */
    readonly recovery_code?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
  }

  export type sendAuthenticationFirebaseSms = {
    /**
     * Sends Firebase Authentication SMS to the phone number of the user. Works only
     * when the current authorization state is authorizationStateWaitCode and the server
     * returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
     */
    readonly _: 'sendAuthenticationFirebaseSms',
    /**
     * Play Integrity API or SafetyNet Attestation API token for the Android application,
     * or secret from push notification for the iOS application
     */
    readonly token?: string,
  }

  export type reportAuthenticationCodeMissing = {
    /**
     * Reports that authentication code wasn't delivered via SMS; for official mobile
     * applications only. Works only when the current authorization state is authorizationStateWaitCode
     */
    readonly _: 'reportAuthenticationCodeMissing',
    /** Current mobile network code */
    readonly mobile_network_code?: string,
  }

  export type checkAuthenticationBotToken = {
    /**
     * Checks the authentication token of a bot; to log in as a bot. Works only when
     * the current authorization state is authorizationStateWaitPhoneNumber. Can be
     * used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to
     * log in
     */
    readonly _: 'checkAuthenticationBotToken',
    /** The bot token */
    readonly token?: string,
  }

  export type logOut = {
    /**
     * Closes the TDLib instance after a proper logout. Requires an available network
     * connection. All local data will be destroyed. After the logout completes, updateAuthorizationState
     * with authorizationStateClosed will be sent
     */
    readonly _: 'logOut',
  }

  export type close = {
    /**
     * Closes the TDLib instance. All databases will be flushed to disk and properly
     * closed. After the close completes, updateAuthorizationState with authorizationStateClosed
     * will be sent. Can be called before initialization
     */
    readonly _: 'close',
  }

  export type destroy = {
    /**
     * Closes the TDLib instance, destroying all local data without a proper logout.
     * The current user session will remain in the list of all active sessions. All
     * local data will be destroyed. After the destruction completes updateAuthorizationState
     * with authorizationStateClosed will be sent. Can be called before authorization
     */
    readonly _: 'destroy',
  }

  export type confirmQrCodeAuthentication = {
    /**
     * Confirms QR code authentication on another device. Returns created session on
     * success
     */
    readonly _: 'confirmQrCodeAuthentication',
    /** A link from a QR code. The link must be scanned by the in-app camera */
    readonly link?: string,
  }

  export type getCurrentState = {
    /**
     * Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat
     * and others. This is especially useful if TDLib is run in a separate process.
     * Can be called before initialization
     */
    readonly _: 'getCurrentState',
  }

  export type setDatabaseEncryptionKey = {
    /**
     * Changes the database encryption key. Usually the encryption key is never changed
     * and is stored in some OS keychain
     */
    readonly _: 'setDatabaseEncryptionKey',
    /** New encryption key */
    readonly new_encryption_key?: string /* base64 */,
  }

  export type getPasswordState = {
    /** Returns the current state of 2-step verification */
    readonly _: 'getPasswordState',
  }

  export type setPassword = {
    /**
     * Changes the 2-step verification password for the current user. If a new recovery
     * email address is specified, then the change will not be applied until the new
     * recovery email address is confirmed
     */
    readonly _: 'setPassword',
    /** Previous 2-step verification password of the user */
    readonly old_password?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
    /** Pass true to change also the recovery email address */
    readonly set_recovery_email_address?: boolean,
    /** New recovery email address; may be empty */
    readonly new_recovery_email_address?: string,
  }

  export type setLoginEmailAddress = {
    /**
     * Changes the login email address of the user. The email address can be changed
     * only if the current user already has login email and passwordState.login_email_address_pattern
     * is non-empty. The change will not be applied until the new login email address
     * is confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID instead
     * of an email address, call checkLoginEmailAddressCode directly
     */
    readonly _: 'setLoginEmailAddress',
    /** New login email address */
    readonly new_login_email_address?: string,
  }

  export type resendLoginEmailAddressCode = {
    /** Resends the login email address verification code */
    readonly _: 'resendLoginEmailAddressCode',
  }

  export type checkLoginEmailAddressCode = {
    /** Checks the login email address authentication */
    readonly _: 'checkLoginEmailAddressCode',
    /** Email address authentication to check */
    readonly code?: EmailAddressAuthentication$Input,
  }

  export type getRecoveryEmailAddress = {
    /**
     * Returns a 2-step verification recovery email address that was previously set
     * up. This method can be used to verify a password provided by the user
     */
    readonly _: 'getRecoveryEmailAddress',
    /** The 2-step verification password for the current user */
    readonly password?: string,
  }

  export type setRecoveryEmailAddress = {
    /**
     * Changes the 2-step verification recovery email address of the user. If a new
     * recovery email address is specified, then the change will not be applied until
     * the new recovery email address is confirmed. If new_recovery_email_address is
     * the same as the email address that is currently set up, this call succeeds immediately
     * and aborts all other requests waiting for an email confirmation
     */
    readonly _: 'setRecoveryEmailAddress',
    /** The 2-step verification password of the current user */
    readonly password?: string,
    /** New recovery email address */
    readonly new_recovery_email_address?: string,
  }

  export type checkRecoveryEmailAddressCode = {
    /** Checks the 2-step verification recovery email address verification code */
    readonly _: 'checkRecoveryEmailAddressCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type resendRecoveryEmailAddressCode = {
    /** Resends the 2-step verification recovery email address verification code */
    readonly _: 'resendRecoveryEmailAddressCode',
  }

  export type cancelRecoveryEmailAddressVerification = {
    /** Cancels verification of the 2-step verification recovery email address */
    readonly _: 'cancelRecoveryEmailAddressVerification',
  }

  export type requestPasswordRecovery = {
    /**
     * Requests to send a 2-step verification password recovery code to an email address
     * that was previously set up
     */
    readonly _: 'requestPasswordRecovery',
  }

  export type checkPasswordRecoveryCode = {
    /**
     * Checks whether a 2-step verification password recovery code sent to an email
     * address is valid
     */
    readonly _: 'checkPasswordRecoveryCode',
    /** Recovery code to check */
    readonly recovery_code?: string,
  }

  export type recoverPassword = {
    /**
     * Recovers the 2-step verification password using a recovery code sent to an email
     * address that was previously set up
     */
    readonly _: 'recoverPassword',
    /** Recovery code to check */
    readonly recovery_code?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
  }

  export type resetPassword = {
    /**
     * Removes 2-step verification password without previous password and access to
     * recovery email address. The password can't be reset immediately and the request
     * needs to be repeated after the specified time
     */
    readonly _: 'resetPassword',
  }

  export type cancelPasswordReset = {
    /**
     * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date
     * > 0
     */
    readonly _: 'cancelPasswordReset',
  }

  export type createTemporaryPassword = {
    /** Creates a new temporary password for processing payments */
    readonly _: 'createTemporaryPassword',
    /** The 2-step verification password of the current user */
    readonly password?: string,
    /**
     * Time during which the temporary password will be valid, in seconds; must be
     * between 60 and 86400
     */
    readonly valid_for?: number,
  }

  export type getTemporaryPasswordState = {
    /** Returns information about the current temporary password */
    readonly _: 'getTemporaryPasswordState',
  }

  export type getMe = {
    /** Returns the current user */
    readonly _: 'getMe',
  }

  export type getUser = {
    /**
     * Returns information about a user by their identifier. This is an offline method
     * if the current user is not a bot
     */
    readonly _: 'getUser',
    /** User identifier */
    readonly user_id?: number,
  }

  export type getUserFullInfo = {
    /** Returns full information about a user by their identifier */
    readonly _: 'getUserFullInfo',
    /** User identifier */
    readonly user_id?: number,
  }

  export type getBasicGroup = {
    /**
     * Returns information about a basic group by its identifier. This is an offline
     * method if the current user is not a bot
     */
    readonly _: 'getBasicGroup',
    /** Basic group identifier */
    readonly basic_group_id?: number,
  }

  export type getBasicGroupFullInfo = {
    /** Returns full information about a basic group by its identifier */
    readonly _: 'getBasicGroupFullInfo',
    /** Basic group identifier */
    readonly basic_group_id?: number,
  }

  export type getSupergroup = {
    /**
     * Returns information about a supergroup or a channel by its identifier. This
     * is an offline method if the current user is not a bot
     */
    readonly _: 'getSupergroup',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
  }

  export type getSupergroupFullInfo = {
    /**
     * Returns full information about a supergroup or a channel by its identifier,
     * cached for up to 1 minute
     */
    readonly _: 'getSupergroupFullInfo',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
  }

  export type getSecretChat = {
    /**
     * Returns information about a secret chat by its identifier. This is an offline
     * method
     */
    readonly _: 'getSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type getChat = {
    /**
     * Returns information about a chat by its identifier. This is an offline method
     * if the current user is not a bot
     */
    readonly _: 'getChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getMessage = {
    /**
     * Returns information about a message. Returns a 404 error if the message doesn't
     * exist
     */
    readonly _: 'getMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message to get */
    readonly message_id?: number,
  }

  export type getMessageLocally = {
    /**
     * Returns information about a message, if it is available without sending network
     * request. Returns a 404 error if message isn't available locally. This is an
     * offline method
     */
    readonly _: 'getMessageLocally',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message to get */
    readonly message_id?: number,
  }

  export type getRepliedMessage = {
    /**
     * Returns information about a non-bundled message that is replied by a given message.
     * Also, returns the pinned message, the game message, the invoice message, the
     * message with a previously set same background, the giveaway message, the checklist
     * message, and the topic creation message for messages of the types messagePinMessage,
     * messageGameScore, messagePaymentSuccessful, messageChatSetBackground, messageGiveawayCompleted,
     * messageChecklistTasksDone and messageChecklistTasksAdded, and topic messages
     * without non-bundled replied message respectively. Returns a 404 error if the
     * message doesn't exist
     */
    readonly _: 'getRepliedMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the reply message */
    readonly message_id?: number,
  }

  export type getChatPinnedMessage = {
    /**
     * Returns information about a newest pinned message in the chat. Returns a 404
     * error if the message doesn't exist
     */
    readonly _: 'getChatPinnedMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
  }

  export type getCallbackQueryMessage = {
    /**
     * Returns information about a message with the callback button that originated
     * a callback query; for bots only
     */
    readonly _: 'getCallbackQueryMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Identifier of the callback query */
    readonly callback_query_id?: number | string,
  }

  export type getMessages = {
    /**
     * Returns information about messages. If a message is not found, returns null
     * on the corresponding position of the result
     */
    readonly _: 'getMessages',
    /** Identifier of the chat the messages belong to */
    readonly chat_id?: number,
    /** Identifiers of the messages to get */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type getMessageProperties = {
    /** Returns properties of a message. This is an offline method */
    readonly _: 'getMessageProperties',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getMessageThread = {
    /**
     * Returns information about a message thread. Can be used only if messageProperties.can_get_message_thread
     * == true
     */
    readonly _: 'getMessageThread',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getMessageReadDate = {
    /**
     * Returns read date of a recent outgoing message in a private chat. The method
     * can be called if messageProperties.can_get_read_date == true
     */
    readonly _: 'getMessageReadDate',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getMessageViewers = {
    /**
     * Returns viewers of a recent outgoing message in a basic group or a supergroup
     * chat. For video notes and voice notes only users, opened content of the message,
     * are returned. The method can be called if messageProperties.can_get_viewers
     * == true
     */
    readonly _: 'getMessageViewers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getMessageAuthor = {
    /**
     * Returns information about actual author of a message sent on behalf of a channel.
     * The method can be called if messageProperties.can_get_author == true
     */
    readonly _: 'getMessageAuthor',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getFile = {
    /** Returns information about a file. This is an offline method */
    readonly _: 'getFile',
    /** Identifier of the file to get */
    readonly file_id?: number,
  }

  export type getRemoteFile = {
    /**
     * Returns information about a file by its remote identifier. This is an offline
     * method. Can be used to register a URL as a file for further uploading, or sending
     * as a message. Even the request succeeds, the file can be used only if it is
     * still accessible to the user. For example, if the file is from a message, then
     * the message must be not deleted and accessible to the user. If the file database
     * is disabled, then the corresponding object with the file must be preloaded by
     * the application
     */
    readonly _: 'getRemoteFile',
    /** Remote identifier of the file to get */
    readonly remote_file_id?: string,
    /** File type; pass null if unknown */
    readonly file_type?: FileType$Input,
  }

  export type loadChats = {
    /**
     * Loads more chats from a chat list. The loaded chats and their positions in the
     * chat list will be sent through updates. Chats are sorted by the pair (chat.position.order,
     * chat.id) in descending order. Returns a 404 error if all chats have been loaded
     */
    readonly _: 'loadChats',
    /**
     * The chat list in which to load chats; pass null to load chats from the main
     * chat list
     */
    readonly chat_list?: ChatList$Input,
    /**
     * The maximum number of chats to be loaded. For optimal performance, the number
     * of loaded chats is chosen by TDLib and can be smaller than the specified limit,
     * even if the end of the list is not reached
     */
    readonly limit?: number,
  }

  export type getChats = {
    /**
     * Returns an ordered list of chats from the beginning of a chat list. For informational
     * purposes only. Use loadChats and updates processing instead to maintain chat
     * lists in a consistent state
     */
    readonly _: 'getChats',
    /**
     * The chat list in which to return chats; pass null to get chats from the main
     * chat list
     */
    readonly chat_list?: ChatList$Input,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchPublicChat = {
    /**
     * Searches a public chat by its username. Currently, only private chats, supergroups
     * and channels can be public. Returns the chat if found; otherwise, an error is
     * returned
     */
    readonly _: 'searchPublicChat',
    /** Username to be resolved */
    readonly username?: string,
  }

  export type searchPublicChats = {
    /**
     * Searches public chats by looking for specified query in their username and title.
     * Currently, only private chats, supergroups and channels can be public. Returns
     * a meaningful number of results. Excludes private chats with contacts and chats
     * from the chat list from the results
     */
    readonly _: 'searchPublicChats',
    /** Query to search for */
    readonly query?: string,
  }

  export type searchChats = {
    /**
     * Searches for the specified query in the title and username of already known
     * chats. This is an offline method. Returns chats in the order seen in the main
     * chat list
     */
    readonly _: 'searchChats',
    /**
     * Query to search for. If the query is empty, returns up to 50 recently found
     * chats
     */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchChatsOnServer = {
    /**
     * Searches for the specified query in the title and username of already known
     * chats via request to the server. Returns chats in the order seen in the main
     * chat list
     */
    readonly _: 'searchChatsOnServer',
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type getRecommendedChats = {
    /** Returns a list of channel chats recommended to the current user */
    readonly _: 'getRecommendedChats',
  }

  export type getChatSimilarChats = {
    /** Returns a list of chats similar to the given chat */
    readonly _: 'getChatSimilarChats',
    /** Identifier of the target chat; must be an identifier of a channel chat */
    readonly chat_id?: number,
  }

  export type getChatSimilarChatCount = {
    /** Returns approximate number of chats similar to the given chat */
    readonly _: 'getChatSimilarChatCount',
    /** Identifier of the target chat; must be an identifier of a channel chat */
    readonly chat_id?: number,
    /**
     * Pass true to get the number of chats without sending network requests, or -1
     * if the number of chats is unknown locally
     */
    readonly return_local?: boolean,
  }

  export type openChatSimilarChat = {
    /**
     * Informs TDLib that a chat was opened from the list of similar chats. The method
     * is independent of openChat and closeChat methods
     */
    readonly _: 'openChatSimilarChat',
    /** Identifier of the original chat, which similar chats were requested */
    readonly chat_id?: number,
    /** Identifier of the opened chat */
    readonly opened_chat_id?: number,
  }

  export type getBotSimilarBots = {
    /** Returns a list of bots similar to the given bot */
    readonly _: 'getBotSimilarBots',
    /** User identifier of the target bot */
    readonly bot_user_id?: number,
  }

  export type getBotSimilarBotCount = {
    /** Returns approximate number of bots similar to the given bot */
    readonly _: 'getBotSimilarBotCount',
    /** User identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * Pass true to get the number of bots without sending network requests, or -1
     * if the number of bots is unknown locally
     */
    readonly return_local?: boolean,
  }

  export type openBotSimilarBot = {
    /** Informs TDLib that a bot was opened from the list of similar bots */
    readonly _: 'openBotSimilarBot',
    /** Identifier of the original bot, which similar bots were requested */
    readonly bot_user_id?: number,
    /** Identifier of the opened bot */
    readonly opened_bot_user_id?: number,
  }

  export type getTopChats = {
    /** Returns a list of frequently used chats */
    readonly _: 'getTopChats',
    /** Category of chats to be returned */
    readonly category?: TopChatCategory$Input,
    /** The maximum number of chats to be returned; up to 30 */
    readonly limit?: number,
  }

  export type removeTopChat = {
    /**
     * Removes a chat from the list of frequently used chats. Supported only if the
     * chat info database is enabled
     */
    readonly _: 'removeTopChat',
    /** Category of frequently used chats */
    readonly category?: TopChatCategory$Input,
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type searchRecentlyFoundChats = {
    /**
     * Searches for the specified query in the title and username of up to 50 recently
     * found chats. This is an offline method
     */
    readonly _: 'searchRecentlyFoundChats',
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type addRecentlyFoundChat = {
    /**
     * Adds a chat to the list of recently found chats. The chat is added to the beginning
     * of the list. If the chat is already in the list, it will be removed from the
     * list first
     */
    readonly _: 'addRecentlyFoundChat',
    /** Identifier of the chat to add */
    readonly chat_id?: number,
  }

  export type removeRecentlyFoundChat = {
    /** Removes a chat from the list of recently found chats */
    readonly _: 'removeRecentlyFoundChat',
    /** Identifier of the chat to be removed */
    readonly chat_id?: number,
  }

  export type clearRecentlyFoundChats = {
    /** Clears the list of recently found chats */
    readonly _: 'clearRecentlyFoundChats',
  }

  export type getRecentlyOpenedChats = {
    /**
     * Returns recently opened chats. This is an offline method. Returns chats in the
     * order of last opening
     */
    readonly _: 'getRecentlyOpenedChats',
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type checkChatUsername = {
    /** Checks whether a username can be set for a chat */
    readonly _: 'checkChatUsername',
    /**
     * Chat identifier; must be identifier of a supergroup chat, or a channel chat,
     * or a private chat with self, or 0 if the chat is being created
     */
    readonly chat_id?: number,
    /** Username to be checked */
    readonly username?: string,
  }

  export type getCreatedPublicChats = {
    /** Returns a list of public chats of the specified type, owned by the user */
    readonly _: 'getCreatedPublicChats',
    /** Type of the public chats to return */
    readonly type?: PublicChatType$Input,
  }

  export type checkCreatedPublicChatsLimit = {
    /**
     * Checks whether the maximum number of owned public chats has been reached. Returns
     * corresponding error if the limit was reached. The limit can be increased with
     * Telegram Premium
     */
    readonly _: 'checkCreatedPublicChatsLimit',
    /** Type of the public chats, for which to check the limit */
    readonly type?: PublicChatType$Input,
  }

  export type getSuitableDiscussionChats = {
    /**
     * Returns a list of basic group and supergroup chats, which can be used as a discussion
     * group for a channel. Returned basic group chats must be first upgraded to supergroups
     * before they can be set as a discussion group. To set a returned supergroup as
     * a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable
     * first
     */
    readonly _: 'getSuitableDiscussionChats',
  }

  export type getInactiveSupergroupChats = {
    /**
     * Returns a list of recently inactive supergroups and channels. Can be used when
     * user reaches limit on the number of joined supergroups and channels and receives
     * the error "CHANNELS_TOO_MUCH". Also, the limit can be increased with Telegram
     * Premium
     */
    readonly _: 'getInactiveSupergroupChats',
  }

  export type getSuitablePersonalChats = {
    /** Returns a list of channel chats, which can be used as a personal chat */
    readonly _: 'getSuitablePersonalChats',
  }

  export type loadDirectMessagesChatTopics = {
    /**
     * Loads more topics in a channel direct messages chat administered by the current
     * user. The loaded topics will be sent through updateDirectMessagesChatTopic.
     * Topics are sorted by their topic.order in descending order. Returns a 404 error
     * if all topics have been loaded
     */
    readonly _: 'loadDirectMessagesChatTopics',
    /** Chat identifier of the channel direct messages chat */
    readonly chat_id?: number,
    /**
     * The maximum number of topics to be loaded. For optimal performance, the number
     * of loaded topics is chosen by TDLib and can be smaller than the specified limit,
     * even if the end of the list is not reached
     */
    readonly limit?: number,
  }

  export type getDirectMessagesChatTopic = {
    /**
     * Returns information about the topic in a channel direct messages chat administered
     * by the current user
     */
    readonly _: 'getDirectMessagesChatTopic',
    /** Chat identifier of the channel direct messages chat */
    readonly chat_id?: number,
    /** Identifier of the topic to get */
    readonly topic_id?: number,
  }

  export type getDirectMessagesChatTopicHistory = {
    /**
     * Returns messages in the topic in a channel direct messages chat administered
     * by the current user. The messages are returned in reverse chronological order
     * (i.e., in order of decreasing message_id)
     */
    readonly _: 'getDirectMessagesChatTopicHistory',
    /** Chat identifier of the channel direct messages chat */
    readonly chat_id?: number,
    /** Identifier of the topic which messages will be fetched */
    readonly topic_id?: number,
    /**
     * Identifier of the message starting from which messages must be fetched; use
     * 0 to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getDirectMessagesChatTopicMessageByDate = {
    /**
     * Returns the last message sent in the topic in a channel direct messages chat
     * administered by the current user no later than the specified date
     */
    readonly _: 'getDirectMessagesChatTopicMessageByDate',
    /** Chat identifier of the channel direct messages chat */
    readonly chat_id?: number,
    /** Identifier of the topic which messages will be fetched */
    readonly topic_id?: number,
    /** Point in time (Unix timestamp) relative to which to search for messages */
    readonly date?: number,
  }

  export type deleteDirectMessagesChatTopicHistory = {
    /**
     * Deletes all messages in the topic in a channel direct messages chat administered
     * by the current user
     */
    readonly _: 'deleteDirectMessagesChatTopicHistory',
    /** Chat identifier of the channel direct messages chat */
    readonly chat_id?: number,
    /** Identifier of the topic which messages will be deleted */
    readonly topic_id?: number,
  }

  export type deleteDirectMessagesChatTopicMessagesByDate = {
    /**
     * Deletes all messages between the specified dates in the topic in a channel direct
     * messages chat administered by the current user. Messages sent in the last 30
     * seconds will not be deleted
     */
    readonly _: 'deleteDirectMessagesChatTopicMessagesByDate',
    /** Chat identifier of the channel direct messages chat */
    readonly chat_id?: number,
    /** Identifier of the topic which messages will be deleted */
    readonly topic_id?: number,
    /** The minimum date of the messages to delete */
    readonly min_date?: number,
    /** The maximum date of the messages to delete */
    readonly max_date?: number,
  }

  export type setDirectMessagesChatTopicIsMarkedAsUnread = {
    /**
     * Changes the marked as unread state of the topic in a channel direct messages
     * chat administered by the current user
     */
    readonly _: 'setDirectMessagesChatTopicIsMarkedAsUnread',
    /** Chat identifier of the channel direct messages chat */
    readonly chat_id?: number,
    /** Topic identifier */
    readonly topic_id?: number,
    /** New value of is_marked_as_unread */
    readonly is_marked_as_unread?: boolean,
  }

  export type setDirectMessagesChatTopicDraftMessage = {
    /**
     * Changes the draft message in the topic in a channel direct messages chat administered
     * by the current user
     */
    readonly _: 'setDirectMessagesChatTopicDraftMessage',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Topic identifier */
    readonly topic_id?: number,
    /**
     * New draft message; pass null to remove the draft. All files in draft message
     * content must be of the type inputFileLocal. Media thumbnails and captions are
     * ignored
     */
    readonly draft_message?: draftMessage$Input,
  }

  export type unpinAllDirectMessagesChatTopicMessages = {
    /**
     * Removes all pinned messages from the topic in a channel direct messages chat
     * administered by the current user
     */
    readonly _: 'unpinAllDirectMessagesChatTopicMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Topic identifier */
    readonly topic_id?: number,
  }

  export type readAllDirectMessagesChatTopicReactions = {
    /**
     * Removes all unread reactions in the topic in a channel direct messages chat
     * administered by the current user
     */
    readonly _: 'readAllDirectMessagesChatTopicReactions',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Topic identifier */
    readonly topic_id?: number,
  }

  export type getDirectMessagesChatTopicRevenue = {
    /**
     * Returns the total number of Telegram Stars received by the channel chat for
     * direct messages from the given topic
     */
    readonly _: 'getDirectMessagesChatTopicRevenue',
    /**
     * Chat identifier of the channel direct messages chat administered by the current
     * user
     */
    readonly chat_id?: number,
    /** Identifier of the topic */
    readonly topic_id?: number,
  }

  export type toggleDirectMessagesChatTopicCanSendUnpaidMessages = {
    /**
     * Allows to send unpaid messages to the given topic of the channel direct messages
     * chat administered by the current user
     */
    readonly _: 'toggleDirectMessagesChatTopicCanSendUnpaidMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the topic */
    readonly topic_id?: number,
    /** Pass true to allow unpaid messages; pass false to disallow unpaid messages */
    readonly can_send_unpaid_messages?: boolean,
    /** Pass true to refund the user previously paid messages */
    readonly refund_payments?: boolean,
  }

  export type loadSavedMessagesTopics = {
    /**
     * Loads more Saved Messages topics. The loaded topics will be sent through updateSavedMessagesTopic.
     * Topics are sorted by their topic.order in descending order. Returns a 404 error
     * if all topics have been loaded
     */
    readonly _: 'loadSavedMessagesTopics',
    /**
     * The maximum number of topics to be loaded. For optimal performance, the number
     * of loaded topics is chosen by TDLib and can be smaller than the specified limit,
     * even if the end of the list is not reached
     */
    readonly limit?: number,
  }

  export type getSavedMessagesTopicHistory = {
    /**
     * Returns messages in a Saved Messages topic. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    readonly _: 'getSavedMessagesTopicHistory',
    /** Identifier of Saved Messages topic which messages will be fetched */
    readonly saved_messages_topic_id?: number,
    /**
     * Identifier of the message starting from which messages must be fetched; use
     * 0 to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getSavedMessagesTopicMessageByDate = {
    /**
     * Returns the last message sent in a Saved Messages topic no later than the specified
     * date
     */
    readonly _: 'getSavedMessagesTopicMessageByDate',
    /** Identifier of Saved Messages topic which message will be returned */
    readonly saved_messages_topic_id?: number,
    /** Point in time (Unix timestamp) relative to which to search for messages */
    readonly date?: number,
  }

  export type deleteSavedMessagesTopicHistory = {
    /** Deletes all messages in a Saved Messages topic */
    readonly _: 'deleteSavedMessagesTopicHistory',
    /** Identifier of Saved Messages topic which messages will be deleted */
    readonly saved_messages_topic_id?: number,
  }

  export type deleteSavedMessagesTopicMessagesByDate = {
    /**
     * Deletes all messages between the specified dates in a Saved Messages topic.
     * Messages sent in the last 30 seconds will not be deleted
     */
    readonly _: 'deleteSavedMessagesTopicMessagesByDate',
    /** Identifier of Saved Messages topic which messages will be deleted */
    readonly saved_messages_topic_id?: number,
    /** The minimum date of the messages to delete */
    readonly min_date?: number,
    /** The maximum date of the messages to delete */
    readonly max_date?: number,
  }

  export type toggleSavedMessagesTopicIsPinned = {
    /**
     * Changes the pinned state of a Saved Messages topic. There can be up to getOption("pinned_saved_messages_topic_count_max")
     * pinned topics. The limit can be increased with Telegram Premium
     */
    readonly _: 'toggleSavedMessagesTopicIsPinned',
    /** Identifier of Saved Messages topic to pin or unpin */
    readonly saved_messages_topic_id?: number,
    /** Pass true to pin the topic; pass false to unpin it */
    readonly is_pinned?: boolean,
  }

  export type setPinnedSavedMessagesTopics = {
    /** Changes the order of pinned Saved Messages topics */
    readonly _: 'setPinnedSavedMessagesTopics',
    /** Identifiers of the new pinned Saved Messages topics */
    readonly saved_messages_topic_ids?: ReadonlyArray<number>,
  }

  export type getGroupsInCommon = {
    /**
     * Returns a list of common group chats with a given user. Chats are sorted by
     * their type and creation date
     */
    readonly _: 'getGroupsInCommon',
    /** User identifier */
    readonly user_id?: number,
    /** Chat identifier starting from which to return chats; use 0 for the first request */
    readonly offset_chat_id?: number,
    /** The maximum number of chats to be returned; up to 100 */
    readonly limit?: number,
  }

  export type getChatHistory = {
    /**
     * Returns messages in a chat. The messages are returned in reverse chronological
     * order (i.e., in order of decreasing message_id). For optimal performance, the
     * number of returned messages is chosen by TDLib. This is an offline method if
     * only_local is true
     */
    readonly _: 'getChatHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
    /** Pass true to get only messages that are available without sending network requests */
    readonly only_local?: boolean,
  }

  export type getMessageThreadHistory = {
    /**
     * Returns messages in a message thread of a message. Can be used only if messageProperties.can_get_message_thread
     * == true. Message thread of a channel message is in the channel's linked supergroup.
     * The messages are returned in reverse chronological order (i.e., in order of
     * decreasing message_id). For optimal performance, the number of returned messages
     * is chosen by TDLib
     */
    readonly _: 'getMessageThreadHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier, which thread history needs to be returned */
    readonly message_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type deleteChatHistory = {
    /**
     * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and
     * chat.can_be_deleted_for_all_users fields to find whether and how the method
     * can be applied to the chat
     */
    readonly _: 'deleteChatHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true to remove the chat from all chat lists */
    readonly remove_from_chat_list?: boolean,
    /** Pass true to delete chat history for all users */
    readonly revoke?: boolean,
  }

  export type deleteChat = {
    /**
     * Deletes a chat along with all messages in the corresponding chat for all chat
     * members. For group chats this will release the usernames and remove all members.
     * Use the field chat.can_be_deleted_for_all_users to find whether the method can
     * be applied to the chat
     */
    readonly _: 'deleteChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type searchChatMessages = {
    /**
     * Searches for messages with given words in the chat. Returns the results in reverse
     * chronological order, i.e. in order of decreasing message_id. Cannot be used
     * in secret chats with a non-empty query (searchSecretMessages must be used instead),
     * or without an enabled message database. For optimal performance, the number
     * of returned messages is chosen by TDLib and can be smaller than the specified
     * limit. A combination of query, sender_id, filter and topic_id search criteria
     * is expected to be supported, only if it is required for Telegram official application
     * implementation
     */
    readonly _: 'searchChatMessages',
    /** Identifier of the chat in which to search messages */
    readonly chat_id?: number,
    /**
     * Pass topic identifier to search messages only in specific topic; pass null to
     * search for messages in all topics
     */
    readonly topic_id?: MessageTopic$Input,
    /** Query to search for */
    readonly query?: string,
    /**
     * Identifier of the sender of messages to search for; pass null to search for
     * messages from any sender. Not supported in secret chats
     */
    readonly sender_id?: MessageSender$Input,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset to get the specified message and some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * -offset. For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    readonly filter?: SearchMessagesFilter$Input,
  }

  export type searchMessages = {
    /**
     * Searches for messages in all chats except secret chats. Returns the results
     * in reverse chronological order (i.e., in order of decreasing (date, chat_id,
     * message_id)). For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly _: 'searchMessages',
    /**
     * Chat list in which to search messages; pass null to search in all chats regardless
     * of their chat list. Only Main and Archive chat lists are supported
     */
    readonly chat_list?: ChatList$Input,
    /** Query to search for */
    readonly query?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /**
     * Additional filter for messages to search; pass null to search for all messages.
     * Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction,
     * searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are unsupported
     * in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * Additional filter for type of the chat of the searched messages; pass null to
     * search for messages in all chats
     */
    readonly chat_type_filter?: SearchMessagesChatTypeFilter$Input,
    /** If not 0, the minimum date of the messages to return */
    readonly min_date?: number,
    /** If not 0, the maximum date of the messages to return */
    readonly max_date?: number,
  }

  export type searchSecretMessages = {
    /**
     * Searches for messages in secret chats. Returns the results in reverse chronological
     * order. For optimal performance, the number of returned messages is chosen by
     * TDLib
     */
    readonly _: 'searchSecretMessages',
    /**
     * Identifier of the chat in which to search. Specify 0 to search in all secret
     * chats
     */
    readonly chat_id?: number,
    /** Query to search for. If empty, searchChatMessages must be used instead */
    readonly query?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    readonly filter?: SearchMessagesFilter$Input,
  }

  export type searchSavedMessages = {
    /**
     * Searches for messages tagged by the given reaction and with the given words
     * in the Saved Messages chat; for Telegram Premium users only. Returns the results
     * in reverse chronological order, i.e. in order of decreasing message_id. For
     * optimal performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    readonly _: 'searchSavedMessages',
    /**
     * If not 0, only messages in the specified Saved Messages topic will be considered;
     * pass 0 to consider all messages
     */
    readonly saved_messages_topic_id?: number,
    /** Tag to search for; pass null to return all suitable messages */
    readonly tag?: ReactionType$Input,
    /** Query to search for */
    readonly query?: string,
    /**
     * Identifier of the message starting from which messages must be fetched; use
     * 0 to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the message from_message_id or a negative
     * offset to get the specified message and some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * -offset. For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type searchCallMessages = {
    /**
     * Searches for call and group call messages. Returns the results in reverse chronological
     * order (i.e., in order of decreasing message_id). For optimal performance, the
     * number of returned messages is chosen by TDLib
     */
    readonly _: 'searchCallMessages',
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /** Pass true to search only for messages with missed/declined calls */
    readonly only_missed?: boolean,
  }

  export type searchOutgoingDocumentMessages = {
    /**
     * Searches for outgoing messages with content of the type messageDocument in all
     * chats except secret chats. Returns the results in reverse chronological order
     */
    readonly _: 'searchOutgoingDocumentMessages',
    /** Query to search for in document file name and message caption */
    readonly query?: string,
    /** The maximum number of messages to be returned; up to 100 */
    readonly limit?: number,
  }

  export type searchPublicMessagesByTag = {
    /**
     * Searches for public channel posts containing the given hashtag or cashtag. For
     * optimal performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    readonly _: 'searchPublicMessagesByTag',
    /** Hashtag or cashtag to search for */
    readonly tag?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
  }

  export type searchPublicStoriesByTag = {
    /**
     * Searches for public stories containing the given hashtag or cashtag. For optimal
     * performance, the number of returned stories is chosen by TDLib and can be smaller
     * than the specified limit
     */
    readonly _: 'searchPublicStoriesByTag',
    /**
     * Identifier of the chat that posted the stories to search for; pass 0 to search
     * stories in all chats
     */
    readonly story_poster_chat_id?: number,
    /** Hashtag or cashtag to search for */
    readonly tag?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of stories to be returned; up to 100. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
  }

  export type searchPublicStoriesByLocation = {
    /**
     * Searches for public stories by the given address location. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly _: 'searchPublicStoriesByLocation',
    /** Address of the location */
    readonly address?: locationAddress$Input,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of stories to be returned; up to 100. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
  }

  export type searchPublicStoriesByVenue = {
    /**
     * Searches for public stories from the given venue. For optimal performance, the
     * number of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    readonly _: 'searchPublicStoriesByVenue',
    /** Provider of the venue */
    readonly venue_provider?: string,
    /** Identifier of the venue in the provider database */
    readonly venue_id?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of stories to be returned; up to 100. For optimal performance,
     * the number of returned stories is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
  }

  export type getSearchedForTags = {
    /** Returns recently searched for hashtags or cashtags by their prefix */
    readonly _: 'getSearchedForTags',
    /** Prefix of hashtags or cashtags to return */
    readonly tag_prefix?: string,
    /** The maximum number of items to be returned */
    readonly limit?: number,
  }

  export type removeSearchedForTag = {
    /**
     * Removes a hashtag or a cashtag from the list of recently searched for hashtags
     * or cashtags
     */
    readonly _: 'removeSearchedForTag',
    /** Hashtag or cashtag to delete */
    readonly tag?: string,
  }

  export type clearSearchedForTags = {
    /** Clears the list of recently searched for hashtags or cashtags */
    readonly _: 'clearSearchedForTags',
    /**
     * Pass true to clear the list of recently searched for cashtags; otherwise, the
     * list of recently searched for hashtags will be cleared
     */
    readonly clear_cashtags?: boolean,
  }

  export type deleteAllCallMessages = {
    /** Deletes all call messages */
    readonly _: 'deleteAllCallMessages',
    /** Pass true to delete the messages for all users */
    readonly revoke?: boolean,
  }

  export type searchChatRecentLocationMessages = {
    /**
     * Returns information about the recent locations of chat members that were sent
     * to the chat. Returns up to 1 location message per user
     */
    readonly _: 'searchChatRecentLocationMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The maximum number of messages to be returned */
    readonly limit?: number,
  }

  export type getChatMessageByDate = {
    /**
     * Returns the last message sent in a chat no later than the specified date. Returns
     * a 404 error if such message doesn't exist
     */
    readonly _: 'getChatMessageByDate',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Point in time (Unix timestamp) relative to which to search for messages */
    readonly date?: number,
  }

  export type getChatSparseMessagePositions = {
    /**
     * Returns sparse positions of messages of the specified type in the chat to be
     * used for shared media scroll implementation. Returns the results in reverse
     * chronological order (i.e., in order of decreasing message_id). Cannot be used
     * in secret chats or with searchMessagesFilterFailedToSend filter without an enabled
     * message database
     */
    readonly _: 'getChatSparseMessagePositions',
    /** Identifier of the chat in which to return information about message positions */
    readonly chat_id?: number,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are
     * unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /** The message identifier from which to return information about message positions */
    readonly from_message_id?: number,
    /**
     * The expected number of message positions to be returned; 50-2000. A smaller
     * number of positions can be returned, if there are not enough appropriate messages
     */
    readonly limit?: number,
    /**
     * If not 0, only messages in the specified Saved Messages topic will be considered;
     * pass 0 to consider all messages, or for chats other than Saved Messages
     */
    readonly saved_messages_topic_id?: number,
  }

  export type getChatMessageCalendar = {
    /**
     * Returns information about the next messages of the specified type in the chat
     * split by days. Returns the results in reverse chronological order. Can return
     * partial result for the last returned day. Behavior of this method depends on
     * the value of the option "utc_time_offset"
     */
    readonly _: 'getChatMessageCalendar',
    /** Identifier of the chat in which to return information about messages */
    readonly chat_id?: number,
    /**
     * Pass topic identifier to get the result only in specific topic; pass null to
     * get the result in all topics; forum topics aren't supported
     */
    readonly topic_id?: MessageTopic$Input,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are
     * unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * The message identifier from which to return information about messages; use
     * 0 to get results from the last message
     */
    readonly from_message_id?: number,
  }

  export type getChatMessageCount = {
    /**
     * Returns approximate number of messages of the specified type in the chat or
     * its topic
     */
    readonly _: 'getChatMessageCount',
    /** Identifier of the chat in which to count messages */
    readonly chat_id?: number,
    /**
     * Pass topic identifier to get number of messages only in specific topic; pass
     * null to get number of messages in all topics
     */
    readonly topic_id?: MessageTopic$Input,
    /**
     * Filter for message content; searchMessagesFilterEmpty is unsupported in this
     * function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * Pass true to get the number of messages without sending network requests, or
     * -1 if the number of messages is unknown locally
     */
    readonly return_local?: boolean,
  }

  export type getChatMessagePosition = {
    /**
     * Returns approximate 1-based position of a message among messages, which can
     * be found by the specified filter in the chat and topic. Cannot be used in secret
     * chats
     */
    readonly _: 'getChatMessagePosition',
    /** Identifier of the chat in which to find message position */
    readonly chat_id?: number,
    /**
     * Pass topic identifier to get position among messages only in specific topic;
     * pass null to get position among all chat messages
     */
    readonly topic_id?: MessageTopic$Input,
    /**
     * Filter for message content; searchMessagesFilterEmpty, searchMessagesFilterUnreadMention,
     * searchMessagesFilterUnreadReaction, and searchMessagesFilterFailedToSend are
     * unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /** Message identifier */
    readonly message_id?: number,
  }

  export type getChatScheduledMessages = {
    /**
     * Returns all scheduled messages in a chat. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    readonly _: 'getChatScheduledMessages',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getChatSponsoredMessages = {
    /**
     * Returns sponsored messages to be shown in a chat; for channel chats and chats
     * with bots only
     */
    readonly _: 'getChatSponsoredMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type clickChatSponsoredMessage = {
    /**
     * Informs TDLib that the user opened the sponsored chat via the button, the name,
     * the chat photo, a mention in the sponsored message text, or the media in the
     * sponsored message
     */
    readonly _: 'clickChatSponsoredMessage',
    /** Chat identifier of the sponsored message */
    readonly chat_id?: number,
    /** Identifier of the sponsored message */
    readonly message_id?: number,
    /** Pass true if the media was clicked in the sponsored message */
    readonly is_media_click?: boolean,
    /**
     * Pass true if the user expanded the video from the sponsored message fullscreen
     * before the click
     */
    readonly from_fullscreen?: boolean,
  }

  export type reportChatSponsoredMessage = {
    /** Reports a sponsored message to Telegram moderators */
    readonly _: 'reportChatSponsoredMessage',
    /** Chat identifier of the sponsored message */
    readonly chat_id?: number,
    /** Identifier of the sponsored message */
    readonly message_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    readonly option_id?: string /* base64 */,
  }

  export type getSearchSponsoredChats = {
    /** Returns sponsored chats to be shown in the search results */
    readonly _: 'getSearchSponsoredChats',
    /** Query the user searches for */
    readonly query?: string,
  }

  export type viewSponsoredChat = {
    /** Informs TDLib that the user fully viewed a sponsored chat */
    readonly _: 'viewSponsoredChat',
    /** Unique identifier of the sponsored chat */
    readonly sponsored_chat_unique_id?: number,
  }

  export type openSponsoredChat = {
    /** Informs TDLib that the user opened a sponsored chat */
    readonly _: 'openSponsoredChat',
    /** Unique identifier of the sponsored chat */
    readonly sponsored_chat_unique_id?: number,
  }

  export type reportSponsoredChat = {
    /** Reports a sponsored chat to Telegram moderators */
    readonly _: 'reportSponsoredChat',
    /** Unique identifier of the sponsored chat */
    readonly sponsored_chat_unique_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    readonly option_id?: string /* base64 */,
  }

  export type getVideoMessageAdvertisements = {
    /**
     * Returns advertisements to be shown while a video from a message is watched.
     * Available only if messageProperties.can_get_video_advertisements
     */
    readonly _: 'getVideoMessageAdvertisements',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type viewVideoMessageAdvertisement = {
    /** Informs TDLib that the user viewed a video message advertisement */
    readonly _: 'viewVideoMessageAdvertisement',
    /** Unique identifier of the advertisement */
    readonly advertisement_unique_id?: number,
  }

  export type clickVideoMessageAdvertisement = {
    /** Informs TDLib that the user clicked a video message advertisement */
    readonly _: 'clickVideoMessageAdvertisement',
    /** Unique identifier of the advertisement */
    readonly advertisement_unique_id?: number,
  }

  export type reportVideoMessageAdvertisement = {
    /** Reports a video message advertisement to Telegram moderators */
    readonly _: 'reportVideoMessageAdvertisement',
    /** Unique identifier of the advertisement */
    readonly advertisement_unique_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    readonly option_id?: string /* base64 */,
  }

  export type removeNotification = {
    /**
     * Removes an active notification from notification list. Needs to be called only
     * if the notification is removed by the current user
     */
    readonly _: 'removeNotification',
    /** Identifier of notification group to which the notification belongs */
    readonly notification_group_id?: number,
    /** Identifier of removed notification */
    readonly notification_id?: number,
  }

  export type removeNotificationGroup = {
    /**
     * Removes a group of active notifications. Needs to be called only if the notification
     * group is removed by the current user
     */
    readonly _: 'removeNotificationGroup',
    /** Notification group identifier */
    readonly notification_group_id?: number,
    /** The maximum identifier of removed notifications */
    readonly max_notification_id?: number,
  }

  export type getMessageLink = {
    /**
     * Returns an HTTPS link to a message in a chat. Available only if messageProperties.can_get_link,
     * or if messageProperties.can_get_media_timestamp_links and a media timestamp
     * link is generated. This is an offline method
     */
    readonly _: 'getMessageLink',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * If not 0, timestamp from which the video/audio/video note/voice note/story playing
     * must start, in seconds. The media can be in the message content or in its link
     * preview
     */
    readonly media_timestamp?: number,
    /** Pass true to create a link for the whole media album */
    readonly for_album?: boolean,
    /**
     * Pass true to create a link to the message as a channel post comment, in a message
     * thread, or a forum topic
     */
    readonly in_message_thread?: boolean,
  }

  export type getMessageEmbeddingCode = {
    /** Returns an HTML code for embedding the message. Available only if messageProperties.can_get_embedding_code */
    readonly _: 'getMessageEmbeddingCode',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true to return an HTML code for embedding of the whole media album */
    readonly for_album?: boolean,
  }

  export type getMessageLinkInfo = {
    /**
     * Returns information about a public or private message link. Can be called for
     * any internal link of the type internalLinkTypeMessage
     */
    readonly _: 'getMessageLinkInfo',
    /** The message link */
    readonly url?: string,
  }

  export type translateText = {
    /**
     * Translates a text to the given language. If the current user is a Telegram Premium
     * user, then text formatting is preserved
     */
    readonly _: 'translateText',
    /** Text to translate */
    readonly text?: formattedText$Input,
    /**
     * Language code of the language to which the message is translated. Must be one
     * of "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb",
     * "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl",
     * "en", "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha",
     * "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja",
     * "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky", "lo", "la", "lv", "lt", "lb",
     * "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or",
     * "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd",
     * "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo",
     * "zu"
     */
    readonly to_language_code?: string,
  }

  export type translateMessageText = {
    /**
     * Extracts text or caption of the given message and translates it to the given
     * language. If the current user is a Telegram Premium user, then text formatting
     * is preserved
     */
    readonly _: 'translateMessageText',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * Language code of the language to which the message is translated. Must be one
     * of "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb",
     * "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl",
     * "en", "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha",
     * "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja",
     * "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky", "lo", "la", "lv", "lt", "lb",
     * "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or",
     * "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd",
     * "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo",
     * "zu"
     */
    readonly to_language_code?: string,
  }

  export type recognizeSpeech = {
    /** Recognizes speech in a video note or a voice note message */
    readonly _: 'recognizeSpeech',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_recognize_speech to check
     * whether the message is suitable
     */
    readonly message_id?: number,
  }

  export type rateSpeechRecognition = {
    /** Rates recognized speech in a video note or a voice note message */
    readonly _: 'rateSpeechRecognition',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true if the speech recognition is good */
    readonly is_good?: boolean,
  }

  export type getChatAvailableMessageSenders = {
    /**
     * Returns the list of message sender identifiers, which can be used to send messages
     * in a chat
     */
    readonly _: 'getChatAvailableMessageSenders',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type setChatMessageSender = {
    /** Selects a message sender to send messages in a chat */
    readonly _: 'setChatMessageSender',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New message sender for the chat */
    readonly message_sender_id?: MessageSender$Input,
  }

  export type sendMessage = {
    /** Sends a message. Returns the sent message */
    readonly _: 'sendMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, the message thread identifier in which the message will be sent */
    readonly message_thread_id?: number,
    /** Information about the message or story to be replied; pass null if none */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Options to be used to send the message; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Markup for replying to the message; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** The content of the message to be sent */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type sendMessageAlbum = {
    /**
     * Sends 2-10 messages grouped together into an album. Currently, only audio, document,
     * photo and video messages can be grouped into an album. Documents and audio files
     * can be only grouped in an album with messages of the same type. Returns sent
     * messages
     */
    readonly _: 'sendMessageAlbum',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, the message thread identifier in which the messages will be sent */
    readonly message_thread_id?: number,
    /** Information about the message or story to be replied; pass null if none */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Options to be used to send the messages; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /**
     * Contents of messages to be sent. At most 10 messages can be added to an album.
     * All messages must have the same value of show_caption_above_media
     */
    readonly input_message_contents?: ReadonlyArray<InputMessageContent$Input>,
  }

  export type sendBotStartMessage = {
    /**
     * Invites a bot to a chat (if it is not yet a member) and sends it the /start
     * command; requires can_invite_users member right. Bots can't be invited to a
     * private chat other than the chat with the bot. Bots can't be invited to channels
     * (although they can be added as admins) and secret chats. Returns the sent message
     */
    readonly _: 'sendBotStartMessage',
    /** Identifier of the bot */
    readonly bot_user_id?: number,
    /** Identifier of the target chat */
    readonly chat_id?: number,
    /** A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking) */
    readonly parameter?: string,
  }

  export type sendInlineQueryResultMessage = {
    /**
     * Sends the result of an inline query as a message. Returns the sent message.
     * Always clears a chat draft message
     */
    readonly _: 'sendInlineQueryResultMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, the message thread identifier in which the message will be sent */
    readonly message_thread_id?: number,
    /** Information about the message or story to be replied; pass null if none */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Options to be used to send the message; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Identifier of the inline query */
    readonly query_id?: number | string,
    /** Identifier of the inline query result */
    readonly result_id?: string,
    /**
     * Pass true to hide the bot, via which the message is sent. Can be used only for
     * bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"),
     * and getOption("venue_search_bot_username")
     */
    readonly hide_via_bot?: boolean,
  }

  export type forwardMessages = {
    /**
     * Forwards previously sent messages. Returns the forwarded messages in the same
     * order as the message identifiers passed in message_ids. If a message can't be
     * forwarded, null will be returned instead of the message
     */
    readonly _: 'forwardMessages',
    /** Identifier of the chat to which to forward messages */
    readonly chat_id?: number,
    /**
     * If not 0, the message thread identifier in which the message will be sent; for
     * forum threads only
     */
    readonly message_thread_id?: number,
    /** Identifier of the chat from which to forward messages */
    readonly from_chat_id?: number,
    /**
     * Identifiers of the messages to forward. Message identifiers must be in a strictly
     * increasing order. At most 100 messages can be forwarded simultaneously. A message
     * can be forwarded only if messageProperties.can_be_forwarded
     */
    readonly message_ids?: ReadonlyArray<number>,
    /** Options to be used to send the messages; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /**
     * Pass true to copy content of the messages without reference to the original
     * sender. Always true if the messages are forwarded to a secret chat or are local.
     * Use messageProperties.can_be_copied and messageProperties.can_be_copied_to_secret_chat
     * to check whether the message is suitable
     */
    readonly send_copy?: boolean,
    /**
     * Pass true to remove media captions of message copies. Ignored if send_copy is
     * false
     */
    readonly remove_caption?: boolean,
  }

  export type sendQuickReplyShortcutMessages = {
    /**
     * Sends messages from a quick reply shortcut. Requires Telegram Business subscription.
     * Can't be used to send paid messages
     */
    readonly _: 'sendQuickReplyShortcutMessages',
    /**
     * Identifier of the chat to which to send messages. The chat must be a private
     * chat with a regular user
     */
    readonly chat_id?: number,
    /** Unique identifier of the quick reply shortcut */
    readonly shortcut_id?: number,
    /**
     * Non-persistent identifier, which will be returned back in messageSendingStatePending
     * object and can be used to match sent messages and corresponding updateNewMessage
     * updates
     */
    readonly sending_id?: number,
  }

  export type resendMessages = {
    /**
     * Resends messages which failed to send. Can be called only for messages for which
     * messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after
     * time passed. If a message is re-sent, the corresponding failed to send message
     * is deleted. Returns the sent messages in the same order as the message identifiers
     * passed in message_ids. If a message can't be re-sent, null will be returned
     * instead of the message
     */
    readonly _: 'resendMessages',
    /** Identifier of the chat to send messages */
    readonly chat_id?: number,
    /**
     * Identifiers of the messages to resend. Message identifiers must be in a strictly
     * increasing order
     */
    readonly message_ids?: ReadonlyArray<number>,
    /**
     * New manually chosen quote from the message to be replied; pass null if none.
     * Ignored if more than one message is re-sent, or if messageSendingStateFailed.need_another_reply_quote
     * == false
     */
    readonly quote?: inputTextQuote$Input,
    /**
     * The number of Telegram Stars the user agreed to pay to send the messages. Ignored
     * if messageSendingStateFailed.required_paid_message_star_count == 0
     */
    readonly paid_message_star_count?: number,
  }

  export type addLocalMessage = {
    /**
     * Adds a local message to a chat. The message is persistent across application
     * restarts only if the message database is used. Returns the added message
     */
    readonly _: 'addLocalMessage',
    /** Target chat; channel direct messages chats aren't supported */
    readonly chat_id?: number,
    /** Identifier of the sender of the message */
    readonly sender_id?: MessageSender$Input,
    /** Information about the message or story to be replied; pass null if none */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /** The content of the message to be added */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type deleteMessages = {
    /** Deletes messages */
    readonly _: 'deleteMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifiers of the messages to be deleted. Use messageProperties.can_be_deleted_only_for_self
     * and messageProperties.can_be_deleted_for_all_users to get suitable messages
     */
    readonly message_ids?: ReadonlyArray<number>,
    /**
     * Pass true to delete messages for all chat members. Always true for supergroups,
     * channels and secret chats
     */
    readonly revoke?: boolean,
  }

  export type deleteChatMessagesBySender = {
    /**
     * Deletes all messages sent by the specified message sender in a chat. Supported
     * only for supergroups; requires can_delete_messages administrator right
     */
    readonly _: 'deleteChatMessagesBySender',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the sender of messages to delete */
    readonly sender_id?: MessageSender$Input,
  }

  export type deleteChatMessagesByDate = {
    /**
     * Deletes all messages between the specified dates in a chat. Supported only for
     * private chats and basic groups. Messages sent in the last 30 seconds will not
     * be deleted
     */
    readonly _: 'deleteChatMessagesByDate',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The minimum date of the messages to delete */
    readonly min_date?: number,
    /** The maximum date of the messages to delete */
    readonly max_date?: number,
    /** Pass true to delete chat messages for all users; private chats only */
    readonly revoke?: boolean,
  }

  export type editMessageText = {
    /**
     * Edits the text of a message (or a text of a game message). Returns the edited
     * message after the edit is completed on the server side
     */
    readonly _: 'editMessageText',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editMessageLiveLocation = {
    /**
     * Edits the message content of a live location. Messages can be edited for a limited
     * period of time specified in the live location. Returns the edited message after
     * the edit is completed on the server side
     */
    readonly _: 'editMessageLiveLocation',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    readonly location?: location$Input,
    /**
     * New time relative to the message send date, for which the location can be updated,
     * in seconds. If 0x7FFFFFFF specified, then the location can be updated forever.
     * Otherwise, must not exceed the current live_period by more than a day, and the
     * live location expiration date must remain in the next 90 days. Pass 0 to keep
     * the current live_period
     */
    readonly live_period?: number,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    readonly heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    readonly proximity_alert_radius?: number,
  }

  export type editMessageChecklist = {
    /**
     * Edits the message content of a checklist. Returns the edited message after the
     * edit is completed on the server side
     */
    readonly _: 'editMessageChecklist',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** The new checklist. If some tasks were completed, this information will be kept */
    readonly checklist?: inputChecklist$Input,
  }

  export type editMessageMedia = {
    /**
     * Edits the media content of a message, including message caption. If only the
     * caption needs to be edited, use editMessageCaption instead. The type of message
     * content in an album can't be changed with exception of replacing a photo with
     * a video or vice versa. Returns the edited message after the edit is completed
     * on the server side
     */
    readonly _: 'editMessageMedia',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_edit_media to check whether
     * the message can be edited
     */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editMessageCaption = {
    /**
     * Edits the message content caption. Returns the edited message after the edit
     * is completed on the server side
     */
    readonly _: 'editMessageCaption',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; 0-getOption("message_caption_length_max") characters;
     * pass null to remove caption
     */
    readonly caption?: formattedText$Input,
    /**
     * Pass true to show the caption above the media; otherwise, the caption will be
     * shown below the media. May be true only for animation, photo, and video messages
     */
    readonly show_caption_above_media?: boolean,
  }

  export type editMessageReplyMarkup = {
    /**
     * Edits the message reply markup; for bots only. Returns the edited message after
     * the edit is completed on the server side
     */
    readonly _: 'editMessageReplyMarkup',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_be_edited to check whether
     * the message can be edited
     */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type editInlineMessageText = {
    /** Edits the text of an inline text or game message sent via a bot; for bots only */
    readonly _: 'editInlineMessageText',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editInlineMessageLiveLocation = {
    /**
     * Edits the content of a live location in an inline message sent via a bot; for
     * bots only
     */
    readonly _: 'editInlineMessageLiveLocation',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    readonly location?: location$Input,
    /**
     * New time relative to the message send date, for which the location can be updated,
     * in seconds. If 0x7FFFFFFF specified, then the location can be updated forever.
     * Otherwise, must not exceed the current live_period by more than a day, and the
     * live location expiration date must remain in the next 90 days. Pass 0 to keep
     * the current live_period
     */
    readonly live_period?: number,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    readonly heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    readonly proximity_alert_radius?: number,
  }

  export type editInlineMessageMedia = {
    /**
     * Edits the media content of a message with a text, an animation, an audio, a
     * document, a photo or a video in an inline message sent via a bot; for bots only
     */
    readonly _: 'editInlineMessageMedia',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editInlineMessageCaption = {
    /** Edits the caption of an inline message sent via a bot; for bots only */
    readonly _: 'editInlineMessageCaption',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * Pass true to show the caption above the media; otherwise, the caption will be
     * shown below the media. May be true only for animation, photo, and video messages
     */
    readonly show_caption_above_media?: boolean,
  }

  export type editInlineMessageReplyMarkup = {
    /** Edits the reply markup of an inline message sent via a bot; for bots only */
    readonly _: 'editInlineMessageReplyMarkup',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type editMessageSchedulingState = {
    /**
     * Edits the time when a scheduled message will be sent. Scheduling state of all
     * messages in the same album or forwarded together with the message will be also
     * changed
     */
    readonly _: 'editMessageSchedulingState',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use messageProperties.can_edit_scheduling_state to
     * check whether the message is suitable
     */
    readonly message_id?: number,
    /**
     * The new message scheduling state; pass null to send the message immediately.
     * Must be null for messages in the state messageSchedulingStateSendWhenVideoProcessed
     */
    readonly scheduling_state?: MessageSchedulingState$Input,
  }

  export type setMessageFactCheck = {
    /**
     * Changes the fact-check of a message. Can be only used if messageProperties.can_set_fact_check
     * == true
     */
    readonly _: 'setMessageFactCheck',
    /** The channel chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * New text of the fact-check; 0-getOption("fact_check_length_max") characters;
     * pass null to remove it. Only Bold, Italic, and TextUrl entities with https://t.me/
     * links are supported
     */
    readonly text?: formattedText$Input,
  }

  export type sendBusinessMessage = {
    /**
     * Sends a message on behalf of a business account; for bots only. Returns the
     * message after it was sent
     */
    readonly _: 'sendBusinessMessage',
    /** Unique identifier of business connection on behalf of which to send the request */
    readonly business_connection_id?: string,
    /** Target chat */
    readonly chat_id?: number,
    /** Information about the message to be replied; pass null if none */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /**
     * Pass true if the content of the message must be protected from forwarding and
     * saving
     */
    readonly protect_content?: boolean,
    /** Identifier of the effect to apply to the message */
    readonly effect_id?: number | string,
    /** Markup for replying to the message; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** The content of the message to be sent */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type sendBusinessMessageAlbum = {
    /**
     * Sends 2-10 messages grouped together into an album on behalf of a business account;
     * for bots only. Currently, only audio, document, photo and video messages can
     * be grouped into an album. Documents and audio files can be only grouped in an
     * album with messages of the same type. Returns sent messages
     */
    readonly _: 'sendBusinessMessageAlbum',
    /** Unique identifier of business connection on behalf of which to send the request */
    readonly business_connection_id?: string,
    /** Target chat */
    readonly chat_id?: number,
    /** Information about the message to be replied; pass null if none */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /**
     * Pass true if the content of the message must be protected from forwarding and
     * saving
     */
    readonly protect_content?: boolean,
    /** Identifier of the effect to apply to the message */
    readonly effect_id?: number | string,
    /**
     * Contents of messages to be sent. At most 10 messages can be added to an album.
     * All messages must have the same value of show_caption_above_media
     */
    readonly input_message_contents?: ReadonlyArray<InputMessageContent$Input>,
  }

  export type editBusinessMessageText = {
    /**
     * Edits the text of a text or game message sent on behalf of a business account;
     * for bots only
     */
    readonly _: 'editBusinessMessageText',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editBusinessMessageLiveLocation = {
    /**
     * Edits the content of a live location in a message sent on behalf of a business
     * account; for bots only
     */
    readonly _: 'editBusinessMessageLiveLocation',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    readonly location?: location$Input,
    /**
     * New time relative to the message send date, for which the location can be updated,
     * in seconds. If 0x7FFFFFFF specified, then the location can be updated forever.
     * Otherwise, must not exceed the current live_period by more than a day, and the
     * live location expiration date must remain in the next 90 days. Pass 0 to keep
     * the current live_period
     */
    readonly live_period?: number,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    readonly heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    readonly proximity_alert_radius?: number,
  }

  export type editBusinessMessageChecklist = {
    /**
     * Edits the content of a checklist in a message sent on behalf of a business account;
     * for bots only
     */
    readonly _: 'editBusinessMessageChecklist',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** The new checklist. If some tasks were completed, this information will be kept */
    readonly checklist?: inputChecklist$Input,
  }

  export type editBusinessMessageMedia = {
    /**
     * Edits the media content of a message with a text, an animation, an audio, a
     * document, a photo or a video in a message sent on behalf of a business account;
     * for bots only
     */
    readonly _: 'editBusinessMessageMedia',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editBusinessMessageCaption = {
    /**
     * Edits the caption of a message sent on behalf of a business account; for bots
     * only
     */
    readonly _: 'editBusinessMessageCaption',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * Pass true to show the caption above the media; otherwise, the caption will be
     * shown below the media. May be true only for animation, photo, and video messages
     */
    readonly show_caption_above_media?: boolean,
  }

  export type editBusinessMessageReplyMarkup = {
    /**
     * Edits the reply markup of a message sent on behalf of a business account; for
     * bots only
     */
    readonly _: 'editBusinessMessageReplyMarkup',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type stopBusinessPoll = {
    /** Stops a poll sent on behalf of a business account; for bots only */
    readonly _: 'stopBusinessPoll',
    /**
     * Unique identifier of business connection on behalf of which the message with
     * the poll was sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type setBusinessMessageIsPinned = {
    /** Pins or unpins a message sent on behalf of a business account; for bots only */
    readonly _: 'setBusinessMessageIsPinned',
    /**
     * Unique identifier of business connection on behalf of which the message was
     * sent
     */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true to pin the message, pass false to unpin it */
    readonly is_pinned?: boolean,
  }

  export type readBusinessMessage = {
    /** Reads a message on behalf of a business account; for bots only */
    readonly _: 'readBusinessMessage',
    /** Unique identifier of business connection through which the message was received */
    readonly business_connection_id?: string,
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type deleteBusinessMessages = {
    /** Deletes messages on behalf of a business account; for bots only */
    readonly _: 'deleteBusinessMessages',
    /** Unique identifier of business connection through which the messages were received */
    readonly business_connection_id?: string,
    /** Identifier of the messages */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type editBusinessStory = {
    /**
     * Changes a story posted by the bot on behalf of a business account; for bots
     * only
     */
    readonly _: 'editBusinessStory',
    /** Identifier of the chat that posted the story */
    readonly story_poster_chat_id?: number,
    /** Identifier of the story to edit */
    readonly story_id?: number,
    /** New content of the story */
    readonly content?: InputStoryContent$Input,
    /** New clickable rectangle areas to be shown on the story media */
    readonly areas?: inputStoryAreas$Input,
    /** New story caption */
    readonly caption?: formattedText$Input,
    /** The new privacy settings for the story */
    readonly privacy_settings?: StoryPrivacySettings$Input,
  }

  export type deleteBusinessStory = {
    /**
     * Deletes a story posted by the bot on behalf of a business account; for bots
     * only
     */
    readonly _: 'deleteBusinessStory',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
    /** Identifier of the story to delete */
    readonly story_id?: number,
  }

  export type setBusinessAccountName = {
    /** Changes the first and last name of a business account; for bots only */
    readonly _: 'setBusinessAccountName',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
    /** The new value of the first name for the business account; 1-64 characters */
    readonly first_name?: string,
    /** The new value of the optional last name for the business account; 0-64 characters */
    readonly last_name?: string,
  }

  export type setBusinessAccountBio = {
    /** Changes the bio of a business account; for bots only */
    readonly _: 'setBusinessAccountBio',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
    /**
     * The new value of the bio; 0-getOption("bio_length_max") characters without line
     * feeds
     */
    readonly bio?: string,
  }

  export type setBusinessAccountProfilePhoto = {
    /** Changes a profile photo of a business account; for bots only */
    readonly _: 'setBusinessAccountProfilePhoto',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
    /** Profile photo to set; pass null to remove the photo */
    readonly photo?: InputChatPhoto$Input,
    /**
     * Pass true to set the public photo, which will be visible even the main photo
     * is hidden by privacy settings
     */
    readonly is_public?: boolean,
  }

  export type setBusinessAccountUsername = {
    /** Changes the editable username of a business account; for bots only */
    readonly _: 'setBusinessAccountUsername',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
    /** The new value of the username */
    readonly username?: string,
  }

  export type setBusinessAccountGiftSettings = {
    /** Changes settings for gift receiving of a business account; for bots only */
    readonly _: 'setBusinessAccountGiftSettings',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
    /** The new settings */
    readonly settings?: giftSettings$Input,
  }

  export type getBusinessAccountStarAmount = {
    /** Returns the amount of Telegram Stars owned by a business account; for bots only */
    readonly _: 'getBusinessAccountStarAmount',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
  }

  export type transferBusinessAccountStars = {
    /**
     * Transfer Telegram Stars from the business account to the business bot; for bots
     * only
     */
    readonly _: 'transferBusinessAccountStars',
    /** Unique identifier of business connection */
    readonly business_connection_id?: string,
    /** Number of Telegram Stars to transfer */
    readonly star_count?: number,
  }

  export type checkQuickReplyShortcutName = {
    /** Checks validness of a name for a quick reply shortcut. Can be called synchronously */
    readonly _: 'checkQuickReplyShortcutName',
    /** The name of the shortcut; 1-32 characters */
    readonly name?: string,
  }

  export type loadQuickReplyShortcuts = {
    /**
     * Loads quick reply shortcuts created by the current user. The loaded data will
     * be sent through updateQuickReplyShortcut and updateQuickReplyShortcuts
     */
    readonly _: 'loadQuickReplyShortcuts',
  }

  export type setQuickReplyShortcutName = {
    /** Changes name of a quick reply shortcut */
    readonly _: 'setQuickReplyShortcutName',
    /** Unique identifier of the quick reply shortcut */
    readonly shortcut_id?: number,
    /** New name for the shortcut. Use checkQuickReplyShortcutName to check its validness */
    readonly name?: string,
  }

  export type deleteQuickReplyShortcut = {
    /** Deletes a quick reply shortcut */
    readonly _: 'deleteQuickReplyShortcut',
    /** Unique identifier of the quick reply shortcut */
    readonly shortcut_id?: number,
  }

  export type reorderQuickReplyShortcuts = {
    /** Changes the order of quick reply shortcuts */
    readonly _: 'reorderQuickReplyShortcuts',
    /** The new order of quick reply shortcuts */
    readonly shortcut_ids?: ReadonlyArray<number>,
  }

  export type loadQuickReplyShortcutMessages = {
    /**
     * Loads quick reply messages that can be sent by a given quick reply shortcut.
     * The loaded messages will be sent through updateQuickReplyShortcutMessages
     */
    readonly _: 'loadQuickReplyShortcutMessages',
    /** Unique identifier of the quick reply shortcut */
    readonly shortcut_id?: number,
  }

  export type deleteQuickReplyShortcutMessages = {
    /** Deletes specified quick reply messages */
    readonly _: 'deleteQuickReplyShortcutMessages',
    /** Unique identifier of the quick reply shortcut to which the messages belong */
    readonly shortcut_id?: number,
    /** Unique identifiers of the messages */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type addQuickReplyShortcutMessage = {
    /**
     * Adds a message to a quick reply shortcut. If shortcut doesn't exist and there
     * are less than getOption("quick_reply_shortcut_count_max") shortcuts, then a
     * new shortcut is created. The shortcut must not contain more than getOption("quick_reply_shortcut_message_count_max")
     * messages after adding the new message. Returns the added message
     */
    readonly _: 'addQuickReplyShortcutMessage',
    /** Name of the target shortcut */
    readonly shortcut_name?: string,
    /**
     * Identifier of a quick reply message in the same shortcut to be replied; pass
     * 0 if none
     */
    readonly reply_to_message_id?: number,
    /**
     * The content of the message to be added; inputMessagePaidMedia, inputMessageForwarded
     * and inputMessageLocation with live_period aren't supported
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type addQuickReplyShortcutInlineQueryResultMessage = {
    /**
     * Adds a message to a quick reply shortcut via inline bot. If shortcut doesn't
     * exist and there are less than getOption("quick_reply_shortcut_count_max") shortcuts,
     * then a new shortcut is created. The shortcut must not contain more than getOption("quick_reply_shortcut_message_count_max")
     * messages after adding the new message. Returns the added message
     */
    readonly _: 'addQuickReplyShortcutInlineQueryResultMessage',
    /** Name of the target shortcut */
    readonly shortcut_name?: string,
    /**
     * Identifier of a quick reply message in the same shortcut to be replied; pass
     * 0 if none
     */
    readonly reply_to_message_id?: number,
    /** Identifier of the inline query */
    readonly query_id?: number | string,
    /** Identifier of the inline query result */
    readonly result_id?: string,
    /**
     * Pass true to hide the bot, via which the message is sent. Can be used only for
     * bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"),
     * and getOption("venue_search_bot_username")
     */
    readonly hide_via_bot?: boolean,
  }

  export type addQuickReplyShortcutMessageAlbum = {
    /**
     * Adds 2-10 messages grouped together into an album to a quick reply shortcut.
     * Currently, only audio, document, photo and video messages can be grouped into
     * an album. Documents and audio files can be only grouped in an album with messages
     * of the same type. Returns sent messages
     */
    readonly _: 'addQuickReplyShortcutMessageAlbum',
    /** Name of the target shortcut */
    readonly shortcut_name?: string,
    /**
     * Identifier of a quick reply message in the same shortcut to be replied; pass
     * 0 if none
     */
    readonly reply_to_message_id?: number,
    /**
     * Contents of messages to be sent. At most 10 messages can be added to an album.
     * All messages must have the same value of show_caption_above_media
     */
    readonly input_message_contents?: ReadonlyArray<InputMessageContent$Input>,
  }

  export type readdQuickReplyShortcutMessages = {
    /**
     * Readds quick reply messages which failed to add. Can be called only for messages
     * for which messageSendingStateFailed.can_retry is true and after specified in
     * messageSendingStateFailed.retry_after time passed. If a message is readded,
     * the corresponding failed to send message is deleted. Returns the sent messages
     * in the same order as the message identifiers passed in message_ids. If a message
     * can't be readded, null will be returned instead of the message
     */
    readonly _: 'readdQuickReplyShortcutMessages',
    /** Name of the target shortcut */
    readonly shortcut_name?: string,
    /**
     * Identifiers of the quick reply messages to readd. Message identifiers must be
     * in a strictly increasing order
     */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type editQuickReplyMessage = {
    /**
     * Asynchronously edits the text, media or caption of a quick reply message. Use
     * quickReplyMessage.can_be_edited to check whether a message can be edited. Media
     * message can be edited only to a media message. Checklist messages can be edited
     * only to a checklist message. The type of message content in an album can't be
     * changed with exception of replacing a photo with a video or vice versa
     */
    readonly _: 'editQuickReplyMessage',
    /** Unique identifier of the quick reply shortcut with the message */
    readonly shortcut_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageChecklist, inputMessageDocument, inputMessagePhoto,
     * inputMessageText, or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type getForumTopicDefaultIcons = {
    /**
     * Returns the list of custom emoji, which can be used as forum topic icon by all
     * users
     */
    readonly _: 'getForumTopicDefaultIcons',
  }

  export type createForumTopic = {
    /**
     * Creates a topic in a forum supergroup chat; requires can_manage_topics administrator
     * or can_create_topics member right in the supergroup
     */
    readonly _: 'createForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Name of the topic; 1-128 characters */
    readonly name?: string,
    /**
     * Icon of the topic. Icon color must be one of 0x6FB9F0, 0xFFD67E, 0xCB86DB, 0x8EEE98,
     * 0xFF93B2, or 0xFB6F5F. Telegram Premium users can use any custom emoji as topic
     * icon, other users can use only a custom emoji returned by getForumTopicDefaultIcons
     */
    readonly icon?: forumTopicIcon$Input,
  }

  export type editForumTopic = {
    /**
     * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics
     * right in the supergroup unless the user is creator of the topic
     */
    readonly _: 'editForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /**
     * New name of the topic; 0-128 characters. If empty, the previous topic name is
     * kept
     */
    readonly name?: string,
    /**
     * Pass true to edit the icon of the topic. Icon of the General topic can't be
     * edited
     */
    readonly edit_icon_custom_emoji?: boolean,
    /**
     * Identifier of the new custom emoji for topic icon; pass 0 to remove the custom
     * emoji. Ignored if edit_icon_custom_emoji is false. Telegram Premium users can
     * use any custom emoji, other users can use only a custom emoji returned by getForumTopicDefaultIcons
     */
    readonly icon_custom_emoji_id?: number | string,
  }

  export type getForumTopic = {
    /** Returns information about a forum topic */
    readonly _: 'getForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
  }

  export type getForumTopicLink = {
    /** Returns an HTTPS link to a topic in a forum chat. This is an offline method */
    readonly _: 'getForumTopicLink',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
  }

  export type getForumTopics = {
    /**
     * Returns found forum topics in a forum chat. This is a temporary method for getting
     * information about topic list from the server
     */
    readonly _: 'getForumTopics',
    /** Identifier of the forum chat */
    readonly chat_id?: number,
    /** Query to search for in the forum topic's name */
    readonly query?: string,
    /**
     * The date starting from which the results need to be fetched. Use 0 or any date
     * in the future to get results from the last topic
     */
    readonly offset_date?: number,
    /**
     * The message identifier of the last message in the last found topic, or 0 for
     * the first request
     */
    readonly offset_message_id?: number,
    /** The message thread identifier of the last found topic, or 0 for the first request */
    readonly offset_message_thread_id?: number,
    /**
     * The maximum number of forum topics to be returned; up to 100. For optimal performance,
     * the number of returned forum topics is chosen by TDLib and can be smaller than
     * the specified limit
     */
    readonly limit?: number,
  }

  export type setForumTopicNotificationSettings = {
    /** Changes the notification settings of a forum topic */
    readonly _: 'setForumTopicNotificationSettings',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /**
     * New notification settings for the forum topic. If the topic is muted for more
     * than 366 days, it is considered to be muted forever
     */
    readonly notification_settings?: chatNotificationSettings$Input,
  }

  export type toggleForumTopicIsClosed = {
    /**
     * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics
     * right in the supergroup unless the user is creator of the topic
     */
    readonly _: 'toggleForumTopicIsClosed',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /** Pass true to close the topic; pass false to reopen it */
    readonly is_closed?: boolean,
  }

  export type toggleGeneralForumTopicIsHidden = {
    /**
     * Toggles whether a General topic is hidden in a forum supergroup chat; requires
     * can_manage_topics right in the supergroup
     */
    readonly _: 'toggleGeneralForumTopicIsHidden',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Pass true to hide and close the General topic; pass false to unhide it */
    readonly is_hidden?: boolean,
  }

  export type toggleForumTopicIsPinned = {
    /**
     * Changes the pinned state of a forum topic; requires can_manage_topics right
     * in the supergroup. There can be up to getOption("pinned_forum_topic_count_max")
     * pinned forum topics
     */
    readonly _: 'toggleForumTopicIsPinned',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /** Pass true to pin the topic; pass false to unpin it */
    readonly is_pinned?: boolean,
  }

  export type setPinnedForumTopics = {
    /**
     * Changes the order of pinned forum topics; requires can_manage_topics right in
     * the supergroup
     */
    readonly _: 'setPinnedForumTopics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The new list of pinned forum topics */
    readonly message_thread_ids?: ReadonlyArray<number>,
  }

  export type deleteForumTopic = {
    /**
     * Deletes all messages in a forum topic; requires can_delete_messages administrator
     * right in the supergroup unless the user is creator of the topic, the topic has
     * no messages from other users and has at most 11 messages
     */
    readonly _: 'deleteForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
  }

  export type getEmojiReaction = {
    /**
     * Returns information about an emoji reaction. Returns a 404 error if the reaction
     * is not found
     */
    readonly _: 'getEmojiReaction',
    /** Text representation of the reaction */
    readonly emoji?: string,
  }

  export type getCustomEmojiReactionAnimations = {
    /** Returns TGS stickers with generic animations for custom emoji reactions */
    readonly _: 'getCustomEmojiReactionAnimations',
  }

  export type getMessageAvailableReactions = {
    /**
     * Returns reactions, which can be added to a message. The list can change after
     * updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo
     * for the message
     */
    readonly _: 'getMessageAvailableReactions',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Number of reaction per row, 5-25 */
    readonly row_size?: number,
  }

  export type clearRecentReactions = {
    /** Clears the list of recently used reactions */
    readonly _: 'clearRecentReactions',
  }

  export type addMessageReaction = {
    /**
     * Adds a reaction or a tag to a message. Use getMessageAvailableReactions to receive
     * the list of available reactions for the message
     */
    readonly _: 'addMessageReaction',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * Type of the reaction to add. Use addPendingPaidMessageReaction instead to add
     * the paid reaction
     */
    readonly reaction_type?: ReactionType$Input,
    /** Pass true if the reaction is added with a big animation */
    readonly is_big?: boolean,
    /**
     * Pass true if the reaction needs to be added to recent reactions; tags are never
     * added to the list of recent reactions
     */
    readonly update_recent_reactions?: boolean,
  }

  export type removeMessageReaction = {
    /** Removes a reaction from a message. A chosen reaction can always be removed */
    readonly _: 'removeMessageReaction',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Type of the reaction to remove. The paid reaction can't be removed */
    readonly reaction_type?: ReactionType$Input,
  }

  export type getChatAvailablePaidMessageReactionSenders = {
    /**
     * Returns the list of message sender identifiers, which can be used to send a
     * paid reaction in a chat
     */
    readonly _: 'getChatAvailablePaidMessageReactionSenders',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addPendingPaidMessageReaction = {
    /**
     * Adds the paid message reaction to a message. Use getMessageAvailableReactions
     * to check whether the reaction is available for the message
     */
    readonly _: 'addPendingPaidMessageReaction',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * Number of Telegram Stars to be used for the reaction. The total number of pending
     * paid reactions must not exceed getOption("paid_reaction_star_count_max")
     */
    readonly star_count?: number,
    /**
     * Type of the paid reaction; pass null if the user didn't choose reaction type
     * explicitly, for example, the reaction is set from the message bubble
     */
    readonly type?: PaidReactionType$Input,
  }

  export type commitPendingPaidMessageReactions = {
    /** Applies all pending paid reactions on a message */
    readonly _: 'commitPendingPaidMessageReactions',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type removePendingPaidMessageReactions = {
    /** Removes all pending paid reactions on a message */
    readonly _: 'removePendingPaidMessageReactions',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type setPaidMessageReactionType = {
    /**
     * Changes type of paid message reaction of the current user on a message. The
     * message must have paid reaction added by the current user
     */
    readonly _: 'setPaidMessageReactionType',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** New type of the paid reaction */
    readonly type?: PaidReactionType$Input,
  }

  export type setMessageReactions = {
    /** Sets reactions on a message; for bots only */
    readonly _: 'setMessageReactions',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Types of the reaction to set; pass an empty list to remove the reactions */
    readonly reaction_types?: ReadonlyArray<ReactionType$Input>,
    /** Pass true if the reactions are added with a big animation */
    readonly is_big?: boolean,
  }

  export type getMessageAddedReactions = {
    /** Returns reactions added for a message, along with their sender */
    readonly _: 'getMessageAddedReactions',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /**
     * Identifier of the message. Use message.interaction_info.reactions.can_get_added_reactions
     * to check whether added reactions can be received for the message
     */
    readonly message_id?: number,
    /**
     * Type of the reactions to return; pass null to return all added reactions; reactionTypePaid
     * isn't supported
     */
    readonly reaction_type?: ReactionType$Input,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of reactions to be returned; must be positive and can't be
     * greater than 100
     */
    readonly limit?: number,
  }

  export type setDefaultReactionType = {
    /** Changes type of default reaction for the current user */
    readonly _: 'setDefaultReactionType',
    /** New type of the default reaction. The paid reaction can't be set as default */
    readonly reaction_type?: ReactionType$Input,
  }

  export type getSavedMessagesTags = {
    /** Returns tags used in Saved Messages or a Saved Messages topic */
    readonly _: 'getSavedMessagesTags',
    /**
     * Identifier of Saved Messages topic which tags will be returned; pass 0 to get
     * all Saved Messages tags
     */
    readonly saved_messages_topic_id?: number,
  }

  export type setSavedMessagesTagLabel = {
    /** Changes label of a Saved Messages tag; for Telegram Premium users only */
    readonly _: 'setSavedMessagesTagLabel',
    /** The tag which label will be changed */
    readonly tag?: ReactionType$Input,
    /** New label for the tag; 0-12 characters */
    readonly label?: string,
  }

  export type getMessageEffect = {
    /**
     * Returns information about a message effect. Returns a 404 error if the effect
     * is not found
     */
    readonly _: 'getMessageEffect',
    /** Unique identifier of the effect */
    readonly effect_id?: number | string,
  }

  export type searchQuote = {
    /**
     * Searches for a given quote in a text. Returns found quote start position in
     * UTF-16 code units. Returns a 404 error if the quote is not found. Can be called
     * synchronously
     */
    readonly _: 'searchQuote',
    /** Text in which to search for the quote */
    readonly text?: formattedText$Input,
    /** Quote to search for */
    readonly quote?: formattedText$Input,
    /** Approximate quote position in UTF-16 code units */
    readonly quote_position?: number,
  }

  export type getTextEntities = {
    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card
     * numbers, URLs, and email addresses) found in the text. Can be called synchronously
     */
    readonly _: 'getTextEntities',
    /** The text in which to look for entities */
    readonly text?: string,
  }

  export type parseTextEntities = {
    /**
     * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote,
     * ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities from
     * a marked-up text. Can be called synchronously
     */
    readonly _: 'parseTextEntities',
    /** The text to parse */
    readonly text?: string,
    /** Text parse mode */
    readonly parse_mode?: TextParseMode$Input,
  }

  export type parseMarkdown = {
    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup errors.
     * Can be called synchronously
     */
    readonly _: 'parseMarkdown',
    /**
     * The text to parse. For example, "__italic__ ~~strikethrough~~ ||spoiler|| **bold**
     * `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
     */
    readonly text?: formattedText$Input,
  }

  export type getMarkdownText = {
    /**
     * Replaces text entities with Markdown formatting in a human-friendly format.
     * Entities that can't be represented in Markdown unambiguously are kept as is.
     * Can be called synchronously
     */
    readonly _: 'getMarkdownText',
    /** The text */
    readonly text?: formattedText$Input,
  }

  export type getCountryFlagEmoji = {
    /**
     * Returns an emoji for the given country. Returns an empty string on failure.
     * Can be called synchronously
     */
    readonly _: 'getCountryFlagEmoji',
    /** A two-letter ISO 3166-1 alpha-2 country code as received from getCountries */
    readonly country_code?: string,
  }

  export type getFileMimeType = {
    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an empty
     * string on failure. Can be called synchronously
     */
    readonly _: 'getFileMimeType',
    /** The name of the file or path to the file */
    readonly file_name?: string,
  }

  export type getFileExtension = {
    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an empty
     * string on failure. Can be called synchronously
     */
    readonly _: 'getFileExtension',
    /** The MIME type of the file */
    readonly mime_type?: string,
  }

  export type cleanFileName = {
    /**
     * Removes potentially dangerous characters from the name of a file. Returns an
     * empty string on failure. Can be called synchronously
     */
    readonly _: 'cleanFileName',
    /** File name or path to the file */
    readonly file_name?: string,
  }

  export type getLanguagePackString = {
    /**
     * Returns a string stored in the local database from the specified localization
     * target and language pack by its key. Returns a 404 error if the string is not
     * found. Can be called synchronously
     */
    readonly _: 'getLanguagePackString',
    /** Path to the language pack database in which strings are stored */
    readonly language_pack_database_path?: string,
    /** Localization target to which the language pack belongs */
    readonly localization_target?: string,
    /** Language pack identifier */
    readonly language_pack_id?: string,
    /** Language pack key of the string to be returned */
    readonly key?: string,
  }

  export type getJsonValue = {
    /**
     * Converts a JSON-serialized string to corresponding JsonValue object. Can be
     * called synchronously
     */
    readonly _: 'getJsonValue',
    /** The JSON-serialized string */
    readonly json?: string,
  }

  export type getJsonString = {
    /**
     * Converts a JsonValue object to corresponding JSON-serialized string. Can be
     * called synchronously
     */
    readonly _: 'getJsonString',
    /** The JsonValue object */
    readonly json_value?: JsonValue$Input,
  }

  export type getThemeParametersJsonString = {
    /**
     * Converts a themeParameters object to corresponding JSON-serialized string. Can
     * be called synchronously
     */
    readonly _: 'getThemeParametersJsonString',
    /** Theme parameters to convert to JSON */
    readonly theme?: themeParameters$Input,
  }

  export type setPollAnswer = {
    /**
     * Changes the user answer to a poll. A poll in quiz mode can be answered only
     * once
     */
    readonly _: 'setPollAnswer',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /**
     * 0-based identifiers of answer options, chosen by the user. User can choose more
     * than 1 answer option only is the poll allows multiple answers
     */
    readonly option_ids?: ReadonlyArray<number>,
  }

  export type getPollVoters = {
    /**
     * Returns message senders voted for the specified option in a non-anonymous polls.
     * For optimal performance, the number of returned users is chosen by TDLib
     */
    readonly _: 'getPollVoters',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /** 0-based identifier of the answer option */
    readonly option_id?: number,
    /** Number of voters to skip in the result; must be non-negative */
    readonly offset?: number,
    /**
     * The maximum number of voters to be returned; must be positive and can't be greater
     * than 50. For optimal performance, the number of returned voters is chosen by
     * TDLib and can be smaller than the specified limit, even if the end of the voter
     * list has not been reached
     */
    readonly limit?: number,
  }

  export type stopPoll = {
    /** Stops a poll */
    readonly _: 'stopPoll',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /**
     * Identifier of the message containing the poll. Use messageProperties.can_be_edited
     * to check whether the poll can be stopped
     */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type addChecklistTasks = {
    /** Adds tasks to a checklist in a message */
    readonly _: 'addChecklistTasks',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /**
     * Identifier of the message containing the checklist. Use messageProperties.can_add_tasks
     * to check whether the tasks can be added
     */
    readonly message_id?: number,
    /** List of added tasks */
    readonly tasks?: ReadonlyArray<inputChecklistTask$Input>,
  }

  export type markChecklistTasksAsDone = {
    /** Adds tasks of a checklist in a message as done or not done */
    readonly _: 'markChecklistTasksAsDone',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /**
     * Identifier of the message containing the checklist. Use messageProperties.can_mark_tasks_as_done
     * to check whether the tasks can be marked as done or not done
     */
    readonly message_id?: number,
    /** Identifiers of tasks that were marked as done */
    readonly marked_as_done_task_ids?: ReadonlyArray<number>,
    /** Identifiers of tasks that were marked as not done */
    readonly marked_as_not_done_task_ids?: ReadonlyArray<number>,
  }

  export type hideSuggestedAction = {
    /** Hides a suggested action */
    readonly _: 'hideSuggestedAction',
    /** Suggested action to hide */
    readonly action?: SuggestedAction$Input,
  }

  export type hideContactCloseBirthdays = {
    /** Hides the list of contacts that have close birthdays for 24 hours */
    readonly _: 'hideContactCloseBirthdays',
  }

  export type getBusinessConnection = {
    /**
     * Returns information about a business connection by its identifier; for bots
     * only
     */
    readonly _: 'getBusinessConnection',
    /** Identifier of the business connection to return */
    readonly connection_id?: string,
  }

  export type getLoginUrlInfo = {
    /**
     * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl.
     * The method needs to be called when the user presses the button
     */
    readonly _: 'getLoginUrlInfo',
    /** Chat identifier of the message with the button */
    readonly chat_id?: number,
    /** Message identifier of the message with the button. The message must not be scheduled */
    readonly message_id?: number,
    /** Button identifier */
    readonly button_id?: number,
  }

  export type getLoginUrl = {
    /**
     * Returns an HTTP URL which can be used to automatically authorize the user on
     * a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
     * Use the method getLoginUrlInfo to find whether a prior user confirmation is
     * needed. If an error is returned, then the button must be handled as an ordinary
     * URL button
     */
    readonly _: 'getLoginUrl',
    /** Chat identifier of the message with the button */
    readonly chat_id?: number,
    /** Message identifier of the message with the button */
    readonly message_id?: number,
    /** Button identifier */
    readonly button_id?: number,
    /** Pass true to allow the bot to send messages to the current user */
    readonly allow_write_access?: boolean,
  }

  export type shareUsersWithBot = {
    /**
     * Shares users after pressing a keyboardButtonTypeRequestUsers button with the
     * bot
     */
    readonly _: 'shareUsersWithBot',
    /** Identifier of the chat with the bot */
    readonly chat_id?: number,
    /** Identifier of the message with the button */
    readonly message_id?: number,
    /** Identifier of the button */
    readonly button_id?: number,
    /** Identifiers of the shared users */
    readonly shared_user_ids?: ReadonlyArray<number>,
    /**
     * Pass true to check that the users can be shared by the button instead of actually
     * sharing them
     */
    readonly only_check?: boolean,
  }

  export type shareChatWithBot = {
    /**
     * Shares a chat after pressing a keyboardButtonTypeRequestChat button with the
     * bot
     */
    readonly _: 'shareChatWithBot',
    /** Identifier of the chat with the bot */
    readonly chat_id?: number,
    /** Identifier of the message with the button */
    readonly message_id?: number,
    /** Identifier of the button */
    readonly button_id?: number,
    /** Identifier of the shared chat */
    readonly shared_chat_id?: number,
    /**
     * Pass true to check that the chat can be shared by the button instead of actually
     * sharing it. Doesn't check bot_is_member and bot_administrator_rights restrictions.
     * If the bot must be a member, then all chats from getGroupsInCommon and all chats,
     * where the user can add the bot, are suitable. In the latter case the bot will
     * be automatically added to the chat. If the bot must be an administrator, then
     * all chats, where the bot already has requested rights or can be added to administrators
     * by the user, are suitable. In the latter case the bot will be automatically
     * granted requested rights
     */
    readonly only_check?: boolean,
  }

  export type getInlineQueryResults = {
    /**
     * Sends an inline query to a bot and returns its results. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    readonly _: 'getInlineQueryResults',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Identifier of the chat where the query was sent */
    readonly chat_id?: number,
    /** Location of the user; pass null if unknown or the bot doesn't need user's location */
    readonly user_location?: location$Input,
    /** Text of the query */
    readonly query?: string,
    /**
     * Offset of the first entry to return; use empty string to get the first chunk
     * of results
     */
    readonly offset?: string,
  }

  export type answerInlineQuery = {
    /** Sets the result of an inline query; for bots only */
    readonly _: 'answerInlineQuery',
    /** Identifier of the inline query */
    readonly inline_query_id?: number | string,
    /**
     * Pass true if results may be cached and returned only for the user that sent
     * the query. By default, results may be returned to any user who sends the same
     * query
     */
    readonly is_personal?: boolean,
    /** Button to be shown above inline query results; pass null if none */
    readonly button?: inlineQueryResultsButton$Input,
    /** The results of the query */
    readonly results?: ReadonlyArray<InputInlineQueryResult$Input>,
    /** Allowed time to cache the results of the query, in seconds */
    readonly cache_time?: number,
    /**
     * Offset for the next inline query; pass an empty string if there are no more
     * results
     */
    readonly next_offset?: string,
  }

  export type savePreparedInlineMessage = {
    /** Saves an inline message to be sent by the given user; for bots only */
    readonly _: 'savePreparedInlineMessage',
    /** Identifier of the user */
    readonly user_id?: number,
    /** The description of the message */
    readonly result?: InputInlineQueryResult$Input,
    /** Types of the chats to which the message can be sent */
    readonly chat_types?: targetChatTypes$Input,
  }

  export type getPreparedInlineMessage = {
    /** Saves an inline message to be sent by the given user */
    readonly _: 'getPreparedInlineMessage',
    /** Identifier of the bot that created the message */
    readonly bot_user_id?: number,
    /** Identifier of the prepared message */
    readonly prepared_message_id?: string,
  }

  export type getGrossingWebAppBots = {
    /** Returns the most grossing Web App bots */
    readonly _: 'getGrossingWebAppBots',
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of bots to be returned; up to 100 */
    readonly limit?: number,
  }

  export type searchWebApp = {
    /**
     * Returns information about a Web App by its short name. Returns a 404 error if
     * the Web App is not found
     */
    readonly _: 'searchWebApp',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Short name of the Web App */
    readonly web_app_short_name?: string,
  }

  export type getWebAppPlaceholder = {
    /**
     * Returns a default placeholder for Web Apps of a bot. This is an offline method.
     * Returns a 404 error if the placeholder isn't known
     */
    readonly _: 'getWebAppPlaceholder',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
  }

  export type getWebAppLinkUrl = {
    /**
     * Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp
     * is clicked
     */
    readonly _: 'getWebAppLinkUrl',
    /** Identifier of the chat in which the link was clicked; pass 0 if none */
    readonly chat_id?: number,
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Short name of the Web App */
    readonly web_app_short_name?: string,
    /** Start parameter from internalLinkTypeWebApp */
    readonly start_parameter?: string,
    /** Pass true if the current user allowed the bot to send them messages */
    readonly allow_write_access?: boolean,
    /** Parameters to use to open the Web App */
    readonly parameters?: webAppOpenParameters$Input,
  }

  export type getMainWebApp = {
    /** Returns information needed to open the main Web App of a bot */
    readonly _: 'getMainWebApp',
    /** Identifier of the chat in which the Web App is opened; pass 0 if none */
    readonly chat_id?: number,
    /**
     * Identifier of the target bot. If the bot is restricted for the current user,
     * then show an error instead of calling the method
     */
    readonly bot_user_id?: number,
    /** Start parameter from internalLinkTypeMainWebApp */
    readonly start_parameter?: string,
    /** Parameters to use to open the Web App */
    readonly parameters?: webAppOpenParameters$Input,
  }

  export type getWebAppUrl = {
    /**
     * Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp
     * button, or an inlineQueryResultsButtonTypeWebApp button
     */
    readonly _: 'getWebAppUrl',
    /**
     * Identifier of the target bot. If the bot is restricted for the current user,
     * then show an error instead of calling the method
     */
    readonly bot_user_id?: number,
    /**
     * The URL from a keyboardButtonTypeWebApp button, inlineQueryResultsButtonTypeWebApp
     * button, or an empty string when the bot is opened from the side menu
     */
    readonly url?: string,
    /** Parameters to use to open the Web App */
    readonly parameters?: webAppOpenParameters$Input,
  }

  export type sendWebAppData = {
    /** Sends data received from a keyboardButtonTypeWebApp Web App to a bot */
    readonly _: 'sendWebAppData',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    readonly button_text?: string,
    /** The data */
    readonly data?: string,
  }

  export type openWebApp = {
    /**
     * Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton
     * button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp
     * button. For each bot, a confirmation alert about data sent to the bot must be
     * shown once
     */
    readonly _: 'openWebApp',
    /**
     * Identifier of the chat in which the Web App is opened. The Web App can't be
     * opened in secret chats
     */
    readonly chat_id?: number,
    /**
     * Identifier of the bot, providing the Web App. If the bot is restricted for the
     * current user, then show an error instead of calling the method
     */
    readonly bot_user_id?: number,
    /**
     * The URL from an inlineKeyboardButtonTypeWebApp button, a botMenuButton button,
     * an internalLinkTypeAttachmentMenuBot link, or an empty string otherwise
     */
    readonly url?: string,
    /** If not 0, the message thread identifier to which the message will be sent */
    readonly message_thread_id?: number,
    /**
     * If not 0, unique identifier of the topic of channel direct messages chat to
     * which the message will be sent
     */
    readonly direct_messages_chat_topic_id?: number,
    /**
     * Information about the message or story to be replied in the message sent by
     * the Web App; pass null if none
     */
    readonly reply_to?: InputMessageReplyTo$Input,
    /** Parameters to use to open the Web App */
    readonly parameters?: webAppOpenParameters$Input,
  }

  export type closeWebApp = {
    /** Informs TDLib that a previously opened Web App was closed */
    readonly _: 'closeWebApp',
    /** Identifier of Web App launch, received from openWebApp */
    readonly web_app_launch_id?: number | string,
  }

  export type answerWebAppQuery = {
    /**
     * Sets the result of interaction with a Web App and sends corresponding message
     * on behalf of the user to the chat from which the query originated; for bots
     * only
     */
    readonly _: 'answerWebAppQuery',
    /** Identifier of the Web App query */
    readonly web_app_query_id?: string,
    /** The result of the query */
    readonly result?: InputInlineQueryResult$Input,
  }

  export type checkWebAppFileDownload = {
    /** Checks whether a file can be downloaded and saved locally by Web App request */
    readonly _: 'checkWebAppFileDownload',
    /** Identifier of the bot, providing the Web App */
    readonly bot_user_id?: number,
    /** Name of the file */
    readonly file_name?: string,
    /** URL of the file */
    readonly url?: string,
  }

  export type getCallbackQueryAnswer = {
    /**
     * Sends a callback query to a bot and returns an answer. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    readonly _: 'getCallbackQueryAnswer',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /**
     * Identifier of the message from which the query originated. The message must
     * not be scheduled
     */
    readonly message_id?: number,
    /** Query payload */
    readonly payload?: CallbackQueryPayload$Input,
  }

  export type answerCallbackQuery = {
    /** Sets the result of a callback query; for bots only */
    readonly _: 'answerCallbackQuery',
    /** Identifier of the callback query */
    readonly callback_query_id?: number | string,
    /** Text of the answer */
    readonly text?: string,
    /** Pass true to show an alert to the user instead of a toast notification */
    readonly show_alert?: boolean,
    /** URL to be opened */
    readonly url?: string,
    /** Time during which the result of the query can be cached, in seconds */
    readonly cache_time?: number,
  }

  export type answerShippingQuery = {
    /** Sets the result of a shipping query; for bots only */
    readonly _: 'answerShippingQuery',
    /** Identifier of the shipping query */
    readonly shipping_query_id?: number | string,
    /** Available shipping options */
    readonly shipping_options?: ReadonlyArray<shippingOption$Input>,
    /** An error message, empty on success */
    readonly error_message?: string,
  }

  export type answerPreCheckoutQuery = {
    /** Sets the result of a pre-checkout query; for bots only */
    readonly _: 'answerPreCheckoutQuery',
    /** Identifier of the pre-checkout query */
    readonly pre_checkout_query_id?: number | string,
    /** An error message, empty on success */
    readonly error_message?: string,
  }

  export type setGameScore = {
    /** Updates the game score of the specified user in the game; for bots only */
    readonly _: 'setGameScore',
    /** The chat to which the message with the game belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true to edit the game message to include the current scoreboard */
    readonly edit_message?: boolean,
    /** User identifier */
    readonly user_id?: number,
    /** The new score */
    readonly score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    readonly force?: boolean,
  }

  export type setInlineGameScore = {
    /** Updates the game score of the specified user in a game; for bots only */
    readonly _: 'setInlineGameScore',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** Pass true to edit the game message to include the current scoreboard */
    readonly edit_message?: boolean,
    /** User identifier */
    readonly user_id?: number,
    /** The new score */
    readonly score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    readonly force?: boolean,
  }

  export type getGameHighScores = {
    /**
     * Returns the high scores for a game and some part of the high score table in
     * the range of the specified user; for bots only
     */
    readonly _: 'getGameHighScores',
    /** The chat that contains the message with the game */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** User identifier */
    readonly user_id?: number,
  }

  export type getInlineGameHighScores = {
    /**
     * Returns game high scores and some part of the high score table in the range
     * of the specified user; for bots only
     */
    readonly _: 'getInlineGameHighScores',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** User identifier */
    readonly user_id?: number,
  }

  export type deleteChatReplyMarkup = {
    /**
     * Deletes the default reply markup from a chat. Must be called after a one-time
     * keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup
     * update will be sent if the reply markup is changed
     */
    readonly _: 'deleteChatReplyMarkup',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The message identifier of the used keyboard */
    readonly message_id?: number,
  }

  export type sendChatAction = {
    /** Sends a notification about user activity in a chat */
    readonly _: 'sendChatAction',
    /** Chat identifier */
    readonly chat_id?: number,
    /** If not 0, the message thread identifier in which the action was performed */
    readonly message_thread_id?: number,
    /**
     * Unique identifier of business connection on behalf of which to send the request;
     * for bots only
     */
    readonly business_connection_id?: string,
    /** The action description; pass null to cancel the currently active action */
    readonly action?: ChatAction$Input,
  }

  export type openChat = {
    /**
     * Informs TDLib that the chat is opened by the user. Many useful activities depend
     * on the chat being opened or closed (e.g., in supergroups and channels all updates
     * are received only for opened chats)
     */
    readonly _: 'openChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type closeChat = {
    /**
     * Informs TDLib that the chat is closed by the user. Many useful activities depend
     * on the chat being opened or closed
     */
    readonly _: 'closeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type viewMessages = {
    /**
     * Informs TDLib that messages are being viewed by the user. Sponsored messages
     * must be marked as viewed only when the entire text of the message is shown on
     * the screen (excluding the button). Many useful activities depend on whether
     * the messages are currently being viewed or not (e.g., marking messages as read,
     * incrementing a view counter, updating a view counter, removing deleted messages
     * in supergroups and channels)
     */
    readonly _: 'viewMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The identifiers of the messages being viewed */
    readonly message_ids?: ReadonlyArray<number>,
    /**
     * Source of the message view; pass null to guess the source based on chat open
     * state
     */
    readonly source?: MessageSource$Input,
    /** Pass true to mark as read the specified messages even the chat is closed */
    readonly force_read?: boolean,
  }

  export type openMessageContent = {
    /**
     * Informs TDLib that the message content has been opened (e.g., the user has opened
     * a photo, video, document, location or venue, or has listened to an audio file
     * or voice note message). An updateMessageContentOpened update will be generated
     * if something has changed
     */
    readonly _: 'openMessageContent',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Identifier of the message with the opened content */
    readonly message_id?: number,
  }

  export type clickAnimatedEmojiMessage = {
    /**
     * Informs TDLib that a message with an animated emoji was clicked by the user.
     * Returns a big animated sticker to be played or a 404 error if usual animation
     * needs to be played
     */
    readonly _: 'clickAnimatedEmojiMessage',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Identifier of the clicked message */
    readonly message_id?: number,
  }

  export type getInternalLink = {
    /** Returns an HTTPS or a tg: link with the given type. Can be called before authorization */
    readonly _: 'getInternalLink',
    /** Expected type of the link */
    readonly type?: InternalLinkType$Input,
    /**
     * Pass true to create an HTTPS link (only available for some link types); pass
     * false to create a tg: link
     */
    readonly is_http?: boolean,
  }

  export type getInternalLinkType = {
    /**
     * Returns information about the type of internal link. Returns a 404 error if
     * the link is not internal. Can be called before authorization
     */
    readonly _: 'getInternalLinkType',
    /** The link */
    readonly link?: string,
  }

  export type getExternalLinkInfo = {
    /**
     * Returns information about an action to be done when the current user clicks
     * an external link. Don't use this method for links from secret chats if link
     * preview is disabled in secret chats
     */
    readonly _: 'getExternalLinkInfo',
    /** The link */
    readonly link?: string,
  }

  export type getExternalLink = {
    /**
     * Returns an HTTP URL which can be used to automatically authorize the current
     * user on a website after clicking an HTTP link. Use the method getExternalLinkInfo
     * to find whether a prior user confirmation is needed
     */
    readonly _: 'getExternalLink',
    /** The HTTP link */
    readonly link?: string,
    /**
     * Pass true if the current user allowed the bot, returned in getExternalLinkInfo,
     * to send them messages
     */
    readonly allow_write_access?: boolean,
  }

  export type readAllChatMentions = {
    /** Marks all mentions in a chat as read */
    readonly _: 'readAllChatMentions',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type readAllMessageThreadMentions = {
    /** Marks all mentions in a forum topic as read */
    readonly _: 'readAllMessageThreadMentions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier in which mentions are marked as read */
    readonly message_thread_id?: number,
  }

  export type readAllChatReactions = {
    /** Marks all reactions in a chat or a forum topic as read */
    readonly _: 'readAllChatReactions',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type readAllMessageThreadReactions = {
    /** Marks all reactions in a forum topic as read */
    readonly _: 'readAllMessageThreadReactions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier in which reactions are marked as read */
    readonly message_thread_id?: number,
  }

  export type createPrivateChat = {
    /** Returns an existing chat corresponding to a given user */
    readonly _: 'createPrivateChat',
    /** User identifier */
    readonly user_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createBasicGroupChat = {
    /** Returns an existing chat corresponding to a known basic group */
    readonly _: 'createBasicGroupChat',
    /** Basic group identifier */
    readonly basic_group_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createSupergroupChat = {
    /** Returns an existing chat corresponding to a known supergroup or channel */
    readonly _: 'createSupergroupChat',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createSecretChat = {
    /** Returns an existing chat corresponding to a known secret chat */
    readonly _: 'createSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type createNewBasicGroupChat = {
    /**
     * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate.
     * Returns information about the newly created chat
     */
    readonly _: 'createNewBasicGroupChat',
    /**
     * Identifiers of users to be added to the basic group; may be empty to create
     * a basic group without other members
     */
    readonly user_ids?: ReadonlyArray<number>,
    /** Title of the new basic group; 1-128 characters */
    readonly title?: string,
    /**
     * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400
     * and be divisible by 86400. If 0, then messages aren't deleted automatically
     */
    readonly message_auto_delete_time?: number,
  }

  export type createNewSupergroupChat = {
    /**
     * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate.
     * Returns the newly created chat
     */
    readonly _: 'createNewSupergroupChat',
    /** Title of the new chat; 1-128 characters */
    readonly title?: string,
    /** Pass true to create a forum supergroup chat */
    readonly is_forum?: boolean,
    /** Pass true to create a channel chat; ignored if a forum is created */
    readonly is_channel?: boolean,
    /** Chat description; 0-255 characters */
    readonly description?: string,
    /**
     * Chat location if a location-based supergroup is being created; pass null to
     * create an ordinary supergroup chat
     */
    readonly location?: chatLocation$Input,
    /**
     * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400
     * and be divisible by 86400. If 0, then messages aren't deleted automatically
     */
    readonly message_auto_delete_time?: number,
    /** Pass true to create a supergroup for importing messages using importMessages */
    readonly for_import?: boolean,
  }

  export type createNewSecretChat = {
    /** Creates a new secret chat. Returns the newly created chat */
    readonly _: 'createNewSecretChat',
    /** Identifier of the target user */
    readonly user_id?: number,
  }

  export type upgradeBasicGroupChatToSupergroupChat = {
    /**
     * Creates a new supergroup from an existing basic group and sends a corresponding
     * messageChatUpgradeTo and messageChatUpgradeFrom; requires owner privileges.
     * Deactivates the original basic group
     */
    readonly _: 'upgradeBasicGroupChatToSupergroupChat',
    /** Identifier of the chat to upgrade */
    readonly chat_id?: number,
  }

  export type getChatListsToAddChat = {
    /** Returns chat lists to which the chat can be added. This is an offline method */
    readonly _: 'getChatListsToAddChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addChatToList = {
    /**
     * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive
     * chat lists, so it is automatically removed from another one if needed
     */
    readonly _: 'addChatToList',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The chat list. Use getChatListsToAddChat to get suitable chat lists */
    readonly chat_list?: ChatList$Input,
  }

  export type getChatFolder = {
    /** Returns information about a chat folder by its identifier */
    readonly _: 'getChatFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type createChatFolder = {
    /**
     * Creates new chat folder. Returns information about the created chat folder.
     * There can be up to getOption("chat_folder_count_max") chat folders, but the
     * limit can be increased with Telegram Premium
     */
    readonly _: 'createChatFolder',
    /** The new chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type editChatFolder = {
    /** Edits existing chat folder. Returns information about the edited chat folder */
    readonly _: 'editChatFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** The edited chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type deleteChatFolder = {
    /** Deletes existing chat folder */
    readonly _: 'deleteChatFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /**
     * Identifiers of the chats to leave. The chats must be pinned or always included
     * in the folder
     */
    readonly leave_chat_ids?: ReadonlyArray<number>,
  }

  export type getChatFolderChatsToLeave = {
    /**
     * Returns identifiers of pinned or always included chats from a chat folder, which
     * are suggested to be left when the chat folder is deleted
     */
    readonly _: 'getChatFolderChatsToLeave',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type getChatFolderChatCount = {
    /**
     * Returns approximate number of chats in a being created chat folder. Main and
     * archive chat lists must be fully preloaded for this function to work correctly
     */
    readonly _: 'getChatFolderChatCount',
    /** The new chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type reorderChatFolders = {
    /** Changes the order of chat folders */
    readonly _: 'reorderChatFolders',
    /** Identifiers of chat folders in the new correct order */
    readonly chat_folder_ids?: ReadonlyArray<number>,
    /**
     * Position of the main chat list among chat folders, 0-based. Can be non-zero
     * only for Premium users
     */
    readonly main_chat_list_position?: number,
  }

  export type toggleChatFolderTags = {
    /** Toggles whether chat folder tags are enabled */
    readonly _: 'toggleChatFolderTags',
    /** Pass true to enable folder tags; pass false to disable them */
    readonly are_tags_enabled?: boolean,
  }

  export type getRecommendedChatFolders = {
    /** Returns recommended chat folders for the current user */
    readonly _: 'getRecommendedChatFolders',
  }

  export type getChatFolderDefaultIconName = {
    /** Returns default icon name for a folder. Can be called synchronously */
    readonly _: 'getChatFolderDefaultIconName',
    /** Chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type getChatsForChatFolderInviteLink = {
    /**
     * Returns identifiers of chats from a chat folder, suitable for adding to a chat
     * folder invite link
     */
    readonly _: 'getChatsForChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type createChatFolderInviteLink = {
    /**
     * Creates a new invite link for a chat folder. A link can be created for a chat
     * folder if it has only pinned and included chats
     */
    readonly _: 'createChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** Name of the link; 0-32 characters */
    readonly name?: string,
    /**
     * Identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink
     * to get suitable chats. Basic groups will be automatically converted to supergroups
     * before link creation
     */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type getChatFolderInviteLinks = {
    /** Returns invite links created by the current user for a shareable chat folder */
    readonly _: 'getChatFolderInviteLinks',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type editChatFolderInviteLink = {
    /** Edits an invite link for a chat folder */
    readonly _: 'editChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** Invite link to be edited */
    readonly invite_link?: string,
    /** New name of the link; 0-32 characters */
    readonly name?: string,
    /**
     * New identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink
     * to get suitable chats. Basic groups will be automatically converted to supergroups
     * before link editing
     */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type deleteChatFolderInviteLink = {
    /** Deletes an invite link for a chat folder */
    readonly _: 'deleteChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** Invite link to be deleted */
    readonly invite_link?: string,
  }

  export type checkChatFolderInviteLink = {
    /**
     * Checks the validity of an invite link for a chat folder and returns information
     * about the corresponding chat folder
     */
    readonly _: 'checkChatFolderInviteLink',
    /** Invite link to be checked */
    readonly invite_link?: string,
  }

  export type addChatFolderByInviteLink = {
    /** Adds a chat folder by an invite link */
    readonly _: 'addChatFolderByInviteLink',
    /** Invite link for the chat folder */
    readonly invite_link?: string,
    /**
     * Identifiers of the chats added to the chat folder. The chats are automatically
     * joined if they aren't joined yet
     */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type getChatFolderNewChats = {
    /**
     * Returns new chats added to a shareable chat folder by its owner. The method
     * must be called at most once in getOption("chat_folder_new_chats_update_period")
     * for the given chat folder
     */
    readonly _: 'getChatFolderNewChats',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type processChatFolderNewChats = {
    /** Process new chats added to a shareable chat folder by its owner */
    readonly _: 'processChatFolderNewChats',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /**
     * Identifiers of the new chats, which are added to the chat folder. The chats
     * are automatically joined if they aren't joined yet
     */
    readonly added_chat_ids?: ReadonlyArray<number>,
  }

  export type getArchiveChatListSettings = {
    /**
     * Returns settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    readonly _: 'getArchiveChatListSettings',
  }

  export type setArchiveChatListSettings = {
    /**
     * Changes settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    readonly _: 'setArchiveChatListSettings',
    /** New settings */
    readonly settings?: archiveChatListSettings$Input,
  }

  export type setChatTitle = {
    /**
     * Changes the chat title. Supported only for basic groups, supergroups and channels.
     * Requires can_change_info member right
     */
    readonly _: 'setChatTitle',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New title of the chat; 1-128 characters */
    readonly title?: string,
  }

  export type setChatPhoto = {
    /**
     * Changes the photo of a chat. Supported only for basic groups, supergroups and
     * channels. Requires can_change_info member right
     */
    readonly _: 'setChatPhoto',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New chat photo; pass null to delete the chat photo */
    readonly photo?: InputChatPhoto$Input,
  }

  export type setChatAccentColor = {
    /**
     * Changes accent color and background custom emoji of a channel chat. Requires
     * can_change_info administrator right
     */
    readonly _: 'setChatAccentColor',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the accent color to use. The chat must have at least accentColor.min_channel_chat_boost_level
     * boost level to pass the corresponding color
     */
    readonly accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background; 0 if none. Use chatBoostLevelFeatures.can_set_background_custom_emoji
     * to check whether a custom emoji can be set
     */
    readonly background_custom_emoji_id?: number | string,
  }

  export type setChatProfileAccentColor = {
    /**
     * Changes accent color and background custom emoji for profile of a supergroup
     * or channel chat. Requires can_change_info administrator right
     */
    readonly _: 'setChatProfileAccentColor',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the accent color to use for profile; pass -1 if none. The chat
     * must have at least profileAccentColor.min_supergroup_chat_boost_level for supergroups
     * or profileAccentColor.min_channel_chat_boost_level for channels boost level
     * to pass the corresponding color
     */
    readonly profile_accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the chat's profile photo background;
     * 0 if none. Use chatBoostLevelFeatures.can_set_profile_background_custom_emoji
     * to check whether a custom emoji can be set
     */
    readonly profile_background_custom_emoji_id?: number | string,
  }

  export type setChatMessageAutoDeleteTime = {
    /**
     * Changes the message auto-delete or self-destruct (for secret chats) time in
     * a chat. Requires change_info administrator right in basic groups, supergroups
     * and channels. Message auto-delete time can't be changed in a chat with the current
     * user (Saved Messages) and the chat 777000 (Telegram).
     */
    readonly _: 'setChatMessageAutoDeleteTime',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New time value, in seconds; unless the chat is secret, it must be from 0 up
     * to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted
     * automatically
     */
    readonly message_auto_delete_time?: number,
  }

  export type setChatEmojiStatus = {
    /**
     * Changes the emoji status of a chat. Use chatBoostLevelFeatures.can_set_emoji_status
     * to check whether an emoji status can be set. Requires can_change_info administrator
     * right
     */
    readonly _: 'setChatEmojiStatus',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New emoji status; pass null to remove emoji status */
    readonly emoji_status?: emojiStatus$Input,
  }

  export type setChatPermissions = {
    /**
     * Changes the chat members permissions. Supported only for basic groups and supergroups.
     * Requires can_restrict_members administrator right
     */
    readonly _: 'setChatPermissions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New non-administrator members permissions in the chat */
    readonly permissions?: chatPermissions$Input,
  }

  export type setChatBackground = {
    /**
     * Sets the background in a specific chat. Supported only in private and secret
     * chats with non-deleted users, and in chats with sufficient boost level and can_change_info
     * administrator right
     */
    readonly _: 'setChatBackground',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * The input background to use; pass null to create a new filled or chat theme
     * background
     */
    readonly background?: InputBackground$Input,
    /**
     * Background type; pass null to use default background type for the chosen background;
     * backgroundTypeChatTheme isn't supported for private and secret chats. Use chatBoostLevelFeatures.chat_theme_background_count
     * and chatBoostLevelFeatures.can_set_custom_background to check whether the background
     * type can be set in the boosted chat
     */
    readonly type?: BackgroundType$Input,
    /**
     * Dimming of the background in dark themes, as a percentage; 0-100. Applied only
     * to Wallpaper and Fill types of background
     */
    readonly dark_theme_dimming?: number,
    /**
     * Pass true to set background only for self; pass false to set background for
     * all chat users. Always false for backgrounds set in boosted chats. Background
     * can be set for both users only by Telegram Premium users and if set background
     * isn't of the type inputBackgroundPrevious
     */
    readonly only_for_self?: boolean,
  }

  export type deleteChatBackground = {
    /** Deletes background in a specific chat */
    readonly _: 'deleteChatBackground',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Pass true to restore previously set background. Can be used only in private
     * and secret chats with non-deleted users if userFullInfo.set_chat_background
     * == true. Supposed to be used from messageChatSetBackground messages with the
     * currently set background that was set for both sides by the other user
     */
    readonly restore_previous?: boolean,
  }

  export type setChatTheme = {
    /** Changes the chat theme. Supported only in private and secret chats */
    readonly _: 'setChatTheme',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Name of the new chat theme; pass an empty string to return the default theme */
    readonly theme_name?: string,
  }

  export type setChatDraftMessage = {
    /** Changes the draft message in a chat */
    readonly _: 'setChatDraftMessage',
    /** Chat identifier */
    readonly chat_id?: number,
    /** If not 0, the message thread identifier in which the draft was changed */
    readonly message_thread_id?: number,
    /**
     * New draft message; pass null to remove the draft. All files in draft message
     * content must be of the type inputFileLocal. Media thumbnails and captions are
     * ignored
     */
    readonly draft_message?: draftMessage$Input,
  }

  export type setChatNotificationSettings = {
    /**
     * Changes the notification settings of a chat. Notification settings of a chat
     * with the current user (Saved Messages) can't be changed
     */
    readonly _: 'setChatNotificationSettings',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New notification settings for the chat. If the chat is muted for more than 366
     * days, it is considered to be muted forever
     */
    readonly notification_settings?: chatNotificationSettings$Input,
  }

  export type toggleChatHasProtectedContent = {
    /**
     * Changes the ability of users to save, forward, or copy chat content. Supported
     * only for basic groups, supergroups and channels. Requires owner privileges
     */
    readonly _: 'toggleChatHasProtectedContent',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of has_protected_content */
    readonly has_protected_content?: boolean,
  }

  export type toggleChatViewAsTopics = {
    /** Changes the view_as_topics setting of a forum chat or Saved Messages */
    readonly _: 'toggleChatViewAsTopics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of view_as_topics */
    readonly view_as_topics?: boolean,
  }

  export type toggleChatIsTranslatable = {
    /** Changes the translatable state of a chat */
    readonly _: 'toggleChatIsTranslatable',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of is_translatable */
    readonly is_translatable?: boolean,
  }

  export type toggleChatIsMarkedAsUnread = {
    /** Changes the marked as unread state of a chat */
    readonly _: 'toggleChatIsMarkedAsUnread',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of is_marked_as_unread */
    readonly is_marked_as_unread?: boolean,
  }

  export type toggleChatDefaultDisableNotification = {
    /**
     * Changes the value of the default disable_notification parameter, used when a
     * message is sent to a chat
     */
    readonly _: 'toggleChatDefaultDisableNotification',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of default_disable_notification */
    readonly default_disable_notification?: boolean,
  }

  export type setChatAvailableReactions = {
    /**
     * Changes reactions, available in a chat. Available for basic groups, supergroups,
     * and channels. Requires can_change_info member right
     */
    readonly _: 'setChatAvailableReactions',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /**
     * Reactions available in the chat. All explicitly specified emoji reactions must
     * be active. In channel chats up to the chat's boost level custom emoji reactions
     * can be explicitly specified
     */
    readonly available_reactions?: ChatAvailableReactions$Input,
  }

  export type setChatClientData = {
    /** Changes application-specific data associated with a chat */
    readonly _: 'setChatClientData',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of client_data */
    readonly client_data?: string,
  }

  export type setChatDescription = {
    /**
     * Changes information about a chat. Available for basic groups, supergroups, and
     * channels. Requires can_change_info member right
     */
    readonly _: 'setChatDescription',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** New chat description; 0-255 characters */
    readonly description?: string,
  }

  export type setChatDiscussionGroup = {
    /**
     * Changes the discussion group of a channel chat; requires can_change_info administrator
     * right in the channel if it is specified
     */
    readonly _: 'setChatDiscussionGroup',
    /**
     * Identifier of the channel chat. Pass 0 to remove a link from the supergroup
     * passed in the second argument to a linked channel chat (requires can_pin_messages
     * member right in the supergroup)
     */
    readonly chat_id?: number,
    /**
     * Identifier of a new channel's discussion group. Use 0 to remove the discussion
     * group. Use the method getSuitableDiscussionChats to find all suitable groups.
     * Basic group chats must be first upgraded to supergroup chats. If new chat members
     * don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable
     * must be used first to change that
     */
    readonly discussion_chat_id?: number,
  }

  export type setChatDirectMessagesGroup = {
    /**
     * Changes direct messages group settings for a channel chat; requires owner privileges
     * in the chat
     */
    readonly _: 'setChatDirectMessagesGroup',
    /** Identifier of the channel chat */
    readonly chat_id?: number,
    /**
     * Pass true if the direct messages group is enabled for the channel chat; pass
     * false otherwise
     */
    readonly is_enabled?: boolean,
    /**
     * The new number of Telegram Stars that must be paid for each message that is
     * sent to the direct messages chat unless the sender is an administrator of the
     * channel chat; 0-getOption("paid_message_star_count_max"). The channel will receive
     * getOption("paid_message_earnings_per_mille") Telegram Stars for each 1000 Telegram
     * Stars paid for message sending. Requires supergroupFullInfo.can_enable_paid_messages
     * for positive amounts
     */
    readonly paid_message_star_count?: number,
  }

  export type setChatLocation = {
    /**
     * Changes the location of a chat. Available only for some location-based supergroups,
     * use supergroupFullInfo.can_set_location to check whether the method is allowed
     * to use
     */
    readonly _: 'setChatLocation',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New location for the chat; must be valid and not null */
    readonly location?: chatLocation$Input,
  }

  export type setChatSlowModeDelay = {
    /**
     * Changes the slow mode delay of a chat. Available only for supergroups; requires
     * can_restrict_members right
     */
    readonly _: 'setChatSlowModeDelay',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60,
     * 300, 900, 3600
     */
    readonly slow_mode_delay?: number,
  }

  export type pinChatMessage = {
    /** Pins a message in a chat. A message can be pinned only if messageProperties.can_be_pinned */
    readonly _: 'pinChatMessage',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Identifier of the new pinned message */
    readonly message_id?: number,
    /**
     * Pass true to disable notification about the pinned message. Notifications are
     * always disabled in channels and private chats
     */
    readonly disable_notification?: boolean,
    /** Pass true to pin the message only for self; private chats only */
    readonly only_for_self?: boolean,
  }

  export type unpinChatMessage = {
    /**
     * Removes a pinned message from a chat; requires can_pin_messages member right
     * if the chat is a basic group or supergroup, or can_edit_messages administrator
     * right if the chat is a channel
     */
    readonly _: 'unpinChatMessage',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Identifier of the removed pinned message */
    readonly message_id?: number,
  }

  export type unpinAllChatMessages = {
    /**
     * Removes all pinned messages from a chat; requires can_pin_messages member right
     * if the chat is a basic group or supergroup, or can_edit_messages administrator
     * right if the chat is a channel
     */
    readonly _: 'unpinAllChatMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type unpinAllMessageThreadMessages = {
    /**
     * Removes all pinned messages from a forum topic; requires can_pin_messages member
     * right in the supergroup
     */
    readonly _: 'unpinAllMessageThreadMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier in which messages will be unpinned */
    readonly message_thread_id?: number,
  }

  export type joinChat = {
    /**
     * Adds the current user as a new member to a chat. Private and secret chats can't
     * be joined using this method. May return an error with a message "INVITE_REQUEST_SENT"
     * if only a join request was created
     */
    readonly _: 'joinChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type leaveChat = {
    /**
     * Removes the current user from chat members. Private and secret chats can't be
     * left using this method
     */
    readonly _: 'leaveChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addChatMember = {
    /**
     * Adds a new member to a chat; requires can_invite_users member right. Members
     * can't be added to private or secret chats. Returns information about members
     * that weren't added
     */
    readonly _: 'addChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the user */
    readonly user_id?: number,
    /**
     * The number of earlier messages from the chat to be forwarded to the new member;
     * up to 100. Ignored for supergroups and channels, or if the added user is a bot
     */
    readonly forward_limit?: number,
  }

  export type addChatMembers = {
    /**
     * Adds multiple new members to a chat; requires can_invite_users member right.
     * Currently, this method is only available for supergroups and channels. This
     * method can't be used to join a chat. Members can't be added to a channel if
     * it has more than 200 members. Returns information about members that weren't
     * added
     */
    readonly _: 'addChatMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifiers of the users to be added to the chat. The maximum number of added
     * users is 20 for supergroups and 100 for channels
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type setChatMemberStatus = {
    /**
     * Changes the status of a chat member; requires can_invite_users member right
     * to add a chat member, can_promote_members administrator right to change administrator
     * rights of the member, and can_restrict_members administrator right to change
     * restrictions of a user. This function is currently not suitable for transferring
     * chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember
     * if some additional parameters needs to be passed
     */
    readonly _: 'setChatMemberStatus',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Member identifier. Chats can be only banned and unbanned in supergroups and
     * channels
     */
    readonly member_id?: MessageSender$Input,
    /** The new status of the member in the chat */
    readonly status?: ChatMemberStatus$Input,
  }

  export type banChatMember = {
    /**
     * Bans a member in a chat; requires can_restrict_members administrator right.
     * Members can't be banned in private or secret chats. In supergroups and channels,
     * the user will not be able to return to the group on their own using invite links,
     * etc., unless unbanned first
     */
    readonly _: 'banChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Member identifier */
    readonly member_id?: MessageSender$Input,
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Ignored in basic
     * groups and if a chat is banned
     */
    readonly banned_until_date?: number,
    /**
     * Pass true to delete all messages in the chat for the user that is being removed.
     * Always true for supergroups and channels
     */
    readonly revoke_messages?: boolean,
  }

  export type canTransferOwnership = {
    /**
     * Checks whether the current session can be used to transfer a chat ownership
     * to another user
     */
    readonly _: 'canTransferOwnership',
  }

  export type transferChatOwnership = {
    /**
     * Changes the owner of a chat; requires owner privileges in the chat. Use the
     * method canTransferOwnership to check whether the ownership can be transferred
     * from the current session. Available only for supergroups and channel chats
     */
    readonly _: 'transferChatOwnership',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the user to which transfer the ownership. The ownership can't
     * be transferred to a bot or to a deleted user
     */
    readonly user_id?: number,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type getChatMember = {
    /** Returns information about a single member of a chat */
    readonly _: 'getChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Member identifier */
    readonly member_id?: MessageSender$Input,
  }

  export type searchChatMembers = {
    /**
     * Searches for a specified query in the first name, last name and usernames of
     * the members of a specified chat. Requires administrator rights if the chat is
     * a channel
     */
    readonly _: 'searchChatMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of users to be returned; up to 200 */
    readonly limit?: number,
    /** The type of users to search for; pass null to search among all chat members */
    readonly filter?: ChatMembersFilter$Input,
  }

  export type getChatAdministrators = {
    /** Returns a list of administrators of the chat with their custom titles */
    readonly _: 'getChatAdministrators',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type clearAllDraftMessages = {
    /** Clears message drafts in all chats */
    readonly _: 'clearAllDraftMessages',
    /** Pass true to keep local message drafts in secret chats */
    readonly exclude_secret_chats?: boolean,
  }

  export type getSavedNotificationSound = {
    /**
     * Returns saved notification sound by its identifier. Returns a 404 error if there
     * is no saved notification sound with the specified identifier
     */
    readonly _: 'getSavedNotificationSound',
    /** Identifier of the notification sound */
    readonly notification_sound_id?: number | string,
  }

  export type getSavedNotificationSounds = {
    /**
     * Returns the list of saved notification sounds. If a sound isn't in the list,
     * then default sound needs to be used
     */
    readonly _: 'getSavedNotificationSounds',
  }

  export type addSavedNotificationSound = {
    /**
     * Adds a new notification sound to the list of saved notification sounds. The
     * new notification sound is added to the top of the list. If it is already in
     * the list, its position isn't changed
     */
    readonly _: 'addSavedNotificationSound',
    /** Notification sound file to add */
    readonly sound?: InputFile$Input,
  }

  export type removeSavedNotificationSound = {
    /** Removes a notification sound from the list of saved notification sounds */
    readonly _: 'removeSavedNotificationSound',
    /** Identifier of the notification sound */
    readonly notification_sound_id?: number | string,
  }

  export type getChatNotificationSettingsExceptions = {
    /** Returns the list of chats with non-default notification settings for new messages */
    readonly _: 'getChatNotificationSettingsExceptions',
    /**
     * If specified, only chats from the scope will be returned; pass null to return
     * chats from all scopes
     */
    readonly scope?: NotificationSettingsScope$Input,
    /** Pass true to include in the response chats with only non-default sound */
    readonly compare_sound?: boolean,
  }

  export type getScopeNotificationSettings = {
    /** Returns the notification settings for chats of a given type */
    readonly _: 'getScopeNotificationSettings',
    /** Types of chats for which to return the notification settings information */
    readonly scope?: NotificationSettingsScope$Input,
  }

  export type setScopeNotificationSettings = {
    /** Changes notification settings for chats of a given type */
    readonly _: 'setScopeNotificationSettings',
    /** Types of chats for which to change the notification settings */
    readonly scope?: NotificationSettingsScope$Input,
    /** The new notification settings for the given scope */
    readonly notification_settings?: scopeNotificationSettings$Input,
  }

  export type setReactionNotificationSettings = {
    /** Changes notification settings for reactions */
    readonly _: 'setReactionNotificationSettings',
    /** The new notification settings for reactions */
    readonly notification_settings?: reactionNotificationSettings$Input,
  }

  export type resetAllNotificationSettings = {
    /**
     * Resets all chat and scope notification settings to their default values. By
     * default, all chats are unmuted and message previews are shown
     */
    readonly _: 'resetAllNotificationSettings',
  }

  export type toggleChatIsPinned = {
    /**
     * Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max")
     * pinned non-secret chats and the same number of secret chats in the main/archive
     * chat list. The limit can be increased with Telegram Premium
     */
    readonly _: 'toggleChatIsPinned',
    /** Chat list in which to change the pinned state of the chat */
    readonly chat_list?: ChatList$Input,
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true to pin the chat; pass false to unpin it */
    readonly is_pinned?: boolean,
  }

  export type setPinnedChats = {
    /** Changes the order of pinned chats */
    readonly _: 'setPinnedChats',
    /** Chat list in which to change the order of pinned chats */
    readonly chat_list?: ChatList$Input,
    /** The new list of pinned chats */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type readChatList = {
    /** Traverse all chats in a chat list and marks all messages in the chats as read */
    readonly _: 'readChatList',
    /** Chat list in which to mark all chats as read */
    readonly chat_list?: ChatList$Input,
  }

  export type getCurrentWeather = {
    /** Returns the current weather in the given location */
    readonly _: 'getCurrentWeather',
    /** The location */
    readonly location?: location$Input,
  }

  export type getStory = {
    /** Returns a story */
    readonly _: 'getStory',
    /** Identifier of the chat that posted the story */
    readonly story_poster_chat_id?: number,
    /** Story identifier */
    readonly story_id?: number,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type getChatsToPostStories = {
    /**
     * Returns supergroup and channel chats in which the current user has the right
     * to post stories. The chats must be rechecked with canPostStory before actually
     * trying to post a story there
     */
    readonly _: 'getChatsToPostStories',
  }

  export type canPostStory = {
    /**
     * Checks whether the current user can post a story on behalf of a chat; requires
     * can_post_stories right for supergroup and channel chats
     */
    readonly _: 'canPostStory',
    /**
     * Chat identifier. Pass Saved Messages chat identifier when posting a story on
     * behalf of the current user
     */
    readonly chat_id?: number,
  }

  export type postStory = {
    /**
     * Posts a new story on behalf of a chat; requires can_post_stories right for supergroup
     * and channel chats. Returns a temporary story
     */
    readonly _: 'postStory',
    /**
     * Identifier of the chat that will post the story. Pass Saved Messages chat identifier
     * when posting a story on behalf of the current user
     */
    readonly chat_id?: number,
    /** Content of the story */
    readonly content?: InputStoryContent$Input,
    /** Clickable rectangle areas to be shown on the story media; pass null if none */
    readonly areas?: inputStoryAreas$Input,
    /**
     * Story caption; pass null to use an empty caption; 0-getOption("story_caption_length_max")
     * characters; can have entities only if getOption("can_use_text_entities_in_story_caption")
     */
    readonly caption?: formattedText$Input,
    /**
     * The privacy settings for the story; ignored for stories posted on behalf of
     * supergroup and channel chats
     */
    readonly privacy_settings?: StoryPrivacySettings$Input,
    /**
     * Period after which the story is moved to archive, in seconds; must be one of
     * 6 * 3600, 12 * 3600, 86400, or 2 * 86400 for Telegram Premium users, and 86400
     * otherwise
     */
    readonly active_period?: number,
    /**
     * Full identifier of the original story, which content was used to create the
     * story; pass null if the story isn't repost of another story
     */
    readonly from_story_full_id?: storyFullId$Input,
    /** Pass true to keep the story accessible after expiration */
    readonly is_posted_to_chat_page?: boolean,
    /**
     * Pass true if the content of the story must be protected from forwarding and
     * screenshotting
     */
    readonly protect_content?: boolean,
  }

  export type editStory = {
    /**
     * Changes content and caption of a story. Can be called only if story.can_be_edited
     * == true
     */
    readonly _: 'editStory',
    /** Identifier of the chat that posted the story */
    readonly story_poster_chat_id?: number,
    /** Identifier of the story to edit */
    readonly story_id?: number,
    /** New content of the story; pass null to keep the current content */
    readonly content?: InputStoryContent$Input,
    /**
     * New clickable rectangle areas to be shown on the story media; pass null to keep
     * the current areas. Areas can't be edited if story content isn't changed
     */
    readonly areas?: inputStoryAreas$Input,
    /** New story caption; pass null to keep the current caption */
    readonly caption?: formattedText$Input,
  }

  export type editStoryCover = {
    /**
     * Changes cover of a video story. Can be called only if story.can_be_edited ==
     * true and the story isn't being edited now
     */
    readonly _: 'editStoryCover',
    /** Identifier of the chat that posted the story */
    readonly story_poster_chat_id?: number,
    /** Identifier of the story to edit */
    readonly story_id?: number,
    /** New timestamp of the frame, which will be used as video thumbnail */
    readonly cover_frame_timestamp?: number,
  }

  export type setStoryPrivacySettings = {
    /**
     * Changes privacy settings of a story. The method can be called only for stories
     * posted on behalf of the current user and if story.can_be_edited == true
     */
    readonly _: 'setStoryPrivacySettings',
    /** Identifier of the story */
    readonly story_id?: number,
    /** The new privacy settings for the story */
    readonly privacy_settings?: StoryPrivacySettings$Input,
  }

  export type toggleStoryIsPostedToChatPage = {
    /**
     * Toggles whether a story is accessible after expiration. Can be called only if
     * story.can_toggle_is_posted_to_chat_page == true
     */
    readonly _: 'toggleStoryIsPostedToChatPage',
    /** Identifier of the chat that posted the story */
    readonly story_poster_chat_id?: number,
    /** Identifier of the story */
    readonly story_id?: number,
    /**
     * Pass true to make the story accessible after expiration; pass false to make
     * it private
     */
    readonly is_posted_to_chat_page?: boolean,
  }

  export type deleteStory = {
    /**
     * Deletes a previously posted story. Can be called only if story.can_be_deleted
     * == true
     */
    readonly _: 'deleteStory',
    /** Identifier of the chat that posted the story */
    readonly story_poster_chat_id?: number,
    /** Identifier of the story to delete */
    readonly story_id?: number,
  }

  export type getStoryNotificationSettingsExceptions = {
    /** Returns the list of chats with non-default notification settings for stories */
    readonly _: 'getStoryNotificationSettingsExceptions',
  }

  export type loadActiveStories = {
    /**
     * Loads more active stories from a story list. The loaded stories will be sent
     * through updates. Active stories are sorted by the pair (active_stories.order,
     * active_stories.story_poster_chat_id) in descending order. Returns a 404 error
     * if all active stories have been loaded
     */
    readonly _: 'loadActiveStories',
    /** The story list in which to load active stories */
    readonly story_list?: StoryList$Input,
  }

  export type setChatActiveStoriesList = {
    /** Changes story list in which stories from the chat are shown */
    readonly _: 'setChatActiveStoriesList',
    /** Identifier of the chat that posted stories */
    readonly chat_id?: number,
    /** New list for active stories posted by the chat */
    readonly story_list?: StoryList$Input,
  }

  export type getChatActiveStories = {
    /** Returns the list of active stories posted by the given chat */
    readonly _: 'getChatActiveStories',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getChatPostedToChatPageStories = {
    /**
     * Returns the list of stories that posted by the given chat to its chat page.
     * If from_story_id == 0, then pinned stories are returned first. Then, stories
     * are returned in reverse chronological order (i.e., in order of decreasing story_id).
     * For optimal performance, the number of returned stories is chosen by TDLib
     */
    readonly _: 'getChatPostedToChatPageStories',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the story starting from which stories must be returned; use 0
     * to get results from pinned and the newest story
     */
    readonly from_story_id?: number,
    /**
     * The maximum number of stories to be returned. For optimal performance, the number
     * of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    readonly limit?: number,
  }

  export type getChatArchivedStories = {
    /**
     * Returns the list of all stories posted by the given chat; requires can_edit_stories
     * right in the chat. The stories are returned in reverse chronological order (i.e.,
     * in order of decreasing story_id). For optimal performance, the number of returned
     * stories is chosen by TDLib
     */
    readonly _: 'getChatArchivedStories',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the story starting from which stories must be returned; use 0
     * to get results from the last story
     */
    readonly from_story_id?: number,
    /**
     * The maximum number of stories to be returned. For optimal performance, the number
     * of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    readonly limit?: number,
  }

  export type setChatPinnedStories = {
    /**
     * Changes the list of pinned stories on a chat page; requires can_edit_stories
     * right in the chat
     */
    readonly _: 'setChatPinnedStories',
    /** Identifier of the chat that posted the stories */
    readonly chat_id?: number,
    /**
     * New list of pinned stories. All stories must be posted to the chat page first.
     * There can be up to getOption("pinned_story_count_max") pinned stories on a chat
     * page
     */
    readonly story_ids?: ReadonlyArray<number>,
  }

  export type openStory = {
    /** Informs TDLib that a story is opened and is being viewed by the user */
    readonly _: 'openStory',
    /** The identifier of the chat that posted the opened story */
    readonly story_poster_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
  }

  export type closeStory = {
    /** Informs TDLib that a story is closed by the user */
    readonly _: 'closeStory',
    /** The identifier of the poster of the story to close */
    readonly story_poster_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
  }

  export type getStoryAvailableReactions = {
    /** Returns reactions, which can be chosen for a story */
    readonly _: 'getStoryAvailableReactions',
    /** Number of reaction per row, 5-25 */
    readonly row_size?: number,
  }

  export type setStoryReaction = {
    /** Changes chosen reaction on a story that has already been sent */
    readonly _: 'setStoryReaction',
    /** The identifier of the poster of the story */
    readonly story_poster_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
    /**
     * Type of the reaction to set; pass null to remove the reaction. Custom emoji
     * reactions can be used only by Telegram Premium users. Paid reactions can't be
     * set
     */
    readonly reaction_type?: ReactionType$Input,
    /** Pass true if the reaction needs to be added to recent reactions */
    readonly update_recent_reactions?: boolean,
  }

  export type getStoryInteractions = {
    /**
     * Returns interactions with a story. The method can be called only for stories
     * posted on behalf of the current user
     */
    readonly _: 'getStoryInteractions',
    /** Story identifier */
    readonly story_id?: number,
    /**
     * Query to search for in names, usernames and titles; may be empty to get all
     * relevant interactions
     */
    readonly query?: string,
    /**
     * Pass true to get only interactions by contacts; pass false to get all relevant
     * interactions
     */
    readonly only_contacts?: boolean,
    /**
     * Pass true to get forwards and reposts first, then reactions, then other views;
     * pass false to get interactions sorted just by interaction date
     */
    readonly prefer_forwards?: boolean,
    /**
     * Pass true to get interactions with reaction first; pass false to get interactions
     * sorted just by interaction date. Ignored if prefer_forwards == true
     */
    readonly prefer_with_reaction?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of story interactions to return */
    readonly limit?: number,
  }

  export type getChatStoryInteractions = {
    /**
     * Returns interactions with a story posted in a chat. Can be used only if story
     * is posted on behalf of a chat and the user is an administrator in the chat
     */
    readonly _: 'getChatStoryInteractions',
    /** The identifier of the poster of the story */
    readonly story_poster_chat_id?: number,
    /** Story identifier */
    readonly story_id?: number,
    /**
     * Pass the default heart reaction or a suggested reaction type to receive only
     * interactions with the specified reaction type; pass null to receive all interactions;
     * reactionTypePaid isn't supported
     */
    readonly reaction_type?: ReactionType$Input,
    /**
     * Pass true to get forwards and reposts first, then reactions, then other views;
     * pass false to get interactions sorted just by interaction date
     */
    readonly prefer_forwards?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of story interactions to return */
    readonly limit?: number,
  }

  export type reportStory = {
    /** Reports a story to the Telegram moderators */
    readonly _: 'reportStory',
    /** The identifier of the poster of the story to report */
    readonly story_poster_chat_id?: number,
    /** The identifier of the story to report */
    readonly story_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    readonly option_id?: string /* base64 */,
    /** Additional report details; 0-1024 characters; leave empty for the initial request */
    readonly text?: string,
  }

  export type activateStoryStealthMode = {
    /**
     * Activates stealth mode for stories, which hides all views of stories from the
     * current user in the last "story_stealth_mode_past_period" seconds and for the
     * next "story_stealth_mode_future_period" seconds; for Telegram Premium users
     * only
     */
    readonly _: 'activateStoryStealthMode',
  }

  export type getStoryPublicForwards = {
    /**
     * Returns forwards of a story as a message to public chats and reposts by public
     * channels. Can be used only if the story is posted on behalf of the current user
     * or story.can_get_statistics == true. For optimal performance, the number of
     * returned messages and stories is chosen by TDLib
     */
    readonly _: 'getStoryPublicForwards',
    /** The identifier of the poster of the story */
    readonly story_poster_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages and stories to be returned; must be positive
     * and can't be greater than 100. For optimal performance, the number of returned
     * objects is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getChatBoostLevelFeatures = {
    /**
     * Returns the list of features available on the specific chat boost level. This
     * is an offline method
     */
    readonly _: 'getChatBoostLevelFeatures',
    /**
     * Pass true to get the list of features for channels; pass false to get the list
     * of features for supergroups
     */
    readonly is_channel?: boolean,
    /** Chat boost level */
    readonly level?: number,
  }

  export type getChatBoostFeatures = {
    /**
     * Returns the list of features available for different chat boost levels. This
     * is an offline method
     */
    readonly _: 'getChatBoostFeatures',
    /**
     * Pass true to get the list of features for channels; pass false to get the list
     * of features for supergroups
     */
    readonly is_channel?: boolean,
  }

  export type getAvailableChatBoostSlots = {
    /** Returns the list of available chat boost slots for the current user */
    readonly _: 'getAvailableChatBoostSlots',
  }

  export type getChatBoostStatus = {
    /** Returns the current boost status for a supergroup or a channel chat */
    readonly _: 'getChatBoostStatus',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type boostChat = {
    /**
     * Boosts a chat and returns the list of available chat boost slots for the current
     * user after the boost
     */
    readonly _: 'boostChat',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /**
     * Identifiers of boost slots of the current user from which to apply boosts to
     * the chat
     */
    readonly slot_ids?: ReadonlyArray<number>,
  }

  export type getChatBoostLink = {
    /** Returns an HTTPS link to boost the specified supergroup or channel chat */
    readonly _: 'getChatBoostLink',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type getChatBoostLinkInfo = {
    /**
     * Returns information about a link to boost a chat. Can be called for any internal
     * link of the type internalLinkTypeChatBoost
     */
    readonly _: 'getChatBoostLinkInfo',
    /** The link to boost a chat */
    readonly url?: string,
  }

  export type getChatBoosts = {
    /**
     * Returns the list of boosts applied to a chat; requires administrator rights
     * in the chat
     */
    readonly _: 'getChatBoosts',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /**
     * Pass true to receive only boosts received from gift codes and giveaways created
     * by the chat
     */
    readonly only_gift_codes?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of boosts to be returned; up to 100. For optimal performance,
     * the number of returned boosts can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getUserChatBoosts = {
    /**
     * Returns the list of boosts applied to a chat by a given user; requires administrator
     * rights in the chat; for bots only
     */
    readonly _: 'getUserChatBoosts',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Identifier of the user */
    readonly user_id?: number,
  }

  export type getAttachmentMenuBot = {
    /** Returns information about a bot that can be added to attachment or side menu */
    readonly _: 'getAttachmentMenuBot',
    /** Bot's user identifier */
    readonly bot_user_id?: number,
  }

  export type toggleBotIsAddedToAttachmentMenu = {
    /**
     * Adds or removes a bot to attachment and side menu. Bot can be added to the menu,
     * only if userTypeBot.can_be_added_to_attachment_menu == true
     */
    readonly _: 'toggleBotIsAddedToAttachmentMenu',
    /** Bot's user identifier */
    readonly bot_user_id?: number,
    /**
     * Pass true to add the bot to attachment menu; pass false to remove the bot from
     * attachment menu
     */
    readonly is_added?: boolean,
    /**
     * Pass true if the current user allowed the bot to send them messages. Ignored
     * if is_added is false
     */
    readonly allow_write_access?: boolean,
  }

  export type getThemedEmojiStatuses = {
    /**
     * Returns up to 8 emoji statuses, which must be shown right after the default
     * Premium Badge in the emoji status list for self status
     */
    readonly _: 'getThemedEmojiStatuses',
  }

  export type getRecentEmojiStatuses = {
    /** Returns recent emoji statuses for self status */
    readonly _: 'getRecentEmojiStatuses',
  }

  export type getUpgradedGiftEmojiStatuses = {
    /** Returns available upgraded gift emoji statuses for self status */
    readonly _: 'getUpgradedGiftEmojiStatuses',
  }

  export type getDefaultEmojiStatuses = {
    /** Returns default emoji statuses for self status */
    readonly _: 'getDefaultEmojiStatuses',
  }

  export type clearRecentEmojiStatuses = {
    /** Clears the list of recently used emoji statuses for self status */
    readonly _: 'clearRecentEmojiStatuses',
  }

  export type getThemedChatEmojiStatuses = {
    /**
     * Returns up to 8 emoji statuses, which must be shown in the emoji status list
     * for chats
     */
    readonly _: 'getThemedChatEmojiStatuses',
  }

  export type getDefaultChatEmojiStatuses = {
    /** Returns default emoji statuses for chats */
    readonly _: 'getDefaultChatEmojiStatuses',
  }

  export type getDisallowedChatEmojiStatuses = {
    /**
     * Returns the list of emoji statuses, which can't be used as chat emoji status,
     * even they are from a sticker set with is_allowed_as_chat_emoji_status == true
     */
    readonly _: 'getDisallowedChatEmojiStatuses',
  }

  export type downloadFile = {
    /**
     * Downloads a file from the cloud. Download progress and completion of the download
     * will be notified through updateFile updates
     */
    readonly _: 'downloadFile',
    /** Identifier of the file to download */
    readonly file_id?: number,
    /**
     * Priority of the download (1-32). The higher the priority, the earlier the file
     * will be downloaded. If the priorities of two files are equal, then the last
     * one for which downloadFile/addFileToDownloads was called will be downloaded
     * first
     */
    readonly priority?: number,
    /** The starting position from which the file needs to be downloaded */
    readonly offset?: number,
    /**
     * Number of bytes which need to be downloaded starting from the "offset" position
     * before the download will automatically be canceled; use 0 to download without
     * a limit
     */
    readonly limit?: number,
    /**
     * Pass true to return response only after the file download has succeeded, has
     * failed, has been canceled, or a new downloadFile request with different offset/limit
     * parameters was sent; pass false to return file state immediately, just after
     * the download has been started
     */
    readonly synchronous?: boolean,
  }

  export type getFileDownloadedPrefixSize = {
    /** Returns file downloaded prefix size from a given offset, in bytes */
    readonly _: 'getFileDownloadedPrefixSize',
    /** Identifier of the file */
    readonly file_id?: number,
    /** Offset from which downloaded prefix size needs to be calculated */
    readonly offset?: number,
  }

  export type cancelDownloadFile = {
    /**
     * Stops the downloading of a file. If a file has already been downloaded, does
     * nothing
     */
    readonly _: 'cancelDownloadFile',
    /** Identifier of a file to stop downloading */
    readonly file_id?: number,
    /**
     * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't
     * been sent to server
     */
    readonly only_if_pending?: boolean,
  }

  export type getSuggestedFileName = {
    /** Returns suggested name for saving a file in a given directory */
    readonly _: 'getSuggestedFileName',
    /** Identifier of the file */
    readonly file_id?: number,
    /** Directory in which the file is expected to be saved */
    readonly directory?: string,
  }

  export type preliminaryUploadFile = {
    /**
     * Preliminary uploads a file to the cloud before sending it in a message, which
     * can be useful for uploading of being recorded voice and video notes. In all
     * other cases there is no need to preliminary upload a file. Updates updateFile
     * will be used to notify about upload progress. The upload will not be completed
     * until the file is sent in a message
     */
    readonly _: 'preliminaryUploadFile',
    /** File to upload */
    readonly file?: InputFile$Input,
    /** File type; pass null if unknown */
    readonly file_type?: FileType$Input,
    /**
     * Priority of the upload (1-32). The higher the priority, the earlier the file
     * will be uploaded. If the priorities of two files are equal, then the first one
     * for which preliminaryUploadFile was called will be uploaded first
     */
    readonly priority?: number,
  }

  export type cancelPreliminaryUploadFile = {
    /**
     * Stops the preliminary uploading of a file. Supported only for files uploaded
     * by using preliminaryUploadFile
     */
    readonly _: 'cancelPreliminaryUploadFile',
    /** Identifier of the file to stop uploading */
    readonly file_id?: number,
  }

  export type writeGeneratedFilePart = {
    /**
     * Writes a part of a generated file. This method is intended to be used only if
     * the application has no direct access to TDLib's file system, because it is usually
     * slower than a direct write to the destination file
     */
    readonly _: 'writeGeneratedFilePart',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /** The offset from which to write the data to the file */
    readonly offset?: number,
    /** The data to write */
    readonly data?: string /* base64 */,
  }

  export type setFileGenerationProgress = {
    /** Informs TDLib on a file generation progress */
    readonly _: 'setFileGenerationProgress',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    readonly expected_size?: number,
    /** The number of bytes already generated */
    readonly local_prefix_size?: number,
  }

  export type finishFileGeneration = {
    /** Finishes the file generation */
    readonly _: 'finishFileGeneration',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /**
     * If passed, the file generation has failed and must be terminated; pass null
     * if the file generation succeeded
     */
    readonly error?: error$Input,
  }

  export type readFilePart = {
    /**
     * Reads a part of a file from the TDLib file cache and returns read bytes. This
     * method is intended to be used only if the application has no direct access to
     * TDLib's file system, because it is usually slower than a direct read from the
     * file
     */
    readonly _: 'readFilePart',
    /** Identifier of the file. The file must be located in the TDLib file cache */
    readonly file_id?: number,
    /** The offset from which to read the file */
    readonly offset?: number,
    /**
     * Number of bytes to read. An error will be returned if there are not enough bytes
     * available in the file from the specified position. Pass 0 to read all available
     * data from the specified position
     */
    readonly count?: number,
  }

  export type deleteFile = {
    /** Deletes a file from the TDLib file cache */
    readonly _: 'deleteFile',
    /** Identifier of the file to delete */
    readonly file_id?: number,
  }

  export type addFileToDownloads = {
    /**
     * Adds a file from a message to the list of file downloads. Download progress
     * and completion of the download will be notified through updateFile updates.
     * If message database is used, the list of file downloads is persistent across
     * application restarts. The downloading is independent of download using downloadFile,
     * i.e. it continues if downloadFile is canceled or is used to download a part
     * of the file
     */
    readonly _: 'addFileToDownloads',
    /** Identifier of the file to download */
    readonly file_id?: number,
    /** Chat identifier of the message with the file */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /**
     * Priority of the download (1-32). The higher the priority, the earlier the file
     * will be downloaded. If the priorities of two files are equal, then the last
     * one for which downloadFile/addFileToDownloads was called will be downloaded
     * first
     */
    readonly priority?: number,
  }

  export type toggleDownloadIsPaused = {
    /** Changes pause state of a file in the file download list */
    readonly _: 'toggleDownloadIsPaused',
    /** Identifier of the downloaded file */
    readonly file_id?: number,
    /** Pass true if the download is paused */
    readonly is_paused?: boolean,
  }

  export type toggleAllDownloadsArePaused = {
    /** Changes pause state of all files in the file download list */
    readonly _: 'toggleAllDownloadsArePaused',
    /** Pass true to pause all downloads; pass false to unpause them */
    readonly are_paused?: boolean,
  }

  export type removeFileFromDownloads = {
    /** Removes a file from the file download list */
    readonly _: 'removeFileFromDownloads',
    /** Identifier of the downloaded file */
    readonly file_id?: number,
    /** Pass true to delete the file from the TDLib file cache */
    readonly delete_from_cache?: boolean,
  }

  export type removeAllFilesFromDownloads = {
    /** Removes all files from the file download list */
    readonly _: 'removeAllFilesFromDownloads',
    /** Pass true to remove only active downloads, including paused */
    readonly only_active?: boolean,
    /** Pass true to remove only completed downloads */
    readonly only_completed?: boolean,
    /** Pass true to delete the file from the TDLib file cache */
    readonly delete_from_cache?: boolean,
  }

  export type searchFileDownloads = {
    /**
     * Searches for files in the file download list or recently downloaded files from
     * the list
     */
    readonly _: 'searchFileDownloads',
    /** Query to search for; may be empty to return all downloaded files */
    readonly query?: string,
    /** Pass true to search only for active downloads, including paused */
    readonly only_active?: boolean,
    /** Pass true to search only for completed downloads */
    readonly only_completed?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of files to be returned */
    readonly limit?: number,
  }

  export type setApplicationVerificationToken = {
    /**
     * Application or reCAPTCHA verification has been completed. Can be called before
     * authorization
     */
    readonly _: 'setApplicationVerificationToken',
    /**
     * Unique identifier for the verification process as received from updateApplicationVerificationRequired
     * or updateApplicationRecaptchaVerificationRequired
     */
    readonly verification_id?: number,
    /**
     * Play Integrity API token for the Android application, or secret from push notification
     * for the iOS application for application verification, or reCAPTCHA token for
     * reCAPTCHA verifications; pass an empty string to abort verification and receive
     * the error "VERIFICATION_FAILED" for the request
     */
    readonly token?: string,
  }

  export type getMessageFileType = {
    /** Returns information about a file with messages exported from another application */
    readonly _: 'getMessageFileType',
    /** Beginning of the message file; up to 100 first lines */
    readonly message_file_head?: string,
  }

  export type getMessageImportConfirmationText = {
    /**
     * Returns a confirmation text to be shown to the user before starting message
     * import
     */
    readonly _: 'getMessageImportConfirmationText',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info member right
     */
    readonly chat_id?: number,
  }

  export type importMessages = {
    /** Imports messages exported from another app */
    readonly _: 'importMessages',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info member right
     */
    readonly chat_id?: number,
    /**
     * File with messages to import. Only inputFileLocal and inputFileGenerated are
     * supported. The file must not be previously uploaded
     */
    readonly message_file?: InputFile$Input,
    /**
     * Files used in the imported messages. Only inputFileLocal and inputFileGenerated
     * are supported. The files must not be previously uploaded
     */
    readonly attached_files?: ReadonlyArray<InputFile$Input>,
  }

  export type replacePrimaryChatInviteLink = {
    /**
     * Replaces current primary invite link for a chat with a new primary invite link.
     * Available for basic groups, supergroups, and channels. Requires administrator
     * privileges and can_invite_users right
     */
    readonly _: 'replacePrimaryChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type createChatInviteLink = {
    /**
     * Creates a new invite link for a chat. Available for basic groups, supergroups,
     * and channels. Requires administrator privileges and can_invite_users right in
     * the chat
     */
    readonly _: 'createChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    readonly expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    readonly member_limit?: number,
    /**
     * Pass true if users joining the chat via the link need to be approved by chat
     * administrators. In this case, member_limit must be 0
     */
    readonly creates_join_request?: boolean,
  }

  export type createChatSubscriptionInviteLink = {
    /**
     * Creates a new subscription invite link for a channel chat. Requires can_invite_users
     * right in the chat
     */
    readonly _: 'createChatSubscriptionInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
    /**
     * Information about subscription plan that will be applied to the users joining
     * the chat via the link. Subscription period must be 2592000 in production environment,
     * and 60 or 300 if Telegram test environment is used
     */
    readonly subscription_pricing?: starSubscriptionPricing$Input,
  }

  export type editChatInviteLink = {
    /**
     * Edits a non-primary invite link for a chat. Available for basic groups, supergroups,
     * and channels. If the link creates a subscription, then expiration_date, member_limit
     * and creates_join_request must not be used. Requires administrator privileges
     * and can_invite_users right in the chat for own links and owner privileges for
     * other links
     */
    readonly _: 'editChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to be edited */
    readonly invite_link?: string,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    readonly expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    readonly member_limit?: number,
    /**
     * Pass true if users joining the chat via the link need to be approved by chat
     * administrators. In this case, member_limit must be 0
     */
    readonly creates_join_request?: boolean,
  }

  export type editChatSubscriptionInviteLink = {
    /**
     * Edits a subscription invite link for a channel chat. Requires can_invite_users
     * right in the chat for own links and owner privileges for other links
     */
    readonly _: 'editChatSubscriptionInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to be edited */
    readonly invite_link?: string,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
  }

  export type getChatInviteLink = {
    /**
     * Returns information about an invite link. Requires administrator privileges
     * and can_invite_users right in the chat to get own links and owner privileges
     * to get other links
     */
    readonly _: 'getChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to get */
    readonly invite_link?: string,
  }

  export type getChatInviteLinkCounts = {
    /**
     * Returns the list of chat administrators with number of their invite links. Requires
     * owner privileges in the chat
     */
    readonly _: 'getChatInviteLinkCounts',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getChatInviteLinks = {
    /**
     * Returns invite links for a chat created by specified administrator. Requires
     * administrator privileges and can_invite_users right in the chat to get own links
     * and owner privileges to get other links
     */
    readonly _: 'getChatInviteLinks',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * User identifier of a chat administrator. Must be an identifier of the current
     * user for non-owner
     */
    readonly creator_user_id?: number,
    /** Pass true if revoked links needs to be returned instead of active or expired */
    readonly is_revoked?: boolean,
    /**
     * Creation date of an invite link starting after which to return invite links;
     * use 0 to get results from the beginning
     */
    readonly offset_date?: number,
    /**
     * Invite link starting after which to return invite links; use empty string to
     * get results from the beginning
     */
    readonly offset_invite_link?: string,
    /** The maximum number of invite links to return; up to 100 */
    readonly limit?: number,
  }

  export type getChatInviteLinkMembers = {
    /**
     * Returns chat members joined a chat via an invite link. Requires administrator
     * privileges and can_invite_users right in the chat for own links and owner privileges
     * for other links
     */
    readonly _: 'getChatInviteLinkMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link for which to return chat members */
    readonly invite_link?: string,
    /**
     * Pass true if the link is a subscription link and only members with expired subscription
     * must be returned
     */
    readonly only_with_expired_subscription?: boolean,
    /**
     * A chat member from which to return next chat members; pass null to get results
     * from the beginning
     */
    readonly offset_member?: chatInviteLinkMember$Input,
    /** The maximum number of chat members to return; up to 100 */
    readonly limit?: number,
  }

  export type revokeChatInviteLink = {
    /**
     * Revokes invite link for a chat. Available for basic groups, supergroups, and
     * channels. Requires administrator privileges and can_invite_users right in the
     * chat for own links and owner privileges for other links. If a primary link is
     * revoked, then additionally to the revoked link returns new primary link
     */
    readonly _: 'revokeChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to be revoked */
    readonly invite_link?: string,
  }

  export type deleteRevokedChatInviteLink = {
    /**
     * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users
     * right in the chat for own links and owner privileges for other links
     */
    readonly _: 'deleteRevokedChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to revoke */
    readonly invite_link?: string,
  }

  export type deleteAllRevokedChatInviteLinks = {
    /**
     * Deletes all revoked chat invite links created by a given chat administrator.
     * Requires administrator privileges and can_invite_users right in the chat for
     * own links and owner privileges for other links
     */
    readonly _: 'deleteAllRevokedChatInviteLinks',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * User identifier of a chat administrator, which links will be deleted. Must be
     * an identifier of the current user for non-owner
     */
    readonly creator_user_id?: number,
  }

  export type checkChatInviteLink = {
    /**
     * Checks the validity of an invite link for a chat and returns information about
     * the corresponding chat
     */
    readonly _: 'checkChatInviteLink',
    /** Invite link to be checked */
    readonly invite_link?: string,
  }

  export type joinChatByInviteLink = {
    /**
     * Uses an invite link to add the current user to the chat if possible. May return
     * an error with a message "INVITE_REQUEST_SENT" if only a join request was created
     */
    readonly _: 'joinChatByInviteLink',
    /** Invite link to use */
    readonly invite_link?: string,
  }

  export type getChatJoinRequests = {
    /** Returns pending join requests in a chat */
    readonly _: 'getChatJoinRequests',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Invite link for which to return join requests. If empty, all join requests will
     * be returned. Requires administrator privileges and can_invite_users right in
     * the chat for own links and owner privileges for other links
     */
    readonly invite_link?: string,
    /**
     * A query to search for in the first names, last names and usernames of the users
     * to return
     */
    readonly query?: string,
    /**
     * A chat join request from which to return next requests; pass null to get results
     * from the beginning
     */
    readonly offset_request?: chatJoinRequest$Input,
    /** The maximum number of requests to join the chat to return */
    readonly limit?: number,
  }

  export type processChatJoinRequest = {
    /** Handles a pending join request in a chat */
    readonly _: 'processChatJoinRequest',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the user that sent the request */
    readonly user_id?: number,
    /** Pass true to approve the request; pass false to decline it */
    readonly approve?: boolean,
  }

  export type processChatJoinRequests = {
    /** Handles all pending join requests for a given link in a chat */
    readonly _: 'processChatJoinRequests',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Invite link for which to process join requests. If empty, all join requests
     * will be processed. Requires administrator privileges and can_invite_users right
     * in the chat for own links and owner privileges for other links
     */
    readonly invite_link?: string,
    /** Pass true to approve all requests; pass false to decline them */
    readonly approve?: boolean,
  }

  export type createCall = {
    /** Creates a new call */
    readonly _: 'createCall',
    /** Identifier of the user to be called */
    readonly user_id?: number,
    /** The call protocols supported by the application */
    readonly protocol?: callProtocol$Input,
    /** Pass true to create a video call */
    readonly is_video?: boolean,
  }

  export type acceptCall = {
    /** Accepts an incoming call */
    readonly _: 'acceptCall',
    /** Call identifier */
    readonly call_id?: number,
    /** The call protocols supported by the application */
    readonly protocol?: callProtocol$Input,
  }

  export type sendCallSignalingData = {
    /** Sends call signaling data */
    readonly _: 'sendCallSignalingData',
    /** Call identifier */
    readonly call_id?: number,
    /** The data */
    readonly data?: string /* base64 */,
  }

  export type discardCall = {
    /** Discards a call */
    readonly _: 'discardCall',
    /** Call identifier */
    readonly call_id?: number,
    /** Pass true if the user was disconnected */
    readonly is_disconnected?: boolean,
    /** If the call was upgraded to a group call, pass invite link to the group call */
    readonly invite_link?: string,
    /** The call duration, in seconds */
    readonly duration?: number,
    /** Pass true if the call was a video call */
    readonly is_video?: boolean,
    /** Identifier of the connection used during the call */
    readonly connection_id?: number | string,
  }

  export type sendCallRating = {
    /** Sends a call rating */
    readonly _: 'sendCallRating',
    /** Call identifier */
    readonly call_id?: number,
    /** Call rating; 1-5 */
    readonly rating?: number,
    /** An optional user comment if the rating is less than 5 */
    readonly comment?: string,
    /** List of the exact types of problems with the call, specified by the user */
    readonly problems?: ReadonlyArray<CallProblem$Input>,
  }

  export type sendCallDebugInformation = {
    /** Sends debug information for a call to Telegram servers */
    readonly _: 'sendCallDebugInformation',
    /** Call identifier */
    readonly call_id?: number,
    /** Debug information in application-specific format */
    readonly debug_information?: string,
  }

  export type sendCallLog = {
    /** Sends log file for a call to Telegram servers */
    readonly _: 'sendCallLog',
    /** Call identifier */
    readonly call_id?: number,
    /** Call log file. Only inputFileLocal and inputFileGenerated are supported */
    readonly log_file?: InputFile$Input,
  }

  export type getVideoChatAvailableParticipants = {
    /**
     * Returns the list of participant identifiers, on whose behalf a video chat in
     * the chat can be joined
     */
    readonly _: 'getVideoChatAvailableParticipants',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type setVideoChatDefaultParticipant = {
    /**
     * Changes default participant identifier, on whose behalf a video chat in the
     * chat will be joined
     */
    readonly _: 'setVideoChatDefaultParticipant',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Default group call participant identifier to join the video chats */
    readonly default_participant_id?: MessageSender$Input,
  }

  export type createVideoChat = {
    /**
     * Creates a video chat (a group call bound to a chat). Available only for basic
     * groups, supergroups and channels; requires can_manage_video_chats administrator
     * right
     */
    readonly _: 'createVideoChat',
    /** Identifier of a chat in which the video chat will be created */
    readonly chat_id?: number,
    /** Group call title; if empty, chat title will be used */
    readonly title?: string,
    /**
     * Point in time (Unix timestamp) when the group call is expected to be started
     * by an administrator; 0 to start the video chat immediately. The date must be
     * at least 10 seconds and at most 8 days in the future
     */
    readonly start_date?: number,
    /** Pass true to create an RTMP stream instead of an ordinary video chat */
    readonly is_rtmp_stream?: boolean,
  }

  export type createGroupCall = {
    /** Creates a new group call that isn't bound to a chat */
    readonly _: 'createGroupCall',
    /**
     * Parameters to join the call; pass null to only create call link without joining
     * the call
     */
    readonly join_parameters?: groupCallJoinParameters$Input,
  }

  export type getVideoChatRtmpUrl = {
    /**
     * Returns RTMP URL for streaming to the video chat of a chat; requires can_manage_video_chats
     * administrator right
     */
    readonly _: 'getVideoChatRtmpUrl',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type replaceVideoChatRtmpUrl = {
    /**
     * Replaces the current RTMP URL for streaming to the video chat of a chat; requires
     * owner privileges in the chat
     */
    readonly _: 'replaceVideoChatRtmpUrl',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getGroupCall = {
    /** Returns information about a group call */
    readonly _: 'getGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type startScheduledVideoChat = {
    /** Starts a scheduled video chat */
    readonly _: 'startScheduledVideoChat',
    /** Group call identifier of the video chat */
    readonly group_call_id?: number,
  }

  export type toggleVideoChatEnabledStartNotification = {
    /**
     * Toggles whether the current user will receive a notification when the video
     * chat starts; for scheduled video chats only
     */
    readonly _: 'toggleVideoChatEnabledStartNotification',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New value of the enabled_start_notification setting */
    readonly enabled_start_notification?: boolean,
  }

  export type joinGroupCall = {
    /** Joins a group call that is not bound to a chat */
    readonly _: 'joinGroupCall',
    /** The group call to join */
    readonly input_group_call?: InputGroupCall$Input,
    /** Parameters to join the call */
    readonly join_parameters?: groupCallJoinParameters$Input,
  }

  export type joinVideoChat = {
    /** Joins an active video chat. Returns join response payload for tgcalls */
    readonly _: 'joinVideoChat',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Identifier of a group call participant, which will be used to join the call;
     * pass null to join as self; video chats only
     */
    readonly participant_id?: MessageSender$Input,
    /** Parameters to join the call */
    readonly join_parameters?: groupCallJoinParameters$Input,
    /** Invite hash as received from internalLinkTypeVideoChat */
    readonly invite_hash?: string,
  }

  export type startGroupCallScreenSharing = {
    /**
     * Starts screen sharing in a joined group call. Returns join response payload
     * for tgcalls
     */
    readonly _: 'startGroupCallScreenSharing',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Screen sharing audio channel synchronization source identifier; received from
     * tgcalls
     */
    readonly audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    readonly payload?: string,
  }

  export type toggleGroupCallScreenSharingIsPaused = {
    /** Pauses or unpauses screen sharing in a joined group call */
    readonly _: 'toggleGroupCallScreenSharingIsPaused',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true to pause screen sharing; pass false to unpause it */
    readonly is_paused?: boolean,
  }

  export type endGroupCallScreenSharing = {
    /** Ends screen sharing in a joined group call */
    readonly _: 'endGroupCallScreenSharing',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type setVideoChatTitle = {
    /** Sets title of a video chat; requires groupCall.can_be_managed right */
    readonly _: 'setVideoChatTitle',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New group call title; 1-64 characters */
    readonly title?: string,
  }

  export type toggleVideoChatMuteNewParticipants = {
    /**
     * Toggles whether new participants of a video chat can be unmuted only by administrators
     * of the video chat. Requires groupCall.can_toggle_mute_new_participants right
     */
    readonly _: 'toggleVideoChatMuteNewParticipants',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New value of the mute_new_participants setting */
    readonly mute_new_participants?: boolean,
  }

  export type inviteGroupCallParticipant = {
    /**
     * Invites a user to an active group call; for group calls not bound to a chat
     * only. Sends a service message of the type messageGroupCall. The group call can
     * have at most getOption("group_call_participant_count_max") participants
     */
    readonly _: 'inviteGroupCallParticipant',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** User identifier */
    readonly user_id?: number,
    /** Pass true if the group call is a video call */
    readonly is_video?: boolean,
  }

  export type declineGroupCallInvitation = {
    /**
     * Declines an invitation to an active group call via messageGroupCall. Can be
     * called both by the sender and the receiver of the invitation
     */
    readonly _: 'declineGroupCallInvitation',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /** Identifier of the message of the type messageGroupCall */
    readonly message_id?: number,
  }

  export type banGroupCallParticipants = {
    /**
     * Bans users from a group call not bound to a chat; requires groupCall.is_owned.
     * Only the owner of the group call can invite the banned users back
     */
    readonly _: 'banGroupCallParticipants',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Identifiers of group call participants to ban; identifiers of unknown users
     * from the update updateGroupCallParticipants can be also passed to the method
     */
    readonly user_ids?: ReadonlyArray<number | string>,
  }

  export type inviteVideoChatParticipants = {
    /**
     * Invites users to an active video chat. Sends a service message of the type messageInviteVideoChatParticipants
     * to the chat bound to the group call
     */
    readonly _: 'inviteVideoChatParticipants',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** User identifiers. At most 10 users can be invited simultaneously */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getVideoChatInviteLink = {
    /** Returns invite link to a video chat in a public chat */
    readonly _: 'getVideoChatInviteLink',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Pass true if the invite link needs to contain an invite hash, passing which
     * to joinVideoChat would allow the invited user to unmute themselves. Requires
     * groupCall.can_be_managed right
     */
    readonly can_self_unmute?: boolean,
  }

  export type revokeGroupCallInviteLink = {
    /**
     * Revokes invite link for a group call. Requires groupCall.can_be_managed right
     * for video chats or groupCall.is_owned otherwise
     */
    readonly _: 'revokeGroupCallInviteLink',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type startGroupCallRecording = {
    /**
     * Starts recording of an active group call; for video chats only. Requires groupCall.can_be_managed
     * right
     */
    readonly _: 'startGroupCallRecording',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Group call recording title; 0-64 characters */
    readonly title?: string,
    /** Pass true to record a video file instead of an audio file */
    readonly record_video?: boolean,
    /** Pass true to use portrait orientation for video instead of landscape one */
    readonly use_portrait_orientation?: boolean,
  }

  export type endGroupCallRecording = {
    /**
     * Ends recording of an active group call; for video chats only. Requires groupCall.can_be_managed
     * right
     */
    readonly _: 'endGroupCallRecording',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type toggleGroupCallIsMyVideoPaused = {
    /** Toggles whether current user's video is paused */
    readonly _: 'toggleGroupCallIsMyVideoPaused',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true if the current user's video is paused */
    readonly is_my_video_paused?: boolean,
  }

  export type toggleGroupCallIsMyVideoEnabled = {
    /** Toggles whether current user's video is enabled */
    readonly _: 'toggleGroupCallIsMyVideoEnabled',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true if the current user's video is enabled */
    readonly is_my_video_enabled?: boolean,
  }

  export type setGroupCallParticipantIsSpeaking = {
    /**
     * Informs TDLib that speaking state of a participant of an active group call has
     * changed. Returns identifier of the participant if it is found
     */
    readonly _: 'setGroupCallParticipantIsSpeaking',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Group call participant's synchronization audio source identifier, or 0 for the
     * current user
     */
    readonly audio_source?: number,
    /** Pass true if the user is speaking */
    readonly is_speaking?: boolean,
  }

  export type toggleGroupCallParticipantIsMuted = {
    /**
     * Toggles whether a participant of an active group call is muted, unmuted, or
     * allowed to unmute themselves
     */
    readonly _: 'toggleGroupCallParticipantIsMuted',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /** Pass true to mute the user; pass false to unmute them */
    readonly is_muted?: boolean,
  }

  export type setGroupCallParticipantVolumeLevel = {
    /**
     * Changes volume level of a participant of an active group call. If the current
     * user can manage the group call or is the owner of the group call, then the participant's
     * volume level will be changed for all users with the default volume level
     */
    readonly _: 'setGroupCallParticipantVolumeLevel',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /** New participant's volume level; 1-20000 in hundreds of percents */
    readonly volume_level?: number,
  }

  export type toggleGroupCallParticipantIsHandRaised = {
    /** Toggles whether a group call participant hand is rased; for video chats only */
    readonly _: 'toggleGroupCallParticipantIsHandRaised',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /**
     * Pass true if the user's hand needs to be raised. Only self hand can be raised.
     * Requires groupCall.can_be_managed right to lower other's hand
     */
    readonly is_hand_raised?: boolean,
  }

  export type getGroupCallParticipants = {
    /**
     * Returns information about participants of a non-joined group call that is not
     * bound to a chat
     */
    readonly _: 'getGroupCallParticipants',
    /** The group call which participants will be returned */
    readonly input_group_call?: InputGroupCall$Input,
    /** The maximum number of participants to return; must be positive */
    readonly limit?: number,
  }

  export type loadGroupCallParticipants = {
    /**
     * Loads more participants of a group call. The loaded participants will be received
     * through updates. Use the field groupCall.loaded_all_participants to check whether
     * all participants have already been loaded
     */
    readonly _: 'loadGroupCallParticipants',
    /**
     * Group call identifier. The group call must be previously received through getGroupCall
     * and must be joined or being joined
     */
    readonly group_call_id?: number,
    /** The maximum number of participants to load; up to 100 */
    readonly limit?: number,
  }

  export type leaveGroupCall = {
    /** Leaves a group call */
    readonly _: 'leaveGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type endGroupCall = {
    /**
     * Ends a group call. Requires groupCall.can_be_managed right for video chats or
     * groupCall.is_owned otherwise
     */
    readonly _: 'endGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type getVideoChatStreams = {
    /** Returns information about available video chat streams */
    readonly _: 'getVideoChatStreams',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type getVideoChatStreamSegment = {
    /**
     * Returns a file with a segment of a video chat stream in a modified OGG format
     * for audio or MPEG-4 format for video
     */
    readonly _: 'getVideoChatStreamSegment',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Point in time when the stream segment begins; Unix timestamp in milliseconds */
    readonly time_offset?: number,
    /** Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds */
    readonly scale?: number,
    /** Identifier of an audio/video channel to get as received from tgcalls */
    readonly channel_id?: number,
    /**
     * Video quality as received from tgcalls; pass null to get the worst available
     * quality
     */
    readonly video_quality?: GroupCallVideoQuality$Input,
  }

  export type encryptGroupCallData = {
    /** Encrypts group call data before sending them over network using tgcalls */
    readonly _: 'encryptGroupCallData',
    /** Group call identifier. The call must not be a video chat */
    readonly group_call_id?: number,
    /** Data channel for which data is encrypted */
    readonly data_channel?: GroupCallDataChannel$Input,
    /** Data to encrypt */
    readonly data?: string /* base64 */,
    /** Size of data prefix that must be kept unencrypted */
    readonly unencrypted_prefix_size?: number,
  }

  export type decryptGroupCallData = {
    /** Decrypts group call data received by tgcalls */
    readonly _: 'decryptGroupCallData',
    /** Group call identifier. The call must not be a video chat */
    readonly group_call_id?: number,
    /** Identifier of the group call participant, which sent the data */
    readonly participant_id?: MessageSender$Input,
    /** Data channel for which data was encrypted; pass null if unknown */
    readonly data_channel?: GroupCallDataChannel$Input,
    /** Data to decrypt */
    readonly data?: string /* base64 */,
  }

  export type setMessageSenderBlockList = {
    /**
     * Changes the block list of a message sender. Currently, only users and supergroup
     * chats can be blocked
     */
    readonly _: 'setMessageSenderBlockList',
    /** Identifier of a message sender to block/unblock */
    readonly sender_id?: MessageSender$Input,
    /** New block list for the message sender; pass null to unblock the message sender */
    readonly block_list?: BlockList$Input,
  }

  export type blockMessageSenderFromReplies = {
    /** Blocks an original sender of a message in the Replies chat */
    readonly _: 'blockMessageSenderFromReplies',
    /** The identifier of an incoming message in the Replies chat */
    readonly message_id?: number,
    /** Pass true to delete the message */
    readonly delete_message?: boolean,
    /** Pass true to delete all messages from the same sender */
    readonly delete_all_messages?: boolean,
    /** Pass true to report the sender to the Telegram moderators */
    readonly report_spam?: boolean,
  }

  export type getBlockedMessageSenders = {
    /** Returns users and chats that were blocked by the current user */
    readonly _: 'getBlockedMessageSenders',
    /** Block list from which to return users */
    readonly block_list?: BlockList$Input,
    /** Number of users and chats to skip in the result; must be non-negative */
    readonly offset?: number,
    /** The maximum number of users and chats to return; up to 100 */
    readonly limit?: number,
  }

  export type addContact = {
    /** Adds a user to the contact list or edits an existing contact by their user identifier */
    readonly _: 'addContact',
    /**
     * The contact to add or edit; phone number may be empty and needs to be specified
     * only if known, vCard is ignored
     */
    readonly contact?: contact$Input,
    /**
     * Pass true to share the current user's phone number with the new contact. A corresponding
     * rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field
     * userFullInfo.need_phone_number_privacy_exception to check whether the current
     * user needs to be asked to share their phone number
     */
    readonly share_phone_number?: boolean,
  }

  export type importContacts = {
    /**
     * Adds new contacts or edits existing contacts by their phone numbers; contacts'
     * user identifiers are ignored
     */
    readonly _: 'importContacts',
    /**
     * The list of contacts to import or edit; contacts' vCard are ignored and are
     * not imported
     */
    readonly contacts?: ReadonlyArray<contact$Input>,
  }

  export type getContacts = {
    /** Returns all contacts of the user */
    readonly _: 'getContacts',
  }

  export type searchContacts = {
    /**
     * Searches for the specified query in the first names, last names and usernames
     * of the known user contacts
     */
    readonly _: 'searchContacts',
    /** Query to search for; may be empty to return all contacts */
    readonly query?: string,
    /** The maximum number of users to be returned */
    readonly limit?: number,
  }

  export type removeContacts = {
    /** Removes users from the contact list */
    readonly _: 'removeContacts',
    /** Identifiers of users to be deleted */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getImportedContactCount = {
    /** Returns the total number of imported contacts */
    readonly _: 'getImportedContactCount',
  }

  export type changeImportedContacts = {
    /**
     * Changes imported contacts using the list of contacts saved on the device. Imports
     * newly added contacts and, if at least the file database is enabled, deletes
     * recently deleted contacts. Query result depends on the result of the previous
     * query, so only one query is possible at the same time
     */
    readonly _: 'changeImportedContacts',
    /** The new list of contacts, contact's vCard are ignored and are not imported */
    readonly contacts?: ReadonlyArray<contact$Input>,
  }

  export type clearImportedContacts = {
    /** Clears all imported contacts, contact list remains unchanged */
    readonly _: 'clearImportedContacts',
  }

  export type setCloseFriends = {
    /** Changes the list of close friends of the current user */
    readonly _: 'setCloseFriends',
    /**
     * User identifiers of close friends; the users must be contacts of the current
     * user
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getCloseFriends = {
    /** Returns all close friends of the current user */
    readonly _: 'getCloseFriends',
  }

  export type setUserPersonalProfilePhoto = {
    /** Changes a personal profile photo of a contact user */
    readonly _: 'setUserPersonalProfilePhoto',
    /** User identifier */
    readonly user_id?: number,
    /**
     * Profile photo to set; pass null to delete the photo; inputChatPhotoPrevious
     * isn't supported in this function
     */
    readonly photo?: InputChatPhoto$Input,
  }

  export type suggestUserProfilePhoto = {
    /**
     * Suggests a profile photo to another regular user with common messages and allowing
     * non-paid messages
     */
    readonly _: 'suggestUserProfilePhoto',
    /** User identifier */
    readonly user_id?: number,
    /** Profile photo to suggest; inputChatPhotoPrevious isn't supported in this function */
    readonly photo?: InputChatPhoto$Input,
  }

  export type toggleBotCanManageEmojiStatus = {
    /** Toggles whether the bot can manage emoji status of the current user */
    readonly _: 'toggleBotCanManageEmojiStatus',
    /** User identifier of the bot */
    readonly bot_user_id?: number,
    /**
     * Pass true if the bot is allowed to change emoji status of the user; pass false
     * otherwise
     */
    readonly can_manage_emoji_status?: boolean,
  }

  export type setUserEmojiStatus = {
    /** Changes the emoji status of a user; for bots only */
    readonly _: 'setUserEmojiStatus',
    /** Identifier of the user */
    readonly user_id?: number,
    /** New emoji status; pass null to switch to the default badge */
    readonly emoji_status?: emojiStatus$Input,
  }

  export type searchUserByPhoneNumber = {
    /**
     * Searches a user by their phone number. Returns a 404 error if the user can't
     * be found
     */
    readonly _: 'searchUserByPhoneNumber',
    /** Phone number to search for */
    readonly phone_number?: string,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type sharePhoneNumber = {
    /**
     * Shares the phone number of the current user with a mutual contact. Supposed
     * to be called when the user clicks on chatActionBarSharePhoneNumber
     */
    readonly _: 'sharePhoneNumber',
    /**
     * Identifier of the user with whom to share the phone number. The user must be
     * a mutual contact
     */
    readonly user_id?: number,
  }

  export type getUserProfilePhotos = {
    /** Returns the profile photos of a user. Personal and public photo aren't returned */
    readonly _: 'getUserProfilePhotos',
    /** User identifier */
    readonly user_id?: number,
    /** The number of photos to skip; must be non-negative */
    readonly offset?: number,
    /** The maximum number of photos to be returned; up to 100 */
    readonly limit?: number,
  }

  export type getStickerOutline = {
    /**
     * Returns outline of a sticker. This is an offline method. Returns a 404 error
     * if the outline isn't known
     */
    readonly _: 'getStickerOutline',
    /** File identifier of the sticker */
    readonly sticker_file_id?: number,
    /** Pass true to get the outline scaled for animated emoji */
    readonly for_animated_emoji?: boolean,
    /** Pass true to get the outline scaled for clicked animated emoji message */
    readonly for_clicked_animated_emoji_message?: boolean,
  }

  export type getStickers = {
    /**
     * Returns stickers from the installed sticker sets that correspond to any of the
     * given emoji or can be found by sticker-specific keywords. If the query is non-empty,
     * then favorite, recently used or trending stickers may also be returned
     */
    readonly _: 'getStickers',
    /** Type of the stickers to return */
    readonly sticker_type?: StickerType$Input,
    /**
     * Search query; a space-separated list of emojis or a keyword prefix. If empty,
     * returns all known installed stickers
     */
    readonly query?: string,
    /** The maximum number of stickers to be returned */
    readonly limit?: number,
    /**
     * Chat identifier for which to return stickers. Available custom emoji stickers
     * may be different for different chats
     */
    readonly chat_id?: number,
  }

  export type getAllStickerEmojis = {
    /**
     * Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type,
     * query, 1000000, chat_id)
     */
    readonly _: 'getAllStickerEmojis',
    /** Type of the stickers to search for */
    readonly sticker_type?: StickerType$Input,
    /** Search query */
    readonly query?: string,
    /** Chat identifier for which to find stickers */
    readonly chat_id?: number,
    /**
     * Pass true if only main emoji for each found sticker must be included in the
     * result
     */
    readonly return_only_main_emoji?: boolean,
  }

  export type searchStickers = {
    /**
     * Searches for stickers from public sticker sets that correspond to any of the
     * given emoji
     */
    readonly _: 'searchStickers',
    /** Type of the stickers to return */
    readonly sticker_type?: StickerType$Input,
    /** Space-separated list of emojis to search for */
    readonly emojis?: string,
    /** Query to search for; may be empty to search for emoji only */
    readonly query?: string,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    readonly input_language_codes?: ReadonlyArray<string>,
    /** The offset from which to return the stickers; must be non-negative */
    readonly offset?: number,
    /** The maximum number of stickers to be returned; 0-100 */
    readonly limit?: number,
  }

  export type getGreetingStickers = {
    /**
     * Returns greeting stickers from regular sticker sets that can be used for the
     * start page of other users
     */
    readonly _: 'getGreetingStickers',
  }

  export type getPremiumStickers = {
    /** Returns premium stickers from regular sticker sets */
    readonly _: 'getPremiumStickers',
    /** The maximum number of stickers to be returned; 0-100 */
    readonly limit?: number,
  }

  export type getInstalledStickerSets = {
    /** Returns a list of installed sticker sets */
    readonly _: 'getInstalledStickerSets',
    /** Type of the sticker sets to return */
    readonly sticker_type?: StickerType$Input,
  }

  export type getArchivedStickerSets = {
    /** Returns a list of archived sticker sets */
    readonly _: 'getArchivedStickerSets',
    /** Type of the sticker sets to return */
    readonly sticker_type?: StickerType$Input,
    /**
     * Identifier of the sticker set from which to return the result; use 0 to get
     * results from the beginning
     */
    readonly offset_sticker_set_id?: number | string,
    /** The maximum number of sticker sets to return; up to 100 */
    readonly limit?: number,
  }

  export type getTrendingStickerSets = {
    /**
     * Returns a list of trending sticker sets. For optimal performance, the number
     * of returned sticker sets is chosen by TDLib
     */
    readonly _: 'getTrendingStickerSets',
    /** Type of the sticker sets to return */
    readonly sticker_type?: StickerType$Input,
    /** The offset from which to return the sticker sets; must be non-negative */
    readonly offset?: number,
    /**
     * The maximum number of sticker sets to be returned; up to 100. For optimal performance,
     * the number of returned sticker sets is chosen by TDLib and can be smaller than
     * the specified limit, even if the end of the list has not been reached
     */
    readonly limit?: number,
  }

  export type getAttachedStickerSets = {
    /**
     * Returns a list of sticker sets attached to a file, including regular, mask,
     * and emoji sticker sets. Currently, only animations, photos, and videos can have
     * attached sticker sets
     */
    readonly _: 'getAttachedStickerSets',
    /** File identifier */
    readonly file_id?: number,
  }

  export type getStickerSet = {
    /** Returns information about a sticker set by its identifier */
    readonly _: 'getStickerSet',
    /** Identifier of the sticker set */
    readonly set_id?: number | string,
  }

  export type getStickerSetName = {
    /** Returns name of a sticker set by its identifier */
    readonly _: 'getStickerSetName',
    /** Identifier of the sticker set */
    readonly set_id?: number | string,
  }

  export type searchStickerSet = {
    /** Searches for a sticker set by its name */
    readonly _: 'searchStickerSet',
    /** Name of the sticker set */
    readonly name?: string,
    /** Pass true to ignore local cache of sticker sets and always send a network request */
    readonly ignore_cache?: boolean,
  }

  export type searchInstalledStickerSets = {
    /**
     * Searches for installed sticker sets by looking for specified query in their
     * title and name
     */
    readonly _: 'searchInstalledStickerSets',
    /** Type of the sticker sets to search for */
    readonly sticker_type?: StickerType$Input,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of sticker sets to return */
    readonly limit?: number,
  }

  export type searchStickerSets = {
    /**
     * Searches for sticker sets by looking for specified query in their title and
     * name. Excludes installed sticker sets from the results
     */
    readonly _: 'searchStickerSets',
    /** Type of the sticker sets to return */
    readonly sticker_type?: StickerType$Input,
    /** Query to search for */
    readonly query?: string,
  }

  export type changeStickerSet = {
    /** Installs/uninstalls or activates/archives a sticker set */
    readonly _: 'changeStickerSet',
    /** Identifier of the sticker set */
    readonly set_id?: number | string,
    /** The new value of is_installed */
    readonly is_installed?: boolean,
    /**
     * The new value of is_archived. A sticker set can't be installed and archived
     * simultaneously
     */
    readonly is_archived?: boolean,
  }

  export type viewTrendingStickerSets = {
    /** Informs the server that some trending sticker sets have been viewed by the user */
    readonly _: 'viewTrendingStickerSets',
    /** Identifiers of viewed trending sticker sets */
    readonly sticker_set_ids?: ReadonlyArray<number | string>,
  }

  export type reorderInstalledStickerSets = {
    /** Changes the order of installed sticker sets */
    readonly _: 'reorderInstalledStickerSets',
    /** Type of the sticker sets to reorder */
    readonly sticker_type?: StickerType$Input,
    /** Identifiers of installed sticker sets in the new correct order */
    readonly sticker_set_ids?: ReadonlyArray<number | string>,
  }

  export type getRecentStickers = {
    /** Returns a list of recently used stickers */
    readonly _: 'getRecentStickers',
    /**
     * Pass true to return stickers and masks that were recently attached to photos
     * or video files; pass false to return recently sent stickers
     */
    readonly is_attached?: boolean,
  }

  export type addRecentSticker = {
    /**
     * Manually adds a new sticker to the list of recently used stickers. The new sticker
     * is added to the top of the list. If the sticker was already in the list, it
     * is removed from the list first. Only stickers belonging to a sticker set or
     * in WEBP or WEBM format can be added to this list. Emoji stickers can't be added
     * to recent stickers
     */
    readonly _: 'addRecentSticker',
    /**
     * Pass true to add the sticker to the list of stickers recently attached to photo
     * or video files; pass false to add the sticker to the list of recently sent stickers
     */
    readonly is_attached?: boolean,
    /** Sticker file to add */
    readonly sticker?: InputFile$Input,
  }

  export type removeRecentSticker = {
    /** Removes a sticker from the list of recently used stickers */
    readonly _: 'removeRecentSticker',
    /**
     * Pass true to remove the sticker from the list of stickers recently attached
     * to photo or video files; pass false to remove the sticker from the list of recently
     * sent stickers
     */
    readonly is_attached?: boolean,
    /** Sticker file to delete */
    readonly sticker?: InputFile$Input,
  }

  export type clearRecentStickers = {
    /** Clears the list of recently used stickers */
    readonly _: 'clearRecentStickers',
    /**
     * Pass true to clear the list of stickers recently attached to photo or video
     * files; pass false to clear the list of recently sent stickers
     */
    readonly is_attached?: boolean,
  }

  export type getFavoriteStickers = {
    /** Returns favorite stickers */
    readonly _: 'getFavoriteStickers',
  }

  export type addFavoriteSticker = {
    /**
     * Adds a new sticker to the list of favorite stickers. The new sticker is added
     * to the top of the list. If the sticker was already in the list, it is removed
     * from the list first. Only stickers belonging to a sticker set or in WEBP or
     * WEBM format can be added to this list. Emoji stickers can't be added to favorite
     * stickers
     */
    readonly _: 'addFavoriteSticker',
    /** Sticker file to add */
    readonly sticker?: InputFile$Input,
  }

  export type removeFavoriteSticker = {
    /** Removes a sticker from the list of favorite stickers */
    readonly _: 'removeFavoriteSticker',
    /** Sticker file to delete from the list */
    readonly sticker?: InputFile$Input,
  }

  export type getStickerEmojis = {
    /**
     * Returns emoji corresponding to a sticker. The list is only for informational
     * purposes, because a sticker is always sent with a fixed emoji from the corresponding
     * Sticker object
     */
    readonly _: 'getStickerEmojis',
    /** Sticker file identifier */
    readonly sticker?: InputFile$Input,
  }

  export type searchEmojis = {
    /**
     * Searches for emojis by keywords. Supported only if the file database is enabled.
     * Order of results is unspecified
     */
    readonly _: 'searchEmojis',
    /** Text to search for */
    readonly text?: string,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    readonly input_language_codes?: ReadonlyArray<string>,
  }

  export type getKeywordEmojis = {
    /**
     * Return emojis matching the keyword. Supported only if the file database is enabled.
     * Order of results is unspecified
     */
    readonly _: 'getKeywordEmojis',
    /** Text to search for */
    readonly text?: string,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    readonly input_language_codes?: ReadonlyArray<string>,
  }

  export type getEmojiCategories = {
    /** Returns available emoji categories */
    readonly _: 'getEmojiCategories',
    /** Type of emoji categories to return; pass null to get default emoji categories */
    readonly type?: EmojiCategoryType$Input,
  }

  export type getAnimatedEmoji = {
    /**
     * Returns an animated emoji corresponding to a given emoji. Returns a 404 error
     * if the emoji has no animated emoji
     */
    readonly _: 'getAnimatedEmoji',
    /** The emoji */
    readonly emoji?: string,
  }

  export type getEmojiSuggestionsUrl = {
    /**
     * Returns an HTTP URL which can be used to automatically log in to the translation
     * platform and suggest new emoji replacements. The URL will be valid for 30 seconds
     * after generation
     */
    readonly _: 'getEmojiSuggestionsUrl',
    /** Language code for which the emoji replacements will be suggested */
    readonly language_code?: string,
  }

  export type getCustomEmojiStickers = {
    /**
     * Returns the list of custom emoji stickers by their identifiers. Stickers are
     * returned in arbitrary order. Only found stickers are returned
     */
    readonly _: 'getCustomEmojiStickers',
    /**
     * Identifiers of custom emoji stickers. At most 200 custom emoji stickers can
     * be received simultaneously
     */
    readonly custom_emoji_ids?: ReadonlyArray<number | string>,
  }

  export type getDefaultChatPhotoCustomEmojiStickers = {
    /** Returns default list of custom emoji stickers for placing on a chat photo */
    readonly _: 'getDefaultChatPhotoCustomEmojiStickers',
  }

  export type getDefaultProfilePhotoCustomEmojiStickers = {
    /** Returns default list of custom emoji stickers for placing on a profile photo */
    readonly _: 'getDefaultProfilePhotoCustomEmojiStickers',
  }

  export type getDefaultBackgroundCustomEmojiStickers = {
    /** Returns default list of custom emoji stickers for reply background */
    readonly _: 'getDefaultBackgroundCustomEmojiStickers',
  }

  export type getSavedAnimations = {
    /** Returns saved animations */
    readonly _: 'getSavedAnimations',
  }

  export type addSavedAnimation = {
    /**
     * Manually adds a new animation to the list of saved animations. The new animation
     * is added to the beginning of the list. If the animation was already in the list,
     * it is removed first. Only non-secret video animations with MIME type "video/mp4"
     * can be added to the list
     */
    readonly _: 'addSavedAnimation',
    /**
     * The animation file to be added. Only animations known to the server (i.e., successfully
     * sent via a message) can be added to the list
     */
    readonly animation?: InputFile$Input,
  }

  export type removeSavedAnimation = {
    /** Removes an animation from the list of saved animations */
    readonly _: 'removeSavedAnimation',
    /** Animation file to be removed */
    readonly animation?: InputFile$Input,
  }

  export type getRecentInlineBots = {
    /** Returns up to 20 recently used inline bots in the order of their last usage */
    readonly _: 'getRecentInlineBots',
  }

  export type getOwnedBots = {
    /** Returns the list of bots owned by the current user */
    readonly _: 'getOwnedBots',
  }

  export type searchHashtags = {
    /** Searches for recently used hashtags by their prefix */
    readonly _: 'searchHashtags',
    /** Hashtag prefix to search for */
    readonly prefix?: string,
    /** The maximum number of hashtags to be returned */
    readonly limit?: number,
  }

  export type removeRecentHashtag = {
    /** Removes a hashtag from the list of recently used hashtags */
    readonly _: 'removeRecentHashtag',
    /** Hashtag to delete */
    readonly hashtag?: string,
  }

  export type getLinkPreview = {
    /**
     * Returns a link preview by the text of a message. Do not call this function too
     * often. Returns a 404 error if the text has no link preview
     */
    readonly _: 'getLinkPreview',
    /** Message text with formatting */
    readonly text?: formattedText$Input,
    /**
     * Options to be used for generation of the link preview; pass null to use default
     * link preview options
     */
    readonly link_preview_options?: linkPreviewOptions$Input,
  }

  export type getWebPageInstantView = {
    /**
     * Returns an instant view version of a web page if available. This is an offline
     * method if only_local is true. Returns a 404 error if the web page has no instant
     * view page
     */
    readonly _: 'getWebPageInstantView',
    /** The web page URL */
    readonly url?: string,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type setProfilePhoto = {
    /** Changes a profile photo for the current user */
    readonly _: 'setProfilePhoto',
    /** Profile photo to set */
    readonly photo?: InputChatPhoto$Input,
    /**
     * Pass true to set the public photo, which will be visible even the main photo
     * is hidden by privacy settings
     */
    readonly is_public?: boolean,
  }

  export type deleteProfilePhoto = {
    /** Deletes a profile photo */
    readonly _: 'deleteProfilePhoto',
    /** Identifier of the profile photo to delete */
    readonly profile_photo_id?: number | string,
  }

  export type setAccentColor = {
    /**
     * Changes accent color and background custom emoji for the current user; for Telegram
     * Premium users only
     */
    readonly _: 'setAccentColor',
    /** Identifier of the accent color to use */
    readonly accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the reply header and link preview
     * background; 0 if none
     */
    readonly background_custom_emoji_id?: number | string,
  }

  export type setProfileAccentColor = {
    /**
     * Changes accent color and background custom emoji for profile of the current
     * user; for Telegram Premium users only
     */
    readonly _: 'setProfileAccentColor',
    /** Identifier of the accent color to use for profile; pass -1 if none */
    readonly profile_accent_color_id?: number,
    /**
     * Identifier of a custom emoji to be shown on the user's profile photo background;
     * 0 if none
     */
    readonly profile_background_custom_emoji_id?: number | string,
  }

  export type setName = {
    /** Changes the first and last name of the current user */
    readonly _: 'setName',
    /** The new value of the first name for the current user; 1-64 characters */
    readonly first_name?: string,
    /** The new value of the optional last name for the current user; 0-64 characters */
    readonly last_name?: string,
  }

  export type setBio = {
    /** Changes the bio of the current user */
    readonly _: 'setBio',
    /**
     * The new value of the user bio; 0-getOption("bio_length_max") characters without
     * line feeds
     */
    readonly bio?: string,
  }

  export type setUsername = {
    /** Changes the editable username of the current user */
    readonly _: 'setUsername',
    /**
     * The new value of the username. Use an empty string to remove the username. The
     * username can't be completely removed if there is another active or disabled
     * username
     */
    readonly username?: string,
  }

  export type toggleUsernameIsActive = {
    /**
     * Changes active state for a username of the current user. The editable username
     * can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH"
     * if the maximum number of active usernames has been reached
     */
    readonly _: 'toggleUsernameIsActive',
    /** The username to change */
    readonly username?: string,
    /** Pass true to activate the username; pass false to disable it */
    readonly is_active?: boolean,
  }

  export type reorderActiveUsernames = {
    /** Changes order of active usernames of the current user */
    readonly _: 'reorderActiveUsernames',
    /** The new order of active usernames. All currently active usernames must be specified */
    readonly usernames?: ReadonlyArray<string>,
  }

  export type setBirthdate = {
    /** Changes the birthdate of the current user */
    readonly _: 'setBirthdate',
    /** The new value of the current user's birthdate; pass null to remove the birthdate */
    readonly birthdate?: birthdate$Input,
  }

  export type setPersonalChat = {
    /** Changes the personal chat of the current user */
    readonly _: 'setPersonalChat',
    /**
     * Identifier of the new personal chat; pass 0 to remove the chat. Use getSuitablePersonalChats
     * to get suitable chats
     */
    readonly chat_id?: number,
  }

  export type setEmojiStatus = {
    /** Changes the emoji status of the current user; for Telegram Premium users only */
    readonly _: 'setEmojiStatus',
    /** New emoji status; pass null to switch to the default badge */
    readonly emoji_status?: emojiStatus$Input,
  }

  export type toggleHasSponsoredMessagesEnabled = {
    /**
     * Toggles whether the current user has sponsored messages enabled. The setting
     * has no effect for users without Telegram Premium for which sponsored messages
     * are always enabled
     */
    readonly _: 'toggleHasSponsoredMessagesEnabled',
    /**
     * Pass true to enable sponsored messages for the current user; false to disable
     * them
     */
    readonly has_sponsored_messages_enabled?: boolean,
  }

  export type setBusinessLocation = {
    /**
     * Changes the business location of the current user. Requires Telegram Business
     * subscription
     */
    readonly _: 'setBusinessLocation',
    /** The new location of the business; pass null to remove the location */
    readonly location?: businessLocation$Input,
  }

  export type setBusinessOpeningHours = {
    /**
     * Changes the business opening hours of the current user. Requires Telegram Business
     * subscription
     */
    readonly _: 'setBusinessOpeningHours',
    /**
     * The new opening hours of the business; pass null to remove the opening hours;
     * up to 28 time intervals can be specified
     */
    readonly opening_hours?: businessOpeningHours$Input,
  }

  export type setBusinessGreetingMessageSettings = {
    /**
     * Changes the business greeting message settings of the current user. Requires
     * Telegram Business subscription
     */
    readonly _: 'setBusinessGreetingMessageSettings',
    /**
     * The new settings for the greeting message of the business; pass null to disable
     * the greeting message
     */
    readonly greeting_message_settings?: businessGreetingMessageSettings$Input,
  }

  export type setBusinessAwayMessageSettings = {
    /**
     * Changes the business away message settings of the current user. Requires Telegram
     * Business subscription
     */
    readonly _: 'setBusinessAwayMessageSettings',
    /**
     * The new settings for the away message of the business; pass null to disable
     * the away message
     */
    readonly away_message_settings?: businessAwayMessageSettings$Input,
  }

  export type setBusinessStartPage = {
    /**
     * Changes the business start page of the current user. Requires Telegram Business
     * subscription
     */
    readonly _: 'setBusinessStartPage',
    /** The new start page of the business; pass null to remove custom start page */
    readonly start_page?: inputBusinessStartPage$Input,
  }

  export type sendPhoneNumberCode = {
    /**
     * Sends a code to the specified phone number. Aborts previous phone number verification
     * if there was one. On success, returns information about the sent code
     */
    readonly _: 'sendPhoneNumberCode',
    /** The phone number, in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
    /** Type of the request for which the code is sent */
    readonly type?: PhoneNumberCodeType$Input,
  }

  export type sendPhoneNumberFirebaseSms = {
    /**
     * Sends Firebase Authentication SMS to the specified phone number. Works only
     * when received a code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
     */
    readonly _: 'sendPhoneNumberFirebaseSms',
    /**
     * Play Integrity API or SafetyNet Attestation API token for the Android application,
     * or secret from push notification for the iOS application
     */
    readonly token?: string,
  }

  export type reportPhoneNumberCodeMissing = {
    /**
     * Reports that authentication code wasn't delivered via SMS to the specified phone
     * number; for official mobile applications only
     */
    readonly _: 'reportPhoneNumberCodeMissing',
    /** Current mobile network code */
    readonly mobile_network_code?: string,
  }

  export type resendPhoneNumberCode = {
    /**
     * Resends the authentication code sent to a phone number. Works only if the previously
     * received authenticationCodeInfo next_code_type was not null and the server-specified
     * timeout has passed
     */
    readonly _: 'resendPhoneNumberCode',
    /** Reason of code resending; pass null if unknown */
    readonly reason?: ResendCodeReason$Input,
  }

  export type checkPhoneNumberCode = {
    /**
     * Check the authentication code and completes the request for which the code was
     * sent if appropriate
     */
    readonly _: 'checkPhoneNumberCode',
    /** Authentication code to check */
    readonly code?: string,
  }

  export type getBusinessConnectedBot = {
    /**
     * Returns the business bot that is connected to the current user account. Returns
     * a 404 error if there is no connected bot
     */
    readonly _: 'getBusinessConnectedBot',
  }

  export type setBusinessConnectedBot = {
    /** Adds or changes business bot that is connected to the current user account */
    readonly _: 'setBusinessConnectedBot',
    /** Connection settings for the bot */
    readonly bot?: businessConnectedBot$Input,
  }

  export type deleteBusinessConnectedBot = {
    /** Deletes the business bot that is connected to the current user account */
    readonly _: 'deleteBusinessConnectedBot',
    /** Unique user identifier for the bot */
    readonly bot_user_id?: number,
  }

  export type toggleBusinessConnectedBotChatIsPaused = {
    /** Pauses or resumes the connected business bot in a specific chat */
    readonly _: 'toggleBusinessConnectedBotChatIsPaused',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true to pause the connected bot in the chat; pass false to resume the bot */
    readonly is_paused?: boolean,
  }

  export type removeBusinessConnectedBotFromChat = {
    /**
     * Removes the connected business bot from a specific chat by adding the chat to
     * businessRecipients.excluded_chat_ids
     */
    readonly _: 'removeBusinessConnectedBotFromChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getBusinessChatLinks = {
    /** Returns business chat links created for the current account */
    readonly _: 'getBusinessChatLinks',
  }

  export type createBusinessChatLink = {
    /**
     * Creates a business chat link for the current account. Requires Telegram Business
     * subscription. There can be up to getOption("business_chat_link_count_max") links
     * created. Returns the created link
     */
    readonly _: 'createBusinessChatLink',
    /** Information about the link to create */
    readonly link_info?: inputBusinessChatLink$Input,
  }

  export type editBusinessChatLink = {
    /**
     * Edits a business chat link of the current account. Requires Telegram Business
     * subscription. Returns the edited link
     */
    readonly _: 'editBusinessChatLink',
    /** The link to edit */
    readonly link?: string,
    /** New description of the link */
    readonly link_info?: inputBusinessChatLink$Input,
  }

  export type deleteBusinessChatLink = {
    /** Deletes a business chat link of the current account */
    readonly _: 'deleteBusinessChatLink',
    /** The link to delete */
    readonly link?: string,
  }

  export type getBusinessChatLinkInfo = {
    /** Returns information about a business chat link */
    readonly _: 'getBusinessChatLinkInfo',
    /** Name of the link */
    readonly link_name?: string,
  }

  export type getUserLink = {
    /**
     * Returns an HTTPS link, which can be used to get information about the current
     * user
     */
    readonly _: 'getUserLink',
  }

  export type searchUserByToken = {
    /** Searches a user by a token from the user's link */
    readonly _: 'searchUserByToken',
    /** Token to search for */
    readonly token?: string,
  }

  export type setCommands = {
    /**
     * Sets the list of commands supported by the bot for the given user scope and
     * language; for bots only
     */
    readonly _: 'setCommands',
    /**
     * The scope to which the commands are relevant; pass null to change commands in
     * the default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /**
     * A two-letter ISO 639-1 language code. If empty, the commands will be applied
     * to all users from the given scope, for which language there are no dedicated
     * commands
     */
    readonly language_code?: string,
    /** List of the bot's commands */
    readonly commands?: ReadonlyArray<botCommand$Input>,
  }

  export type deleteCommands = {
    /**
     * Deletes commands supported by the bot for the given user scope and language;
     * for bots only
     */
    readonly _: 'deleteCommands',
    /**
     * The scope to which the commands are relevant; pass null to delete commands in
     * the default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type getCommands = {
    /**
     * Returns the list of commands supported by the bot for the given user scope and
     * language; for bots only
     */
    readonly _: 'getCommands',
    /**
     * The scope to which the commands are relevant; pass null to get commands in the
     * default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type setMenuButton = {
    /** Sets menu button for the given user or for all users; for bots only */
    readonly _: 'setMenuButton',
    /** Identifier of the user or 0 to set menu button for all users */
    readonly user_id?: number,
    /** New menu button */
    readonly menu_button?: botMenuButton$Input,
  }

  export type getMenuButton = {
    /** Returns menu button set by the bot for the given user; for bots only */
    readonly _: 'getMenuButton',
    /** Identifier of the user or 0 to get the default menu button */
    readonly user_id?: number,
  }

  export type setDefaultGroupAdministratorRights = {
    /**
     * Sets default administrator rights for adding the bot to basic group and supergroup
     * chats; for bots only
     */
    readonly _: 'setDefaultGroupAdministratorRights',
    /**
     * Default administrator rights for adding the bot to basic group and supergroup
     * chats; pass null to remove default rights
     */
    readonly default_group_administrator_rights?: chatAdministratorRights$Input,
  }

  export type setDefaultChannelAdministratorRights = {
    /**
     * Sets default administrator rights for adding the bot to channel chats; for bots
     * only
     */
    readonly _: 'setDefaultChannelAdministratorRights',
    /**
     * Default administrator rights for adding the bot to channels; pass null to remove
     * default rights
     */
    readonly default_channel_administrator_rights?: chatAdministratorRights$Input,
  }

  export type canBotSendMessages = {
    /**
     * Checks whether the specified bot can send messages to the user. Returns a 404
     * error if can't and the access can be granted by call to allowBotToSendMessages
     */
    readonly _: 'canBotSendMessages',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
  }

  export type allowBotToSendMessages = {
    /** Allows the specified bot to send messages to the user */
    readonly _: 'allowBotToSendMessages',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
  }

  export type sendWebAppCustomRequest = {
    /** Sends a custom request from a Web App */
    readonly _: 'sendWebAppCustomRequest',
    /** Identifier of the bot */
    readonly bot_user_id?: number,
    /** The method name */
    readonly method?: string,
    /** JSON-serialized method parameters */
    readonly parameters?: string,
  }

  export type getBotMediaPreviews = {
    /** Returns the list of media previews of a bot */
    readonly _: 'getBotMediaPreviews',
    /** Identifier of the target bot. The bot must have the main Web App */
    readonly bot_user_id?: number,
  }

  export type getBotMediaPreviewInfo = {
    /**
     * Returns the list of media previews for the given language and the list of languages
     * for which the bot has dedicated previews
     */
    readonly _: 'getBotMediaPreviewInfo',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code for which to get previews. If empty, then
     * default previews are returned
     */
    readonly language_code?: string,
  }

  export type addBotMediaPreview = {
    /**
     * Adds a new media preview to the beginning of the list of media previews of a
     * bot. Returns the added preview after addition is completed server-side. The
     * total number of previews must not exceed getOption("bot_media_preview_count_max")
     * for the given language
     */
    readonly _: 'addBotMediaPreview',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code for which preview is added. If empty, then
     * the preview will be shown to all users for whose languages there are no dedicated
     * previews. If non-empty, then there must be an official language pack of the
     * same name, which is returned by getLocalizationTargetInfo
     */
    readonly language_code?: string,
    /** Content of the added preview */
    readonly content?: InputStoryContent$Input,
  }

  export type editBotMediaPreview = {
    /**
     * Replaces media preview in the list of media previews of a bot. Returns the new
     * preview after edit is completed server-side
     */
    readonly _: 'editBotMediaPreview',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    readonly bot_user_id?: number,
    /** Language code of the media preview to edit */
    readonly language_code?: string,
    /** File identifier of the media to replace */
    readonly file_id?: number,
    /** Content of the new preview */
    readonly content?: InputStoryContent$Input,
  }

  export type reorderBotMediaPreviews = {
    /** Changes order of media previews in the list of media previews of a bot */
    readonly _: 'reorderBotMediaPreviews',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    readonly bot_user_id?: number,
    /** Language code of the media previews to reorder */
    readonly language_code?: string,
    /** File identifiers of the media in the new order */
    readonly file_ids?: ReadonlyArray<number>,
  }

  export type deleteBotMediaPreviews = {
    /** Delete media previews from the list of media previews of a bot */
    readonly _: 'deleteBotMediaPreviews',
    /**
     * Identifier of the target bot. The bot must be owned and must have the main Web
     * App
     */
    readonly bot_user_id?: number,
    /** Language code of the media previews to delete */
    readonly language_code?: string,
    /** File identifiers of the media to delete */
    readonly file_ids?: ReadonlyArray<number>,
  }

  export type setBotName = {
    /** Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true */
    readonly _: 'setBotName',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the name will be shown to all
     * users for whose languages there is no dedicated name
     */
    readonly language_code?: string,
    /**
     * New bot's name on the specified language; 0-64 characters; must be non-empty
     * if language code is empty
     */
    readonly name?: string,
  }

  export type getBotName = {
    /**
     * Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    readonly _: 'getBotName',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type setBotProfilePhoto = {
    /** Changes a profile photo for a bot */
    readonly _: 'setBotProfilePhoto',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Profile photo to set; pass null to delete the chat photo */
    readonly photo?: InputChatPhoto$Input,
  }

  export type toggleBotUsernameIsActive = {
    /**
     * Changes active state for a username of a bot. The editable username can't be
     * disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if
     * the maximum number of active usernames has been reached. Can be called only
     * if userTypeBot.can_be_edited == true
     */
    readonly _: 'toggleBotUsernameIsActive',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** The username to change */
    readonly username?: string,
    /** Pass true to activate the username; pass false to disable it */
    readonly is_active?: boolean,
  }

  export type reorderBotActiveUsernames = {
    /**
     * Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    readonly _: 'reorderBotActiveUsernames',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** The new order of active usernames. All currently active usernames must be specified */
    readonly usernames?: ReadonlyArray<string>,
  }

  export type setBotInfoDescription = {
    /**
     * Sets the text shown in the chat with a bot if the chat is empty. Can be called
     * only if userTypeBot.can_be_edited == true
     */
    readonly _: 'setBotInfoDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the description will be shown
     * to all users for whose languages there is no dedicated description
     */
    readonly language_code?: string,
    /** New bot's description on the specified language */
    readonly description?: string,
  }

  export type getBotInfoDescription = {
    /**
     * Returns the text shown in the chat with a bot if the chat is empty in the given
     * language. Can be called only if userTypeBot.can_be_edited == true
     */
    readonly _: 'getBotInfoDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type setBotInfoShortDescription = {
    /**
     * Sets the text shown on a bot's profile page and sent together with the link
     * when users share the bot. Can be called only if userTypeBot.can_be_edited ==
     * true
     */
    readonly _: 'setBotInfoShortDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the short description will be
     * shown to all users for whose languages there is no dedicated description
     */
    readonly language_code?: string,
    /** New bot's short description on the specified language */
    readonly short_description?: string,
  }

  export type getBotInfoShortDescription = {
    /**
     * Returns the text shown on a bot's profile page and sent together with the link
     * when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    readonly _: 'getBotInfoShortDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type setMessageSenderBotVerification = {
    /** Changes the verification status of a user or a chat by an owned bot */
    readonly _: 'setMessageSenderBotVerification',
    /** Identifier of the owned bot, which will verify the user or the chat */
    readonly bot_user_id?: number,
    /**
     * Identifier of the user or the supergroup or channel chat, which will be verified
     * by the bot
     */
    readonly verified_id?: MessageSender$Input,
    /**
     * Custom description of verification reason; 0-getOption("bot_verification_custom_description_length_max").
     * If empty, then "was verified by organization "organization_name"" will be used
     * as description. Can be specified only if the bot is allowed to provide custom
     * description
     */
    readonly custom_description?: string,
  }

  export type removeMessageSenderBotVerification = {
    /** Removes the verification status of a user or a chat by an owned bot */
    readonly _: 'removeMessageSenderBotVerification',
    /** Identifier of the owned bot, which verified the user or the chat */
    readonly bot_user_id?: number,
    /**
     * Identifier of the user or the supergroup or channel chat, which verification
     * is removed
     */
    readonly verified_id?: MessageSender$Input,
  }

  export type getActiveSessions = {
    /** Returns all active sessions of the current user */
    readonly _: 'getActiveSessions',
  }

  export type terminateSession = {
    /** Terminates a session of the current user */
    readonly _: 'terminateSession',
    /** Session identifier */
    readonly session_id?: number | string,
  }

  export type terminateAllOtherSessions = {
    /** Terminates all other sessions of the current user */
    readonly _: 'terminateAllOtherSessions',
  }

  export type confirmSession = {
    /** Confirms an unconfirmed session of the current user from another device */
    readonly _: 'confirmSession',
    /** Session identifier */
    readonly session_id?: number | string,
  }

  export type toggleSessionCanAcceptCalls = {
    /** Toggles whether a session can accept incoming calls */
    readonly _: 'toggleSessionCanAcceptCalls',
    /** Session identifier */
    readonly session_id?: number | string,
    /** Pass true to allow accepting incoming calls by the session; pass false otherwise */
    readonly can_accept_calls?: boolean,
  }

  export type toggleSessionCanAcceptSecretChats = {
    /** Toggles whether a session can accept incoming secret chats */
    readonly _: 'toggleSessionCanAcceptSecretChats',
    /** Session identifier */
    readonly session_id?: number | string,
    /** Pass true to allow accepting secret chats by the session; pass false otherwise */
    readonly can_accept_secret_chats?: boolean,
  }

  export type setInactiveSessionTtl = {
    /**
     * Changes the period of inactivity after which sessions will automatically be
     * terminated
     */
    readonly _: 'setInactiveSessionTtl',
    /**
     * New number of days of inactivity before sessions will be automatically terminated;
     * 1-366 days
     */
    readonly inactive_session_ttl_days?: number,
  }

  export type getConnectedWebsites = {
    /** Returns all website where the current user used Telegram to log in */
    readonly _: 'getConnectedWebsites',
  }

  export type disconnectWebsite = {
    /** Disconnects website from the current user's Telegram account */
    readonly _: 'disconnectWebsite',
    /** Website identifier */
    readonly website_id?: number | string,
  }

  export type disconnectAllWebsites = {
    /** Disconnects all websites from the current user's Telegram account */
    readonly _: 'disconnectAllWebsites',
  }

  export type setSupergroupUsername = {
    /**
     * Changes the editable username of a supergroup or channel, requires owner privileges
     * in the supergroup or channel
     */
    readonly _: 'setSupergroupUsername',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /**
     * New value of the username. Use an empty string to remove the username. The username
     * can't be completely removed if there is another active or disabled username
     */
    readonly username?: string,
  }

  export type toggleSupergroupUsernameIsActive = {
    /**
     * Changes active state for a username of a supergroup or channel, requires owner
     * privileges in the supergroup or channel. The editable username can't be disabled.
     * May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum
     * number of active usernames has been reached
     */
    readonly _: 'toggleSupergroupUsernameIsActive',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** The username to change */
    readonly username?: string,
    /** Pass true to activate the username; pass false to disable it */
    readonly is_active?: boolean,
  }

  export type disableAllSupergroupUsernames = {
    /**
     * Disables all active non-editable usernames of a supergroup or channel, requires
     * owner privileges in the supergroup or channel
     */
    readonly _: 'disableAllSupergroupUsernames',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
  }

  export type reorderSupergroupActiveUsernames = {
    /**
     * Changes order of active usernames of a supergroup or channel, requires owner
     * privileges in the supergroup or channel
     */
    readonly _: 'reorderSupergroupActiveUsernames',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** The new order of active usernames. All currently active usernames must be specified */
    readonly usernames?: ReadonlyArray<string>,
  }

  export type setSupergroupStickerSet = {
    /**
     * Changes the sticker set of a supergroup; requires can_change_info administrator
     * right
     */
    readonly _: 'setSupergroupStickerSet',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /**
     * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup
     * sticker set
     */
    readonly sticker_set_id?: number | string,
  }

  export type setSupergroupCustomEmojiStickerSet = {
    /**
     * Changes the custom emoji sticker set of a supergroup; requires can_change_info
     * administrator right. The chat must have at least chatBoostFeatures.min_custom_emoji_sticker_set_boost_level
     * boost level to pass the corresponding color
     */
    readonly _: 'setSupergroupCustomEmojiStickerSet',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /**
     * New value of the custom emoji sticker set identifier for the supergroup. Use
     * 0 to remove the custom emoji sticker set in the supergroup
     */
    readonly custom_emoji_sticker_set_id?: number | string,
  }

  export type setSupergroupUnrestrictBoostCount = {
    /**
     * Changes the number of times the supergroup must be boosted by a user to ignore
     * slow mode and chat permission restrictions; requires can_restrict_members administrator
     * right
     */
    readonly _: 'setSupergroupUnrestrictBoostCount',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /**
     * New value of the unrestrict_boost_count supergroup setting; 0-8. Use 0 to remove
     * the setting
     */
    readonly unrestrict_boost_count?: number,
  }

  export type toggleSupergroupSignMessages = {
    /**
     * Toggles whether sender signature or link to the account is added to sent messages
     * in a channel; requires can_change_info member right
     */
    readonly _: 'toggleSupergroupSignMessages',
    /** Identifier of the channel */
    readonly supergroup_id?: number,
    /** New value of sign_messages */
    readonly sign_messages?: boolean,
    /** New value of show_message_sender */
    readonly show_message_sender?: boolean,
  }

  export type toggleSupergroupJoinToSendMessages = {
    /**
     * Toggles whether joining is mandatory to send messages to a discussion supergroup;
     * requires can_restrict_members administrator right
     */
    readonly _: 'toggleSupergroupJoinToSendMessages',
    /** Identifier of the supergroup that isn't a broadcast group */
    readonly supergroup_id?: number,
    /** New value of join_to_send_messages */
    readonly join_to_send_messages?: boolean,
  }

  export type toggleSupergroupJoinByRequest = {
    /**
     * Toggles whether all users directly joining the supergroup need to be approved
     * by supergroup administrators; requires can_restrict_members administrator right
     */
    readonly _: 'toggleSupergroupJoinByRequest',
    /** Identifier of the supergroup that isn't a broadcast group */
    readonly supergroup_id?: number,
    /** New value of join_by_request */
    readonly join_by_request?: boolean,
  }

  export type toggleSupergroupIsAllHistoryAvailable = {
    /**
     * Toggles whether the message history of a supergroup is available to new members;
     * requires can_change_info member right
     */
    readonly _: 'toggleSupergroupIsAllHistoryAvailable',
    /** The identifier of the supergroup */
    readonly supergroup_id?: number,
    /** The new value of is_all_history_available */
    readonly is_all_history_available?: boolean,
  }

  export type toggleSupergroupCanHaveSponsoredMessages = {
    /**
     * Toggles whether sponsored messages are shown in the channel chat; requires owner
     * privileges in the channel. The chat must have at least chatBoostFeatures.min_sponsored_message_disable_boost_level
     * boost level to disable sponsored messages
     */
    readonly _: 'toggleSupergroupCanHaveSponsoredMessages',
    /** The identifier of the channel */
    readonly supergroup_id?: number,
    /** The new value of can_have_sponsored_messages */
    readonly can_have_sponsored_messages?: boolean,
  }

  export type toggleSupergroupHasAutomaticTranslation = {
    /**
     * Toggles whether messages are automatically translated in the channel chat; requires
     * can_change_info administrator right in the channel. The chat must have at least
     * chatBoostFeatures.min_automatic_translation_boost_level boost level to enable
     * automatic translation
     */
    readonly _: 'toggleSupergroupHasAutomaticTranslation',
    /** The identifier of the channel */
    readonly supergroup_id?: number,
    /** The new value of has_automatic_translation */
    readonly has_automatic_translation?: boolean,
  }

  export type toggleSupergroupHasHiddenMembers = {
    /**
     * Toggles whether non-administrators can receive only administrators and bots
     * using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members
     * == true
     */
    readonly _: 'toggleSupergroupHasHiddenMembers',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /** New value of has_hidden_members */
    readonly has_hidden_members?: boolean,
  }

  export type toggleSupergroupHasAggressiveAntiSpamEnabled = {
    /**
     * Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can
     * be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
     */
    readonly _: 'toggleSupergroupHasAggressiveAntiSpamEnabled',
    /** The identifier of the supergroup, which isn't a broadcast group */
    readonly supergroup_id?: number,
    /** The new value of has_aggressive_anti_spam_enabled */
    readonly has_aggressive_anti_spam_enabled?: boolean,
  }

  export type toggleSupergroupIsForum = {
    /**
     * Toggles whether the supergroup is a forum; requires owner privileges in the
     * supergroup. Discussion supergroups can't be converted to forums
     */
    readonly _: 'toggleSupergroupIsForum',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /** New value of is_forum */
    readonly is_forum?: boolean,
    /** New value of has_forum_tabs; ignored if is_forum is false */
    readonly has_forum_tabs?: boolean,
  }

  export type toggleSupergroupIsBroadcastGroup = {
    /** Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup */
    readonly _: 'toggleSupergroupIsBroadcastGroup',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
  }

  export type reportSupergroupSpam = {
    /**
     * Reports messages in a supergroup as spam; requires administrator rights in the
     * supergroup
     */
    readonly _: 'reportSupergroupSpam',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
    /**
     * Identifiers of messages to report. Use messageProperties.can_report_supergroup_spam
     * to check whether the message can be reported
     */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type reportSupergroupAntiSpamFalsePositive = {
    /**
     * Reports a false deletion of a message by aggressive anti-spam checks; requires
     * administrator rights in the supergroup. Can be called only for messages from
     * chatEventMessageDeleted with can_report_anti_spam_false_positive == true
     */
    readonly _: 'reportSupergroupAntiSpamFalsePositive',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
    /** Identifier of the erroneously deleted message from chatEventMessageDeleted */
    readonly message_id?: number,
  }

  export type getSupergroupMembers = {
    /**
     * Returns information about members or banned users in a supergroup or channel.
     * Can be used only if supergroupFullInfo.can_get_members == true; additionally,
     * administrator privileges may be required for some filters
     */
    readonly _: 'getSupergroupMembers',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** The type of users to return; pass null to use supergroupMembersFilterRecent */
    readonly filter?: SupergroupMembersFilter$Input,
    /** Number of users to skip */
    readonly offset?: number,
    /** The maximum number of users to be returned; up to 200 */
    readonly limit?: number,
  }

  export type closeSecretChat = {
    /** Closes a secret chat, effectively transferring its state to secretChatStateClosed */
    readonly _: 'closeSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type getChatEventLog = {
    /**
     * Returns a list of service actions taken by chat members and administrators in
     * the last 48 hours. Available only for supergroups and channels. Requires administrator
     * rights. Returns results in reverse chronological order (i.e., in order of decreasing
     * event_id)
     */
    readonly _: 'getChatEventLog',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Search query by which to filter events */
    readonly query?: string,
    /**
     * Identifier of an event from which to return results. Use 0 to get results from
     * the latest events
     */
    readonly from_event_id?: number | string,
    /** The maximum number of events to return; up to 100 */
    readonly limit?: number,
    /** The types of events to return; pass null to get chat events of all types */
    readonly filters?: chatEventLogFilters$Input,
    /**
     * User identifiers by which to filter events. By default, events relating to all
     * users will be returned
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getTimeZones = {
    /** Returns the list of supported time zones */
    readonly _: 'getTimeZones',
  }

  export type getPaymentForm = {
    /**
     * Returns an invoice payment form. This method must be called when the user presses
     * inline button of the type inlineKeyboardButtonTypeBuy, or wants to buy access
     * to media in a messagePaidMedia message
     */
    readonly _: 'getPaymentForm',
    /** The invoice */
    readonly input_invoice?: InputInvoice$Input,
    /** Preferred payment form theme; pass null to use the default theme */
    readonly theme?: themeParameters$Input,
  }

  export type validateOrderInfo = {
    /**
     * Validates the order information provided by a user and returns the available
     * shipping options for a flexible invoice
     */
    readonly _: 'validateOrderInfo',
    /** The invoice */
    readonly input_invoice?: InputInvoice$Input,
    /** The order information, provided by the user; pass null if empty */
    readonly order_info?: orderInfo$Input,
    /** Pass true to save the order information */
    readonly allow_save?: boolean,
  }

  export type sendPaymentForm = {
    /** Sends a filled-out payment form to the bot for final verification */
    readonly _: 'sendPaymentForm',
    /** The invoice */
    readonly input_invoice?: InputInvoice$Input,
    /** Payment form identifier returned by getPaymentForm */
    readonly payment_form_id?: number | string,
    /** Identifier returned by validateOrderInfo, or an empty string */
    readonly order_info_id?: string,
    /** Identifier of a chosen shipping option, if applicable */
    readonly shipping_option_id?: string,
    /**
     * The credentials chosen by user for payment; pass null for a payment in Telegram
     * Stars
     */
    readonly credentials?: InputCredentials$Input,
    /** Chosen by the user amount of tip in the smallest units of the currency */
    readonly tip_amount?: number,
  }

  export type getPaymentReceipt = {
    /** Returns information about a successful payment */
    readonly _: 'getPaymentReceipt',
    /** Chat identifier of the messagePaymentSuccessful message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
  }

  export type getSavedOrderInfo = {
    /**
     * Returns saved order information. Returns a 404 error if there is no saved order
     * information
     */
    readonly _: 'getSavedOrderInfo',
  }

  export type deleteSavedOrderInfo = {
    /** Deletes saved order information */
    readonly _: 'deleteSavedOrderInfo',
  }

  export type deleteSavedCredentials = {
    /** Deletes saved credentials for all payment provider bots */
    readonly _: 'deleteSavedCredentials',
  }

  export type setGiftSettings = {
    /** Changes settings for gift receiving for the current user */
    readonly _: 'setGiftSettings',
    /** The new settings */
    readonly settings?: giftSettings$Input,
  }

  export type getAvailableGifts = {
    /** Returns gifts that can be sent to other users and channel chats */
    readonly _: 'getAvailableGifts',
  }

  export type sendGift = {
    /**
     * Sends a gift to another user or channel chat. May return an error with a message
     * "STARGIFT_USAGE_LIMITED" if the gift was sold out
     */
    readonly _: 'sendGift',
    /** Identifier of the gift to send */
    readonly gift_id?: number | string,
    /** Identifier of the user or the channel chat that will receive the gift */
    readonly owner_id?: MessageSender$Input,
    /**
     * Text to show along with the gift; 0-getOption("gift_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities
     * are allowed. Must be empty if the receiver enabled paid messages
     */
    readonly text?: formattedText$Input,
    /**
     * Pass true to show gift text and sender only to the gift receiver; otherwise,
     * everyone will be able to see them
     */
    readonly is_private?: boolean,
    /**
     * Pass true to additionally pay for the gift upgrade and allow the receiver to
     * upgrade it for free
     */
    readonly pay_for_upgrade?: boolean,
  }

  export type sellGift = {
    /** Sells a gift for Telegram Stars */
    readonly _: 'sellGift',
    /**
     * Unique identifier of business connection on behalf of which to send the request;
     * for bots only
     */
    readonly business_connection_id?: string,
    /** Identifier of the gift */
    readonly received_gift_id?: string,
  }

  export type toggleGiftIsSaved = {
    /**
     * Toggles whether a gift is shown on the current user's or the channel's profile
     * page; requires can_post_messages administrator right in the channel chat
     */
    readonly _: 'toggleGiftIsSaved',
    /** Identifier of the gift */
    readonly received_gift_id?: string,
    /**
     * Pass true to display the gift on the user's or the channel's profile page; pass
     * false to remove it from the profile page
     */
    readonly is_saved?: boolean,
  }

  export type setPinnedGifts = {
    /**
     * Changes the list of pinned gifts on the current user's or the channel's profile
     * page; requires can_post_messages administrator right in the channel chat
     */
    readonly _: 'setPinnedGifts',
    /** Identifier of the user or the channel chat that received the gifts */
    readonly owner_id?: MessageSender$Input,
    /**
     * New list of pinned gifts. All gifts must be upgraded and saved on the profile
     * page first. There can be up to getOption("pinned_gift_count_max") pinned gifts
     */
    readonly received_gift_ids?: ReadonlyArray<string>,
  }

  export type toggleChatGiftNotifications = {
    /**
     * Toggles whether notifications for new gifts received by a channel chat are sent
     * to the current user; requires can_post_messages administrator right in the chat
     */
    readonly _: 'toggleChatGiftNotifications',
    /** Identifier of the channel chat */
    readonly chat_id?: number,
    /**
     * Pass true to enable notifications about new gifts owned by the channel chat;
     * pass false to disable the notifications
     */
    readonly are_enabled?: boolean,
  }

  export type getGiftUpgradePreview = {
    /** Returns examples of possible upgraded gifts for a regular gift */
    readonly _: 'getGiftUpgradePreview',
    /** Identifier of the gift */
    readonly gift_id?: number | string,
  }

  export type upgradeGift = {
    /** Upgrades a regular gift */
    readonly _: 'upgradeGift',
    /**
     * Unique identifier of business connection on behalf of which to send the request;
     * for bots only
     */
    readonly business_connection_id?: string,
    /** Identifier of the gift */
    readonly received_gift_id?: string,
    /**
     * Pass true to keep the original gift text, sender and receiver in the upgraded
     * gift
     */
    readonly keep_original_details?: boolean,
    /**
     * The amount of Telegram Stars required to pay for the upgrade. It the gift has
     * prepaid_upgrade_star_count > 0, then pass 0, otherwise, pass gift.upgrade_star_count
     */
    readonly star_count?: number,
  }

  export type transferGift = {
    /** Sends an upgraded gift to another user or a channel chat */
    readonly _: 'transferGift',
    /**
     * Unique identifier of business connection on behalf of which to send the request;
     * for bots only
     */
    readonly business_connection_id?: string,
    /** Identifier of the gift */
    readonly received_gift_id?: string,
    /** Identifier of the user or the channel chat that will receive the gift */
    readonly new_owner_id?: MessageSender$Input,
    /** The amount of Telegram Stars required to pay for the transfer */
    readonly star_count?: number,
  }

  export type sendResoldGift = {
    /**
     * Sends an upgraded gift that is available for resale to another user or channel
     * chat; gifts already owned by the current user must be transferred using transferGift
     * and can't be passed to the method
     */
    readonly _: 'sendResoldGift',
    /** Name of the upgraded gift to send */
    readonly gift_name?: string,
    /** Identifier of the user or the channel chat that will receive the gift */
    readonly owner_id?: MessageSender$Input,
    /** The amount of Telegram Stars required to pay for the gift */
    readonly star_count?: number,
  }

  export type getReceivedGifts = {
    /** Returns gifts received by the given user or chat */
    readonly _: 'getReceivedGifts',
    /**
     * Unique identifier of business connection on behalf of which to send the request;
     * for bots only
     */
    readonly business_connection_id?: string,
    /** Identifier of the gift receiver */
    readonly owner_id?: MessageSender$Input,
    /**
     * Pass true to exclude gifts that aren't saved to the chat's profile page. Always
     * true for gifts received by other users and channel chats without can_post_messages
     * administrator right
     */
    readonly exclude_unsaved?: boolean,
    /**
     * Pass true to exclude gifts that are saved to the chat's profile page. Always
     * false for gifts received by other users and channel chats without can_post_messages
     * administrator right
     */
    readonly exclude_saved?: boolean,
    /** Pass true to exclude gifts that can be purchased unlimited number of times */
    readonly exclude_unlimited?: boolean,
    /** Pass true to exclude gifts that can be purchased limited number of times */
    readonly exclude_limited?: boolean,
    /** Pass true to exclude upgraded gifts */
    readonly exclude_upgraded?: boolean,
    /** Pass true to sort results by gift price instead of send date */
    readonly sort_by_price?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of gifts to be returned; must be positive and can't be greater
     * than 100. For optimal performance, the number of returned objects is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getReceivedGift = {
    /** Returns information about a received gift */
    readonly _: 'getReceivedGift',
    /** Identifier of the gift */
    readonly received_gift_id?: string,
  }

  export type getUpgradedGift = {
    /** Returns information about an upgraded gift by its name */
    readonly _: 'getUpgradedGift',
    /** Unique name of the upgraded gift */
    readonly name?: string,
  }

  export type getUpgradedGiftWithdrawalUrl = {
    /**
     * Returns a URL for upgraded gift withdrawal in the TON blockchain as an NFT;
     * requires owner privileges for gifts owned by a chat
     */
    readonly _: 'getUpgradedGiftWithdrawalUrl',
    /** Identifier of the gift */
    readonly received_gift_id?: string,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type setGiftResalePrice = {
    /** Changes resale price of a unique gift owned by the current user */
    readonly _: 'setGiftResalePrice',
    /** Identifier of the unique gift */
    readonly received_gift_id?: string,
    /**
     * The new price for the unique gift; 0 or getOption("gift_resale_star_count_min")-getOption("gift_resale_star_count_max").
     * Pass 0 to disallow gift resale. The current user will receive getOption("gift_resale_earnings_per_mille")
     * Telegram Stars for each 1000 Telegram Stars paid for the gift
     */
    readonly resale_star_count?: number,
  }

  export type searchGiftsForResale = {
    /** Returns upgraded gifts that can be bought from other owners */
    readonly _: 'searchGiftsForResale',
    /** Identifier of the regular gift that was upgraded to a unique gift */
    readonly gift_id?: number | string,
    /** Order in which the results will be sorted */
    readonly order?: GiftForResaleOrder$Input,
    /**
     * Attributes used to filter received gifts. If multiple attributes of the same
     * type are specified, then all of them are allowed. If none attributes of specific
     * type are specified, then all values for this attribute type are allowed
     */
    readonly attributes?: ReadonlyArray<UpgradedGiftAttributeId$Input>,
    /**
     * Offset of the first entry to return as received from the previous request with
     * the same order and attributes; use empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of gifts to return */
    readonly limit?: number,
  }

  export type createInvoiceLink = {
    /** Creates a link for the given invoice; for bots only */
    readonly _: 'createInvoiceLink',
    /** Unique identifier of business connection on behalf of which to send the request */
    readonly business_connection_id?: string,
    /** Information about the invoice of the type inputMessageInvoice */
    readonly invoice?: InputMessageContent$Input,
  }

  export type refundStarPayment = {
    /** Refunds a previously done payment in Telegram Stars; for bots only */
    readonly _: 'refundStarPayment',
    /** Identifier of the user that did the payment */
    readonly user_id?: number,
    /** Telegram payment identifier */
    readonly telegram_payment_charge_id?: string,
  }

  export type getSupportUser = {
    /** Returns a user that can be contacted to get support */
    readonly _: 'getSupportUser',
  }

  export type getBackgroundUrl = {
    /** Constructs a persistent HTTP URL for a background */
    readonly _: 'getBackgroundUrl',
    /** Background name */
    readonly name?: string,
    /** Background type; backgroundTypeChatTheme isn't supported */
    readonly type?: BackgroundType$Input,
  }

  export type searchBackground = {
    /** Searches for a background by its name */
    readonly _: 'searchBackground',
    /** The name of the background */
    readonly name?: string,
  }

  export type setDefaultBackground = {
    /**
     * Sets default background for chats; adds the background to the list of installed
     * backgrounds
     */
    readonly _: 'setDefaultBackground',
    /** The input background to use; pass null to create a new filled background */
    readonly background?: InputBackground$Input,
    /**
     * Background type; pass null to use the default type of the remote background;
     * backgroundTypeChatTheme isn't supported
     */
    readonly type?: BackgroundType$Input,
    /** Pass true if the background is set for a dark theme */
    readonly for_dark_theme?: boolean,
  }

  export type deleteDefaultBackground = {
    /** Deletes default background for chats */
    readonly _: 'deleteDefaultBackground',
    /** Pass true if the background is deleted for a dark theme */
    readonly for_dark_theme?: boolean,
  }

  export type getInstalledBackgrounds = {
    /** Returns backgrounds installed by the user */
    readonly _: 'getInstalledBackgrounds',
    /** Pass true to order returned backgrounds for a dark theme */
    readonly for_dark_theme?: boolean,
  }

  export type removeInstalledBackground = {
    /** Removes background from the list of installed backgrounds */
    readonly _: 'removeInstalledBackground',
    /** The background identifier */
    readonly background_id?: number | string,
  }

  export type resetInstalledBackgrounds = {
    /** Resets list of installed backgrounds to its default value */
    readonly _: 'resetInstalledBackgrounds',
  }

  export type getLocalizationTargetInfo = {
    /**
     * Returns information about the current localization target. This is an offline
     * method if only_local is true. Can be called before authorization
     */
    readonly _: 'getLocalizationTargetInfo',
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type getLanguagePackInfo = {
    /**
     * Returns information about a language pack. Returned language pack identifier
     * may be different from a provided one. Can be called before authorization
     */
    readonly _: 'getLanguagePackInfo',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type getLanguagePackStrings = {
    /**
     * Returns strings from a language pack in the current localization target by their
     * keys. Can be called before authorization
     */
    readonly _: 'getLanguagePackStrings',
    /** Language pack identifier of the strings to be returned */
    readonly language_pack_id?: string,
    /**
     * Language pack keys of the strings to be returned; leave empty to request all
     * available strings
     */
    readonly keys?: ReadonlyArray<string>,
  }

  export type synchronizeLanguagePack = {
    /**
     * Fetches the latest versions of all strings from a language pack in the current
     * localization target from the server. This method doesn't need to be called explicitly
     * for the current used/base language packs. Can be called before authorization
     */
    readonly _: 'synchronizeLanguagePack',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type addCustomServerLanguagePack = {
    /**
     * Adds a custom server language pack to the list of installed language packs in
     * current localization target. Can be called before authorization
     */
    readonly _: 'addCustomServerLanguagePack',
    /** Identifier of a language pack to be added */
    readonly language_pack_id?: string,
  }

  export type setCustomLanguagePack = {
    /** Adds or changes a custom local language pack to the current localization target */
    readonly _: 'setCustomLanguagePack',
    /**
     * Information about the language pack. Language pack identifier must start with
     * 'X', consist only of English letters, digits and hyphens, and must not exceed
     * 64 characters. Can be called before authorization
     */
    readonly info?: languagePackInfo$Input,
    /** Strings of the new language pack */
    readonly strings?: ReadonlyArray<languagePackString$Input>,
  }

  export type editCustomLanguagePackInfo = {
    /**
     * Edits information about a custom local language pack in the current localization
     * target. Can be called before authorization
     */
    readonly _: 'editCustomLanguagePackInfo',
    /** New information about the custom local language pack */
    readonly info?: languagePackInfo$Input,
  }

  export type setCustomLanguagePackString = {
    /**
     * Adds, edits or deletes a string in a custom local language pack. Can be called
     * before authorization
     */
    readonly _: 'setCustomLanguagePackString',
    /**
     * Identifier of a previously added custom local language pack in the current localization
     * target
     */
    readonly language_pack_id?: string,
    /** New language pack string */
    readonly new_string?: languagePackString$Input,
  }

  export type deleteLanguagePack = {
    /**
     * Deletes all information about a language pack in the current localization target.
     * The language pack which is currently in use (including base language pack) or
     * is being synchronized can't be deleted. Can be called before authorization
     */
    readonly _: 'deleteLanguagePack',
    /** Identifier of the language pack to delete */
    readonly language_pack_id?: string,
  }

  export type registerDevice = {
    /**
     * Registers the currently used device for receiving push notifications. Returns
     * a globally unique identifier of the push notification subscription
     */
    readonly _: 'registerDevice',
    /** Device token */
    readonly device_token?: DeviceToken$Input,
    /** List of user identifiers of other users currently using the application */
    readonly other_user_ids?: ReadonlyArray<number>,
  }

  export type processPushNotification = {
    /**
     * Handles a push notification. Returns error with code 406 if the push notification
     * is not supported and connection to the server is required to fetch new data.
     * Can be called before authorization
     */
    readonly _: 'processPushNotification',
    /**
     * JSON-encoded push notification payload with all fields sent by the server, and
     * "google.sent_time" and "google.notification.sound" fields added
     */
    readonly payload?: string,
  }

  export type getPushReceiverId = {
    /**
     * Returns a globally unique push notification subscription identifier for identification
     * of an account, which has received a push notification. Can be called synchronously
     */
    readonly _: 'getPushReceiverId',
    /** JSON-encoded push notification payload */
    readonly payload?: string,
  }

  export type getRecentlyVisitedTMeUrls = {
    /** Returns t.me URLs recently visited by a newly registered user */
    readonly _: 'getRecentlyVisitedTMeUrls',
    /** Google Play referrer to identify the user */
    readonly referrer?: string,
  }

  export type setUserPrivacySettingRules = {
    /** Changes user privacy settings */
    readonly _: 'setUserPrivacySettingRules',
    /** The privacy setting */
    readonly setting?: UserPrivacySetting$Input,
    /** The new privacy rules */
    readonly rules?: userPrivacySettingRules$Input,
  }

  export type getUserPrivacySettingRules = {
    /** Returns the current privacy settings */
    readonly _: 'getUserPrivacySettingRules',
    /** The privacy setting */
    readonly setting?: UserPrivacySetting$Input,
  }

  export type setReadDatePrivacySettings = {
    /** Changes privacy settings for message read date */
    readonly _: 'setReadDatePrivacySettings',
    /** New settings */
    readonly settings?: readDatePrivacySettings$Input,
  }

  export type getReadDatePrivacySettings = {
    /** Returns privacy settings for message read date */
    readonly _: 'getReadDatePrivacySettings',
  }

  export type setNewChatPrivacySettings = {
    /** Changes privacy settings for new chat creation; can be used only if getOption("can_set_new_chat_privacy_settings") */
    readonly _: 'setNewChatPrivacySettings',
    /** New settings */
    readonly settings?: newChatPrivacySettings$Input,
  }

  export type getNewChatPrivacySettings = {
    /** Returns privacy settings for new chat creation */
    readonly _: 'getNewChatPrivacySettings',
  }

  export type getPaidMessageRevenue = {
    /**
     * Returns the total number of Telegram Stars received by the current user for
     * paid messages from the given user
     */
    readonly _: 'getPaidMessageRevenue',
    /** Identifier of the user */
    readonly user_id?: number,
  }

  export type allowUnpaidMessagesFromUser = {
    /**
     * Allows the specified user to send unpaid private messages to the current user
     * by adding a rule to userPrivacySettingAllowUnpaidMessages
     */
    readonly _: 'allowUnpaidMessagesFromUser',
    /** Identifier of the user */
    readonly user_id?: number,
    /** Pass true to refund the user previously paid messages */
    readonly refund_payments?: boolean,
  }

  export type setChatPaidMessageStarCount = {
    /**
     * Changes the amount of Telegram Stars that must be paid to send a message to
     * a supergroup chat; requires can_restrict_members administrator right and supergroupFullInfo.can_enable_paid_messages
     */
    readonly _: 'setChatPaidMessageStarCount',
    /** Identifier of the supergroup chat */
    readonly chat_id?: number,
    /**
     * The new number of Telegram Stars that must be paid for each message that is
     * sent to the supergroup chat unless the sender is an administrator of the chat;
     * 0-getOption("paid_message_star_count_max"). The supergroup will receive getOption("paid_message_earnings_per_mille")
     * Telegram Stars for each 1000 Telegram Stars paid for message sending
     */
    readonly paid_message_star_count?: number,
  }

  export type canSendMessageToUser = {
    /**
     * Check whether the current user can message another user or try to create a chat
     * with them
     */
    readonly _: 'canSendMessageToUser',
    /** Identifier of the other user */
    readonly user_id?: number,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type getOption = {
    /**
     * Returns the value of an option by its name. (Check the list of available options
     * on https://core.telegram.org/tdlib/options.) Can be called before authorization.
     * Can be called synchronously for options "version" and "commit_hash"
     */
    readonly _: 'getOption',
    /** The name of the option */
    readonly name?: string,
  }

  export type setOption = {
    /**
     * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.)
     * Only writable options can be set. Can be called before authorization
     */
    readonly _: 'setOption',
    /** The name of the option */
    readonly name?: string,
    /** The new value of the option; pass null to reset option value to a default value */
    readonly value?: OptionValue$Input,
  }

  export type setAccountTtl = {
    /**
     * Changes the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    readonly _: 'setAccountTtl',
    /** New account TTL */
    readonly ttl?: accountTtl$Input,
  }

  export type getAccountTtl = {
    /**
     * Returns the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    readonly _: 'getAccountTtl',
  }

  export type deleteAccount = {
    /**
     * Deletes the account of the current user, deleting all information associated
     * with the user from the server. The phone number of the account can be used to
     * create a new account. Can be called before authorization when the current authorization
     * state is authorizationStateWaitPassword
     */
    readonly _: 'deleteAccount',
    /** The reason why the account was deleted; optional */
    readonly reason?: string,
    /**
     * The 2-step verification password of the current user. If the current user isn't
     * authorized, then an empty string can be passed and account deletion can be canceled
     * within one week
     */
    readonly password?: string,
  }

  export type setDefaultMessageAutoDeleteTime = {
    /** Changes the default message auto-delete time for new chats */
    readonly _: 'setDefaultMessageAutoDeleteTime',
    /**
     * New default message auto-delete time; must be from 0 up to 365 * 86400 and be
     * divisible by 86400. If 0, then messages aren't deleted automatically
     */
    readonly message_auto_delete_time?: messageAutoDeleteTime$Input,
  }

  export type getDefaultMessageAutoDeleteTime = {
    /** Returns default message auto-delete time setting for new chats */
    readonly _: 'getDefaultMessageAutoDeleteTime',
  }

  export type removeChatActionBar = {
    /** Removes a chat action bar without any other action */
    readonly _: 'removeChatActionBar',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type reportChat = {
    /**
     * Reports a chat to the Telegram moderators. A chat can be reported only from
     * the chat action bar, or if chat.can_be_reported
     */
    readonly _: 'reportChat',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Option identifier chosen by the user; leave empty for the initial request */
    readonly option_id?: string /* base64 */,
    /**
     * Identifiers of reported messages. Use messageProperties.can_report_chat to check
     * whether the message can be reported
     */
    readonly message_ids?: ReadonlyArray<number>,
    /**
     * Additional report details if asked by the server; 0-1024 characters; leave empty
     * for the initial request
     */
    readonly text?: string,
  }

  export type reportChatPhoto = {
    /**
     * Reports a chat photo to the Telegram moderators. A chat photo can be reported
     * only if chat.can_be_reported
     */
    readonly _: 'reportChatPhoto',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the photo to report. Only full photos from chatPhoto can be reported */
    readonly file_id?: number,
    /** The reason for reporting the chat photo */
    readonly reason?: ReportReason$Input,
    /** Additional report details; 0-1024 characters */
    readonly text?: string,
  }

  export type reportMessageReactions = {
    /**
     * Reports reactions set on a message to the Telegram moderators. Reactions on
     * a message can be reported only if messageProperties.can_report_reactions
     */
    readonly _: 'reportMessageReactions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Identifier of the sender, which added the reaction */
    readonly sender_id?: MessageSender$Input,
  }

  export type getChatRevenueStatistics = {
    /**
     * Returns detailed revenue statistics about a chat. Currently, this method can
     * be used only for channels if supergroupFullInfo.can_get_revenue_statistics ==
     * true or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     */
    readonly _: 'getChatRevenueStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getChatRevenueWithdrawalUrl = {
    /**
     * Returns a URL for chat revenue withdrawal; requires owner privileges in the
     * channel chat or the bot. Currently, this method can be used only if getOption("can_withdraw_chat_revenue")
     * for channels with supergroupFullInfo.can_get_revenue_statistics == true or bots
     * with userFullInfo.bot_info.can_get_revenue_statistics == true
     */
    readonly _: 'getChatRevenueWithdrawalUrl',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type getChatRevenueTransactions = {
    /**
     * Returns the list of revenue transactions for a chat. Currently, this method
     * can be used only for channels if supergroupFullInfo.can_get_revenue_statistics
     * == true or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     */
    readonly _: 'getChatRevenueTransactions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Number of transactions to skip */
    readonly offset?: number,
    /** The maximum number of transactions to be returned; up to 200 */
    readonly limit?: number,
  }

  export type getStarRevenueStatistics = {
    /** Returns detailed Telegram Star revenue statistics */
    readonly _: 'getStarRevenueStatistics',
    /**
     * Identifier of the owner of the Telegram Stars; can be identifier of the current
     * user, an owned bot, or a supergroup or a channel chat with supergroupFullInfo.can_get_star_revenue_statistics
     * == true
     */
    readonly owner_id?: MessageSender$Input,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getStarWithdrawalUrl = {
    /** Returns a URL for Telegram Star withdrawal */
    readonly _: 'getStarWithdrawalUrl',
    /**
     * Identifier of the owner of the Telegram Stars; can be identifier of the current
     * user, an owned bot, or an owned supergroup or channel chat
     */
    readonly owner_id?: MessageSender$Input,
    /** The number of Telegram Stars to withdraw. Must be at least getOption("star_withdrawal_count_min") */
    readonly star_count?: number,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type getStarAdAccountUrl = {
    /**
     * Returns a URL for a Telegram Ad platform account that can be used to set up
     * advertisements for the chat paid in the owned Telegram Stars
     */
    readonly _: 'getStarAdAccountUrl',
    /**
     * Identifier of the owner of the Telegram Stars; can be identifier of an owned
     * bot, or identifier of an owned channel chat
     */
    readonly owner_id?: MessageSender$Input,
  }

  export type getChatStatistics = {
    /**
     * Returns detailed statistics about a chat. Currently, this method can be used
     * only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics
     * == true
     */
    readonly _: 'getChatStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getMessageStatistics = {
    /**
     * Returns detailed statistics about a message. Can be used only if messageProperties.can_get_statistics
     * == true
     */
    readonly _: 'getMessageStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getMessagePublicForwards = {
    /**
     * Returns forwarded copies of a channel message to different public channels and
     * public reposts as a story. Can be used only if messageProperties.can_get_statistics
     * == true. For optimal performance, the number of returned messages and stories
     * is chosen by TDLib
     */
    readonly _: 'getMessagePublicForwards',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages and stories to be returned; must be positive
     * and can't be greater than 100. For optimal performance, the number of returned
     * objects is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getStoryStatistics = {
    /**
     * Returns detailed statistics about a story. Can be used only if story.can_get_statistics
     * == true
     */
    readonly _: 'getStoryStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Story identifier */
    readonly story_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getStatisticalGraph = {
    /** Loads an asynchronous or a zoomed in statistical graph */
    readonly _: 'getStatisticalGraph',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The token for graph loading */
    readonly token?: string,
    /** X-value for zoomed in graph or 0 otherwise */
    readonly x?: number,
  }

  export type getStorageStatistics = {
    /** Returns storage usage statistics. Can be called before authorization */
    readonly _: 'getStorageStatistics',
    /**
     * The maximum number of chats with the largest storage usage for which separate
     * statistics need to be returned. All other chats will be grouped in entries with
     * chat_id == 0. If the chat info database is not used, the chat_limit is ignored
     * and is always set to 0
     */
    readonly chat_limit?: number,
  }

  export type getStorageStatisticsFast = {
    /** Quickly returns approximate storage usage statistics. Can be called before authorization */
    readonly _: 'getStorageStatisticsFast',
  }

  export type getDatabaseStatistics = {
    /** Returns database statistics */
    readonly _: 'getDatabaseStatistics',
  }

  export type optimizeStorage = {
    /**
     * Optimizes storage usage, i.e. deletes some files and returns new storage usage
     * statistics. Secret thumbnails can't be deleted
     */
    readonly _: 'optimizeStorage',
    /**
     * Limit on the total size of files after deletion, in bytes. Pass -1 to use the
     * default limit
     */
    readonly size?: number,
    /**
     * Limit on the time that has passed since the last time a file was accessed (or
     * creation time for some filesystems). Pass -1 to use the default limit
     */
    readonly ttl?: number,
    /**
     * Limit on the total number of files after deletion. Pass -1 to use the default
     * limit
     */
    readonly count?: number,
    /**
     * The amount of time after the creation of a file during which it can't be deleted,
     * in seconds. Pass -1 to use the default value
     */
    readonly immunity_delay?: number,
    /**
     * If non-empty, only files with the given types are considered. By default, all
     * types except thumbnails, profile photos, stickers and wallpapers are deleted
     */
    readonly file_types?: ReadonlyArray<FileType$Input>,
    /**
     * If non-empty, only files from the given chats are considered. Use 0 as chat
     * identifier to delete files not belonging to any chat (e.g., profile photos)
     */
    readonly chat_ids?: ReadonlyArray<number>,
    /**
     * If non-empty, files from the given chats are excluded. Use 0 as chat identifier
     * to exclude all files not belonging to any chat (e.g., profile photos)
     */
    readonly exclude_chat_ids?: ReadonlyArray<number>,
    /**
     * Pass true if statistics about the files that were deleted must be returned instead
     * of the whole storage usage statistics. Affects only returned statistics
     */
    readonly return_deleted_file_statistics?: boolean,
    /** Same as in getStorageStatistics. Affects only returned statistics */
    readonly chat_limit?: number,
  }

  export type setNetworkType = {
    /**
     * Sets the current network type. Can be called before authorization. Calling this
     * method forces all network connections to reopen, mitigating the delay in switching
     * between different networks, so it must be called whenever the network is changed,
     * even if the network type remains the same. Network type is used to check whether
     * the library can use the network at all and also for collecting detailed network
     * data usage statistics
     */
    readonly _: 'setNetworkType',
    /** The new network type; pass null to set network type to networkTypeOther */
    readonly type?: NetworkType$Input,
  }

  export type getNetworkStatistics = {
    /** Returns network data usage statistics. Can be called before authorization */
    readonly _: 'getNetworkStatistics',
    /** Pass true to get statistics only for the current library launch */
    readonly only_current?: boolean,
  }

  export type addNetworkStatistics = {
    /** Adds the specified data to data usage statistics. Can be called before authorization */
    readonly _: 'addNetworkStatistics',
    /** The network statistics entry with the data to be added to statistics */
    readonly entry?: NetworkStatisticsEntry$Input,
  }

  export type resetNetworkStatistics = {
    /** Resets all network data usage statistics to zero. Can be called before authorization */
    readonly _: 'resetNetworkStatistics',
  }

  export type getAutoDownloadSettingsPresets = {
    /** Returns auto-download settings presets for the current user */
    readonly _: 'getAutoDownloadSettingsPresets',
  }

  export type setAutoDownloadSettings = {
    /** Sets auto-download settings */
    readonly _: 'setAutoDownloadSettings',
    /** New user auto-download settings */
    readonly settings?: autoDownloadSettings$Input,
    /** Type of the network for which the new settings are relevant */
    readonly type?: NetworkType$Input,
  }

  export type getAutosaveSettings = {
    /** Returns autosave settings for the current user */
    readonly _: 'getAutosaveSettings',
  }

  export type setAutosaveSettings = {
    /**
     * Sets autosave settings for the given scope. The method is guaranteed to work
     * only after at least one call to getAutosaveSettings
     */
    readonly _: 'setAutosaveSettings',
    /** Autosave settings scope */
    readonly scope?: AutosaveSettingsScope$Input,
    /** New autosave settings for the scope; pass null to set autosave settings to default */
    readonly settings?: scopeAutosaveSettings$Input,
  }

  export type clearAutosaveSettingsExceptions = {
    /**
     * Clears the list of all autosave settings exceptions. The method is guaranteed
     * to work only after at least one call to getAutosaveSettings
     */
    readonly _: 'clearAutosaveSettingsExceptions',
  }

  export type getBankCardInfo = {
    /** Returns information about a bank card */
    readonly _: 'getBankCardInfo',
    /** The bank card number */
    readonly bank_card_number?: string,
  }

  export type getPassportElement = {
    /** Returns one of the available Telegram Passport elements */
    readonly _: 'getPassportElement',
    /** Telegram Passport element type */
    readonly type?: PassportElementType$Input,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type getAllPassportElements = {
    /** Returns all available Telegram Passport elements */
    readonly _: 'getAllPassportElements',
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type setPassportElement = {
    /**
     * Adds an element to the user's Telegram Passport. May return an error with a
     * message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen
     * phone number or the chosen email address must be verified first
     */
    readonly _: 'setPassportElement',
    /** Input Telegram Passport element */
    readonly element?: InputPassportElement$Input,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type deletePassportElement = {
    /** Deletes a Telegram Passport element */
    readonly _: 'deletePassportElement',
    /** Element type */
    readonly type?: PassportElementType$Input,
  }

  export type setPassportElementErrors = {
    /**
     * Informs the user that some of the elements in their Telegram Passport contain
     * errors; for bots only. The user will not be able to resend the elements, until
     * the errors are fixed
     */
    readonly _: 'setPassportElementErrors',
    /** User identifier */
    readonly user_id?: number,
    /** The errors */
    readonly errors?: ReadonlyArray<inputPassportElementError$Input>,
  }

  export type getPreferredCountryLanguage = {
    /**
     * Returns an IETF language tag of the language preferred in the country, which
     * must be used to fill native fields in Telegram Passport personal details. Returns
     * a 404 error if unknown
     */
    readonly _: 'getPreferredCountryLanguage',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    readonly country_code?: string,
  }

  export type sendEmailAddressVerificationCode = {
    /** Sends a code to verify an email address to be added to a user's Telegram Passport */
    readonly _: 'sendEmailAddressVerificationCode',
    /** Email address */
    readonly email_address?: string,
  }

  export type resendEmailAddressVerificationCode = {
    /**
     * Resends the code to verify an email address to be added to a user's Telegram
     * Passport
     */
    readonly _: 'resendEmailAddressVerificationCode',
  }

  export type checkEmailAddressVerificationCode = {
    /** Checks the email address verification code for Telegram Passport */
    readonly _: 'checkEmailAddressVerificationCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type getPassportAuthorizationForm = {
    /** Returns a Telegram Passport authorization form for sharing data with a service */
    readonly _: 'getPassportAuthorizationForm',
    /** User identifier of the service's bot */
    readonly bot_user_id?: number,
    /** Telegram Passport element types requested by the service */
    readonly scope?: string,
    /** Service's public key */
    readonly public_key?: string,
    /** Unique request identifier provided by the service */
    readonly nonce?: string,
  }

  export type getPassportAuthorizationFormAvailableElements = {
    /**
     * Returns already available Telegram Passport elements suitable for completing
     * a Telegram Passport authorization form. Result can be received only once for
     * each authorization form
     */
    readonly _: 'getPassportAuthorizationFormAvailableElements',
    /** Authorization form identifier */
    readonly authorization_form_id?: number,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type sendPassportAuthorizationForm = {
    /**
     * Sends a Telegram Passport authorization form, effectively sharing data with
     * the service. This method must be called after getPassportAuthorizationFormAvailableElements
     * if some previously available elements are going to be reused
     */
    readonly _: 'sendPassportAuthorizationForm',
    /** Authorization form identifier */
    readonly authorization_form_id?: number,
    /**
     * Types of Telegram Passport elements chosen by user to complete the authorization
     * form
     */
    readonly types?: ReadonlyArray<PassportElementType$Input>,
  }

  export type setBotUpdatesStatus = {
    /**
     * Informs the server about the number of pending bot updates if they haven't been
     * processed for a long time; for bots only
     */
    readonly _: 'setBotUpdatesStatus',
    /** The number of pending updates */
    readonly pending_update_count?: number,
    /** The last error message */
    readonly error_message?: string,
  }

  export type uploadStickerFile = {
    /** Uploads a file with a sticker; returns the uploaded file */
    readonly _: 'uploadStickerFile',
    /** Sticker file owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker format */
    readonly sticker_format?: StickerFormat$Input,
    /**
     * File file to upload; must fit in a 512x512 square. For WEBP stickers the file
     * must be in WEBP or PNG format, which will be converted to WEBP server-side.
     * See https://core.telegram.org/animated_stickers#technical-requirements for technical
     * requirements
     */
    readonly sticker?: InputFile$Input,
  }

  export type getSuggestedStickerSetName = {
    /** Returns a suggested name for a new sticker set with a given title */
    readonly _: 'getSuggestedStickerSetName',
    /** Sticker set title; 1-64 characters */
    readonly title?: string,
  }

  export type checkStickerSetName = {
    /** Checks whether a name can be used for a new sticker set */
    readonly _: 'checkStickerSetName',
    /** Name to be checked */
    readonly name?: string,
  }

  export type createNewStickerSet = {
    /** Creates a new sticker set. Returns the newly created sticker set */
    readonly _: 'createNewStickerSet',
    /** Sticker set owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker set title; 1-64 characters */
    readonly title?: string,
    /**
     * Sticker set name. Can contain only English letters, digits and underscores.
     * Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive)
     * for bots; 0-64 characters. If empty, then the name returned by getSuggestedStickerSetName
     * will be used automatically
     */
    readonly name?: string,
    /** Type of the stickers in the set */
    readonly sticker_type?: StickerType$Input,
    /**
     * Pass true if stickers in the sticker set must be repainted; for custom emoji
     * sticker sets only
     */
    readonly needs_repainting?: boolean,
    /**
     * List of stickers to be added to the set; 1-200 stickers for custom emoji sticker
     * sets, and 1-120 stickers otherwise. For TGS stickers, uploadStickerFile must
     * be used before the sticker is shown
     */
    readonly stickers?: ReadonlyArray<inputSticker$Input>,
    /** Source of the sticker set; may be empty if unknown */
    readonly source?: string,
  }

  export type addStickerToSet = {
    /** Adds a new sticker to a set */
    readonly _: 'addStickerToSet',
    /** Sticker set owner; ignored for regular users */
    readonly user_id?: number,
    /**
     * Sticker set name. The sticker set must be owned by the current user, and contain
     * less than 200 stickers for custom emoji sticker sets and less than 120 otherwise
     */
    readonly name?: string,
    /** Sticker to add to the set */
    readonly sticker?: inputSticker$Input,
  }

  export type replaceStickerInSet = {
    /**
     * Replaces existing sticker in a set. The function is equivalent to removeStickerFromSet,
     * then addStickerToSet, then setStickerPositionInSet
     */
    readonly _: 'replaceStickerInSet',
    /** Sticker set owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker set name. The sticker set must be owned by the current user */
    readonly name?: string,
    /** Sticker to remove from the set */
    readonly old_sticker?: InputFile$Input,
    /** Sticker to add to the set */
    readonly new_sticker?: inputSticker$Input,
  }

  export type setStickerSetThumbnail = {
    /** Sets a sticker set thumbnail */
    readonly _: 'setStickerSetThumbnail',
    /** Sticker set owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker set name. The sticker set must be owned by the current user */
    readonly name?: string,
    /** Thumbnail to set; pass null to remove the sticker set thumbnail */
    readonly thumbnail?: InputFile$Input,
    /** Format of the thumbnail; pass null if thumbnail is removed */
    readonly format?: StickerFormat$Input,
  }

  export type setCustomEmojiStickerSetThumbnail = {
    /** Sets a custom emoji sticker set thumbnail */
    readonly _: 'setCustomEmojiStickerSetThumbnail',
    /** Sticker set name. The sticker set must be owned by the current user */
    readonly name?: string,
    /**
     * Identifier of the custom emoji from the sticker set, which will be set as sticker
     * set thumbnail; pass 0 to remove the sticker set thumbnail
     */
    readonly custom_emoji_id?: number | string,
  }

  export type setStickerSetTitle = {
    /** Sets a sticker set title */
    readonly _: 'setStickerSetTitle',
    /** Sticker set name. The sticker set must be owned by the current user */
    readonly name?: string,
    /** New sticker set title */
    readonly title?: string,
  }

  export type deleteStickerSet = {
    /** Completely deletes a sticker set */
    readonly _: 'deleteStickerSet',
    /** Sticker set name. The sticker set must be owned by the current user */
    readonly name?: string,
  }

  export type setStickerPositionInSet = {
    /**
     * Changes the position of a sticker in the set to which it belongs. The sticker
     * set must be owned by the current user
     */
    readonly _: 'setStickerPositionInSet',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /** New position of the sticker in the set, 0-based */
    readonly position?: number,
  }

  export type removeStickerFromSet = {
    /**
     * Removes a sticker from the set to which it belongs. The sticker set must be
     * owned by the current user
     */
    readonly _: 'removeStickerFromSet',
    /** Sticker to remove from the set */
    readonly sticker?: InputFile$Input,
  }

  export type setStickerEmojis = {
    /**
     * Changes the list of emojis corresponding to a sticker. The sticker must belong
     * to a regular or custom emoji sticker set that is owned by the current user
     */
    readonly _: 'setStickerEmojis',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /** New string with 1-20 emoji corresponding to the sticker */
    readonly emojis?: string,
  }

  export type setStickerKeywords = {
    /**
     * Changes the list of keywords of a sticker. The sticker must belong to a regular
     * or custom emoji sticker set that is owned by the current user
     */
    readonly _: 'setStickerKeywords',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /**
     * List of up to 20 keywords with total length up to 64 characters, which can be
     * used to find the sticker
     */
    readonly keywords?: ReadonlyArray<string>,
  }

  export type setStickerMaskPosition = {
    /**
     * Changes the mask position of a mask sticker. The sticker must belong to a mask
     * sticker set that is owned by the current user
     */
    readonly _: 'setStickerMaskPosition',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /** Position where the mask is placed; pass null to remove mask position */
    readonly mask_position?: maskPosition$Input,
  }

  export type getOwnedStickerSets = {
    /** Returns sticker sets owned by the current user */
    readonly _: 'getOwnedStickerSets',
    /**
     * Identifier of the sticker set from which to return owned sticker sets; use 0
     * to get results from the beginning
     */
    readonly offset_sticker_set_id?: number | string,
    /**
     * The maximum number of sticker sets to be returned; must be positive and can't
     * be greater than 100. For optimal performance, the number of returned objects
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getMapThumbnailFile = {
    /**
     * Returns information about a file with a map thumbnail in PNG format. Only map
     * thumbnail files with size less than 1MB can be downloaded
     */
    readonly _: 'getMapThumbnailFile',
    /** Location of the map center */
    readonly location?: location$Input,
    /** Map zoom level; 13-20 */
    readonly zoom?: number,
    /** Map width in pixels before applying scale; 16-1024 */
    readonly width?: number,
    /** Map height in pixels before applying scale; 16-1024 */
    readonly height?: number,
    /** Map scale; 1-3 */
    readonly scale?: number,
    /** Identifier of a chat in which the thumbnail will be shown. Use 0 if unknown */
    readonly chat_id?: number,
  }

  export type getPremiumLimit = {
    /**
     * Returns information about a limit, increased for Premium users. Returns a 404
     * error if the limit is unknown
     */
    readonly _: 'getPremiumLimit',
    /** Type of the limit */
    readonly limit_type?: PremiumLimitType$Input,
  }

  export type getPremiumFeatures = {
    /** Returns information about features, available to Premium users */
    readonly _: 'getPremiumFeatures',
    /**
     * Source of the request; pass null if the method is called from some non-standard
     * source
     */
    readonly source?: PremiumSource$Input,
  }

  export type getPremiumStickerExamples = {
    /** Returns examples of premium stickers for demonstration purposes */
    readonly _: 'getPremiumStickerExamples',
  }

  export type getPremiumInfoSticker = {
    /** Returns the sticker to be used as representation of the Telegram Premium subscription */
    readonly _: 'getPremiumInfoSticker',
    /** Number of months the Telegram Premium subscription will be active */
    readonly month_count?: number,
  }

  export type viewPremiumFeature = {
    /**
     * Informs TDLib that the user viewed detailed information about a Premium feature
     * on the Premium features screen
     */
    readonly _: 'viewPremiumFeature',
    /** The viewed premium feature */
    readonly feature?: PremiumFeature$Input,
  }

  export type clickPremiumSubscriptionButton = {
    /**
     * Informs TDLib that the user clicked Premium subscription button on the Premium
     * features screen
     */
    readonly _: 'clickPremiumSubscriptionButton',
  }

  export type getPremiumState = {
    /**
     * Returns state of Telegram Premium subscription and promotion videos for Premium
     * features
     */
    readonly _: 'getPremiumState',
  }

  export type getPremiumGiftPaymentOptions = {
    /** Returns available options for gifting Telegram Premium to a user */
    readonly _: 'getPremiumGiftPaymentOptions',
  }

  export type getPremiumGiveawayPaymentOptions = {
    /**
     * Returns available options for creating of Telegram Premium giveaway or manual
     * distribution of Telegram Premium among chat members
     */
    readonly _: 'getPremiumGiveawayPaymentOptions',
    /**
     * Identifier of the supergroup or channel chat, which will be automatically boosted
     * by receivers of the gift codes and which is administered by the user
     */
    readonly boosted_chat_id?: number,
  }

  export type checkPremiumGiftCode = {
    /** Return information about a Telegram Premium gift code */
    readonly _: 'checkPremiumGiftCode',
    /** The code to check */
    readonly code?: string,
  }

  export type applyPremiumGiftCode = {
    /** Applies a Telegram Premium gift code */
    readonly _: 'applyPremiumGiftCode',
    /** The code to apply */
    readonly code?: string,
  }

  export type giftPremiumWithStars = {
    /**
     * Allows to buy a Telegram Premium subscription for another user with payment
     * in Telegram Stars; for bots only
     */
    readonly _: 'giftPremiumWithStars',
    /** Identifier of the user which will receive Telegram Premium */
    readonly user_id?: number,
    /** The number of Telegram Stars to pay for subscription */
    readonly star_count?: number,
    /** Number of months the Telegram Premium subscription will be active for the user */
    readonly month_count?: number,
    /**
     * Text to show to the user receiving Telegram Premium; 0-getOption("gift_text_length_max")
     * characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji
     * entities are allowed
     */
    readonly text?: formattedText$Input,
  }

  export type launchPrepaidGiveaway = {
    /** Launches a prepaid giveaway */
    readonly _: 'launchPrepaidGiveaway',
    /** Unique identifier of the prepaid giveaway */
    readonly giveaway_id?: number | string,
    /** Giveaway parameters */
    readonly parameters?: giveawayParameters$Input,
    /** The number of users to receive giveaway prize */
    readonly winner_count?: number,
    /**
     * The number of Telegram Stars to be distributed through the giveaway; pass 0
     * for Telegram Premium giveaways
     */
    readonly star_count?: number,
  }

  export type getGiveawayInfo = {
    /** Returns information about a giveaway */
    readonly _: 'getGiveawayInfo',
    /** Identifier of the channel chat which started the giveaway */
    readonly chat_id?: number,
    /** Identifier of the giveaway or a giveaway winners message in the chat */
    readonly message_id?: number,
  }

  export type getStarPaymentOptions = {
    /** Returns available options for Telegram Stars purchase */
    readonly _: 'getStarPaymentOptions',
  }

  export type getStarGiftPaymentOptions = {
    /** Returns available options for Telegram Stars gifting */
    readonly _: 'getStarGiftPaymentOptions',
    /**
     * Identifier of the user that will receive Telegram Stars; pass 0 to get options
     * for an unspecified user
     */
    readonly user_id?: number,
  }

  export type getStarGiveawayPaymentOptions = {
    /** Returns available options for Telegram Star giveaway creation */
    readonly _: 'getStarGiveawayPaymentOptions',
  }

  export type getStarTransactions = {
    /** Returns the list of Telegram Star transactions for the specified owner */
    readonly _: 'getStarTransactions',
    /**
     * Identifier of the owner of the Telegram Stars; can be the identifier of the
     * current user, identifier of an owned bot, or identifier of a supergroup or a
     * channel chat with supergroupFullInfo.can_get_star_revenue_statistics == true
     */
    readonly owner_id?: MessageSender$Input,
    /** If non-empty, only transactions related to the Star Subscription will be returned */
    readonly subscription_id?: string,
    /** Direction of the transactions to receive; pass null to get all transactions */
    readonly direction?: StarTransactionDirection$Input,
    /**
     * Offset of the first transaction to return as received from the previous request;
     * use empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of transactions to return */
    readonly limit?: number,
  }

  export type getStarSubscriptions = {
    /** Returns the list of Telegram Star subscriptions for the current user */
    readonly _: 'getStarSubscriptions',
    /**
     * Pass true to receive only expiring subscriptions for which there are no enough
     * Telegram Stars to extend
     */
    readonly only_expiring?: boolean,
    /**
     * Offset of the first subscription to return as received from the previous request;
     * use empty string to get the first chunk of results
     */
    readonly offset?: string,
  }

  export type canPurchaseFromStore = {
    /**
     * Checks whether an in-store purchase is possible. Must be called before any in-store
     * purchase. For official applications only
     */
    readonly _: 'canPurchaseFromStore',
    /** Transaction purpose */
    readonly purpose?: StorePaymentPurpose$Input,
  }

  export type assignStoreTransaction = {
    /** Informs server about an in-store purchase. For official applications only */
    readonly _: 'assignStoreTransaction',
    /** Information about the transaction */
    readonly transaction?: StoreTransaction$Input,
    /** Transaction purpose */
    readonly purpose?: StorePaymentPurpose$Input,
  }

  export type editStarSubscription = {
    /** Cancels or re-enables Telegram Star subscription */
    readonly _: 'editStarSubscription',
    /** Identifier of the subscription to change */
    readonly subscription_id?: string,
    /** New value of is_canceled */
    readonly is_canceled?: boolean,
  }

  export type editUserStarSubscription = {
    /** Cancels or re-enables Telegram Star subscription for a user; for bots only */
    readonly _: 'editUserStarSubscription',
    /** User identifier */
    readonly user_id?: number,
    /** Telegram payment identifier of the subscription */
    readonly telegram_payment_charge_id?: string,
    /**
     * Pass true to cancel the subscription; pass false to allow the user to enable
     * it
     */
    readonly is_canceled?: boolean,
  }

  export type reuseStarSubscription = {
    /**
     * Reuses an active Telegram Star subscription to a channel chat and joins the
     * chat again
     */
    readonly _: 'reuseStarSubscription',
    /** Identifier of the subscription */
    readonly subscription_id?: string,
  }

  export type setChatAffiliateProgram = {
    /** Changes affiliate program for a bot */
    readonly _: 'setChatAffiliateProgram',
    /** Identifier of the chat with an owned bot for which affiliate program is changed */
    readonly chat_id?: number,
    /**
     * Parameters of the affiliate program; pass null to close the currently active
     * program. If there is an active program, then commission and program duration
     * can only be increased. If the active program is scheduled to be closed, then
     * it can't be changed anymore
     */
    readonly parameters?: affiliateProgramParameters$Input,
  }

  export type searchChatAffiliateProgram = {
    /**
     * Searches a chat with an affiliate program. Returns the chat if found and the
     * program is active
     */
    readonly _: 'searchChatAffiliateProgram',
    /** Username of the chat */
    readonly username?: string,
    /** The referrer from an internalLinkTypeChatAffiliateProgram link */
    readonly referrer?: string,
  }

  export type searchAffiliatePrograms = {
    /** Searches affiliate programs that can be connected to the given affiliate */
    readonly _: 'searchAffiliatePrograms',
    /** The affiliate for which affiliate programs are searched for */
    readonly affiliate?: AffiliateType$Input,
    /** Sort order for the results */
    readonly sort_order?: AffiliateProgramSortOrder$Input,
    /**
     * Offset of the first affiliate program to return as received from the previous
     * request; use empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of affiliate programs to return */
    readonly limit?: number,
  }

  export type connectAffiliateProgram = {
    /**
     * Connects an affiliate program to the given affiliate. Returns information about
     * the connected affiliate program
     */
    readonly _: 'connectAffiliateProgram',
    /** The affiliate to which the affiliate program will be connected */
    readonly affiliate?: AffiliateType$Input,
    /** Identifier of the bot, which affiliate program is connected */
    readonly bot_user_id?: number,
  }

  export type disconnectAffiliateProgram = {
    /**
     * Disconnects an affiliate program from the given affiliate and immediately deactivates
     * its referral link. Returns updated information about the disconnected affiliate
     * program
     */
    readonly _: 'disconnectAffiliateProgram',
    /** The affiliate to which the affiliate program is connected */
    readonly affiliate?: AffiliateType$Input,
    /** The referral link of the affiliate program */
    readonly url?: string,
  }

  export type getConnectedAffiliateProgram = {
    /**
     * Returns an affiliate program that were connected to the given affiliate by identifier
     * of the bot that created the program
     */
    readonly _: 'getConnectedAffiliateProgram',
    /** The affiliate to which the affiliate program will be connected */
    readonly affiliate?: AffiliateType$Input,
    /** Identifier of the bot that created the program */
    readonly bot_user_id?: number,
  }

  export type getConnectedAffiliatePrograms = {
    /** Returns affiliate programs that were connected to the given affiliate */
    readonly _: 'getConnectedAffiliatePrograms',
    /** The affiliate to which the affiliate program were connected */
    readonly affiliate?: AffiliateType$Input,
    /**
     * Offset of the first affiliate program to return as received from the previous
     * request; use empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of affiliate programs to return */
    readonly limit?: number,
  }

  export type getBusinessFeatures = {
    /** Returns information about features, available to Business users */
    readonly _: 'getBusinessFeatures',
    /**
     * Source of the request; pass null if the method is called from settings or some
     * non-standard source
     */
    readonly source?: BusinessFeature$Input,
  }

  export type acceptTermsOfService = {
    /** Accepts Telegram terms of services */
    readonly _: 'acceptTermsOfService',
    /** Terms of service identifier */
    readonly terms_of_service_id?: string,
  }

  export type searchStringsByPrefix = {
    /**
     * Searches specified query by word prefixes in the provided strings. Returns 0-based
     * positions of strings that matched. Can be called synchronously
     */
    readonly _: 'searchStringsByPrefix',
    /** The strings to search in for the query */
    readonly strings?: ReadonlyArray<string>,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of objects to return */
    readonly limit?: number,
    /** Pass true to receive no results for an empty query */
    readonly return_none_for_empty_query?: boolean,
  }

  export type sendCustomRequest = {
    /** Sends a custom request; for bots only */
    readonly _: 'sendCustomRequest',
    /** The method name */
    readonly method?: string,
    /** JSON-serialized method parameters */
    readonly parameters?: string,
  }

  export type answerCustomQuery = {
    /** Answers a custom query; for bots only */
    readonly _: 'answerCustomQuery',
    /** Identifier of a custom query */
    readonly custom_query_id?: number | string,
    /** JSON-serialized answer to the query */
    readonly data?: string,
  }

  export type setAlarm = {
    /** Succeeds after a specified amount of time has passed. Can be called before initialization */
    readonly _: 'setAlarm',
    /** Number of seconds before the function returns */
    readonly seconds?: number,
  }

  export type getCountries = {
    /** Returns information about existing countries. Can be called before authorization */
    readonly _: 'getCountries',
  }

  export type getCountryCode = {
    /**
     * Uses the current IP address to find the current country. Returns two-letter
     * ISO 3166-1 alpha-2 country code. Can be called before authorization
     */
    readonly _: 'getCountryCode',
  }

  export type getPhoneNumberInfo = {
    /**
     * Returns information about a phone number by its prefix. Can be called before
     * authorization
     */
    readonly _: 'getPhoneNumberInfo',
    /** The phone number prefix */
    readonly phone_number_prefix?: string,
  }

  export type getPhoneNumberInfoSync = {
    /**
     * Returns information about a phone number by its prefix synchronously. getCountries
     * must be called at least once after changing localization to the specified language
     * if properly localized country information is expected. Can be called synchronously
     */
    readonly _: 'getPhoneNumberInfoSync',
    /** A two-letter ISO 639-1 language code for country information localization */
    readonly language_code?: string,
    /** The phone number prefix */
    readonly phone_number_prefix?: string,
  }

  export type getCollectibleItemInfo = {
    /** Returns information about a given collectible item that was purchased at https://fragment.com */
    readonly _: 'getCollectibleItemInfo',
    /**
     * Type of the collectible item. The item must be used by a user and must be visible
     * to the current user
     */
    readonly type?: CollectibleItemType$Input,
  }

  export type getDeepLinkInfo = {
    /**
     * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature"
     * or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown
     * links. Can be called before authorization
     */
    readonly _: 'getDeepLinkInfo',
    /** The link */
    readonly link?: string,
  }

  export type getApplicationConfig = {
    /** Returns application config, provided by the server. Can be called before authorization */
    readonly _: 'getApplicationConfig',
  }

  export type saveApplicationLogEvent = {
    /** Saves application log event on the server. Can be called before authorization */
    readonly _: 'saveApplicationLogEvent',
    /** Event type */
    readonly type?: string,
    /** Optional chat identifier, associated with the event */
    readonly chat_id?: number,
    /** The log event data */
    readonly data?: JsonValue$Input,
  }

  export type getApplicationDownloadLink = {
    /**
     * Returns the link for downloading official Telegram application to be used when
     * the current user invites friends to Telegram
     */
    readonly _: 'getApplicationDownloadLink',
  }

  export type addProxy = {
    /** Adds a proxy server for network requests. Can be called before authorization */
    readonly _: 'addProxy',
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Pass true to immediately enable the proxy */
    readonly enable?: boolean,
    /** Proxy type */
    readonly type?: ProxyType$Input,
  }

  export type editProxy = {
    /** Edits an existing proxy server for network requests. Can be called before authorization */
    readonly _: 'editProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Pass true to immediately enable the proxy */
    readonly enable?: boolean,
    /** Proxy type */
    readonly type?: ProxyType$Input,
  }

  export type enableProxy = {
    /**
     * Enables a proxy. Only one proxy can be enabled at a time. Can be called before
     * authorization
     */
    readonly _: 'enableProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type disableProxy = {
    /** Disables the currently enabled proxy. Can be called before authorization */
    readonly _: 'disableProxy',
  }

  export type removeProxy = {
    /** Removes a proxy server. Can be called before authorization */
    readonly _: 'removeProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type getProxies = {
    /**
     * Returns the list of proxies that are currently set up. Can be called before
     * authorization
     */
    readonly _: 'getProxies',
  }

  export type getProxyLink = {
    /**
     * Returns an HTTPS link, which can be used to add a proxy. Available only for
     * SOCKS5 and MTProto proxies. Can be called before authorization
     */
    readonly _: 'getProxyLink',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type pingProxy = {
    /**
     * Computes time needed to receive a response from a Telegram server through a
     * proxy. Can be called before authorization
     */
    readonly _: 'pingProxy',
    /** Proxy identifier. Use 0 to ping a Telegram server without a proxy */
    readonly proxy_id?: number,
  }

  export type setLogStream = {
    /** Sets new log stream for internal logging of TDLib. Can be called synchronously */
    readonly _: 'setLogStream',
    /** New log stream */
    readonly log_stream?: LogStream$Input,
  }

  export type getLogStream = {
    /**
     * Returns information about currently used log stream for internal logging of
     * TDLib. Can be called synchronously
     */
    readonly _: 'getLogStream',
  }

  export type setLogVerbosityLevel = {
    /** Sets the verbosity level of the internal logging of TDLib. Can be called synchronously */
    readonly _: 'setLogVerbosityLevel',
    /**
     * New value of the verbosity level for logging. Value 0 corresponds to fatal errors,
     * value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,
     * value 3 corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can be used
     * to enable even more logging
     */
    readonly new_verbosity_level?: number,
  }

  export type getLogVerbosityLevel = {
    /**
     * Returns current verbosity level of the internal logging of TDLib. Can be called
     * synchronously
     */
    readonly _: 'getLogVerbosityLevel',
  }

  export type getLogTags = {
    /**
     * Returns the list of available TDLib internal log tags, for example, ["actor",
     * "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
     */
    readonly _: 'getLogTags',
  }

  export type setLogTagVerbosityLevel = {
    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can be called
     * synchronously
     */
    readonly _: 'setLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    readonly tag?: string,
    /** New verbosity level; 1-1024 */
    readonly new_verbosity_level?: number,
  }

  export type getLogTagVerbosityLevel = {
    /**
     * Returns current verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     */
    readonly _: 'getLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    readonly tag?: string,
  }

  export type addLogMessage = {
    /** Adds a message to TDLib internal log. Can be called synchronously */
    readonly _: 'addLogMessage',
    /** The minimum verbosity level needed for the message to be logged; 0-1023 */
    readonly verbosity_level?: number,
    /** Text of a message to log */
    readonly text?: string,
  }

  export type getUserSupportInfo = {
    /** Returns support information for the given user; for Telegram support only */
    readonly _: 'getUserSupportInfo',
    /** User identifier */
    readonly user_id?: number,
  }

  export type setUserSupportInfo = {
    /** Sets support information for the given user; for Telegram support only */
    readonly _: 'setUserSupportInfo',
    /** User identifier */
    readonly user_id?: number,
    /** New information message */
    readonly message?: formattedText$Input,
  }

  export type getSupportName = {
    /** Returns localized name of the Telegram support user; for Telegram support only */
    readonly _: 'getSupportName',
  }

  export type testCallEmpty = {
    /**
     * Does nothing; for testing only. This is an offline method. Can be called before
     * authorization
     */
    readonly _: 'testCallEmpty',
  }

  export type testCallString = {
    /**
     * Returns the received string; for testing only. This is an offline method. Can
     * be called before authorization
     */
    readonly _: 'testCallString',
    /** String to return */
    readonly x?: string,
  }

  export type testCallBytes = {
    /**
     * Returns the received bytes; for testing only. This is an offline method. Can
     * be called before authorization
     */
    readonly _: 'testCallBytes',
    /** Bytes to return */
    readonly x?: string /* base64 */,
  }

  export type testCallVectorInt = {
    /**
     * Returns the received vector of numbers; for testing only. This is an offline
     * method. Can be called before authorization
     */
    readonly _: 'testCallVectorInt',
    /** Vector of numbers to return */
    readonly x?: ReadonlyArray<number>,
  }

  export type testCallVectorIntObject = {
    /**
     * Returns the received vector of objects containing a number; for testing only.
     * This is an offline method. Can be called before authorization
     */
    readonly _: 'testCallVectorIntObject',
    /** Vector of objects to return */
    readonly x?: ReadonlyArray<testInt$Input>,
  }

  export type testCallVectorString = {
    /**
     * Returns the received vector of strings; for testing only. This is an offline
     * method. Can be called before authorization
     */
    readonly _: 'testCallVectorString',
    /** Vector of strings to return */
    readonly x?: ReadonlyArray<string>,
  }

  export type testCallVectorStringObject = {
    /**
     * Returns the received vector of objects containing a string; for testing only.
     * This is an offline method. Can be called before authorization
     */
    readonly _: 'testCallVectorStringObject',
    /** Vector of objects to return */
    readonly x?: ReadonlyArray<testString$Input>,
  }

  export type testSquareInt = {
    /**
     * Returns the squared received number; for testing only. This is an offline method.
     * Can be called before authorization
     */
    readonly _: 'testSquareInt',
    /** Number to square */
    readonly x?: number,
  }

  export type testNetwork = {
    /**
     * Sends a simple network request to the Telegram servers; for testing only. Can
     * be called before authorization
     */
    readonly _: 'testNetwork',
  }

  export type testProxy = {
    /**
     * Sends a simple network request to the Telegram servers via proxy; for testing
     * only. Can be called before authorization
     */
    readonly _: 'testProxy',
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Proxy type */
    readonly type?: ProxyType$Input,
    /** Identifier of a datacenter with which to test connection */
    readonly dc_id?: number,
    /** The maximum overall timeout for the request */
    readonly timeout?: number,
  }

  export type testGetDifference = {
    /** Forces an updates.getDifference call to the Telegram servers; for testing only */
    readonly _: 'testGetDifference',
  }

  export type testUseUpdate = {
    /**
     * Does nothing and ensures that the Update object is used; for testing only. This
     * is an offline method. Can be called before authorization
     */
    readonly _: 'testUseUpdate',
  }

  export type testReturnError = {
    /**
     * Returns the specified error and ensures that the Error object is used; for testing
     * only. Can be called synchronously
     */
    readonly _: 'testReturnError',
    /** The error to be returned */
    readonly error?: error$Input,
  }

  // --- ---

  export type Error = error

  export type Ok = ok

  /**
   * Provides information about the method by which an authentication code is delivered
   * to the user
   */
  export type AuthenticationCodeType =
    | authenticationCodeTypeTelegramMessage
    | authenticationCodeTypeSms
    | authenticationCodeTypeSmsWord
    | authenticationCodeTypeSmsPhrase
    | authenticationCodeTypeCall
    | authenticationCodeTypeFlashCall
    | authenticationCodeTypeMissedCall
    | authenticationCodeTypeFragment
    | authenticationCodeTypeFirebaseAndroid
    | authenticationCodeTypeFirebaseIos

  export type AuthenticationCodeInfo = authenticationCodeInfo

  export type EmailAddressAuthenticationCodeInfo = emailAddressAuthenticationCodeInfo

  /** Contains authentication data for an email address */
  export type EmailAddressAuthentication$Input =
    | emailAddressAuthenticationCode$Input
    | emailAddressAuthenticationAppleId$Input
    | emailAddressAuthenticationGoogleId$Input

  /** Describes reset state of an email address */
  export type EmailAddressResetState =
    | emailAddressResetStateAvailable
    | emailAddressResetStatePending

  export type TextEntities = textEntities

  export type FormattedText = formattedText

  /** Represents the current authorization state of the TDLib client */
  export type AuthorizationState =
    | authorizationStateWaitTdlibParameters
    | authorizationStateWaitPhoneNumber
    | authorizationStateWaitPremiumPurchase
    | authorizationStateWaitEmailAddress
    | authorizationStateWaitEmailCode
    | authorizationStateWaitCode
    | authorizationStateWaitOtherDeviceConfirmation
    | authorizationStateWaitRegistration
    | authorizationStateWaitPassword
    | authorizationStateReady
    | authorizationStateLoggingOut
    | authorizationStateClosing
    | authorizationStateClosed

  /** Describes parameters to be used for device verification */
  export type FirebaseDeviceVerificationParameters =
    | firebaseDeviceVerificationParametersSafetyNet
    | firebaseDeviceVerificationParametersPlayIntegrity

  export type PasswordState = passwordState

  export type RecoveryEmailAddress = recoveryEmailAddress

  export type TemporaryPasswordState = temporaryPasswordState

  export type File = file

  /** Points to a file */
  export type InputFile =
    | inputFileId
    | inputFileRemote
    | inputFileLocal
    | inputFileGenerated

  /** Points to a file */
  export type InputFile$Input =
    | inputFileId$Input
    | inputFileRemote$Input
    | inputFileLocal$Input
    | inputFileGenerated$Input

  /** Describes format of a thumbnail */
  export type ThumbnailFormat =
    | thumbnailFormatJpeg
    | thumbnailFormatGif
    | thumbnailFormatMpeg4
    | thumbnailFormatPng
    | thumbnailFormatTgs
    | thumbnailFormatWebm
    | thumbnailFormatWebp

  /** Part of the face, relative to which a mask is placed */
  export type MaskPoint =
    | maskPointForehead
    | maskPointEyes
    | maskPointMouth
    | maskPointChin

  /** Part of the face, relative to which a mask is placed */
  export type MaskPoint$Input =
    | maskPointForehead$Input
    | maskPointEyes$Input
    | maskPointMouth$Input
    | maskPointChin$Input

  /** Describes format of a sticker */
  export type StickerFormat =
    | stickerFormatWebp
    | stickerFormatTgs
    | stickerFormatWebm

  /** Describes format of a sticker */
  export type StickerFormat$Input =
    | stickerFormatWebp$Input
    | stickerFormatTgs$Input
    | stickerFormatWebm$Input

  /** Describes type of sticker */
  export type StickerType =
    | stickerTypeRegular
    | stickerTypeMask
    | stickerTypeCustomEmoji

  /** Describes type of sticker */
  export type StickerType$Input =
    | stickerTypeRegular$Input
    | stickerTypeMask$Input
    | stickerTypeCustomEmoji$Input

  /** Contains full information about sticker type */
  export type StickerFullType =
    | stickerFullTypeRegular
    | stickerFullTypeMask
    | stickerFullTypeCustomEmoji

  export type Outline = outline

  /** Describes the type of poll */
  export type PollType =
    | pollTypeRegular
    | pollTypeQuiz

  /** Describes the type of poll */
  export type PollType$Input =
    | pollTypeRegular$Input
    | pollTypeQuiz$Input

  export type Sticker = sticker

  export type AnimatedEmoji = animatedEmoji

  export type Background = background

  export type Backgrounds = backgrounds

  /**
   * Represents the type of user. The following types are possible: regular users,
   * deleted users and bots
   */
  export type UserType =
    | userTypeRegular
    | userTypeDeleted
    | userTypeBot
    | userTypeUnknown

  export type BotCommands = botCommands

  export type BotMenuButton = botMenuButton

  /** Describes conditions for sending of away messages by a Telegram Business account */
  export type BusinessAwayMessageSchedule =
    | businessAwayMessageScheduleAlways
    | businessAwayMessageScheduleOutsideOfOpeningHours
    | businessAwayMessageScheduleCustom

  /** Describes conditions for sending of away messages by a Telegram Business account */
  export type BusinessAwayMessageSchedule$Input =
    | businessAwayMessageScheduleAlways$Input
    | businessAwayMessageScheduleOutsideOfOpeningHours$Input
    | businessAwayMessageScheduleCustom$Input

  export type BusinessConnectedBot = businessConnectedBot

  export type BusinessChatLink = businessChatLink

  export type BusinessChatLinks = businessChatLinks

  export type BusinessChatLinkInfo = businessChatLinkInfo

  /** Describes type of sticker, which was used to create a chat photo */
  export type ChatPhotoStickerType =
    | chatPhotoStickerTypeRegularOrMask
    | chatPhotoStickerTypeCustomEmoji

  /** Describes type of sticker, which was used to create a chat photo */
  export type ChatPhotoStickerType$Input =
    | chatPhotoStickerTypeRegularOrMask$Input
    | chatPhotoStickerTypeCustomEmoji$Input

  export type ChatPhotos = chatPhotos

  /** Describes a photo to be set as a user profile or chat photo */
  export type InputChatPhoto$Input =
    | inputChatPhotoPrevious$Input
    | inputChatPhotoStatic$Input
    | inputChatPhotoAnimation$Input
    | inputChatPhotoSticker$Input

  export type StarAmount = starAmount

  /** Describes type of subscription paid in Telegram Stars */
  export type StarSubscriptionType =
    | starSubscriptionTypeChannel
    | starSubscriptionTypeBot

  export type StarSubscriptions = starSubscriptions

  /** Describes type of affiliate for an affiliate program */
  export type AffiliateType$Input =
    | affiliateTypeCurrentUser$Input
    | affiliateTypeBot$Input
    | affiliateTypeChannel$Input

  /** Describes the order of the found affiliate programs */
  export type AffiliateProgramSortOrder$Input =
    | affiliateProgramSortOrderProfitability$Input
    | affiliateProgramSortOrderCreationDate$Input
    | affiliateProgramSortOrderRevenue$Input

  export type FoundAffiliatePrograms = foundAffiliatePrograms

  export type ConnectedAffiliateProgram = connectedAffiliateProgram

  export type ConnectedAffiliatePrograms = connectedAffiliatePrograms

  export type PremiumGiftPaymentOptions = premiumGiftPaymentOptions

  export type PremiumGiveawayPaymentOptions = premiumGiveawayPaymentOptions

  export type PremiumGiftCodeInfo = premiumGiftCodeInfo

  export type StarPaymentOptions = starPaymentOptions

  export type StarGiveawayPaymentOptions = starGiveawayPaymentOptions

  export type UpgradedGift = upgradedGift

  export type UpgradeGiftResult = upgradeGiftResult

  export type AvailableGifts = availableGifts

  /** Contains identifier of an upgraded gift attribute to search for */
  export type UpgradedGiftAttributeId$Input =
    | upgradedGiftAttributeIdModel$Input
    | upgradedGiftAttributeIdSymbol$Input
    | upgradedGiftAttributeIdBackdrop$Input

  /** Describes order in which upgraded gifts for resale will be sorted */
  export type GiftForResaleOrder$Input =
    | giftForResaleOrderPrice$Input
    | giftForResaleOrderPriceChangeDate$Input
    | giftForResaleOrderNumber$Input

  export type GiftsForResale = giftsForResale

  /** Represents content of a gift received by a user or a channel chat */
  export type SentGift =
    | sentGiftRegular
    | sentGiftUpgraded

  export type ReceivedGift = receivedGift

  export type ReceivedGifts = receivedGifts

  export type GiftUpgradePreview = giftUpgradePreview

  /** Describes direction of a transaction with Telegram Stars */
  export type StarTransactionDirection$Input =
    | starTransactionDirectionIncoming$Input
    | starTransactionDirectionOutgoing$Input

  /** Describes type of transaction with Telegram Stars */
  export type StarTransactionType =
    | starTransactionTypePremiumBotDeposit
    | starTransactionTypeAppStoreDeposit
    | starTransactionTypeGooglePlayDeposit
    | starTransactionTypeFragmentDeposit
    | starTransactionTypeUserDeposit
    | starTransactionTypeGiveawayDeposit
    | starTransactionTypeFragmentWithdrawal
    | starTransactionTypeTelegramAdsWithdrawal
    | starTransactionTypeTelegramApiUsage
    | starTransactionTypeBotPaidMediaPurchase
    | starTransactionTypeBotPaidMediaSale
    | starTransactionTypeChannelPaidMediaPurchase
    | starTransactionTypeChannelPaidMediaSale
    | starTransactionTypeBotInvoicePurchase
    | starTransactionTypeBotInvoiceSale
    | starTransactionTypeBotSubscriptionPurchase
    | starTransactionTypeBotSubscriptionSale
    | starTransactionTypeChannelSubscriptionPurchase
    | starTransactionTypeChannelSubscriptionSale
    | starTransactionTypeGiftPurchase
    | starTransactionTypeGiftTransfer
    | starTransactionTypeGiftSale
    | starTransactionTypeGiftUpgrade
    | starTransactionTypeUpgradedGiftPurchase
    | starTransactionTypeUpgradedGiftSale
    | starTransactionTypeChannelPaidReactionSend
    | starTransactionTypeChannelPaidReactionReceive
    | starTransactionTypeAffiliateProgramCommission
    | starTransactionTypePaidMessageSend
    | starTransactionTypePaidMessageReceive
    | starTransactionTypePremiumPurchase
    | starTransactionTypeBusinessBotTransferSend
    | starTransactionTypeBusinessBotTransferReceive
    | starTransactionTypeUnsupported

  export type StarTransactions = starTransactions

  /** Contains information about status of a user in a giveaway */
  export type GiveawayParticipantStatus =
    | giveawayParticipantStatusEligible
    | giveawayParticipantStatusParticipating
    | giveawayParticipantStatusAlreadyWasMember
    | giveawayParticipantStatusAdministrator
    | giveawayParticipantStatusDisallowedCountry

  /** Contains information about a giveaway */
  export type GiveawayInfo =
    | giveawayInfoOngoing
    | giveawayInfoCompleted

  /** Contains information about a giveaway prize */
  export type GiveawayPrize =
    | giveawayPrizePremium
    | giveawayPrizeStars

  /** Describes type of emoji status */
  export type EmojiStatusType =
    | emojiStatusTypeCustomEmoji
    | emojiStatusTypeUpgradedGift

  /** Describes type of emoji status */
  export type EmojiStatusType$Input =
    | emojiStatusTypeCustomEmoji$Input
    | emojiStatusTypeUpgradedGift$Input

  export type EmojiStatuses = emojiStatuses

  export type EmojiStatusCustomEmojis = emojiStatusCustomEmojis

  export type User = user

  export type UserFullInfo = userFullInfo

  export type Users = users

  export type FoundUsers = foundUsers

  export type ChatAdministrators = chatAdministrators

  /** Provides information about the status of a member in a chat */
  export type ChatMemberStatus =
    | chatMemberStatusCreator
    | chatMemberStatusAdministrator
    | chatMemberStatusMember
    | chatMemberStatusRestricted
    | chatMemberStatusLeft
    | chatMemberStatusBanned

  /** Provides information about the status of a member in a chat */
  export type ChatMemberStatus$Input =
    | chatMemberStatusCreator$Input
    | chatMemberStatusAdministrator$Input
    | chatMemberStatusMember$Input
    | chatMemberStatusRestricted$Input
    | chatMemberStatusLeft$Input
    | chatMemberStatusBanned$Input

  export type ChatMember = chatMember

  export type ChatMembers = chatMembers

  /** Specifies the kind of chat members to return in searchChatMembers */
  export type ChatMembersFilter$Input =
    | chatMembersFilterContacts$Input
    | chatMembersFilterAdministrators$Input
    | chatMembersFilterMembers$Input
    | chatMembersFilterMention$Input
    | chatMembersFilterRestricted$Input
    | chatMembersFilterBanned$Input
    | chatMembersFilterBots$Input

  /** Specifies the kind of chat members to return in getSupergroupMembers */
  export type SupergroupMembersFilter$Input =
    | supergroupMembersFilterRecent$Input
    | supergroupMembersFilterContacts$Input
    | supergroupMembersFilterAdministrators$Input
    | supergroupMembersFilterSearch$Input
    | supergroupMembersFilterRestricted$Input
    | supergroupMembersFilterBanned$Input
    | supergroupMembersFilterMention$Input
    | supergroupMembersFilterBots$Input

  export type ChatInviteLink = chatInviteLink

  export type ChatInviteLinks = chatInviteLinks

  export type ChatInviteLinkCounts = chatInviteLinkCounts

  export type ChatInviteLinkMembers = chatInviteLinkMembers

  /** Describes the type of chat to which points an invite link */
  export type InviteLinkChatType =
    | inviteLinkChatTypeBasicGroup
    | inviteLinkChatTypeSupergroup
    | inviteLinkChatTypeChannel

  export type ChatInviteLinkInfo = chatInviteLinkInfo

  export type ChatJoinRequests = chatJoinRequests

  export type BasicGroup = basicGroup

  export type BasicGroupFullInfo = basicGroupFullInfo

  export type Supergroup = supergroup

  export type SupergroupFullInfo = supergroupFullInfo

  /** Describes the current secret chat state */
  export type SecretChatState =
    | secretChatStatePending
    | secretChatStateReady
    | secretChatStateClosed

  export type SecretChat = secretChat

  /** Contains information about the sender of a message */
  export type MessageSender =
    | messageSenderUser
    | messageSenderChat

  /** Contains information about the sender of a message */
  export type MessageSender$Input =
    | messageSenderUser$Input
    | messageSenderChat$Input

  export type MessageSenders = messageSenders

  export type ChatMessageSenders = chatMessageSenders

  /** Describes read date of a recent outgoing message in a private chat */
  export type MessageReadDate =
    | messageReadDateRead
    | messageReadDateUnread
    | messageReadDateTooOld
    | messageReadDateUserPrivacyRestricted
    | messageReadDateMyPrivacyRestricted

  export type MessageViewers = messageViewers

  /** Contains information about the origin of a message */
  export type MessageOrigin =
    | messageOriginUser
    | messageOriginHiddenUser
    | messageOriginChat
    | messageOriginChannel

  /** Describes type of message reaction */
  export type ReactionType =
    | reactionTypeEmoji
    | reactionTypeCustomEmoji
    | reactionTypePaid

  /** Describes type of message reaction */
  export type ReactionType$Input =
    | reactionTypeEmoji$Input
    | reactionTypeCustomEmoji$Input
    | reactionTypePaid$Input

  /** Describes type of paid message reaction */
  export type PaidReactionType =
    | paidReactionTypeRegular
    | paidReactionTypeAnonymous
    | paidReactionTypeChat

  /** Describes type of paid message reaction */
  export type PaidReactionType$Input =
    | paidReactionTypeRegular$Input
    | paidReactionTypeAnonymous$Input
    | paidReactionTypeChat$Input

  /** Describes a topic of messages in a chat */
  export type MessageTopic =
    | messageTopicForum
    | messageTopicDirectMessages
    | messageTopicSavedMessages

  /** Describes a topic of messages in a chat */
  export type MessageTopic$Input =
    | messageTopicForum$Input
    | messageTopicDirectMessages$Input
    | messageTopicSavedMessages$Input

  /** Describes type of emoji effect */
  export type MessageEffectType =
    | messageEffectTypeEmojiReaction
    | messageEffectTypePremiumSticker

  export type MessageEffect = messageEffect

  /** Contains information about the sending state of the message */
  export type MessageSendingState =
    | messageSendingStatePending
    | messageSendingStateFailed

  /** Contains information about the message or the story a message is replying to */
  export type MessageReplyTo =
    | messageReplyToMessage
    | messageReplyToStory

  /** Contains information about the message or the story to be replied */
  export type InputMessageReplyTo =
    | inputMessageReplyToMessage
    | inputMessageReplyToExternalMessage
    | inputMessageReplyToStory

  /** Contains information about the message or the story to be replied */
  export type InputMessageReplyTo$Input =
    | inputMessageReplyToMessage$Input
    | inputMessageReplyToExternalMessage$Input
    | inputMessageReplyToStory$Input

  export type Message = message

  export type Messages = messages

  export type FoundMessages = foundMessages

  export type FoundChatMessages = foundChatMessages

  export type MessagePositions = messagePositions

  export type MessageCalendar = messageCalendar

  export type BusinessMessage = businessMessage

  export type BusinessMessages = businessMessages

  /** Describes source of a message */
  export type MessageSource$Input =
    | messageSourceChatHistory$Input
    | messageSourceMessageThreadHistory$Input
    | messageSourceForumTopicHistory$Input
    | messageSourceDirectMessagesChatTopicHistory$Input
    | messageSourceHistoryPreview$Input
    | messageSourceChatList$Input
    | messageSourceSearch$Input
    | messageSourceChatEventLog$Input
    | messageSourceNotification$Input
    | messageSourceScreenshot$Input
    | messageSourceOther$Input

  export type SponsoredMessages = sponsoredMessages

  export type SponsoredChats = sponsoredChats

  export type VideoMessageAdvertisements = videoMessageAdvertisements

  /** Describes result of sponsored message or chat report */
  export type ReportSponsoredResult =
    | reportSponsoredResultOk
    | reportSponsoredResultFailed
    | reportSponsoredResultOptionRequired
    | reportSponsoredResultAdsHidden
    | reportSponsoredResultPremiumRequired

  export type FoundFileDownloads = foundFileDownloads

  /** Describes the types of chats to which notification settings are relevant */
  export type NotificationSettingsScope =
    | notificationSettingsScopePrivateChats
    | notificationSettingsScopeGroupChats
    | notificationSettingsScopeChannelChats

  /** Describes the types of chats to which notification settings are relevant */
  export type NotificationSettingsScope$Input =
    | notificationSettingsScopePrivateChats$Input
    | notificationSettingsScopeGroupChats$Input
    | notificationSettingsScopeChannelChats$Input

  export type ScopeNotificationSettings = scopeNotificationSettings

  /** Describes sources of reactions for which notifications will be shown */
  export type ReactionNotificationSource =
    | reactionNotificationSourceNone
    | reactionNotificationSourceContacts
    | reactionNotificationSourceAll

  /** Describes sources of reactions for which notifications will be shown */
  export type ReactionNotificationSource$Input =
    | reactionNotificationSourceNone$Input
    | reactionNotificationSourceContacts$Input
    | reactionNotificationSourceAll$Input

  /** Describes the type of chat */
  export type ChatType =
    | chatTypePrivate
    | chatTypeBasicGroup
    | chatTypeSupergroup
    | chatTypeSecret

  export type ChatFolderIcon = chatFolderIcon

  export type ChatFolder = chatFolder

  export type ChatFolderInfo = chatFolderInfo

  export type ChatFolderInviteLink = chatFolderInviteLink

  export type ChatFolderInviteLinks = chatFolderInviteLinks

  export type ChatFolderInviteLinkInfo = chatFolderInviteLinkInfo

  export type RecommendedChatFolders = recommendedChatFolders

  export type ArchiveChatListSettings = archiveChatListSettings

  /** Describes a list of chats */
  export type ChatList =
    | chatListMain
    | chatListArchive
    | chatListFolder

  /** Describes a list of chats */
  export type ChatList$Input =
    | chatListMain$Input
    | chatListArchive$Input
    | chatListFolder$Input

  export type ChatLists = chatLists

  /** Describes a reason why an external chat is shown in a chat list */
  export type ChatSource =
    | chatSourceMtprotoProxy
    | chatSourcePublicServiceAnnouncement

  /** Describes reactions available in the chat */
  export type ChatAvailableReactions =
    | chatAvailableReactionsAll
    | chatAvailableReactionsSome

  /** Describes reactions available in the chat */
  export type ChatAvailableReactions$Input =
    | chatAvailableReactionsAll$Input
    | chatAvailableReactionsSome$Input

  export type SavedMessagesTags = savedMessagesTags

  export type Chat = chat

  export type Chats = chats

  export type FailedToAddMembers = failedToAddMembers

  export type CreatedBasicGroupChat = createdBasicGroupChat

  /** Describes type of public chat */
  export type PublicChatType$Input =
    | publicChatTypeHasUsername$Input
    | publicChatTypeIsLocationBased$Input

  /** Describes actions which must be possible to do through a chat action bar */
  export type ChatActionBar =
    | chatActionBarReportSpam
    | chatActionBarInviteMembers
    | chatActionBarReportAddBlock
    | chatActionBarAddContact
    | chatActionBarSharePhoneNumber
    | chatActionBarJoinRequest

  /** Describes a keyboard button type */
  export type KeyboardButtonType =
    | keyboardButtonTypeText
    | keyboardButtonTypeRequestPhoneNumber
    | keyboardButtonTypeRequestLocation
    | keyboardButtonTypeRequestPoll
    | keyboardButtonTypeRequestUsers
    | keyboardButtonTypeRequestChat
    | keyboardButtonTypeWebApp

  /** Describes a keyboard button type */
  export type KeyboardButtonType$Input =
    | keyboardButtonTypeText$Input
    | keyboardButtonTypeRequestPhoneNumber$Input
    | keyboardButtonTypeRequestLocation$Input
    | keyboardButtonTypeRequestPoll$Input
    | keyboardButtonTypeRequestUsers$Input
    | keyboardButtonTypeRequestChat$Input
    | keyboardButtonTypeWebApp$Input

  /** Describes the type of inline keyboard button */
  export type InlineKeyboardButtonType =
    | inlineKeyboardButtonTypeUrl
    | inlineKeyboardButtonTypeLoginUrl
    | inlineKeyboardButtonTypeWebApp
    | inlineKeyboardButtonTypeCallback
    | inlineKeyboardButtonTypeCallbackWithPassword
    | inlineKeyboardButtonTypeCallbackGame
    | inlineKeyboardButtonTypeSwitchInline
    | inlineKeyboardButtonTypeBuy
    | inlineKeyboardButtonTypeUser
    | inlineKeyboardButtonTypeCopyText

  /** Describes the type of inline keyboard button */
  export type InlineKeyboardButtonType$Input =
    | inlineKeyboardButtonTypeUrl$Input
    | inlineKeyboardButtonTypeLoginUrl$Input
    | inlineKeyboardButtonTypeWebApp$Input
    | inlineKeyboardButtonTypeCallback$Input
    | inlineKeyboardButtonTypeCallbackWithPassword$Input
    | inlineKeyboardButtonTypeCallbackGame$Input
    | inlineKeyboardButtonTypeSwitchInline$Input
    | inlineKeyboardButtonTypeBuy$Input
    | inlineKeyboardButtonTypeUser$Input
    | inlineKeyboardButtonTypeCopyText$Input

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  export type ReplyMarkup =
    | replyMarkupRemoveKeyboard
    | replyMarkupForceReply
    | replyMarkupShowKeyboard
    | replyMarkupInlineKeyboard

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  export type ReplyMarkup$Input =
    | replyMarkupRemoveKeyboard$Input
    | replyMarkupForceReply$Input
    | replyMarkupShowKeyboard$Input
    | replyMarkupInlineKeyboard$Input

  /** Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl */
  export type LoginUrlInfo =
    | loginUrlInfoOpen
    | loginUrlInfoRequestConfirmation

  /** Describes mode in which a Web App is opened */
  export type WebAppOpenMode =
    | webAppOpenModeCompact
    | webAppOpenModeFullSize
    | webAppOpenModeFullScreen

  /** Describes mode in which a Web App is opened */
  export type WebAppOpenMode$Input =
    | webAppOpenModeCompact$Input
    | webAppOpenModeFullSize$Input
    | webAppOpenModeFullScreen$Input

  export type FoundWebApp = foundWebApp

  export type WebAppInfo = webAppInfo

  export type MainWebApp = mainWebApp

  export type MessageThreadInfo = messageThreadInfo

  /** Describes type of Saved Messages topic */
  export type SavedMessagesTopicType =
    | savedMessagesTopicTypeMyNotes
    | savedMessagesTopicTypeAuthorHidden
    | savedMessagesTopicTypeSavedFromChat

  export type DirectMessagesChatTopic = directMessagesChatTopic

  export type ForumTopicInfo = forumTopicInfo

  export type ForumTopic = forumTopic

  export type ForumTopics = forumTopics

  /** Describes a formatted text object */
  export type RichText =
    | richTextPlain
    | richTextBold
    | richTextItalic
    | richTextUnderline
    | richTextStrikethrough
    | richTextFixed
    | richTextUrl
    | richTextEmailAddress
    | richTextSubscript
    | richTextSuperscript
    | richTextMarked
    | richTextPhoneNumber
    | richTextIcon
    | richTextReference
    | richTextAnchor
    | richTextAnchorLink
    | richTexts

  /** Describes a horizontal alignment of a table cell content */
  export type PageBlockHorizontalAlignment =
    | pageBlockHorizontalAlignmentLeft
    | pageBlockHorizontalAlignmentCenter
    | pageBlockHorizontalAlignmentRight

  /** Describes a Vertical alignment of a table cell content */
  export type PageBlockVerticalAlignment =
    | pageBlockVerticalAlignmentTop
    | pageBlockVerticalAlignmentMiddle
    | pageBlockVerticalAlignmentBottom

  /** Describes a block of an instant view for a web page */
  export type PageBlock =
    | pageBlockTitle
    | pageBlockSubtitle
    | pageBlockAuthorDate
    | pageBlockHeader
    | pageBlockSubheader
    | pageBlockKicker
    | pageBlockParagraph
    | pageBlockPreformatted
    | pageBlockFooter
    | pageBlockDivider
    | pageBlockAnchor
    | pageBlockList
    | pageBlockBlockQuote
    | pageBlockPullQuote
    | pageBlockAnimation
    | pageBlockAudio
    | pageBlockPhoto
    | pageBlockVideo
    | pageBlockVoiceNote
    | pageBlockCover
    | pageBlockEmbedded
    | pageBlockEmbeddedPost
    | pageBlockCollage
    | pageBlockSlideshow
    | pageBlockChatLink
    | pageBlockTable
    | pageBlockDetails
    | pageBlockRelatedArticles
    | pageBlockMap

  export type WebPageInstantView = webPageInstantView

  /** Describes a media from a link preview album */
  export type LinkPreviewAlbumMedia =
    | linkPreviewAlbumMediaPhoto
    | linkPreviewAlbumMediaVideo

  /** Describes type of link preview */
  export type LinkPreviewType =
    | linkPreviewTypeAlbum
    | linkPreviewTypeAnimation
    | linkPreviewTypeApp
    | linkPreviewTypeArticle
    | linkPreviewTypeAudio
    | linkPreviewTypeBackground
    | linkPreviewTypeChannelBoost
    | linkPreviewTypeChat
    | linkPreviewTypeDocument
    | linkPreviewTypeEmbeddedAnimationPlayer
    | linkPreviewTypeEmbeddedAudioPlayer
    | linkPreviewTypeEmbeddedVideoPlayer
    | linkPreviewTypeExternalAudio
    | linkPreviewTypeExternalVideo
    | linkPreviewTypeGroupCall
    | linkPreviewTypeInvoice
    | linkPreviewTypeMessage
    | linkPreviewTypePhoto
    | linkPreviewTypePremiumGiftCode
    | linkPreviewTypeShareableChatFolder
    | linkPreviewTypeSticker
    | linkPreviewTypeStickerSet
    | linkPreviewTypeStory
    | linkPreviewTypeSupergroupBoost
    | linkPreviewTypeTheme
    | linkPreviewTypeUnsupported
    | linkPreviewTypeUpgradedGift
    | linkPreviewTypeUser
    | linkPreviewTypeVideo
    | linkPreviewTypeVideoChat
    | linkPreviewTypeVideoNote
    | linkPreviewTypeVoiceNote
    | linkPreviewTypeWebApp

  export type LinkPreview = linkPreview

  export type Countries = countries

  export type PhoneNumberInfo = phoneNumberInfo

  /** Describes a collectible item that can be purchased at https://fragment.com */
  export type CollectibleItemType$Input =
    | collectibleItemTypeUsername$Input
    | collectibleItemTypePhoneNumber$Input

  export type CollectibleItemInfo = collectibleItemInfo

  export type BankCardInfo = bankCardInfo

  export type OrderInfo = orderInfo

  /** Contains information about the payment method chosen by the user */
  export type InputCredentials$Input =
    | inputCredentialsSaved$Input
    | inputCredentialsNew$Input
    | inputCredentialsApplePay$Input
    | inputCredentialsGooglePay$Input

  /** Contains information about a payment provider */
  export type PaymentProvider =
    | paymentProviderSmartGlocal
    | paymentProviderStripe
    | paymentProviderOther

  /** Describes type of payment form */
  export type PaymentFormType =
    | paymentFormTypeRegular
    | paymentFormTypeStars
    | paymentFormTypeStarSubscription

  export type PaymentForm = paymentForm

  export type ValidatedOrderInfo = validatedOrderInfo

  export type PaymentResult = paymentResult

  /** Describes type of successful payment */
  export type PaymentReceiptType =
    | paymentReceiptTypeRegular
    | paymentReceiptTypeStars

  export type PaymentReceipt = paymentReceipt

  /** Describes an invoice to process */
  export type InputInvoice$Input =
    | inputInvoiceMessage$Input
    | inputInvoiceName$Input
    | inputInvoiceTelegram$Input

  /** Describes a paid media */
  export type PaidMedia =
    | paidMediaPreview
    | paidMediaPhoto
    | paidMediaVideo
    | paidMediaUnsupported

  /** Contains the type of Telegram Passport element */
  export type PassportElementType =
    | passportElementTypePersonalDetails
    | passportElementTypePassport
    | passportElementTypeDriverLicense
    | passportElementTypeIdentityCard
    | passportElementTypeInternalPassport
    | passportElementTypeAddress
    | passportElementTypeUtilityBill
    | passportElementTypeBankStatement
    | passportElementTypeRentalAgreement
    | passportElementTypePassportRegistration
    | passportElementTypeTemporaryRegistration
    | passportElementTypePhoneNumber
    | passportElementTypeEmailAddress

  /** Contains the type of Telegram Passport element */
  export type PassportElementType$Input =
    | passportElementTypePersonalDetails$Input
    | passportElementTypePassport$Input
    | passportElementTypeDriverLicense$Input
    | passportElementTypeIdentityCard$Input
    | passportElementTypeInternalPassport$Input
    | passportElementTypeAddress$Input
    | passportElementTypeUtilityBill$Input
    | passportElementTypeBankStatement$Input
    | passportElementTypeRentalAgreement$Input
    | passportElementTypePassportRegistration$Input
    | passportElementTypeTemporaryRegistration$Input
    | passportElementTypePhoneNumber$Input
    | passportElementTypeEmailAddress$Input

  /** Contains information about a Telegram Passport element */
  export type PassportElement =
    | passportElementPersonalDetails
    | passportElementPassport
    | passportElementDriverLicense
    | passportElementIdentityCard
    | passportElementInternalPassport
    | passportElementAddress
    | passportElementUtilityBill
    | passportElementBankStatement
    | passportElementRentalAgreement
    | passportElementPassportRegistration
    | passportElementTemporaryRegistration
    | passportElementPhoneNumber
    | passportElementEmailAddress

  /** Contains information about a Telegram Passport element to be saved */
  export type InputPassportElement$Input =
    | inputPassportElementPersonalDetails$Input
    | inputPassportElementPassport$Input
    | inputPassportElementDriverLicense$Input
    | inputPassportElementIdentityCard$Input
    | inputPassportElementInternalPassport$Input
    | inputPassportElementAddress$Input
    | inputPassportElementUtilityBill$Input
    | inputPassportElementBankStatement$Input
    | inputPassportElementRentalAgreement$Input
    | inputPassportElementPassportRegistration$Input
    | inputPassportElementTemporaryRegistration$Input
    | inputPassportElementPhoneNumber$Input
    | inputPassportElementEmailAddress$Input

  export type PassportElements = passportElements

  /** Contains the description of an error in a Telegram Passport element */
  export type PassportElementErrorSource =
    | passportElementErrorSourceUnspecified
    | passportElementErrorSourceDataField
    | passportElementErrorSourceFrontSide
    | passportElementErrorSourceReverseSide
    | passportElementErrorSourceSelfie
    | passportElementErrorSourceTranslationFile
    | passportElementErrorSourceTranslationFiles
    | passportElementErrorSourceFile
    | passportElementErrorSourceFiles

  export type PassportAuthorizationForm = passportAuthorizationForm

  export type PassportElementsWithErrors = passportElementsWithErrors

  /**
   * Contains the description of an error in a Telegram Passport element; for bots
   * only
   */
  export type InputPassportElementErrorSource$Input =
    | inputPassportElementErrorSourceUnspecified$Input
    | inputPassportElementErrorSourceDataField$Input
    | inputPassportElementErrorSourceFrontSide$Input
    | inputPassportElementErrorSourceReverseSide$Input
    | inputPassportElementErrorSourceSelfie$Input
    | inputPassportElementErrorSourceTranslationFile$Input
    | inputPassportElementErrorSourceTranslationFiles$Input
    | inputPassportElementErrorSourceFile$Input
    | inputPassportElementErrorSourceFiles$Input

  /** Contains the content of a message */
  export type MessageContent =
    | messageText
    | messageAnimation
    | messageAudio
    | messageDocument
    | messagePaidMedia
    | messagePhoto
    | messageSticker
    | messageVideo
    | messageVideoNote
    | messageVoiceNote
    | messageExpiredPhoto
    | messageExpiredVideo
    | messageExpiredVideoNote
    | messageExpiredVoiceNote
    | messageLocation
    | messageVenue
    | messageContact
    | messageAnimatedEmoji
    | messageDice
    | messageGame
    | messagePoll
    | messageStory
    | messageChecklist
    | messageInvoice
    | messageCall
    | messageGroupCall
    | messageVideoChatScheduled
    | messageVideoChatStarted
    | messageVideoChatEnded
    | messageInviteVideoChatParticipants
    | messageBasicGroupChatCreate
    | messageSupergroupChatCreate
    | messageChatChangeTitle
    | messageChatChangePhoto
    | messageChatDeletePhoto
    | messageChatAddMembers
    | messageChatJoinByLink
    | messageChatJoinByRequest
    | messageChatDeleteMember
    | messageChatUpgradeTo
    | messageChatUpgradeFrom
    | messagePinMessage
    | messageScreenshotTaken
    | messageChatSetBackground
    | messageChatSetTheme
    | messageChatSetMessageAutoDeleteTime
    | messageChatBoost
    | messageForumTopicCreated
    | messageForumTopicEdited
    | messageForumTopicIsClosedToggled
    | messageForumTopicIsHiddenToggled
    | messageSuggestProfilePhoto
    | messageCustomServiceAction
    | messageGameScore
    | messagePaymentSuccessful
    | messagePaymentSuccessfulBot
    | messagePaymentRefunded
    | messageGiftedPremium
    | messagePremiumGiftCode
    | messageGiveawayCreated
    | messageGiveaway
    | messageGiveawayCompleted
    | messageGiveawayWinners
    | messageGiftedStars
    | messageGiveawayPrizeStars
    | messageGift
    | messageUpgradedGift
    | messageRefundedUpgradedGift
    | messagePaidMessagesRefunded
    | messagePaidMessagePriceChanged
    | messageDirectMessagePriceChanged
    | messageChecklistTasksDone
    | messageChecklistTasksAdded
    | messageContactRegistered
    | messageUsersShared
    | messageChatShared
    | messageBotWriteAccessAllowed
    | messageWebAppDataSent
    | messageWebAppDataReceived
    | messagePassportDataSent
    | messagePassportDataReceived
    | messageProximityAlertTriggered
    | messageUnsupported

  /** Represents a part of the text which must be formatted differently */
  export type TextEntityType =
    | textEntityTypeMention
    | textEntityTypeHashtag
    | textEntityTypeCashtag
    | textEntityTypeBotCommand
    | textEntityTypeUrl
    | textEntityTypeEmailAddress
    | textEntityTypePhoneNumber
    | textEntityTypeBankCardNumber
    | textEntityTypeBold
    | textEntityTypeItalic
    | textEntityTypeUnderline
    | textEntityTypeStrikethrough
    | textEntityTypeSpoiler
    | textEntityTypeCode
    | textEntityTypePre
    | textEntityTypePreCode
    | textEntityTypeBlockQuote
    | textEntityTypeExpandableBlockQuote
    | textEntityTypeTextUrl
    | textEntityTypeMentionName
    | textEntityTypeCustomEmoji
    | textEntityTypeMediaTimestamp

  /** Represents a part of the text which must be formatted differently */
  export type TextEntityType$Input =
    | textEntityTypeMention$Input
    | textEntityTypeHashtag$Input
    | textEntityTypeCashtag$Input
    | textEntityTypeBotCommand$Input
    | textEntityTypeUrl$Input
    | textEntityTypeEmailAddress$Input
    | textEntityTypePhoneNumber$Input
    | textEntityTypeBankCardNumber$Input
    | textEntityTypeBold$Input
    | textEntityTypeItalic$Input
    | textEntityTypeUnderline$Input
    | textEntityTypeStrikethrough$Input
    | textEntityTypeSpoiler$Input
    | textEntityTypeCode$Input
    | textEntityTypePre$Input
    | textEntityTypePreCode$Input
    | textEntityTypeBlockQuote$Input
    | textEntityTypeExpandableBlockQuote$Input
    | textEntityTypeTextUrl$Input
    | textEntityTypeMentionName$Input
    | textEntityTypeCustomEmoji$Input
    | textEntityTypeMediaTimestamp$Input

  /** Describes type of paid media to sent */
  export type InputPaidMediaType =
    | inputPaidMediaTypePhoto
    | inputPaidMediaTypeVideo

  /** Describes type of paid media to sent */
  export type InputPaidMediaType$Input =
    | inputPaidMediaTypePhoto$Input
    | inputPaidMediaTypeVideo$Input

  /** Contains information about the time when a scheduled message will be sent */
  export type MessageSchedulingState =
    | messageSchedulingStateSendAtDate
    | messageSchedulingStateSendWhenOnline
    | messageSchedulingStateSendWhenVideoProcessed

  /** Contains information about the time when a scheduled message will be sent */
  export type MessageSchedulingState$Input =
    | messageSchedulingStateSendAtDate$Input
    | messageSchedulingStateSendWhenOnline$Input
    | messageSchedulingStateSendWhenVideoProcessed$Input

  /** Describes when a message will be self-destructed */
  export type MessageSelfDestructType =
    | messageSelfDestructTypeTimer
    | messageSelfDestructTypeImmediately

  /** Describes when a message will be self-destructed */
  export type MessageSelfDestructType$Input =
    | messageSelfDestructTypeTimer$Input
    | messageSelfDestructTypeImmediately$Input

  /** The content of a message to send */
  export type InputMessageContent =
    | inputMessageText
    | inputMessageAnimation
    | inputMessageAudio
    | inputMessageDocument
    | inputMessagePaidMedia
    | inputMessagePhoto
    | inputMessageSticker
    | inputMessageVideo
    | inputMessageVideoNote
    | inputMessageVoiceNote
    | inputMessageLocation
    | inputMessageVenue
    | inputMessageContact
    | inputMessageDice
    | inputMessageGame
    | inputMessageInvoice
    | inputMessagePoll
    | inputMessageStory
    | inputMessageChecklist
    | inputMessageForwarded

  /** The content of a message to send */
  export type InputMessageContent$Input =
    | inputMessageText$Input
    | inputMessageAnimation$Input
    | inputMessageAudio$Input
    | inputMessageDocument$Input
    | inputMessagePaidMedia$Input
    | inputMessagePhoto$Input
    | inputMessageSticker$Input
    | inputMessageVideo$Input
    | inputMessageVideoNote$Input
    | inputMessageVoiceNote$Input
    | inputMessageLocation$Input
    | inputMessageVenue$Input
    | inputMessageContact$Input
    | inputMessageDice$Input
    | inputMessageGame$Input
    | inputMessageInvoice$Input
    | inputMessagePoll$Input
    | inputMessageStory$Input
    | inputMessageChecklist$Input
    | inputMessageForwarded$Input

  export type MessageProperties = messageProperties

  /** Represents a filter for message search results */
  export type SearchMessagesFilter$Input =
    | searchMessagesFilterEmpty$Input
    | searchMessagesFilterAnimation$Input
    | searchMessagesFilterAudio$Input
    | searchMessagesFilterDocument$Input
    | searchMessagesFilterPhoto$Input
    | searchMessagesFilterVideo$Input
    | searchMessagesFilterVoiceNote$Input
    | searchMessagesFilterPhotoAndVideo$Input
    | searchMessagesFilterUrl$Input
    | searchMessagesFilterChatPhoto$Input
    | searchMessagesFilterVideoNote$Input
    | searchMessagesFilterVoiceAndVideoNote$Input
    | searchMessagesFilterMention$Input
    | searchMessagesFilterUnreadMention$Input
    | searchMessagesFilterUnreadReaction$Input
    | searchMessagesFilterFailedToSend$Input
    | searchMessagesFilterPinned$Input

  /** Represents a filter for type of the chats in which to search messages */
  export type SearchMessagesChatTypeFilter$Input =
    | searchMessagesChatTypeFilterPrivate$Input
    | searchMessagesChatTypeFilterGroup$Input
    | searchMessagesChatTypeFilterChannel$Input

  /** Describes the different types of activity in a chat */
  export type ChatAction =
    | chatActionTyping
    | chatActionRecordingVideo
    | chatActionUploadingVideo
    | chatActionRecordingVoiceNote
    | chatActionUploadingVoiceNote
    | chatActionUploadingPhoto
    | chatActionUploadingDocument
    | chatActionChoosingSticker
    | chatActionChoosingLocation
    | chatActionChoosingContact
    | chatActionStartPlayingGame
    | chatActionRecordingVideoNote
    | chatActionUploadingVideoNote
    | chatActionWatchingAnimations
    | chatActionCancel

  /** Describes the different types of activity in a chat */
  export type ChatAction$Input =
    | chatActionTyping$Input
    | chatActionRecordingVideo$Input
    | chatActionUploadingVideo$Input
    | chatActionRecordingVoiceNote$Input
    | chatActionUploadingVoiceNote$Input
    | chatActionUploadingPhoto$Input
    | chatActionUploadingDocument$Input
    | chatActionChoosingSticker$Input
    | chatActionChoosingLocation$Input
    | chatActionChoosingContact$Input
    | chatActionStartPlayingGame$Input
    | chatActionRecordingVideoNote$Input
    | chatActionUploadingVideoNote$Input
    | chatActionWatchingAnimations$Input
    | chatActionCancel$Input

  /** Describes the last time the user was online */
  export type UserStatus =
    | userStatusEmpty
    | userStatusOnline
    | userStatusOffline
    | userStatusRecently
    | userStatusLastWeek
    | userStatusLastMonth

  export type EmojiKeywords = emojiKeywords

  export type Stickers = stickers

  export type Emojis = emojis

  export type StickerSet = stickerSet

  export type StickerSets = stickerSets

  export type TrendingStickerSets = trendingStickerSets

  /** Describes source of stickers for an emoji category */
  export type EmojiCategorySource =
    | emojiCategorySourceSearch
    | emojiCategorySourcePremium

  export type EmojiCategories = emojiCategories

  /** Describes type of emoji category */
  export type EmojiCategoryType$Input =
    | emojiCategoryTypeDefault$Input
    | emojiCategoryTypeRegularStickers$Input
    | emojiCategoryTypeEmojiStatus$Input
    | emojiCategoryTypeChatPhoto$Input

  export type CurrentWeather = currentWeather

  /** Describes type of clickable area on a story media */
  export type StoryAreaType =
    | storyAreaTypeLocation
    | storyAreaTypeVenue
    | storyAreaTypeSuggestedReaction
    | storyAreaTypeMessage
    | storyAreaTypeLink
    | storyAreaTypeWeather
    | storyAreaTypeUpgradedGift

  /** Describes type of clickable area on a story media to be added */
  export type InputStoryAreaType$Input =
    | inputStoryAreaTypeLocation$Input
    | inputStoryAreaTypeFoundVenue$Input
    | inputStoryAreaTypePreviousVenue$Input
    | inputStoryAreaTypeSuggestedReaction$Input
    | inputStoryAreaTypeMessage$Input
    | inputStoryAreaTypeLink$Input
    | inputStoryAreaTypeWeather$Input
    | inputStoryAreaTypeUpgradedGift$Input

  /** Contains the content of a story */
  export type StoryContent =
    | storyContentPhoto
    | storyContentVideo
    | storyContentUnsupported

  /** The content of a story to post */
  export type InputStoryContent$Input =
    | inputStoryContentPhoto$Input
    | inputStoryContentVideo$Input

  /** Describes a list of stories */
  export type StoryList =
    | storyListMain
    | storyListArchive

  /** Describes a list of stories */
  export type StoryList$Input =
    | storyListMain$Input
    | storyListArchive$Input

  /** Contains information about the origin of a story that was reposted */
  export type StoryOrigin =
    | storyOriginPublicStory
    | storyOriginHiddenUser

  export type Story = story

  export type Stories = stories

  export type FoundStories = foundStories

  export type ChatActiveStories = chatActiveStories

  /** Describes type of interaction with a story */
  export type StoryInteractionType =
    | storyInteractionTypeView
    | storyInteractionTypeForward
    | storyInteractionTypeRepost

  export type StoryInteractions = storyInteractions

  export type QuickReplyMessage = quickReplyMessage

  export type QuickReplyMessages = quickReplyMessages

  /** Describes a public forward or repost of a story */
  export type PublicForward =
    | publicForwardMessage
    | publicForwardStory

  export type PublicForwards = publicForwards

  export type BotMediaPreview = botMediaPreview

  export type BotMediaPreviews = botMediaPreviews

  export type BotMediaPreviewInfo = botMediaPreviewInfo

  export type ChatBoostLevelFeatures = chatBoostLevelFeatures

  export type ChatBoostFeatures = chatBoostFeatures

  /** Describes source of a chat boost */
  export type ChatBoostSource =
    | chatBoostSourceGiftCode
    | chatBoostSourceGiveaway
    | chatBoostSourcePremium

  export type ChatBoostStatus = chatBoostStatus

  export type FoundChatBoosts = foundChatBoosts

  export type ChatBoostSlots = chatBoostSlots

  /** Describes the reason why a code needs to be re-sent */
  export type ResendCodeReason$Input =
    | resendCodeReasonUserRequest$Input
    | resendCodeReasonVerificationFailed$Input

  /** Describes the reason why a call was discarded */
  export type CallDiscardReason =
    | callDiscardReasonEmpty
    | callDiscardReasonMissed
    | callDiscardReasonDeclined
    | callDiscardReasonDisconnected
    | callDiscardReasonHungUp
    | callDiscardReasonUpgradeToGroupCall

  /** Describes the type of call server */
  export type CallServerType =
    | callServerTypeTelegramReflector
    | callServerTypeWebrtc

  export type CallId = callId

  export type GroupCallId = groupCallId

  /** Describes the current call state */
  export type CallState =
    | callStatePending
    | callStateExchangingKeys
    | callStateReady
    | callStateHangingUp
    | callStateDiscarded
    | callStateError

  /** Describes the quality of a group call video */
  export type GroupCallVideoQuality$Input =
    | groupCallVideoQualityThumbnail$Input
    | groupCallVideoQualityMedium$Input
    | groupCallVideoQualityFull$Input

  export type VideoChatStreams = videoChatStreams

  export type RtmpUrl = rtmpUrl

  export type GroupCall = groupCall

  export type GroupCallParticipants = groupCallParticipants

  export type GroupCallInfo = groupCallInfo

  /** Describes result of group call participant invitation */
  export type InviteGroupCallParticipantResult =
    | inviteGroupCallParticipantResultUserPrivacyRestricted
    | inviteGroupCallParticipantResultUserAlreadyParticipant
    | inviteGroupCallParticipantResultUserWasBanned
    | inviteGroupCallParticipantResultSuccess

  /** Describes data channel for a group call */
  export type GroupCallDataChannel$Input =
    | groupCallDataChannelMain$Input
    | groupCallDataChannelScreenSharing$Input

  /** Describes a non-joined group call that isn't bound to a chat */
  export type InputGroupCall$Input =
    | inputGroupCallLink$Input
    | inputGroupCallMessage$Input

  /** Describes the exact type of problem with a call */
  export type CallProblem$Input =
    | callProblemEcho$Input
    | callProblemNoise$Input
    | callProblemInterruptions$Input
    | callProblemDistortedSpeech$Input
    | callProblemSilentLocal$Input
    | callProblemSilentRemote$Input
    | callProblemDropped$Input
    | callProblemDistortedVideo$Input
    | callProblemPixelatedVideo$Input

  /** Contains settings for Firebase Authentication in the official applications */
  export type FirebaseAuthenticationSettings$Input =
    | firebaseAuthenticationSettingsAndroid$Input
    | firebaseAuthenticationSettingsIos$Input

  export type AddedReactions = addedReactions

  export type AvailableReactions = availableReactions

  export type EmojiReaction = emojiReaction

  /**
   * Describes why the current user can't add reactions to the message, despite some
   * other users can
   */
  export type ReactionUnavailabilityReason =
    | reactionUnavailabilityReasonAnonymousAdministrator
    | reactionUnavailabilityReasonGuest

  export type Animations = animations

  /** Contains animated stickers which must be used for dice animation rendering */
  export type DiceStickers =
    | diceStickersRegular
    | diceStickersSlotMachine

  export type ImportedContacts = importedContacts

  /** Describes result of speech recognition in a voice note */
  export type SpeechRecognitionResult =
    | speechRecognitionResultPending
    | speechRecognitionResultText
    | speechRecognitionResultError

  export type BusinessConnection = businessConnection

  export type AttachmentMenuBot = attachmentMenuBot

  export type SentWebAppMessage = sentWebAppMessage

  /** Describes a reason why a bot was allowed to write messages to the current user */
  export type BotWriteAccessAllowReason =
    | botWriteAccessAllowReasonConnectedWebsite
    | botWriteAccessAllowReasonAddedToAttachmentMenu
    | botWriteAccessAllowReasonLaunchedWebApp
    | botWriteAccessAllowReasonAcceptedRequest

  export type HttpUrl = httpUrl

  export type UserLink = userLink

  /** Describes the target chat to be opened */
  export type TargetChat =
    | targetChatCurrent
    | targetChatChosen
    | targetChatInternalLink

  /** Describes the target chat to be opened */
  export type TargetChat$Input =
    | targetChatCurrent$Input
    | targetChatChosen$Input
    | targetChatInternalLink$Input

  /** Represents a single result of an inline query; for bots only */
  export type InputInlineQueryResult$Input =
    | inputInlineQueryResultAnimation$Input
    | inputInlineQueryResultArticle$Input
    | inputInlineQueryResultAudio$Input
    | inputInlineQueryResultContact$Input
    | inputInlineQueryResultDocument$Input
    | inputInlineQueryResultGame$Input
    | inputInlineQueryResultLocation$Input
    | inputInlineQueryResultPhoto$Input
    | inputInlineQueryResultSticker$Input
    | inputInlineQueryResultVenue$Input
    | inputInlineQueryResultVideo$Input
    | inputInlineQueryResultVoiceNote$Input

  /** Represents a single result of an inline query */
  export type InlineQueryResult =
    | inlineQueryResultArticle
    | inlineQueryResultContact
    | inlineQueryResultLocation
    | inlineQueryResultVenue
    | inlineQueryResultGame
    | inlineQueryResultAnimation
    | inlineQueryResultAudio
    | inlineQueryResultDocument
    | inlineQueryResultPhoto
    | inlineQueryResultSticker
    | inlineQueryResultVideo
    | inlineQueryResultVoiceNote

  /** Represents type of button in results of inline query */
  export type InlineQueryResultsButtonType =
    | inlineQueryResultsButtonTypeStartBot
    | inlineQueryResultsButtonTypeWebApp

  /** Represents type of button in results of inline query */
  export type InlineQueryResultsButtonType$Input =
    | inlineQueryResultsButtonTypeStartBot$Input
    | inlineQueryResultsButtonTypeWebApp$Input

  export type InlineQueryResults = inlineQueryResults

  export type PreparedInlineMessageId = preparedInlineMessageId

  export type PreparedInlineMessage = preparedInlineMessage

  /** Represents a payload of a callback query */
  export type CallbackQueryPayload =
    | callbackQueryPayloadData
    | callbackQueryPayloadDataWithPassword
    | callbackQueryPayloadGame

  /** Represents a payload of a callback query */
  export type CallbackQueryPayload$Input =
    | callbackQueryPayloadData$Input
    | callbackQueryPayloadDataWithPassword$Input
    | callbackQueryPayloadGame$Input

  export type CallbackQueryAnswer = callbackQueryAnswer

  export type CustomRequestResult = customRequestResult

  export type GameHighScores = gameHighScores

  /** Represents a chat event */
  export type ChatEventAction =
    | chatEventMessageEdited
    | chatEventMessageDeleted
    | chatEventMessagePinned
    | chatEventMessageUnpinned
    | chatEventPollStopped
    | chatEventMemberJoined
    | chatEventMemberJoinedByInviteLink
    | chatEventMemberJoinedByRequest
    | chatEventMemberInvited
    | chatEventMemberLeft
    | chatEventMemberPromoted
    | chatEventMemberRestricted
    | chatEventMemberSubscriptionExtended
    | chatEventAvailableReactionsChanged
    | chatEventBackgroundChanged
    | chatEventDescriptionChanged
    | chatEventEmojiStatusChanged
    | chatEventLinkedChatChanged
    | chatEventLocationChanged
    | chatEventMessageAutoDeleteTimeChanged
    | chatEventPermissionsChanged
    | chatEventPhotoChanged
    | chatEventSlowModeDelayChanged
    | chatEventStickerSetChanged
    | chatEventCustomEmojiStickerSetChanged
    | chatEventTitleChanged
    | chatEventUsernameChanged
    | chatEventActiveUsernamesChanged
    | chatEventAccentColorChanged
    | chatEventProfileAccentColorChanged
    | chatEventHasProtectedContentToggled
    | chatEventInvitesToggled
    | chatEventIsAllHistoryAvailableToggled
    | chatEventHasAggressiveAntiSpamEnabledToggled
    | chatEventSignMessagesToggled
    | chatEventShowMessageSenderToggled
    | chatEventAutomaticTranslationToggled
    | chatEventInviteLinkEdited
    | chatEventInviteLinkRevoked
    | chatEventInviteLinkDeleted
    | chatEventVideoChatCreated
    | chatEventVideoChatEnded
    | chatEventVideoChatMuteNewParticipantsToggled
    | chatEventVideoChatParticipantIsMutedToggled
    | chatEventVideoChatParticipantVolumeLevelChanged
    | chatEventIsForumToggled
    | chatEventForumTopicCreated
    | chatEventForumTopicEdited
    | chatEventForumTopicToggleIsClosed
    | chatEventForumTopicToggleIsHidden
    | chatEventForumTopicDeleted
    | chatEventForumTopicPinned

  export type ChatEvents = chatEvents

  /** Represents the value of a string in a language pack */
  export type LanguagePackStringValue =
    | languagePackStringValueOrdinary
    | languagePackStringValuePluralized
    | languagePackStringValueDeleted

  /** Represents the value of a string in a language pack */
  export type LanguagePackStringValue$Input =
    | languagePackStringValueOrdinary$Input
    | languagePackStringValuePluralized$Input
    | languagePackStringValueDeleted$Input

  export type LanguagePackStrings = languagePackStrings

  export type LanguagePackInfo = languagePackInfo

  export type LocalizationTargetInfo = localizationTargetInfo

  /** Describes type of limit, increased for Premium users */
  export type PremiumLimitType =
    | premiumLimitTypeSupergroupCount
    | premiumLimitTypePinnedChatCount
    | premiumLimitTypeCreatedPublicChatCount
    | premiumLimitTypeSavedAnimationCount
    | premiumLimitTypeFavoriteStickerCount
    | premiumLimitTypeChatFolderCount
    | premiumLimitTypeChatFolderChosenChatCount
    | premiumLimitTypePinnedArchivedChatCount
    | premiumLimitTypePinnedSavedMessagesTopicCount
    | premiumLimitTypeCaptionLength
    | premiumLimitTypeBioLength
    | premiumLimitTypeChatFolderInviteLinkCount
    | premiumLimitTypeShareableChatFolderCount
    | premiumLimitTypeActiveStoryCount
    | premiumLimitTypeWeeklyPostedStoryCount
    | premiumLimitTypeMonthlyPostedStoryCount
    | premiumLimitTypeStoryCaptionLength
    | premiumLimitTypeStorySuggestedReactionAreaCount
    | premiumLimitTypeSimilarChatCount

  /** Describes type of limit, increased for Premium users */
  export type PremiumLimitType$Input =
    | premiumLimitTypeSupergroupCount$Input
    | premiumLimitTypePinnedChatCount$Input
    | premiumLimitTypeCreatedPublicChatCount$Input
    | premiumLimitTypeSavedAnimationCount$Input
    | premiumLimitTypeFavoriteStickerCount$Input
    | premiumLimitTypeChatFolderCount$Input
    | premiumLimitTypeChatFolderChosenChatCount$Input
    | premiumLimitTypePinnedArchivedChatCount$Input
    | premiumLimitTypePinnedSavedMessagesTopicCount$Input
    | premiumLimitTypeCaptionLength$Input
    | premiumLimitTypeBioLength$Input
    | premiumLimitTypeChatFolderInviteLinkCount$Input
    | premiumLimitTypeShareableChatFolderCount$Input
    | premiumLimitTypeActiveStoryCount$Input
    | premiumLimitTypeWeeklyPostedStoryCount$Input
    | premiumLimitTypeMonthlyPostedStoryCount$Input
    | premiumLimitTypeStoryCaptionLength$Input
    | premiumLimitTypeStorySuggestedReactionAreaCount$Input
    | premiumLimitTypeSimilarChatCount$Input

  /** Describes a feature available to Premium users */
  export type PremiumFeature =
    | premiumFeatureIncreasedLimits
    | premiumFeatureIncreasedUploadFileSize
    | premiumFeatureImprovedDownloadSpeed
    | premiumFeatureVoiceRecognition
    | premiumFeatureDisabledAds
    | premiumFeatureUniqueReactions
    | premiumFeatureUniqueStickers
    | premiumFeatureCustomEmoji
    | premiumFeatureAdvancedChatManagement
    | premiumFeatureProfileBadge
    | premiumFeatureEmojiStatus
    | premiumFeatureAnimatedProfilePhoto
    | premiumFeatureForumTopicIcon
    | premiumFeatureAppIcons
    | premiumFeatureRealTimeChatTranslation
    | premiumFeatureUpgradedStories
    | premiumFeatureChatBoost
    | premiumFeatureAccentColor
    | premiumFeatureBackgroundForBoth
    | premiumFeatureSavedMessagesTags
    | premiumFeatureMessagePrivacy
    | premiumFeatureLastSeenTimes
    | premiumFeatureBusiness
    | premiumFeatureMessageEffects
    | premiumFeatureChecklists

  /** Describes a feature available to Premium users */
  export type PremiumFeature$Input =
    | premiumFeatureIncreasedLimits$Input
    | premiumFeatureIncreasedUploadFileSize$Input
    | premiumFeatureImprovedDownloadSpeed$Input
    | premiumFeatureVoiceRecognition$Input
    | premiumFeatureDisabledAds$Input
    | premiumFeatureUniqueReactions$Input
    | premiumFeatureUniqueStickers$Input
    | premiumFeatureCustomEmoji$Input
    | premiumFeatureAdvancedChatManagement$Input
    | premiumFeatureProfileBadge$Input
    | premiumFeatureEmojiStatus$Input
    | premiumFeatureAnimatedProfilePhoto$Input
    | premiumFeatureForumTopicIcon$Input
    | premiumFeatureAppIcons$Input
    | premiumFeatureRealTimeChatTranslation$Input
    | premiumFeatureUpgradedStories$Input
    | premiumFeatureChatBoost$Input
    | premiumFeatureAccentColor$Input
    | premiumFeatureBackgroundForBoth$Input
    | premiumFeatureSavedMessagesTags$Input
    | premiumFeatureMessagePrivacy$Input
    | premiumFeatureLastSeenTimes$Input
    | premiumFeatureBusiness$Input
    | premiumFeatureMessageEffects$Input
    | premiumFeatureChecklists$Input

  /** Describes a feature available to Business user accounts */
  export type BusinessFeature =
    | businessFeatureLocation
    | businessFeatureOpeningHours
    | businessFeatureQuickReplies
    | businessFeatureGreetingMessage
    | businessFeatureAwayMessage
    | businessFeatureAccountLinks
    | businessFeatureStartPage
    | businessFeatureBots
    | businessFeatureEmojiStatus
    | businessFeatureChatFolderTags
    | businessFeatureUpgradedStories

  /** Describes a feature available to Business user accounts */
  export type BusinessFeature$Input =
    | businessFeatureLocation$Input
    | businessFeatureOpeningHours$Input
    | businessFeatureQuickReplies$Input
    | businessFeatureGreetingMessage$Input
    | businessFeatureAwayMessage$Input
    | businessFeatureAccountLinks$Input
    | businessFeatureStartPage$Input
    | businessFeatureBots$Input
    | businessFeatureEmojiStatus$Input
    | businessFeatureChatFolderTags$Input
    | businessFeatureUpgradedStories$Input

  /** Describes a story feature available to Premium users */
  export type PremiumStoryFeature$Input =
    | premiumStoryFeaturePriorityOrder$Input
    | premiumStoryFeatureStealthMode$Input
    | premiumStoryFeaturePermanentViewsHistory$Input
    | premiumStoryFeatureCustomExpirationDuration$Input
    | premiumStoryFeatureSaveStories$Input
    | premiumStoryFeatureLinksAndFormatting$Input
    | premiumStoryFeatureVideoQuality$Input

  export type PremiumLimit = premiumLimit

  export type PremiumFeatures = premiumFeatures

  export type BusinessFeatures = businessFeatures

  /** Describes a source from which the Premium features screen is opened */
  export type PremiumSource$Input =
    | premiumSourceLimitExceeded$Input
    | premiumSourceFeature$Input
    | premiumSourceBusinessFeature$Input
    | premiumSourceStoryFeature$Input
    | premiumSourceLink$Input
    | premiumSourceSettings$Input

  export type PremiumState = premiumState

  /** Describes a purpose of an in-store payment */
  export type StorePaymentPurpose$Input =
    | storePaymentPurposePremiumSubscription$Input
    | storePaymentPurposePremiumGift$Input
    | storePaymentPurposePremiumGiftCodes$Input
    | storePaymentPurposePremiumGiveaway$Input
    | storePaymentPurposeStarGiveaway$Input
    | storePaymentPurposeStars$Input
    | storePaymentPurposeGiftedStars$Input

  /** Describes an in-store transaction */
  export type StoreTransaction$Input =
    | storeTransactionAppStore$Input
    | storeTransactionGooglePlay$Input

  /** Describes a purpose of a payment toward Telegram */
  export type TelegramPaymentPurpose$Input =
    | telegramPaymentPurposePremiumGift$Input
    | telegramPaymentPurposePremiumGiftCodes$Input
    | telegramPaymentPurposePremiumGiveaway$Input
    | telegramPaymentPurposeStars$Input
    | telegramPaymentPurposeGiftedStars$Input
    | telegramPaymentPurposeStarGiveaway$Input
    | telegramPaymentPurposeJoinChat$Input

  /**
   * Represents a data needed to subscribe for push notifications through registerDevice
   * method. To use specific push notification service, the correct application platform
   * must be specified and a valid server authentication data must be uploaded at
   * https://my.telegram.org
   */
  export type DeviceToken$Input =
    | deviceTokenFirebaseCloudMessaging$Input
    | deviceTokenApplePush$Input
    | deviceTokenApplePushVoIP$Input
    | deviceTokenWindowsPush$Input
    | deviceTokenMicrosoftPush$Input
    | deviceTokenMicrosoftPushVoIP$Input
    | deviceTokenWebPush$Input
    | deviceTokenSimplePush$Input
    | deviceTokenUbuntuPush$Input
    | deviceTokenBlackBerryPush$Input
    | deviceTokenTizenPush$Input
    | deviceTokenHuaweiPush$Input

  export type PushReceiverId = pushReceiverId

  /** Describes a fill of a background */
  export type BackgroundFill =
    | backgroundFillSolid
    | backgroundFillGradient
    | backgroundFillFreeformGradient

  /** Describes a fill of a background */
  export type BackgroundFill$Input =
    | backgroundFillSolid$Input
    | backgroundFillGradient$Input
    | backgroundFillFreeformGradient$Input

  /** Describes the type of background */
  export type BackgroundType =
    | backgroundTypeWallpaper
    | backgroundTypePattern
    | backgroundTypeFill
    | backgroundTypeChatTheme

  /** Describes the type of background */
  export type BackgroundType$Input =
    | backgroundTypeWallpaper$Input
    | backgroundTypePattern$Input
    | backgroundTypeFill$Input
    | backgroundTypeChatTheme$Input

  /** Contains information about background to set */
  export type InputBackground$Input =
    | inputBackgroundLocal$Input
    | inputBackgroundRemote$Input
    | inputBackgroundPrevious$Input

  export type TimeZones = timeZones

  export type Hashtags = hashtags

  /**
   * Represents result of checking whether the current user can post a story on behalf
   * of the specific chat
   */
  export type CanPostStoryResult =
    | canPostStoryResultOk
    | canPostStoryResultPremiumNeeded
    | canPostStoryResultBoostNeeded
    | canPostStoryResultActiveStoryLimitExceeded
    | canPostStoryResultWeeklyLimitExceeded
    | canPostStoryResultMonthlyLimitExceeded

  /**
   * Represents result of checking whether the current session can be used to transfer
   * a chat ownership to another user
   */
  export type CanTransferOwnershipResult =
    | canTransferOwnershipResultOk
    | canTransferOwnershipResultPasswordNeeded
    | canTransferOwnershipResultPasswordTooFresh
    | canTransferOwnershipResultSessionTooFresh

  /** Represents result of checking whether a username can be set for a chat */
  export type CheckChatUsernameResult =
    | checkChatUsernameResultOk
    | checkChatUsernameResultUsernameInvalid
    | checkChatUsernameResultUsernameOccupied
    | checkChatUsernameResultUsernamePurchasable
    | checkChatUsernameResultPublicChatsTooMany
    | checkChatUsernameResultPublicGroupsUnavailable

  /** Represents result of checking whether a name can be used for a new sticker set */
  export type CheckStickerSetNameResult =
    | checkStickerSetNameResultOk
    | checkStickerSetNameResultNameInvalid
    | checkStickerSetNameResultNameOccupied

  /** Represents result of 2-step verification password reset */
  export type ResetPasswordResult =
    | resetPasswordResultOk
    | resetPasswordResultPending
    | resetPasswordResultDeclined

  /** Contains information about a file with messages exported from another app */
  export type MessageFileType =
    | messageFileTypePrivate
    | messageFileTypeGroup
    | messageFileTypeUnknown

  /** Contains content of a push message notification */
  export type PushMessageContent =
    | pushMessageContentHidden
    | pushMessageContentAnimation
    | pushMessageContentAudio
    | pushMessageContentContact
    | pushMessageContentContactRegistered
    | pushMessageContentDocument
    | pushMessageContentGame
    | pushMessageContentGameScore
    | pushMessageContentInvoice
    | pushMessageContentLocation
    | pushMessageContentPaidMedia
    | pushMessageContentPhoto
    | pushMessageContentPoll
    | pushMessageContentPremiumGiftCode
    | pushMessageContentGiveaway
    | pushMessageContentGift
    | pushMessageContentUpgradedGift
    | pushMessageContentScreenshotTaken
    | pushMessageContentSticker
    | pushMessageContentStory
    | pushMessageContentText
    | pushMessageContentChecklist
    | pushMessageContentVideo
    | pushMessageContentVideoNote
    | pushMessageContentVoiceNote
    | pushMessageContentBasicGroupChatCreate
    | pushMessageContentVideoChatStarted
    | pushMessageContentVideoChatEnded
    | pushMessageContentInviteVideoChatParticipants
    | pushMessageContentChatAddMembers
    | pushMessageContentChatChangePhoto
    | pushMessageContentChatChangeTitle
    | pushMessageContentChatSetBackground
    | pushMessageContentChatSetTheme
    | pushMessageContentChatDeleteMember
    | pushMessageContentChatJoinByLink
    | pushMessageContentChatJoinByRequest
    | pushMessageContentRecurringPayment
    | pushMessageContentSuggestProfilePhoto
    | pushMessageContentProximityAlertTriggered
    | pushMessageContentChecklistTasksAdded
    | pushMessageContentChecklistTasksDone
    | pushMessageContentMessageForwards
    | pushMessageContentMediaAlbum

  /** Contains detailed information about a notification */
  export type NotificationType =
    | notificationTypeNewMessage
    | notificationTypeNewSecretChat
    | notificationTypeNewCall
    | notificationTypeNewPushMessage

  /** Describes the type of notifications in a notification group */
  export type NotificationGroupType =
    | notificationGroupTypeMessages
    | notificationGroupTypeMentions
    | notificationGroupTypeSecretChat
    | notificationGroupTypeCalls

  export type NotificationSound = notificationSound

  export type NotificationSounds = notificationSounds

  /** Represents the value of an option */
  export type OptionValue =
    | optionValueBoolean
    | optionValueEmpty
    | optionValueInteger
    | optionValueString

  /** Represents the value of an option */
  export type OptionValue$Input =
    | optionValueBoolean$Input
    | optionValueEmpty$Input
    | optionValueInteger$Input
    | optionValueString$Input

  /** Represents a JSON value */
  export type JsonValue =
    | jsonValueNull
    | jsonValueBoolean
    | jsonValueNumber
    | jsonValueString
    | jsonValueArray
    | jsonValueObject

  /** Represents a JSON value */
  export type JsonValue$Input =
    | jsonValueNull$Input
    | jsonValueBoolean$Input
    | jsonValueNumber$Input
    | jsonValueString$Input
    | jsonValueArray$Input
    | jsonValueObject$Input

  /** Describes privacy settings of a story */
  export type StoryPrivacySettings =
    | storyPrivacySettingsEveryone
    | storyPrivacySettingsContacts
    | storyPrivacySettingsCloseFriends
    | storyPrivacySettingsSelectedUsers

  /** Describes privacy settings of a story */
  export type StoryPrivacySettings$Input =
    | storyPrivacySettingsEveryone$Input
    | storyPrivacySettingsContacts$Input
    | storyPrivacySettingsCloseFriends$Input
    | storyPrivacySettingsSelectedUsers$Input

  /** Represents a single rule for managing user privacy settings */
  export type UserPrivacySettingRule =
    | userPrivacySettingRuleAllowAll
    | userPrivacySettingRuleAllowContacts
    | userPrivacySettingRuleAllowBots
    | userPrivacySettingRuleAllowPremiumUsers
    | userPrivacySettingRuleAllowUsers
    | userPrivacySettingRuleAllowChatMembers
    | userPrivacySettingRuleRestrictAll
    | userPrivacySettingRuleRestrictContacts
    | userPrivacySettingRuleRestrictBots
    | userPrivacySettingRuleRestrictUsers
    | userPrivacySettingRuleRestrictChatMembers

  /** Represents a single rule for managing user privacy settings */
  export type UserPrivacySettingRule$Input =
    | userPrivacySettingRuleAllowAll$Input
    | userPrivacySettingRuleAllowContacts$Input
    | userPrivacySettingRuleAllowBots$Input
    | userPrivacySettingRuleAllowPremiumUsers$Input
    | userPrivacySettingRuleAllowUsers$Input
    | userPrivacySettingRuleAllowChatMembers$Input
    | userPrivacySettingRuleRestrictAll$Input
    | userPrivacySettingRuleRestrictContacts$Input
    | userPrivacySettingRuleRestrictBots$Input
    | userPrivacySettingRuleRestrictUsers$Input
    | userPrivacySettingRuleRestrictChatMembers$Input

  export type UserPrivacySettingRules = userPrivacySettingRules

  /** Describes available user privacy settings */
  export type UserPrivacySetting =
    | userPrivacySettingShowStatus
    | userPrivacySettingShowProfilePhoto
    | userPrivacySettingShowLinkInForwardedMessages
    | userPrivacySettingShowPhoneNumber
    | userPrivacySettingShowBio
    | userPrivacySettingShowBirthdate
    | userPrivacySettingAllowChatInvites
    | userPrivacySettingAllowCalls
    | userPrivacySettingAllowPeerToPeerCalls
    | userPrivacySettingAllowFindingByPhoneNumber
    | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
    | userPrivacySettingAutosaveGifts
    | userPrivacySettingAllowUnpaidMessages

  /** Describes available user privacy settings */
  export type UserPrivacySetting$Input =
    | userPrivacySettingShowStatus$Input
    | userPrivacySettingShowProfilePhoto$Input
    | userPrivacySettingShowLinkInForwardedMessages$Input
    | userPrivacySettingShowPhoneNumber$Input
    | userPrivacySettingShowBio$Input
    | userPrivacySettingShowBirthdate$Input
    | userPrivacySettingAllowChatInvites$Input
    | userPrivacySettingAllowCalls$Input
    | userPrivacySettingAllowPeerToPeerCalls$Input
    | userPrivacySettingAllowFindingByPhoneNumber$Input
    | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input
    | userPrivacySettingAutosaveGifts$Input
    | userPrivacySettingAllowUnpaidMessages$Input

  export type ReadDatePrivacySettings = readDatePrivacySettings

  export type NewChatPrivacySettings = newChatPrivacySettings

  /** Describes result of canSendMessageToUser */
  export type CanSendMessageToUserResult =
    | canSendMessageToUserResultOk
    | canSendMessageToUserResultUserHasPaidMessages
    | canSendMessageToUserResultUserIsDeleted
    | canSendMessageToUserResultUserRestrictsNewChats

  export type AccountTtl = accountTtl

  export type MessageAutoDeleteTime = messageAutoDeleteTime

  /** Represents the type of session */
  export type SessionType =
    | sessionTypeAndroid
    | sessionTypeApple
    | sessionTypeBrave
    | sessionTypeChrome
    | sessionTypeEdge
    | sessionTypeFirefox
    | sessionTypeIpad
    | sessionTypeIphone
    | sessionTypeLinux
    | sessionTypeMac
    | sessionTypeOpera
    | sessionTypeSafari
    | sessionTypeUbuntu
    | sessionTypeUnknown
    | sessionTypeVivaldi
    | sessionTypeWindows
    | sessionTypeXbox

  export type Session = session

  export type Sessions = sessions

  export type ConnectedWebsites = connectedWebsites

  /** Describes the reason why a chat is reported */
  export type ReportReason$Input =
    | reportReasonSpam$Input
    | reportReasonViolence$Input
    | reportReasonPornography$Input
    | reportReasonChildAbuse$Input
    | reportReasonCopyright$Input
    | reportReasonUnrelatedLocation$Input
    | reportReasonFake$Input
    | reportReasonIllegalDrugs$Input
    | reportReasonPersonalDetails$Input
    | reportReasonCustom$Input

  /** Describes result of chat report */
  export type ReportChatResult =
    | reportChatResultOk
    | reportChatResultOptionRequired
    | reportChatResultTextRequired
    | reportChatResultMessagesRequired

  /** Describes result of story report */
  export type ReportStoryResult =
    | reportStoryResultOk
    | reportStoryResultOptionRequired
    | reportStoryResultTextRequired

  /**
   * Describes an internal https://t.me or tg: link, which must be processed by the
   * application in a special way
   */
  export type InternalLinkType =
    | internalLinkTypeActiveSessions
    | internalLinkTypeAttachmentMenuBot
    | internalLinkTypeAuthenticationCode
    | internalLinkTypeBackground
    | internalLinkTypeBotAddToChannel
    | internalLinkTypeBotStart
    | internalLinkTypeBotStartInGroup
    | internalLinkTypeBusinessChat
    | internalLinkTypeBuyStars
    | internalLinkTypeChangePhoneNumber
    | internalLinkTypeChatAffiliateProgram
    | internalLinkTypeChatBoost
    | internalLinkTypeChatFolderInvite
    | internalLinkTypeChatFolderSettings
    | internalLinkTypeChatInvite
    | internalLinkTypeDefaultMessageAutoDeleteTimerSettings
    | internalLinkTypeEditProfileSettings
    | internalLinkTypeGame
    | internalLinkTypeGroupCall
    | internalLinkTypeInstantView
    | internalLinkTypeInvoice
    | internalLinkTypeLanguagePack
    | internalLinkTypeLanguageSettings
    | internalLinkTypeMainWebApp
    | internalLinkTypeMessage
    | internalLinkTypeMessageDraft
    | internalLinkTypeMyStars
    | internalLinkTypePassportDataRequest
    | internalLinkTypePhoneNumberConfirmation
    | internalLinkTypePremiumFeatures
    | internalLinkTypePremiumGift
    | internalLinkTypePremiumGiftCode
    | internalLinkTypePrivacyAndSecuritySettings
    | internalLinkTypeProxy
    | internalLinkTypePublicChat
    | internalLinkTypeQrCodeAuthentication
    | internalLinkTypeRestorePurchases
    | internalLinkTypeSettings
    | internalLinkTypeStickerSet
    | internalLinkTypeStory
    | internalLinkTypeTheme
    | internalLinkTypeThemeSettings
    | internalLinkTypeUnknownDeepLink
    | internalLinkTypeUnsupportedProxy
    | internalLinkTypeUpgradedGift
    | internalLinkTypeUserPhoneNumber
    | internalLinkTypeUserToken
    | internalLinkTypeVideoChat
    | internalLinkTypeWebApp

  /**
   * Describes an internal https://t.me or tg: link, which must be processed by the
   * application in a special way
   */
  export type InternalLinkType$Input =
    | internalLinkTypeActiveSessions$Input
    | internalLinkTypeAttachmentMenuBot$Input
    | internalLinkTypeAuthenticationCode$Input
    | internalLinkTypeBackground$Input
    | internalLinkTypeBotAddToChannel$Input
    | internalLinkTypeBotStart$Input
    | internalLinkTypeBotStartInGroup$Input
    | internalLinkTypeBusinessChat$Input
    | internalLinkTypeBuyStars$Input
    | internalLinkTypeChangePhoneNumber$Input
    | internalLinkTypeChatAffiliateProgram$Input
    | internalLinkTypeChatBoost$Input
    | internalLinkTypeChatFolderInvite$Input
    | internalLinkTypeChatFolderSettings$Input
    | internalLinkTypeChatInvite$Input
    | internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input
    | internalLinkTypeEditProfileSettings$Input
    | internalLinkTypeGame$Input
    | internalLinkTypeGroupCall$Input
    | internalLinkTypeInstantView$Input
    | internalLinkTypeInvoice$Input
    | internalLinkTypeLanguagePack$Input
    | internalLinkTypeLanguageSettings$Input
    | internalLinkTypeMainWebApp$Input
    | internalLinkTypeMessage$Input
    | internalLinkTypeMessageDraft$Input
    | internalLinkTypeMyStars$Input
    | internalLinkTypePassportDataRequest$Input
    | internalLinkTypePhoneNumberConfirmation$Input
    | internalLinkTypePremiumFeatures$Input
    | internalLinkTypePremiumGift$Input
    | internalLinkTypePremiumGiftCode$Input
    | internalLinkTypePrivacyAndSecuritySettings$Input
    | internalLinkTypeProxy$Input
    | internalLinkTypePublicChat$Input
    | internalLinkTypeQrCodeAuthentication$Input
    | internalLinkTypeRestorePurchases$Input
    | internalLinkTypeSettings$Input
    | internalLinkTypeStickerSet$Input
    | internalLinkTypeStory$Input
    | internalLinkTypeTheme$Input
    | internalLinkTypeThemeSettings$Input
    | internalLinkTypeUnknownDeepLink$Input
    | internalLinkTypeUnsupportedProxy$Input
    | internalLinkTypeUpgradedGift$Input
    | internalLinkTypeUserPhoneNumber$Input
    | internalLinkTypeUserToken$Input
    | internalLinkTypeVideoChat$Input
    | internalLinkTypeWebApp$Input

  export type MessageLink = messageLink

  export type MessageLinkInfo = messageLinkInfo

  export type ChatBoostLink = chatBoostLink

  export type ChatBoostLinkInfo = chatBoostLinkInfo

  /** Describes type of block list */
  export type BlockList =
    | blockListMain
    | blockListStories

  /** Describes type of block list */
  export type BlockList$Input =
    | blockListMain$Input
    | blockListStories$Input

  /** Represents the type of file */
  export type FileType =
    | fileTypeNone
    | fileTypeAnimation
    | fileTypeAudio
    | fileTypeDocument
    | fileTypeNotificationSound
    | fileTypePhoto
    | fileTypePhotoStory
    | fileTypeProfilePhoto
    | fileTypeSecret
    | fileTypeSecretThumbnail
    | fileTypeSecure
    | fileTypeSelfDestructingPhoto
    | fileTypeSelfDestructingVideo
    | fileTypeSelfDestructingVideoNote
    | fileTypeSelfDestructingVoiceNote
    | fileTypeSticker
    | fileTypeThumbnail
    | fileTypeUnknown
    | fileTypeVideo
    | fileTypeVideoNote
    | fileTypeVideoStory
    | fileTypeVoiceNote
    | fileTypeWallpaper

  /** Represents the type of file */
  export type FileType$Input =
    | fileTypeNone$Input
    | fileTypeAnimation$Input
    | fileTypeAudio$Input
    | fileTypeDocument$Input
    | fileTypeNotificationSound$Input
    | fileTypePhoto$Input
    | fileTypePhotoStory$Input
    | fileTypeProfilePhoto$Input
    | fileTypeSecret$Input
    | fileTypeSecretThumbnail$Input
    | fileTypeSecure$Input
    | fileTypeSelfDestructingPhoto$Input
    | fileTypeSelfDestructingVideo$Input
    | fileTypeSelfDestructingVideoNote$Input
    | fileTypeSelfDestructingVoiceNote$Input
    | fileTypeSticker$Input
    | fileTypeThumbnail$Input
    | fileTypeUnknown$Input
    | fileTypeVideo$Input
    | fileTypeVideoNote$Input
    | fileTypeVideoStory$Input
    | fileTypeVoiceNote$Input
    | fileTypeWallpaper$Input

  export type StorageStatistics = storageStatistics

  export type StorageStatisticsFast = storageStatisticsFast

  export type DatabaseStatistics = databaseStatistics

  /** Represents the type of network */
  export type NetworkType =
    | networkTypeNone
    | networkTypeMobile
    | networkTypeMobileRoaming
    | networkTypeWiFi
    | networkTypeOther

  /** Represents the type of network */
  export type NetworkType$Input =
    | networkTypeNone$Input
    | networkTypeMobile$Input
    | networkTypeMobileRoaming$Input
    | networkTypeWiFi$Input
    | networkTypeOther$Input

  /** Contains statistics about network usage */
  export type NetworkStatisticsEntry =
    | networkStatisticsEntryFile
    | networkStatisticsEntryCall

  /** Contains statistics about network usage */
  export type NetworkStatisticsEntry$Input =
    | networkStatisticsEntryFile$Input
    | networkStatisticsEntryCall$Input

  export type NetworkStatistics = networkStatistics

  export type AutoDownloadSettingsPresets = autoDownloadSettingsPresets

  /** Describes scope of autosave settings */
  export type AutosaveSettingsScope =
    | autosaveSettingsScopePrivateChats
    | autosaveSettingsScopeGroupChats
    | autosaveSettingsScopeChannelChats
    | autosaveSettingsScopeChat

  /** Describes scope of autosave settings */
  export type AutosaveSettingsScope$Input =
    | autosaveSettingsScopePrivateChats$Input
    | autosaveSettingsScopeGroupChats$Input
    | autosaveSettingsScopeChannelChats$Input
    | autosaveSettingsScopeChat$Input

  export type AutosaveSettings = autosaveSettings

  /** Describes the current state of the connection to Telegram servers */
  export type ConnectionState =
    | connectionStateWaitingForNetwork
    | connectionStateConnectingToProxy
    | connectionStateConnecting
    | connectionStateUpdating
    | connectionStateReady

  /**
   * Represents the categories of chats for which a list of frequently used chats
   * can be retrieved
   */
  export type TopChatCategory$Input =
    | topChatCategoryUsers$Input
    | topChatCategoryBots$Input
    | topChatCategoryGroups$Input
    | topChatCategoryChannels$Input
    | topChatCategoryInlineBots$Input
    | topChatCategoryWebAppBots$Input
    | topChatCategoryCalls$Input
    | topChatCategoryForwardChats$Input

  export type FoundPosition = foundPosition

  export type FoundPositions = foundPositions

  /** Describes the type of URL linking to an internal Telegram entity */
  export type TMeUrlType =
    | tMeUrlTypeUser
    | tMeUrlTypeSupergroup
    | tMeUrlTypeChatInvite
    | tMeUrlTypeStickerSet

  export type TMeUrls = tMeUrls

  /** Describes an action suggested to the current user */
  export type SuggestedAction =
    | suggestedActionEnableArchiveAndMuteNewChats
    | suggestedActionCheckPassword
    | suggestedActionCheckPhoneNumber
    | suggestedActionViewChecksHint
    | suggestedActionConvertToBroadcastGroup
    | suggestedActionSetPassword
    | suggestedActionUpgradePremium
    | suggestedActionRestorePremium
    | suggestedActionSubscribeToAnnualPremium
    | suggestedActionGiftPremiumForChristmas
    | suggestedActionSetBirthdate
    | suggestedActionSetProfilePhoto
    | suggestedActionExtendPremium
    | suggestedActionExtendStarSubscriptions
    | suggestedActionCustom

  /** Describes an action suggested to the current user */
  export type SuggestedAction$Input =
    | suggestedActionEnableArchiveAndMuteNewChats$Input
    | suggestedActionCheckPassword$Input
    | suggestedActionCheckPhoneNumber$Input
    | suggestedActionViewChecksHint$Input
    | suggestedActionConvertToBroadcastGroup$Input
    | suggestedActionSetPassword$Input
    | suggestedActionUpgradePremium$Input
    | suggestedActionRestorePremium$Input
    | suggestedActionSubscribeToAnnualPremium$Input
    | suggestedActionGiftPremiumForChristmas$Input
    | suggestedActionSetBirthdate$Input
    | suggestedActionSetProfilePhoto$Input
    | suggestedActionExtendPremium$Input
    | suggestedActionExtendStarSubscriptions$Input
    | suggestedActionCustom$Input

  export type Count = count

  export type Text = text

  export type Data = data

  export type Seconds = seconds

  export type FileDownloadedPrefixSize = fileDownloadedPrefixSize

  export type StarCount = starCount

  export type DeepLinkInfo = deepLinkInfo

  /** Describes the way the text needs to be parsed for text entities */
  export type TextParseMode$Input =
    | textParseModeMarkdown$Input
    | textParseModeHTML$Input

  /** Describes the type of proxy server */
  export type ProxyType =
    | proxyTypeSocks5
    | proxyTypeHttp
    | proxyTypeMtproto

  /** Describes the type of proxy server */
  export type ProxyType$Input =
    | proxyTypeSocks5$Input
    | proxyTypeHttp$Input
    | proxyTypeMtproto$Input

  export type Proxy = proxy

  export type Proxies = proxies

  /** Describes a statistical graph */
  export type StatisticalGraph =
    | statisticalGraphData
    | statisticalGraphAsync
    | statisticalGraphError

  /** Describes type of object, for which statistics are provided */
  export type ChatStatisticsObjectType =
    | chatStatisticsObjectTypeMessage
    | chatStatisticsObjectTypeStory

  /** Contains a detailed statistics about a chat */
  export type ChatStatistics =
    | chatStatisticsSupergroup
    | chatStatisticsChannel

  export type ChatRevenueStatistics = chatRevenueStatistics

  export type MessageStatistics = messageStatistics

  export type StoryStatistics = storyStatistics

  /** Describes state of a revenue withdrawal */
  export type RevenueWithdrawalState =
    | revenueWithdrawalStatePending
    | revenueWithdrawalStateSucceeded
    | revenueWithdrawalStateFailed

  /**
   * Describes type of transaction for revenue earned from sponsored messages in
   * a chat
   */
  export type ChatRevenueTransactionType =
    | chatRevenueTransactionTypeEarnings
    | chatRevenueTransactionTypeWithdrawal
    | chatRevenueTransactionTypeRefund

  export type ChatRevenueTransactions = chatRevenueTransactions

  export type StarRevenueStatistics = starRevenueStatistics

  /** Represents a vector path command */
  export type VectorPathCommand =
    | vectorPathCommandLine
    | vectorPathCommandCubicBezierCurve

  /** Represents the scope to which bot commands are relevant */
  export type BotCommandScope$Input =
    | botCommandScopeDefault$Input
    | botCommandScopeAllPrivateChats$Input
    | botCommandScopeAllGroupChats$Input
    | botCommandScopeAllChatAdministrators$Input
    | botCommandScopeChat$Input
    | botCommandScopeChatAdministrators$Input
    | botCommandScopeChatMember$Input

  /** Describes type of the request for which a code is sent to a phone number */
  export type PhoneNumberCodeType$Input =
    | phoneNumberCodeTypeChange$Input
    | phoneNumberCodeTypeVerify$Input
    | phoneNumberCodeTypeConfirmOwnership$Input

  /** Contains notifications about data changes */
  export type Update =
    | updateAuthorizationState
    | updateNewMessage
    | updateMessageSendAcknowledged
    | updateMessageSendSucceeded
    | updateMessageSendFailed
    | updateMessageContent
    | updateMessageEdited
    | updateMessageIsPinned
    | updateMessageInteractionInfo
    | updateMessageContentOpened
    | updateMessageMentionRead
    | updateMessageUnreadReactions
    | updateMessageFactCheck
    | updateMessageLiveLocationViewed
    | updateVideoPublished
    | updateNewChat
    | updateChatTitle
    | updateChatPhoto
    | updateChatAccentColors
    | updateChatPermissions
    | updateChatLastMessage
    | updateChatPosition
    | updateChatAddedToList
    | updateChatRemovedFromList
    | updateChatReadInbox
    | updateChatReadOutbox
    | updateChatActionBar
    | updateChatBusinessBotManageBar
    | updateChatAvailableReactions
    | updateChatDraftMessage
    | updateChatEmojiStatus
    | updateChatMessageSender
    | updateChatMessageAutoDeleteTime
    | updateChatNotificationSettings
    | updateChatPendingJoinRequests
    | updateChatReplyMarkup
    | updateChatBackground
    | updateChatTheme
    | updateChatUnreadMentionCount
    | updateChatUnreadReactionCount
    | updateChatVideoChat
    | updateChatDefaultDisableNotification
    | updateChatHasProtectedContent
    | updateChatIsTranslatable
    | updateChatIsMarkedAsUnread
    | updateChatViewAsTopics
    | updateChatBlockList
    | updateChatHasScheduledMessages
    | updateChatFolders
    | updateChatOnlineMemberCount
    | updateSavedMessagesTopic
    | updateSavedMessagesTopicCount
    | updateDirectMessagesChatTopic
    | updateTopicMessageCount
    | updateQuickReplyShortcut
    | updateQuickReplyShortcutDeleted
    | updateQuickReplyShortcuts
    | updateQuickReplyShortcutMessages
    | updateForumTopicInfo
    | updateForumTopic
    | updateScopeNotificationSettings
    | updateReactionNotificationSettings
    | updateNotification
    | updateNotificationGroup
    | updateActiveNotifications
    | updateHavePendingNotifications
    | updateDeleteMessages
    | updateChatAction
    | updateUserStatus
    | updateUser
    | updateBasicGroup
    | updateSupergroup
    | updateSecretChat
    | updateUserFullInfo
    | updateBasicGroupFullInfo
    | updateSupergroupFullInfo
    | updateServiceNotification
    | updateFile
    | updateFileGenerationStart
    | updateFileGenerationStop
    | updateFileDownloads
    | updateFileAddedToDownloads
    | updateFileDownload
    | updateFileRemovedFromDownloads
    | updateApplicationVerificationRequired
    | updateApplicationRecaptchaVerificationRequired
    | updateCall
    | updateGroupCall
    | updateGroupCallParticipant
    | updateGroupCallParticipants
    | updateGroupCallVerificationState
    | updateNewCallSignalingData
    | updateUserPrivacySettingRules
    | updateUnreadMessageCount
    | updateUnreadChatCount
    | updateStory
    | updateStoryDeleted
    | updateStoryPostSucceeded
    | updateStoryPostFailed
    | updateChatActiveStories
    | updateStoryListChatCount
    | updateStoryStealthMode
    | updateOption
    | updateStickerSet
    | updateInstalledStickerSets
    | updateTrendingStickerSets
    | updateRecentStickers
    | updateFavoriteStickers
    | updateSavedAnimations
    | updateSavedNotificationSounds
    | updateDefaultBackground
    | updateChatThemes
    | updateAccentColors
    | updateProfileAccentColors
    | updateLanguagePackStrings
    | updateConnectionState
    | updateFreezeState
    | updateTermsOfService
    | updateUnconfirmedSession
    | updateAttachmentMenuBots
    | updateWebAppMessageSent
    | updateActiveEmojiReactions
    | updateAvailableMessageEffects
    | updateDefaultReactionType
    | updateDefaultPaidReactionType
    | updateSavedMessagesTags
    | updateActiveLiveLocationMessages
    | updateOwnedStarCount
    | updateChatRevenueAmount
    | updateStarRevenueStatus
    | updateSpeechRecognitionTrial
    | updateDiceEmojis
    | updateAnimatedEmojiMessageClicked
    | updateAnimationSearchParameters
    | updateSuggestedActions
    | updateSpeedLimitNotification
    | updateContactCloseBirthdays
    | updateAutosaveSettings
    | updateBusinessConnection
    | updateNewBusinessMessage
    | updateBusinessMessageEdited
    | updateBusinessMessagesDeleted
    | updateNewInlineQuery
    | updateNewChosenInlineResult
    | updateNewCallbackQuery
    | updateNewInlineCallbackQuery
    | updateNewBusinessCallbackQuery
    | updateNewShippingQuery
    | updateNewPreCheckoutQuery
    | updateNewCustomEvent
    | updateNewCustomQuery
    | updatePoll
    | updatePollAnswer
    | updateChatMember
    | updateNewChatJoinRequest
    | updateChatBoost
    | updateMessageReaction
    | updateMessageReactions
    | updatePaidMediaPurchased

  export type Updates = updates

  /** Describes a stream to which TDLib internal log is written */
  export type LogStream =
    | logStreamDefault
    | logStreamFile
    | logStreamEmpty

  /** Describes a stream to which TDLib internal log is written */
  export type LogStream$Input =
    | logStreamDefault$Input
    | logStreamFile$Input
    | logStreamEmpty$Input

  export type LogVerbosityLevel = logVerbosityLevel

  export type LogTags = logTags

  export type UserSupportInfo = userSupportInfo

  export type TestInt = testInt

  export type TestString = testString

  export type TestBytes = testBytes

  export type TestVectorInt = testVectorInt

  export type TestVectorIntObject = testVectorIntObject

  export type TestVectorString = testVectorString

  export type TestVectorStringObject = testVectorStringObject

  // --- Special types ---

  export type $Function =
    | getAuthorizationState
    | setTdlibParameters
    | setAuthenticationPhoneNumber
    | checkAuthenticationPremiumPurchase
    | setAuthenticationPremiumPurchaseTransaction
    | setAuthenticationEmailAddress
    | resendAuthenticationCode
    | checkAuthenticationEmailCode
    | checkAuthenticationCode
    | requestQrCodeAuthentication
    | registerUser
    | resetAuthenticationEmailAddress
    | checkAuthenticationPassword
    | requestAuthenticationPasswordRecovery
    | checkAuthenticationPasswordRecoveryCode
    | recoverAuthenticationPassword
    | sendAuthenticationFirebaseSms
    | reportAuthenticationCodeMissing
    | checkAuthenticationBotToken
    | logOut
    | close
    | destroy
    | confirmQrCodeAuthentication
    | getCurrentState
    | setDatabaseEncryptionKey
    | getPasswordState
    | setPassword
    | setLoginEmailAddress
    | resendLoginEmailAddressCode
    | checkLoginEmailAddressCode
    | getRecoveryEmailAddress
    | setRecoveryEmailAddress
    | checkRecoveryEmailAddressCode
    | resendRecoveryEmailAddressCode
    | cancelRecoveryEmailAddressVerification
    | requestPasswordRecovery
    | checkPasswordRecoveryCode
    | recoverPassword
    | resetPassword
    | cancelPasswordReset
    | createTemporaryPassword
    | getTemporaryPasswordState
    | getMe
    | getUser
    | getUserFullInfo
    | getBasicGroup
    | getBasicGroupFullInfo
    | getSupergroup
    | getSupergroupFullInfo
    | getSecretChat
    | getChat
    | getMessage
    | getMessageLocally
    | getRepliedMessage
    | getChatPinnedMessage
    | getCallbackQueryMessage
    | getMessages
    | getMessageProperties
    | getMessageThread
    | getMessageReadDate
    | getMessageViewers
    | getMessageAuthor
    | getFile
    | getRemoteFile
    | loadChats
    | getChats
    | searchPublicChat
    | searchPublicChats
    | searchChats
    | searchChatsOnServer
    | getRecommendedChats
    | getChatSimilarChats
    | getChatSimilarChatCount
    | openChatSimilarChat
    | getBotSimilarBots
    | getBotSimilarBotCount
    | openBotSimilarBot
    | getTopChats
    | removeTopChat
    | searchRecentlyFoundChats
    | addRecentlyFoundChat
    | removeRecentlyFoundChat
    | clearRecentlyFoundChats
    | getRecentlyOpenedChats
    | checkChatUsername
    | getCreatedPublicChats
    | checkCreatedPublicChatsLimit
    | getSuitableDiscussionChats
    | getInactiveSupergroupChats
    | getSuitablePersonalChats
    | loadDirectMessagesChatTopics
    | getDirectMessagesChatTopic
    | getDirectMessagesChatTopicHistory
    | getDirectMessagesChatTopicMessageByDate
    | deleteDirectMessagesChatTopicHistory
    | deleteDirectMessagesChatTopicMessagesByDate
    | setDirectMessagesChatTopicIsMarkedAsUnread
    | setDirectMessagesChatTopicDraftMessage
    | unpinAllDirectMessagesChatTopicMessages
    | readAllDirectMessagesChatTopicReactions
    | getDirectMessagesChatTopicRevenue
    | toggleDirectMessagesChatTopicCanSendUnpaidMessages
    | loadSavedMessagesTopics
    | getSavedMessagesTopicHistory
    | getSavedMessagesTopicMessageByDate
    | deleteSavedMessagesTopicHistory
    | deleteSavedMessagesTopicMessagesByDate
    | toggleSavedMessagesTopicIsPinned
    | setPinnedSavedMessagesTopics
    | getGroupsInCommon
    | getChatHistory
    | getMessageThreadHistory
    | deleteChatHistory
    | deleteChat
    | searchChatMessages
    | searchMessages
    | searchSecretMessages
    | searchSavedMessages
    | searchCallMessages
    | searchOutgoingDocumentMessages
    | searchPublicMessagesByTag
    | searchPublicStoriesByTag
    | searchPublicStoriesByLocation
    | searchPublicStoriesByVenue
    | getSearchedForTags
    | removeSearchedForTag
    | clearSearchedForTags
    | deleteAllCallMessages
    | searchChatRecentLocationMessages
    | getChatMessageByDate
    | getChatSparseMessagePositions
    | getChatMessageCalendar
    | getChatMessageCount
    | getChatMessagePosition
    | getChatScheduledMessages
    | getChatSponsoredMessages
    | clickChatSponsoredMessage
    | reportChatSponsoredMessage
    | getSearchSponsoredChats
    | viewSponsoredChat
    | openSponsoredChat
    | reportSponsoredChat
    | getVideoMessageAdvertisements
    | viewVideoMessageAdvertisement
    | clickVideoMessageAdvertisement
    | reportVideoMessageAdvertisement
    | removeNotification
    | removeNotificationGroup
    | getMessageLink
    | getMessageEmbeddingCode
    | getMessageLinkInfo
    | translateText
    | translateMessageText
    | recognizeSpeech
    | rateSpeechRecognition
    | getChatAvailableMessageSenders
    | setChatMessageSender
    | sendMessage
    | sendMessageAlbum
    | sendBotStartMessage
    | sendInlineQueryResultMessage
    | forwardMessages
    | sendQuickReplyShortcutMessages
    | resendMessages
    | addLocalMessage
    | deleteMessages
    | deleteChatMessagesBySender
    | deleteChatMessagesByDate
    | editMessageText
    | editMessageLiveLocation
    | editMessageChecklist
    | editMessageMedia
    | editMessageCaption
    | editMessageReplyMarkup
    | editInlineMessageText
    | editInlineMessageLiveLocation
    | editInlineMessageMedia
    | editInlineMessageCaption
    | editInlineMessageReplyMarkup
    | editMessageSchedulingState
    | setMessageFactCheck
    | sendBusinessMessage
    | sendBusinessMessageAlbum
    | editBusinessMessageText
    | editBusinessMessageLiveLocation
    | editBusinessMessageChecklist
    | editBusinessMessageMedia
    | editBusinessMessageCaption
    | editBusinessMessageReplyMarkup
    | stopBusinessPoll
    | setBusinessMessageIsPinned
    | readBusinessMessage
    | deleteBusinessMessages
    | editBusinessStory
    | deleteBusinessStory
    | setBusinessAccountName
    | setBusinessAccountBio
    | setBusinessAccountProfilePhoto
    | setBusinessAccountUsername
    | setBusinessAccountGiftSettings
    | getBusinessAccountStarAmount
    | transferBusinessAccountStars
    | checkQuickReplyShortcutName
    | loadQuickReplyShortcuts
    | setQuickReplyShortcutName
    | deleteQuickReplyShortcut
    | reorderQuickReplyShortcuts
    | loadQuickReplyShortcutMessages
    | deleteQuickReplyShortcutMessages
    | addQuickReplyShortcutMessage
    | addQuickReplyShortcutInlineQueryResultMessage
    | addQuickReplyShortcutMessageAlbum
    | readdQuickReplyShortcutMessages
    | editQuickReplyMessage
    | getForumTopicDefaultIcons
    | createForumTopic
    | editForumTopic
    | getForumTopic
    | getForumTopicLink
    | getForumTopics
    | setForumTopicNotificationSettings
    | toggleForumTopicIsClosed
    | toggleGeneralForumTopicIsHidden
    | toggleForumTopicIsPinned
    | setPinnedForumTopics
    | deleteForumTopic
    | getEmojiReaction
    | getCustomEmojiReactionAnimations
    | getMessageAvailableReactions
    | clearRecentReactions
    | addMessageReaction
    | removeMessageReaction
    | getChatAvailablePaidMessageReactionSenders
    | addPendingPaidMessageReaction
    | commitPendingPaidMessageReactions
    | removePendingPaidMessageReactions
    | setPaidMessageReactionType
    | setMessageReactions
    | getMessageAddedReactions
    | setDefaultReactionType
    | getSavedMessagesTags
    | setSavedMessagesTagLabel
    | getMessageEffect
    | searchQuote
    | getTextEntities
    | parseTextEntities
    | parseMarkdown
    | getMarkdownText
    | getCountryFlagEmoji
    | getFileMimeType
    | getFileExtension
    | cleanFileName
    | getLanguagePackString
    | getJsonValue
    | getJsonString
    | getThemeParametersJsonString
    | setPollAnswer
    | getPollVoters
    | stopPoll
    | addChecklistTasks
    | markChecklistTasksAsDone
    | hideSuggestedAction
    | hideContactCloseBirthdays
    | getBusinessConnection
    | getLoginUrlInfo
    | getLoginUrl
    | shareUsersWithBot
    | shareChatWithBot
    | getInlineQueryResults
    | answerInlineQuery
    | savePreparedInlineMessage
    | getPreparedInlineMessage
    | getGrossingWebAppBots
    | searchWebApp
    | getWebAppPlaceholder
    | getWebAppLinkUrl
    | getMainWebApp
    | getWebAppUrl
    | sendWebAppData
    | openWebApp
    | closeWebApp
    | answerWebAppQuery
    | checkWebAppFileDownload
    | getCallbackQueryAnswer
    | answerCallbackQuery
    | answerShippingQuery
    | answerPreCheckoutQuery
    | setGameScore
    | setInlineGameScore
    | getGameHighScores
    | getInlineGameHighScores
    | deleteChatReplyMarkup
    | sendChatAction
    | openChat
    | closeChat
    | viewMessages
    | openMessageContent
    | clickAnimatedEmojiMessage
    | getInternalLink
    | getInternalLinkType
    | getExternalLinkInfo
    | getExternalLink
    | readAllChatMentions
    | readAllMessageThreadMentions
    | readAllChatReactions
    | readAllMessageThreadReactions
    | createPrivateChat
    | createBasicGroupChat
    | createSupergroupChat
    | createSecretChat
    | createNewBasicGroupChat
    | createNewSupergroupChat
    | createNewSecretChat
    | upgradeBasicGroupChatToSupergroupChat
    | getChatListsToAddChat
    | addChatToList
    | getChatFolder
    | createChatFolder
    | editChatFolder
    | deleteChatFolder
    | getChatFolderChatsToLeave
    | getChatFolderChatCount
    | reorderChatFolders
    | toggleChatFolderTags
    | getRecommendedChatFolders
    | getChatFolderDefaultIconName
    | getChatsForChatFolderInviteLink
    | createChatFolderInviteLink
    | getChatFolderInviteLinks
    | editChatFolderInviteLink
    | deleteChatFolderInviteLink
    | checkChatFolderInviteLink
    | addChatFolderByInviteLink
    | getChatFolderNewChats
    | processChatFolderNewChats
    | getArchiveChatListSettings
    | setArchiveChatListSettings
    | setChatTitle
    | setChatPhoto
    | setChatAccentColor
    | setChatProfileAccentColor
    | setChatMessageAutoDeleteTime
    | setChatEmojiStatus
    | setChatPermissions
    | setChatBackground
    | deleteChatBackground
    | setChatTheme
    | setChatDraftMessage
    | setChatNotificationSettings
    | toggleChatHasProtectedContent
    | toggleChatViewAsTopics
    | toggleChatIsTranslatable
    | toggleChatIsMarkedAsUnread
    | toggleChatDefaultDisableNotification
    | setChatAvailableReactions
    | setChatClientData
    | setChatDescription
    | setChatDiscussionGroup
    | setChatDirectMessagesGroup
    | setChatLocation
    | setChatSlowModeDelay
    | pinChatMessage
    | unpinChatMessage
    | unpinAllChatMessages
    | unpinAllMessageThreadMessages
    | joinChat
    | leaveChat
    | addChatMember
    | addChatMembers
    | setChatMemberStatus
    | banChatMember
    | canTransferOwnership
    | transferChatOwnership
    | getChatMember
    | searchChatMembers
    | getChatAdministrators
    | clearAllDraftMessages
    | getSavedNotificationSound
    | getSavedNotificationSounds
    | addSavedNotificationSound
    | removeSavedNotificationSound
    | getChatNotificationSettingsExceptions
    | getScopeNotificationSettings
    | setScopeNotificationSettings
    | setReactionNotificationSettings
    | resetAllNotificationSettings
    | toggleChatIsPinned
    | setPinnedChats
    | readChatList
    | getCurrentWeather
    | getStory
    | getChatsToPostStories
    | canPostStory
    | postStory
    | editStory
    | editStoryCover
    | setStoryPrivacySettings
    | toggleStoryIsPostedToChatPage
    | deleteStory
    | getStoryNotificationSettingsExceptions
    | loadActiveStories
    | setChatActiveStoriesList
    | getChatActiveStories
    | getChatPostedToChatPageStories
    | getChatArchivedStories
    | setChatPinnedStories
    | openStory
    | closeStory
    | getStoryAvailableReactions
    | setStoryReaction
    | getStoryInteractions
    | getChatStoryInteractions
    | reportStory
    | activateStoryStealthMode
    | getStoryPublicForwards
    | getChatBoostLevelFeatures
    | getChatBoostFeatures
    | getAvailableChatBoostSlots
    | getChatBoostStatus
    | boostChat
    | getChatBoostLink
    | getChatBoostLinkInfo
    | getChatBoosts
    | getUserChatBoosts
    | getAttachmentMenuBot
    | toggleBotIsAddedToAttachmentMenu
    | getThemedEmojiStatuses
    | getRecentEmojiStatuses
    | getUpgradedGiftEmojiStatuses
    | getDefaultEmojiStatuses
    | clearRecentEmojiStatuses
    | getThemedChatEmojiStatuses
    | getDefaultChatEmojiStatuses
    | getDisallowedChatEmojiStatuses
    | downloadFile
    | getFileDownloadedPrefixSize
    | cancelDownloadFile
    | getSuggestedFileName
    | preliminaryUploadFile
    | cancelPreliminaryUploadFile
    | writeGeneratedFilePart
    | setFileGenerationProgress
    | finishFileGeneration
    | readFilePart
    | deleteFile
    | addFileToDownloads
    | toggleDownloadIsPaused
    | toggleAllDownloadsArePaused
    | removeFileFromDownloads
    | removeAllFilesFromDownloads
    | searchFileDownloads
    | setApplicationVerificationToken
    | getMessageFileType
    | getMessageImportConfirmationText
    | importMessages
    | replacePrimaryChatInviteLink
    | createChatInviteLink
    | createChatSubscriptionInviteLink
    | editChatInviteLink
    | editChatSubscriptionInviteLink
    | getChatInviteLink
    | getChatInviteLinkCounts
    | getChatInviteLinks
    | getChatInviteLinkMembers
    | revokeChatInviteLink
    | deleteRevokedChatInviteLink
    | deleteAllRevokedChatInviteLinks
    | checkChatInviteLink
    | joinChatByInviteLink
    | getChatJoinRequests
    | processChatJoinRequest
    | processChatJoinRequests
    | createCall
    | acceptCall
    | sendCallSignalingData
    | discardCall
    | sendCallRating
    | sendCallDebugInformation
    | sendCallLog
    | getVideoChatAvailableParticipants
    | setVideoChatDefaultParticipant
    | createVideoChat
    | createGroupCall
    | getVideoChatRtmpUrl
    | replaceVideoChatRtmpUrl
    | getGroupCall
    | startScheduledVideoChat
    | toggleVideoChatEnabledStartNotification
    | joinGroupCall
    | joinVideoChat
    | startGroupCallScreenSharing
    | toggleGroupCallScreenSharingIsPaused
    | endGroupCallScreenSharing
    | setVideoChatTitle
    | toggleVideoChatMuteNewParticipants
    | inviteGroupCallParticipant
    | declineGroupCallInvitation
    | banGroupCallParticipants
    | inviteVideoChatParticipants
    | getVideoChatInviteLink
    | revokeGroupCallInviteLink
    | startGroupCallRecording
    | endGroupCallRecording
    | toggleGroupCallIsMyVideoPaused
    | toggleGroupCallIsMyVideoEnabled
    | setGroupCallParticipantIsSpeaking
    | toggleGroupCallParticipantIsMuted
    | setGroupCallParticipantVolumeLevel
    | toggleGroupCallParticipantIsHandRaised
    | getGroupCallParticipants
    | loadGroupCallParticipants
    | leaveGroupCall
    | endGroupCall
    | getVideoChatStreams
    | getVideoChatStreamSegment
    | encryptGroupCallData
    | decryptGroupCallData
    | setMessageSenderBlockList
    | blockMessageSenderFromReplies
    | getBlockedMessageSenders
    | addContact
    | importContacts
    | getContacts
    | searchContacts
    | removeContacts
    | getImportedContactCount
    | changeImportedContacts
    | clearImportedContacts
    | setCloseFriends
    | getCloseFriends
    | setUserPersonalProfilePhoto
    | suggestUserProfilePhoto
    | toggleBotCanManageEmojiStatus
    | setUserEmojiStatus
    | searchUserByPhoneNumber
    | sharePhoneNumber
    | getUserProfilePhotos
    | getStickerOutline
    | getStickers
    | getAllStickerEmojis
    | searchStickers
    | getGreetingStickers
    | getPremiumStickers
    | getInstalledStickerSets
    | getArchivedStickerSets
    | getTrendingStickerSets
    | getAttachedStickerSets
    | getStickerSet
    | getStickerSetName
    | searchStickerSet
    | searchInstalledStickerSets
    | searchStickerSets
    | changeStickerSet
    | viewTrendingStickerSets
    | reorderInstalledStickerSets
    | getRecentStickers
    | addRecentSticker
    | removeRecentSticker
    | clearRecentStickers
    | getFavoriteStickers
    | addFavoriteSticker
    | removeFavoriteSticker
    | getStickerEmojis
    | searchEmojis
    | getKeywordEmojis
    | getEmojiCategories
    | getAnimatedEmoji
    | getEmojiSuggestionsUrl
    | getCustomEmojiStickers
    | getDefaultChatPhotoCustomEmojiStickers
    | getDefaultProfilePhotoCustomEmojiStickers
    | getDefaultBackgroundCustomEmojiStickers
    | getSavedAnimations
    | addSavedAnimation
    | removeSavedAnimation
    | getRecentInlineBots
    | getOwnedBots
    | searchHashtags
    | removeRecentHashtag
    | getLinkPreview
    | getWebPageInstantView
    | setProfilePhoto
    | deleteProfilePhoto
    | setAccentColor
    | setProfileAccentColor
    | setName
    | setBio
    | setUsername
    | toggleUsernameIsActive
    | reorderActiveUsernames
    | setBirthdate
    | setPersonalChat
    | setEmojiStatus
    | toggleHasSponsoredMessagesEnabled
    | setBusinessLocation
    | setBusinessOpeningHours
    | setBusinessGreetingMessageSettings
    | setBusinessAwayMessageSettings
    | setBusinessStartPage
    | sendPhoneNumberCode
    | sendPhoneNumberFirebaseSms
    | reportPhoneNumberCodeMissing
    | resendPhoneNumberCode
    | checkPhoneNumberCode
    | getBusinessConnectedBot
    | setBusinessConnectedBot
    | deleteBusinessConnectedBot
    | toggleBusinessConnectedBotChatIsPaused
    | removeBusinessConnectedBotFromChat
    | getBusinessChatLinks
    | createBusinessChatLink
    | editBusinessChatLink
    | deleteBusinessChatLink
    | getBusinessChatLinkInfo
    | getUserLink
    | searchUserByToken
    | setCommands
    | deleteCommands
    | getCommands
    | setMenuButton
    | getMenuButton
    | setDefaultGroupAdministratorRights
    | setDefaultChannelAdministratorRights
    | canBotSendMessages
    | allowBotToSendMessages
    | sendWebAppCustomRequest
    | getBotMediaPreviews
    | getBotMediaPreviewInfo
    | addBotMediaPreview
    | editBotMediaPreview
    | reorderBotMediaPreviews
    | deleteBotMediaPreviews
    | setBotName
    | getBotName
    | setBotProfilePhoto
    | toggleBotUsernameIsActive
    | reorderBotActiveUsernames
    | setBotInfoDescription
    | getBotInfoDescription
    | setBotInfoShortDescription
    | getBotInfoShortDescription
    | setMessageSenderBotVerification
    | removeMessageSenderBotVerification
    | getActiveSessions
    | terminateSession
    | terminateAllOtherSessions
    | confirmSession
    | toggleSessionCanAcceptCalls
    | toggleSessionCanAcceptSecretChats
    | setInactiveSessionTtl
    | getConnectedWebsites
    | disconnectWebsite
    | disconnectAllWebsites
    | setSupergroupUsername
    | toggleSupergroupUsernameIsActive
    | disableAllSupergroupUsernames
    | reorderSupergroupActiveUsernames
    | setSupergroupStickerSet
    | setSupergroupCustomEmojiStickerSet
    | setSupergroupUnrestrictBoostCount
    | toggleSupergroupSignMessages
    | toggleSupergroupJoinToSendMessages
    | toggleSupergroupJoinByRequest
    | toggleSupergroupIsAllHistoryAvailable
    | toggleSupergroupCanHaveSponsoredMessages
    | toggleSupergroupHasAutomaticTranslation
    | toggleSupergroupHasHiddenMembers
    | toggleSupergroupHasAggressiveAntiSpamEnabled
    | toggleSupergroupIsForum
    | toggleSupergroupIsBroadcastGroup
    | reportSupergroupSpam
    | reportSupergroupAntiSpamFalsePositive
    | getSupergroupMembers
    | closeSecretChat
    | getChatEventLog
    | getTimeZones
    | getPaymentForm
    | validateOrderInfo
    | sendPaymentForm
    | getPaymentReceipt
    | getSavedOrderInfo
    | deleteSavedOrderInfo
    | deleteSavedCredentials
    | setGiftSettings
    | getAvailableGifts
    | sendGift
    | sellGift
    | toggleGiftIsSaved
    | setPinnedGifts
    | toggleChatGiftNotifications
    | getGiftUpgradePreview
    | upgradeGift
    | transferGift
    | sendResoldGift
    | getReceivedGifts
    | getReceivedGift
    | getUpgradedGift
    | getUpgradedGiftWithdrawalUrl
    | setGiftResalePrice
    | searchGiftsForResale
    | createInvoiceLink
    | refundStarPayment
    | getSupportUser
    | getBackgroundUrl
    | searchBackground
    | setDefaultBackground
    | deleteDefaultBackground
    | getInstalledBackgrounds
    | removeInstalledBackground
    | resetInstalledBackgrounds
    | getLocalizationTargetInfo
    | getLanguagePackInfo
    | getLanguagePackStrings
    | synchronizeLanguagePack
    | addCustomServerLanguagePack
    | setCustomLanguagePack
    | editCustomLanguagePackInfo
    | setCustomLanguagePackString
    | deleteLanguagePack
    | registerDevice
    | processPushNotification
    | getPushReceiverId
    | getRecentlyVisitedTMeUrls
    | setUserPrivacySettingRules
    | getUserPrivacySettingRules
    | setReadDatePrivacySettings
    | getReadDatePrivacySettings
    | setNewChatPrivacySettings
    | getNewChatPrivacySettings
    | getPaidMessageRevenue
    | allowUnpaidMessagesFromUser
    | setChatPaidMessageStarCount
    | canSendMessageToUser
    | getOption
    | setOption
    | setAccountTtl
    | getAccountTtl
    | deleteAccount
    | setDefaultMessageAutoDeleteTime
    | getDefaultMessageAutoDeleteTime
    | removeChatActionBar
    | reportChat
    | reportChatPhoto
    | reportMessageReactions
    | getChatRevenueStatistics
    | getChatRevenueWithdrawalUrl
    | getChatRevenueTransactions
    | getStarRevenueStatistics
    | getStarWithdrawalUrl
    | getStarAdAccountUrl
    | getChatStatistics
    | getMessageStatistics
    | getMessagePublicForwards
    | getStoryStatistics
    | getStatisticalGraph
    | getStorageStatistics
    | getStorageStatisticsFast
    | getDatabaseStatistics
    | optimizeStorage
    | setNetworkType
    | getNetworkStatistics
    | addNetworkStatistics
    | resetNetworkStatistics
    | getAutoDownloadSettingsPresets
    | setAutoDownloadSettings
    | getAutosaveSettings
    | setAutosaveSettings
    | clearAutosaveSettingsExceptions
    | getBankCardInfo
    | getPassportElement
    | getAllPassportElements
    | setPassportElement
    | deletePassportElement
    | setPassportElementErrors
    | getPreferredCountryLanguage
    | sendEmailAddressVerificationCode
    | resendEmailAddressVerificationCode
    | checkEmailAddressVerificationCode
    | getPassportAuthorizationForm
    | getPassportAuthorizationFormAvailableElements
    | sendPassportAuthorizationForm
    | setBotUpdatesStatus
    | uploadStickerFile
    | getSuggestedStickerSetName
    | checkStickerSetName
    | createNewStickerSet
    | addStickerToSet
    | replaceStickerInSet
    | setStickerSetThumbnail
    | setCustomEmojiStickerSetThumbnail
    | setStickerSetTitle
    | deleteStickerSet
    | setStickerPositionInSet
    | removeStickerFromSet
    | setStickerEmojis
    | setStickerKeywords
    | setStickerMaskPosition
    | getOwnedStickerSets
    | getMapThumbnailFile
    | getPremiumLimit
    | getPremiumFeatures
    | getPremiumStickerExamples
    | getPremiumInfoSticker
    | viewPremiumFeature
    | clickPremiumSubscriptionButton
    | getPremiumState
    | getPremiumGiftPaymentOptions
    | getPremiumGiveawayPaymentOptions
    | checkPremiumGiftCode
    | applyPremiumGiftCode
    | giftPremiumWithStars
    | launchPrepaidGiveaway
    | getGiveawayInfo
    | getStarPaymentOptions
    | getStarGiftPaymentOptions
    | getStarGiveawayPaymentOptions
    | getStarTransactions
    | getStarSubscriptions
    | canPurchaseFromStore
    | assignStoreTransaction
    | editStarSubscription
    | editUserStarSubscription
    | reuseStarSubscription
    | setChatAffiliateProgram
    | searchChatAffiliateProgram
    | searchAffiliatePrograms
    | connectAffiliateProgram
    | disconnectAffiliateProgram
    | getConnectedAffiliateProgram
    | getConnectedAffiliatePrograms
    | getBusinessFeatures
    | acceptTermsOfService
    | searchStringsByPrefix
    | sendCustomRequest
    | answerCustomQuery
    | setAlarm
    | getCountries
    | getCountryCode
    | getPhoneNumberInfo
    | getPhoneNumberInfoSync
    | getCollectibleItemInfo
    | getDeepLinkInfo
    | getApplicationConfig
    | saveApplicationLogEvent
    | getApplicationDownloadLink
    | addProxy
    | editProxy
    | enableProxy
    | disableProxy
    | removeProxy
    | getProxies
    | getProxyLink
    | pingProxy
    | setLogStream
    | getLogStream
    | setLogVerbosityLevel
    | getLogVerbosityLevel
    | getLogTags
    | setLogTagVerbosityLevel
    | getLogTagVerbosityLevel
    | addLogMessage
    | getUserSupportInfo
    | setUserSupportInfo
    | getSupportName
    | testCallEmpty
    | testCallString
    | testCallBytes
    | testCallVectorInt
    | testCallVectorIntObject
    | testCallVectorString
    | testCallVectorStringObject
    | testSquareInt
    | testNetwork
    | testProxy
    | testGetDifference
    | testUseUpdate
    | testReturnError

  export type $FunctionResultByName = {
    getAuthorizationState: AuthorizationState,
    setTdlibParameters: Ok,
    setAuthenticationPhoneNumber: Ok,
    checkAuthenticationPremiumPurchase: Ok,
    setAuthenticationPremiumPurchaseTransaction: Ok,
    setAuthenticationEmailAddress: Ok,
    resendAuthenticationCode: Ok,
    checkAuthenticationEmailCode: Ok,
    checkAuthenticationCode: Ok,
    requestQrCodeAuthentication: Ok,
    registerUser: Ok,
    resetAuthenticationEmailAddress: Ok,
    checkAuthenticationPassword: Ok,
    requestAuthenticationPasswordRecovery: Ok,
    checkAuthenticationPasswordRecoveryCode: Ok,
    recoverAuthenticationPassword: Ok,
    sendAuthenticationFirebaseSms: Ok,
    reportAuthenticationCodeMissing: Ok,
    checkAuthenticationBotToken: Ok,
    logOut: Ok,
    close: Ok,
    destroy: Ok,
    confirmQrCodeAuthentication: Session,
    getCurrentState: Updates,
    setDatabaseEncryptionKey: Ok,
    getPasswordState: PasswordState,
    setPassword: PasswordState,
    setLoginEmailAddress: EmailAddressAuthenticationCodeInfo,
    resendLoginEmailAddressCode: EmailAddressAuthenticationCodeInfo,
    checkLoginEmailAddressCode: Ok,
    getRecoveryEmailAddress: RecoveryEmailAddress,
    setRecoveryEmailAddress: PasswordState,
    checkRecoveryEmailAddressCode: PasswordState,
    resendRecoveryEmailAddressCode: PasswordState,
    cancelRecoveryEmailAddressVerification: PasswordState,
    requestPasswordRecovery: EmailAddressAuthenticationCodeInfo,
    checkPasswordRecoveryCode: Ok,
    recoverPassword: PasswordState,
    resetPassword: ResetPasswordResult,
    cancelPasswordReset: Ok,
    createTemporaryPassword: TemporaryPasswordState,
    getTemporaryPasswordState: TemporaryPasswordState,
    getMe: User,
    getUser: User,
    getUserFullInfo: UserFullInfo,
    getBasicGroup: BasicGroup,
    getBasicGroupFullInfo: BasicGroupFullInfo,
    getSupergroup: Supergroup,
    getSupergroupFullInfo: SupergroupFullInfo,
    getSecretChat: SecretChat,
    getChat: Chat,
    getMessage: Message,
    getMessageLocally: Message,
    getRepliedMessage: Message,
    getChatPinnedMessage: Message,
    getCallbackQueryMessage: Message,
    getMessages: Messages,
    getMessageProperties: MessageProperties,
    getMessageThread: MessageThreadInfo,
    getMessageReadDate: MessageReadDate,
    getMessageViewers: MessageViewers,
    getMessageAuthor: User,
    getFile: File,
    getRemoteFile: File,
    loadChats: Ok,
    getChats: Chats,
    searchPublicChat: Chat,
    searchPublicChats: Chats,
    searchChats: Chats,
    searchChatsOnServer: Chats,
    getRecommendedChats: Chats,
    getChatSimilarChats: Chats,
    getChatSimilarChatCount: Count,
    openChatSimilarChat: Ok,
    getBotSimilarBots: Users,
    getBotSimilarBotCount: Count,
    openBotSimilarBot: Ok,
    getTopChats: Chats,
    removeTopChat: Ok,
    searchRecentlyFoundChats: Chats,
    addRecentlyFoundChat: Ok,
    removeRecentlyFoundChat: Ok,
    clearRecentlyFoundChats: Ok,
    getRecentlyOpenedChats: Chats,
    checkChatUsername: CheckChatUsernameResult,
    getCreatedPublicChats: Chats,
    checkCreatedPublicChatsLimit: Ok,
    getSuitableDiscussionChats: Chats,
    getInactiveSupergroupChats: Chats,
    getSuitablePersonalChats: Chats,
    loadDirectMessagesChatTopics: Ok,
    getDirectMessagesChatTopic: DirectMessagesChatTopic,
    getDirectMessagesChatTopicHistory: Messages,
    getDirectMessagesChatTopicMessageByDate: Message,
    deleteDirectMessagesChatTopicHistory: Ok,
    deleteDirectMessagesChatTopicMessagesByDate: Ok,
    setDirectMessagesChatTopicIsMarkedAsUnread: Ok,
    setDirectMessagesChatTopicDraftMessage: Ok,
    unpinAllDirectMessagesChatTopicMessages: Ok,
    readAllDirectMessagesChatTopicReactions: Ok,
    getDirectMessagesChatTopicRevenue: StarCount,
    toggleDirectMessagesChatTopicCanSendUnpaidMessages: Ok,
    loadSavedMessagesTopics: Ok,
    getSavedMessagesTopicHistory: Messages,
    getSavedMessagesTopicMessageByDate: Message,
    deleteSavedMessagesTopicHistory: Ok,
    deleteSavedMessagesTopicMessagesByDate: Ok,
    toggleSavedMessagesTopicIsPinned: Ok,
    setPinnedSavedMessagesTopics: Ok,
    getGroupsInCommon: Chats,
    getChatHistory: Messages,
    getMessageThreadHistory: Messages,
    deleteChatHistory: Ok,
    deleteChat: Ok,
    searchChatMessages: FoundChatMessages,
    searchMessages: FoundMessages,
    searchSecretMessages: FoundMessages,
    searchSavedMessages: FoundChatMessages,
    searchCallMessages: FoundMessages,
    searchOutgoingDocumentMessages: FoundMessages,
    searchPublicMessagesByTag: FoundMessages,
    searchPublicStoriesByTag: FoundStories,
    searchPublicStoriesByLocation: FoundStories,
    searchPublicStoriesByVenue: FoundStories,
    getSearchedForTags: Hashtags,
    removeSearchedForTag: Ok,
    clearSearchedForTags: Ok,
    deleteAllCallMessages: Ok,
    searchChatRecentLocationMessages: Messages,
    getChatMessageByDate: Message,
    getChatSparseMessagePositions: MessagePositions,
    getChatMessageCalendar: MessageCalendar,
    getChatMessageCount: Count,
    getChatMessagePosition: Count,
    getChatScheduledMessages: Messages,
    getChatSponsoredMessages: SponsoredMessages,
    clickChatSponsoredMessage: Ok,
    reportChatSponsoredMessage: ReportSponsoredResult,
    getSearchSponsoredChats: SponsoredChats,
    viewSponsoredChat: Ok,
    openSponsoredChat: Ok,
    reportSponsoredChat: ReportSponsoredResult,
    getVideoMessageAdvertisements: VideoMessageAdvertisements,
    viewVideoMessageAdvertisement: Ok,
    clickVideoMessageAdvertisement: Ok,
    reportVideoMessageAdvertisement: ReportSponsoredResult,
    removeNotification: Ok,
    removeNotificationGroup: Ok,
    getMessageLink: MessageLink,
    getMessageEmbeddingCode: Text,
    getMessageLinkInfo: MessageLinkInfo,
    translateText: FormattedText,
    translateMessageText: FormattedText,
    recognizeSpeech: Ok,
    rateSpeechRecognition: Ok,
    getChatAvailableMessageSenders: ChatMessageSenders,
    setChatMessageSender: Ok,
    sendMessage: Message,
    sendMessageAlbum: Messages,
    sendBotStartMessage: Message,
    sendInlineQueryResultMessage: Message,
    forwardMessages: Messages,
    sendQuickReplyShortcutMessages: Messages,
    resendMessages: Messages,
    addLocalMessage: Message,
    deleteMessages: Ok,
    deleteChatMessagesBySender: Ok,
    deleteChatMessagesByDate: Ok,
    editMessageText: Message,
    editMessageLiveLocation: Message,
    editMessageChecklist: Message,
    editMessageMedia: Message,
    editMessageCaption: Message,
    editMessageReplyMarkup: Message,
    editInlineMessageText: Ok,
    editInlineMessageLiveLocation: Ok,
    editInlineMessageMedia: Ok,
    editInlineMessageCaption: Ok,
    editInlineMessageReplyMarkup: Ok,
    editMessageSchedulingState: Ok,
    setMessageFactCheck: Ok,
    sendBusinessMessage: BusinessMessage,
    sendBusinessMessageAlbum: BusinessMessages,
    editBusinessMessageText: BusinessMessage,
    editBusinessMessageLiveLocation: BusinessMessage,
    editBusinessMessageChecklist: BusinessMessage,
    editBusinessMessageMedia: BusinessMessage,
    editBusinessMessageCaption: BusinessMessage,
    editBusinessMessageReplyMarkup: BusinessMessage,
    stopBusinessPoll: BusinessMessage,
    setBusinessMessageIsPinned: Ok,
    readBusinessMessage: Ok,
    deleteBusinessMessages: Ok,
    editBusinessStory: Story,
    deleteBusinessStory: Ok,
    setBusinessAccountName: Ok,
    setBusinessAccountBio: Ok,
    setBusinessAccountProfilePhoto: Ok,
    setBusinessAccountUsername: Ok,
    setBusinessAccountGiftSettings: Ok,
    getBusinessAccountStarAmount: StarAmount,
    transferBusinessAccountStars: Ok,
    checkQuickReplyShortcutName: Ok,
    loadQuickReplyShortcuts: Ok,
    setQuickReplyShortcutName: Ok,
    deleteQuickReplyShortcut: Ok,
    reorderQuickReplyShortcuts: Ok,
    loadQuickReplyShortcutMessages: Ok,
    deleteQuickReplyShortcutMessages: Ok,
    addQuickReplyShortcutMessage: QuickReplyMessage,
    addQuickReplyShortcutInlineQueryResultMessage: QuickReplyMessage,
    addQuickReplyShortcutMessageAlbum: QuickReplyMessages,
    readdQuickReplyShortcutMessages: QuickReplyMessages,
    editQuickReplyMessage: Ok,
    getForumTopicDefaultIcons: Stickers,
    createForumTopic: ForumTopicInfo,
    editForumTopic: Ok,
    getForumTopic: ForumTopic,
    getForumTopicLink: MessageLink,
    getForumTopics: ForumTopics,
    setForumTopicNotificationSettings: Ok,
    toggleForumTopicIsClosed: Ok,
    toggleGeneralForumTopicIsHidden: Ok,
    toggleForumTopicIsPinned: Ok,
    setPinnedForumTopics: Ok,
    deleteForumTopic: Ok,
    getEmojiReaction: EmojiReaction,
    getCustomEmojiReactionAnimations: Stickers,
    getMessageAvailableReactions: AvailableReactions,
    clearRecentReactions: Ok,
    addMessageReaction: Ok,
    removeMessageReaction: Ok,
    getChatAvailablePaidMessageReactionSenders: MessageSenders,
    addPendingPaidMessageReaction: Ok,
    commitPendingPaidMessageReactions: Ok,
    removePendingPaidMessageReactions: Ok,
    setPaidMessageReactionType: Ok,
    setMessageReactions: Ok,
    getMessageAddedReactions: AddedReactions,
    setDefaultReactionType: Ok,
    getSavedMessagesTags: SavedMessagesTags,
    setSavedMessagesTagLabel: Ok,
    getMessageEffect: MessageEffect,
    searchQuote: FoundPosition,
    getTextEntities: TextEntities,
    parseTextEntities: FormattedText,
    parseMarkdown: FormattedText,
    getMarkdownText: FormattedText,
    getCountryFlagEmoji: Text,
    getFileMimeType: Text,
    getFileExtension: Text,
    cleanFileName: Text,
    getLanguagePackString: LanguagePackStringValue,
    getJsonValue: JsonValue,
    getJsonString: Text,
    getThemeParametersJsonString: Text,
    setPollAnswer: Ok,
    getPollVoters: MessageSenders,
    stopPoll: Ok,
    addChecklistTasks: Ok,
    markChecklistTasksAsDone: Ok,
    hideSuggestedAction: Ok,
    hideContactCloseBirthdays: Ok,
    getBusinessConnection: BusinessConnection,
    getLoginUrlInfo: LoginUrlInfo,
    getLoginUrl: HttpUrl,
    shareUsersWithBot: Ok,
    shareChatWithBot: Ok,
    getInlineQueryResults: InlineQueryResults,
    answerInlineQuery: Ok,
    savePreparedInlineMessage: PreparedInlineMessageId,
    getPreparedInlineMessage: PreparedInlineMessage,
    getGrossingWebAppBots: FoundUsers,
    searchWebApp: FoundWebApp,
    getWebAppPlaceholder: Outline,
    getWebAppLinkUrl: HttpUrl,
    getMainWebApp: MainWebApp,
    getWebAppUrl: HttpUrl,
    sendWebAppData: Ok,
    openWebApp: WebAppInfo,
    closeWebApp: Ok,
    answerWebAppQuery: SentWebAppMessage,
    checkWebAppFileDownload: Ok,
    getCallbackQueryAnswer: CallbackQueryAnswer,
    answerCallbackQuery: Ok,
    answerShippingQuery: Ok,
    answerPreCheckoutQuery: Ok,
    setGameScore: Message,
    setInlineGameScore: Ok,
    getGameHighScores: GameHighScores,
    getInlineGameHighScores: GameHighScores,
    deleteChatReplyMarkup: Ok,
    sendChatAction: Ok,
    openChat: Ok,
    closeChat: Ok,
    viewMessages: Ok,
    openMessageContent: Ok,
    clickAnimatedEmojiMessage: Sticker,
    getInternalLink: HttpUrl,
    getInternalLinkType: InternalLinkType,
    getExternalLinkInfo: LoginUrlInfo,
    getExternalLink: HttpUrl,
    readAllChatMentions: Ok,
    readAllMessageThreadMentions: Ok,
    readAllChatReactions: Ok,
    readAllMessageThreadReactions: Ok,
    createPrivateChat: Chat,
    createBasicGroupChat: Chat,
    createSupergroupChat: Chat,
    createSecretChat: Chat,
    createNewBasicGroupChat: CreatedBasicGroupChat,
    createNewSupergroupChat: Chat,
    createNewSecretChat: Chat,
    upgradeBasicGroupChatToSupergroupChat: Chat,
    getChatListsToAddChat: ChatLists,
    addChatToList: Ok,
    getChatFolder: ChatFolder,
    createChatFolder: ChatFolderInfo,
    editChatFolder: ChatFolderInfo,
    deleteChatFolder: Ok,
    getChatFolderChatsToLeave: Chats,
    getChatFolderChatCount: Count,
    reorderChatFolders: Ok,
    toggleChatFolderTags: Ok,
    getRecommendedChatFolders: RecommendedChatFolders,
    getChatFolderDefaultIconName: ChatFolderIcon,
    getChatsForChatFolderInviteLink: Chats,
    createChatFolderInviteLink: ChatFolderInviteLink,
    getChatFolderInviteLinks: ChatFolderInviteLinks,
    editChatFolderInviteLink: ChatFolderInviteLink,
    deleteChatFolderInviteLink: Ok,
    checkChatFolderInviteLink: ChatFolderInviteLinkInfo,
    addChatFolderByInviteLink: Ok,
    getChatFolderNewChats: Chats,
    processChatFolderNewChats: Ok,
    getArchiveChatListSettings: ArchiveChatListSettings,
    setArchiveChatListSettings: Ok,
    setChatTitle: Ok,
    setChatPhoto: Ok,
    setChatAccentColor: Ok,
    setChatProfileAccentColor: Ok,
    setChatMessageAutoDeleteTime: Ok,
    setChatEmojiStatus: Ok,
    setChatPermissions: Ok,
    setChatBackground: Ok,
    deleteChatBackground: Ok,
    setChatTheme: Ok,
    setChatDraftMessage: Ok,
    setChatNotificationSettings: Ok,
    toggleChatHasProtectedContent: Ok,
    toggleChatViewAsTopics: Ok,
    toggleChatIsTranslatable: Ok,
    toggleChatIsMarkedAsUnread: Ok,
    toggleChatDefaultDisableNotification: Ok,
    setChatAvailableReactions: Ok,
    setChatClientData: Ok,
    setChatDescription: Ok,
    setChatDiscussionGroup: Ok,
    setChatDirectMessagesGroup: Ok,
    setChatLocation: Ok,
    setChatSlowModeDelay: Ok,
    pinChatMessage: Ok,
    unpinChatMessage: Ok,
    unpinAllChatMessages: Ok,
    unpinAllMessageThreadMessages: Ok,
    joinChat: Ok,
    leaveChat: Ok,
    addChatMember: FailedToAddMembers,
    addChatMembers: FailedToAddMembers,
    setChatMemberStatus: Ok,
    banChatMember: Ok,
    canTransferOwnership: CanTransferOwnershipResult,
    transferChatOwnership: Ok,
    getChatMember: ChatMember,
    searchChatMembers: ChatMembers,
    getChatAdministrators: ChatAdministrators,
    clearAllDraftMessages: Ok,
    getSavedNotificationSound: NotificationSounds,
    getSavedNotificationSounds: NotificationSounds,
    addSavedNotificationSound: NotificationSound,
    removeSavedNotificationSound: Ok,
    getChatNotificationSettingsExceptions: Chats,
    getScopeNotificationSettings: ScopeNotificationSettings,
    setScopeNotificationSettings: Ok,
    setReactionNotificationSettings: Ok,
    resetAllNotificationSettings: Ok,
    toggleChatIsPinned: Ok,
    setPinnedChats: Ok,
    readChatList: Ok,
    getCurrentWeather: CurrentWeather,
    getStory: Story,
    getChatsToPostStories: Chats,
    canPostStory: CanPostStoryResult,
    postStory: Story,
    editStory: Ok,
    editStoryCover: Ok,
    setStoryPrivacySettings: Ok,
    toggleStoryIsPostedToChatPage: Ok,
    deleteStory: Ok,
    getStoryNotificationSettingsExceptions: Chats,
    loadActiveStories: Ok,
    setChatActiveStoriesList: Ok,
    getChatActiveStories: ChatActiveStories,
    getChatPostedToChatPageStories: Stories,
    getChatArchivedStories: Stories,
    setChatPinnedStories: Ok,
    openStory: Ok,
    closeStory: Ok,
    getStoryAvailableReactions: AvailableReactions,
    setStoryReaction: Ok,
    getStoryInteractions: StoryInteractions,
    getChatStoryInteractions: StoryInteractions,
    reportStory: ReportStoryResult,
    activateStoryStealthMode: Ok,
    getStoryPublicForwards: PublicForwards,
    getChatBoostLevelFeatures: ChatBoostLevelFeatures,
    getChatBoostFeatures: ChatBoostFeatures,
    getAvailableChatBoostSlots: ChatBoostSlots,
    getChatBoostStatus: ChatBoostStatus,
    boostChat: ChatBoostSlots,
    getChatBoostLink: ChatBoostLink,
    getChatBoostLinkInfo: ChatBoostLinkInfo,
    getChatBoosts: FoundChatBoosts,
    getUserChatBoosts: FoundChatBoosts,
    getAttachmentMenuBot: AttachmentMenuBot,
    toggleBotIsAddedToAttachmentMenu: Ok,
    getThemedEmojiStatuses: EmojiStatusCustomEmojis,
    getRecentEmojiStatuses: EmojiStatuses,
    getUpgradedGiftEmojiStatuses: EmojiStatuses,
    getDefaultEmojiStatuses: EmojiStatusCustomEmojis,
    clearRecentEmojiStatuses: Ok,
    getThemedChatEmojiStatuses: EmojiStatusCustomEmojis,
    getDefaultChatEmojiStatuses: EmojiStatusCustomEmojis,
    getDisallowedChatEmojiStatuses: EmojiStatusCustomEmojis,
    downloadFile: File,
    getFileDownloadedPrefixSize: FileDownloadedPrefixSize,
    cancelDownloadFile: Ok,
    getSuggestedFileName: Text,
    preliminaryUploadFile: File,
    cancelPreliminaryUploadFile: Ok,
    writeGeneratedFilePart: Ok,
    setFileGenerationProgress: Ok,
    finishFileGeneration: Ok,
    readFilePart: Data,
    deleteFile: Ok,
    addFileToDownloads: File,
    toggleDownloadIsPaused: Ok,
    toggleAllDownloadsArePaused: Ok,
    removeFileFromDownloads: Ok,
    removeAllFilesFromDownloads: Ok,
    searchFileDownloads: FoundFileDownloads,
    setApplicationVerificationToken: Ok,
    getMessageFileType: MessageFileType,
    getMessageImportConfirmationText: Text,
    importMessages: Ok,
    replacePrimaryChatInviteLink: ChatInviteLink,
    createChatInviteLink: ChatInviteLink,
    createChatSubscriptionInviteLink: ChatInviteLink,
    editChatInviteLink: ChatInviteLink,
    editChatSubscriptionInviteLink: ChatInviteLink,
    getChatInviteLink: ChatInviteLink,
    getChatInviteLinkCounts: ChatInviteLinkCounts,
    getChatInviteLinks: ChatInviteLinks,
    getChatInviteLinkMembers: ChatInviteLinkMembers,
    revokeChatInviteLink: ChatInviteLinks,
    deleteRevokedChatInviteLink: Ok,
    deleteAllRevokedChatInviteLinks: Ok,
    checkChatInviteLink: ChatInviteLinkInfo,
    joinChatByInviteLink: Chat,
    getChatJoinRequests: ChatJoinRequests,
    processChatJoinRequest: Ok,
    processChatJoinRequests: Ok,
    createCall: CallId,
    acceptCall: Ok,
    sendCallSignalingData: Ok,
    discardCall: Ok,
    sendCallRating: Ok,
    sendCallDebugInformation: Ok,
    sendCallLog: Ok,
    getVideoChatAvailableParticipants: MessageSenders,
    setVideoChatDefaultParticipant: Ok,
    createVideoChat: GroupCallId,
    createGroupCall: GroupCallInfo,
    getVideoChatRtmpUrl: RtmpUrl,
    replaceVideoChatRtmpUrl: RtmpUrl,
    getGroupCall: GroupCall,
    startScheduledVideoChat: Ok,
    toggleVideoChatEnabledStartNotification: Ok,
    joinGroupCall: GroupCallInfo,
    joinVideoChat: Text,
    startGroupCallScreenSharing: Text,
    toggleGroupCallScreenSharingIsPaused: Ok,
    endGroupCallScreenSharing: Ok,
    setVideoChatTitle: Ok,
    toggleVideoChatMuteNewParticipants: Ok,
    inviteGroupCallParticipant: InviteGroupCallParticipantResult,
    declineGroupCallInvitation: Ok,
    banGroupCallParticipants: Ok,
    inviteVideoChatParticipants: Ok,
    getVideoChatInviteLink: HttpUrl,
    revokeGroupCallInviteLink: Ok,
    startGroupCallRecording: Ok,
    endGroupCallRecording: Ok,
    toggleGroupCallIsMyVideoPaused: Ok,
    toggleGroupCallIsMyVideoEnabled: Ok,
    setGroupCallParticipantIsSpeaking: MessageSender,
    toggleGroupCallParticipantIsMuted: Ok,
    setGroupCallParticipantVolumeLevel: Ok,
    toggleGroupCallParticipantIsHandRaised: Ok,
    getGroupCallParticipants: GroupCallParticipants,
    loadGroupCallParticipants: Ok,
    leaveGroupCall: Ok,
    endGroupCall: Ok,
    getVideoChatStreams: VideoChatStreams,
    getVideoChatStreamSegment: Data,
    encryptGroupCallData: Data,
    decryptGroupCallData: Data,
    setMessageSenderBlockList: Ok,
    blockMessageSenderFromReplies: Ok,
    getBlockedMessageSenders: MessageSenders,
    addContact: Ok,
    importContacts: ImportedContacts,
    getContacts: Users,
    searchContacts: Users,
    removeContacts: Ok,
    getImportedContactCount: Count,
    changeImportedContacts: ImportedContacts,
    clearImportedContacts: Ok,
    setCloseFriends: Ok,
    getCloseFriends: Users,
    setUserPersonalProfilePhoto: Ok,
    suggestUserProfilePhoto: Ok,
    toggleBotCanManageEmojiStatus: Ok,
    setUserEmojiStatus: Ok,
    searchUserByPhoneNumber: User,
    sharePhoneNumber: Ok,
    getUserProfilePhotos: ChatPhotos,
    getStickerOutline: Outline,
    getStickers: Stickers,
    getAllStickerEmojis: Emojis,
    searchStickers: Stickers,
    getGreetingStickers: Stickers,
    getPremiumStickers: Stickers,
    getInstalledStickerSets: StickerSets,
    getArchivedStickerSets: StickerSets,
    getTrendingStickerSets: TrendingStickerSets,
    getAttachedStickerSets: StickerSets,
    getStickerSet: StickerSet,
    getStickerSetName: Text,
    searchStickerSet: StickerSet,
    searchInstalledStickerSets: StickerSets,
    searchStickerSets: StickerSets,
    changeStickerSet: Ok,
    viewTrendingStickerSets: Ok,
    reorderInstalledStickerSets: Ok,
    getRecentStickers: Stickers,
    addRecentSticker: Stickers,
    removeRecentSticker: Ok,
    clearRecentStickers: Ok,
    getFavoriteStickers: Stickers,
    addFavoriteSticker: Ok,
    removeFavoriteSticker: Ok,
    getStickerEmojis: Emojis,
    searchEmojis: EmojiKeywords,
    getKeywordEmojis: Emojis,
    getEmojiCategories: EmojiCategories,
    getAnimatedEmoji: AnimatedEmoji,
    getEmojiSuggestionsUrl: HttpUrl,
    getCustomEmojiStickers: Stickers,
    getDefaultChatPhotoCustomEmojiStickers: Stickers,
    getDefaultProfilePhotoCustomEmojiStickers: Stickers,
    getDefaultBackgroundCustomEmojiStickers: Stickers,
    getSavedAnimations: Animations,
    addSavedAnimation: Ok,
    removeSavedAnimation: Ok,
    getRecentInlineBots: Users,
    getOwnedBots: Users,
    searchHashtags: Hashtags,
    removeRecentHashtag: Ok,
    getLinkPreview: LinkPreview,
    getWebPageInstantView: WebPageInstantView,
    setProfilePhoto: Ok,
    deleteProfilePhoto: Ok,
    setAccentColor: Ok,
    setProfileAccentColor: Ok,
    setName: Ok,
    setBio: Ok,
    setUsername: Ok,
    toggleUsernameIsActive: Ok,
    reorderActiveUsernames: Ok,
    setBirthdate: Ok,
    setPersonalChat: Ok,
    setEmojiStatus: Ok,
    toggleHasSponsoredMessagesEnabled: Ok,
    setBusinessLocation: Ok,
    setBusinessOpeningHours: Ok,
    setBusinessGreetingMessageSettings: Ok,
    setBusinessAwayMessageSettings: Ok,
    setBusinessStartPage: Ok,
    sendPhoneNumberCode: AuthenticationCodeInfo,
    sendPhoneNumberFirebaseSms: Ok,
    reportPhoneNumberCodeMissing: Ok,
    resendPhoneNumberCode: AuthenticationCodeInfo,
    checkPhoneNumberCode: Ok,
    getBusinessConnectedBot: BusinessConnectedBot,
    setBusinessConnectedBot: Ok,
    deleteBusinessConnectedBot: Ok,
    toggleBusinessConnectedBotChatIsPaused: Ok,
    removeBusinessConnectedBotFromChat: Ok,
    getBusinessChatLinks: BusinessChatLinks,
    createBusinessChatLink: BusinessChatLink,
    editBusinessChatLink: BusinessChatLink,
    deleteBusinessChatLink: Ok,
    getBusinessChatLinkInfo: BusinessChatLinkInfo,
    getUserLink: UserLink,
    searchUserByToken: User,
    setCommands: Ok,
    deleteCommands: Ok,
    getCommands: BotCommands,
    setMenuButton: Ok,
    getMenuButton: BotMenuButton,
    setDefaultGroupAdministratorRights: Ok,
    setDefaultChannelAdministratorRights: Ok,
    canBotSendMessages: Ok,
    allowBotToSendMessages: Ok,
    sendWebAppCustomRequest: CustomRequestResult,
    getBotMediaPreviews: BotMediaPreviews,
    getBotMediaPreviewInfo: BotMediaPreviewInfo,
    addBotMediaPreview: BotMediaPreview,
    editBotMediaPreview: BotMediaPreview,
    reorderBotMediaPreviews: Ok,
    deleteBotMediaPreviews: Ok,
    setBotName: Ok,
    getBotName: Text,
    setBotProfilePhoto: Ok,
    toggleBotUsernameIsActive: Ok,
    reorderBotActiveUsernames: Ok,
    setBotInfoDescription: Ok,
    getBotInfoDescription: Text,
    setBotInfoShortDescription: Ok,
    getBotInfoShortDescription: Text,
    setMessageSenderBotVerification: Ok,
    removeMessageSenderBotVerification: Ok,
    getActiveSessions: Sessions,
    terminateSession: Ok,
    terminateAllOtherSessions: Ok,
    confirmSession: Ok,
    toggleSessionCanAcceptCalls: Ok,
    toggleSessionCanAcceptSecretChats: Ok,
    setInactiveSessionTtl: Ok,
    getConnectedWebsites: ConnectedWebsites,
    disconnectWebsite: Ok,
    disconnectAllWebsites: Ok,
    setSupergroupUsername: Ok,
    toggleSupergroupUsernameIsActive: Ok,
    disableAllSupergroupUsernames: Ok,
    reorderSupergroupActiveUsernames: Ok,
    setSupergroupStickerSet: Ok,
    setSupergroupCustomEmojiStickerSet: Ok,
    setSupergroupUnrestrictBoostCount: Ok,
    toggleSupergroupSignMessages: Ok,
    toggleSupergroupJoinToSendMessages: Ok,
    toggleSupergroupJoinByRequest: Ok,
    toggleSupergroupIsAllHistoryAvailable: Ok,
    toggleSupergroupCanHaveSponsoredMessages: Ok,
    toggleSupergroupHasAutomaticTranslation: Ok,
    toggleSupergroupHasHiddenMembers: Ok,
    toggleSupergroupHasAggressiveAntiSpamEnabled: Ok,
    toggleSupergroupIsForum: Ok,
    toggleSupergroupIsBroadcastGroup: Ok,
    reportSupergroupSpam: Ok,
    reportSupergroupAntiSpamFalsePositive: Ok,
    getSupergroupMembers: ChatMembers,
    closeSecretChat: Ok,
    getChatEventLog: ChatEvents,
    getTimeZones: TimeZones,
    getPaymentForm: PaymentForm,
    validateOrderInfo: ValidatedOrderInfo,
    sendPaymentForm: PaymentResult,
    getPaymentReceipt: PaymentReceipt,
    getSavedOrderInfo: OrderInfo,
    deleteSavedOrderInfo: Ok,
    deleteSavedCredentials: Ok,
    setGiftSettings: Ok,
    getAvailableGifts: AvailableGifts,
    sendGift: Ok,
    sellGift: Ok,
    toggleGiftIsSaved: Ok,
    setPinnedGifts: Ok,
    toggleChatGiftNotifications: Ok,
    getGiftUpgradePreview: GiftUpgradePreview,
    upgradeGift: UpgradeGiftResult,
    transferGift: Ok,
    sendResoldGift: Ok,
    getReceivedGifts: ReceivedGifts,
    getReceivedGift: ReceivedGift,
    getUpgradedGift: UpgradedGift,
    getUpgradedGiftWithdrawalUrl: HttpUrl,
    setGiftResalePrice: Ok,
    searchGiftsForResale: GiftsForResale,
    createInvoiceLink: HttpUrl,
    refundStarPayment: Ok,
    getSupportUser: User,
    getBackgroundUrl: HttpUrl,
    searchBackground: Background,
    setDefaultBackground: Background,
    deleteDefaultBackground: Ok,
    getInstalledBackgrounds: Backgrounds,
    removeInstalledBackground: Ok,
    resetInstalledBackgrounds: Ok,
    getLocalizationTargetInfo: LocalizationTargetInfo,
    getLanguagePackInfo: LanguagePackInfo,
    getLanguagePackStrings: LanguagePackStrings,
    synchronizeLanguagePack: Ok,
    addCustomServerLanguagePack: Ok,
    setCustomLanguagePack: Ok,
    editCustomLanguagePackInfo: Ok,
    setCustomLanguagePackString: Ok,
    deleteLanguagePack: Ok,
    registerDevice: PushReceiverId,
    processPushNotification: Ok,
    getPushReceiverId: PushReceiverId,
    getRecentlyVisitedTMeUrls: TMeUrls,
    setUserPrivacySettingRules: Ok,
    getUserPrivacySettingRules: UserPrivacySettingRules,
    setReadDatePrivacySettings: Ok,
    getReadDatePrivacySettings: ReadDatePrivacySettings,
    setNewChatPrivacySettings: Ok,
    getNewChatPrivacySettings: NewChatPrivacySettings,
    getPaidMessageRevenue: StarCount,
    allowUnpaidMessagesFromUser: Ok,
    setChatPaidMessageStarCount: Ok,
    canSendMessageToUser: CanSendMessageToUserResult,
    getOption: OptionValue,
    setOption: Ok,
    setAccountTtl: Ok,
    getAccountTtl: AccountTtl,
    deleteAccount: Ok,
    setDefaultMessageAutoDeleteTime: Ok,
    getDefaultMessageAutoDeleteTime: MessageAutoDeleteTime,
    removeChatActionBar: Ok,
    reportChat: ReportChatResult,
    reportChatPhoto: Ok,
    reportMessageReactions: Ok,
    getChatRevenueStatistics: ChatRevenueStatistics,
    getChatRevenueWithdrawalUrl: HttpUrl,
    getChatRevenueTransactions: ChatRevenueTransactions,
    getStarRevenueStatistics: StarRevenueStatistics,
    getStarWithdrawalUrl: HttpUrl,
    getStarAdAccountUrl: HttpUrl,
    getChatStatistics: ChatStatistics,
    getMessageStatistics: MessageStatistics,
    getMessagePublicForwards: PublicForwards,
    getStoryStatistics: StoryStatistics,
    getStatisticalGraph: StatisticalGraph,
    getStorageStatistics: StorageStatistics,
    getStorageStatisticsFast: StorageStatisticsFast,
    getDatabaseStatistics: DatabaseStatistics,
    optimizeStorage: StorageStatistics,
    setNetworkType: Ok,
    getNetworkStatistics: NetworkStatistics,
    addNetworkStatistics: Ok,
    resetNetworkStatistics: Ok,
    getAutoDownloadSettingsPresets: AutoDownloadSettingsPresets,
    setAutoDownloadSettings: Ok,
    getAutosaveSettings: AutosaveSettings,
    setAutosaveSettings: Ok,
    clearAutosaveSettingsExceptions: Ok,
    getBankCardInfo: BankCardInfo,
    getPassportElement: PassportElement,
    getAllPassportElements: PassportElements,
    setPassportElement: PassportElement,
    deletePassportElement: Ok,
    setPassportElementErrors: Ok,
    getPreferredCountryLanguage: Text,
    sendEmailAddressVerificationCode: EmailAddressAuthenticationCodeInfo,
    resendEmailAddressVerificationCode: EmailAddressAuthenticationCodeInfo,
    checkEmailAddressVerificationCode: Ok,
    getPassportAuthorizationForm: PassportAuthorizationForm,
    getPassportAuthorizationFormAvailableElements: PassportElementsWithErrors,
    sendPassportAuthorizationForm: Ok,
    setBotUpdatesStatus: Ok,
    uploadStickerFile: File,
    getSuggestedStickerSetName: Text,
    checkStickerSetName: CheckStickerSetNameResult,
    createNewStickerSet: StickerSet,
    addStickerToSet: Ok,
    replaceStickerInSet: Ok,
    setStickerSetThumbnail: Ok,
    setCustomEmojiStickerSetThumbnail: Ok,
    setStickerSetTitle: Ok,
    deleteStickerSet: Ok,
    setStickerPositionInSet: Ok,
    removeStickerFromSet: Ok,
    setStickerEmojis: Ok,
    setStickerKeywords: Ok,
    setStickerMaskPosition: Ok,
    getOwnedStickerSets: StickerSets,
    getMapThumbnailFile: File,
    getPremiumLimit: PremiumLimit,
    getPremiumFeatures: PremiumFeatures,
    getPremiumStickerExamples: Stickers,
    getPremiumInfoSticker: Sticker,
    viewPremiumFeature: Ok,
    clickPremiumSubscriptionButton: Ok,
    getPremiumState: PremiumState,
    getPremiumGiftPaymentOptions: PremiumGiftPaymentOptions,
    getPremiumGiveawayPaymentOptions: PremiumGiveawayPaymentOptions,
    checkPremiumGiftCode: PremiumGiftCodeInfo,
    applyPremiumGiftCode: Ok,
    giftPremiumWithStars: Ok,
    launchPrepaidGiveaway: Ok,
    getGiveawayInfo: GiveawayInfo,
    getStarPaymentOptions: StarPaymentOptions,
    getStarGiftPaymentOptions: StarPaymentOptions,
    getStarGiveawayPaymentOptions: StarGiveawayPaymentOptions,
    getStarTransactions: StarTransactions,
    getStarSubscriptions: StarSubscriptions,
    canPurchaseFromStore: Ok,
    assignStoreTransaction: Ok,
    editStarSubscription: Ok,
    editUserStarSubscription: Ok,
    reuseStarSubscription: Ok,
    setChatAffiliateProgram: Ok,
    searchChatAffiliateProgram: Chat,
    searchAffiliatePrograms: FoundAffiliatePrograms,
    connectAffiliateProgram: ConnectedAffiliateProgram,
    disconnectAffiliateProgram: ConnectedAffiliateProgram,
    getConnectedAffiliateProgram: ConnectedAffiliateProgram,
    getConnectedAffiliatePrograms: ConnectedAffiliatePrograms,
    getBusinessFeatures: BusinessFeatures,
    acceptTermsOfService: Ok,
    searchStringsByPrefix: FoundPositions,
    sendCustomRequest: CustomRequestResult,
    answerCustomQuery: Ok,
    setAlarm: Ok,
    getCountries: Countries,
    getCountryCode: Text,
    getPhoneNumberInfo: PhoneNumberInfo,
    getPhoneNumberInfoSync: PhoneNumberInfo,
    getCollectibleItemInfo: CollectibleItemInfo,
    getDeepLinkInfo: DeepLinkInfo,
    getApplicationConfig: JsonValue,
    saveApplicationLogEvent: Ok,
    getApplicationDownloadLink: HttpUrl,
    addProxy: Proxy,
    editProxy: Proxy,
    enableProxy: Ok,
    disableProxy: Ok,
    removeProxy: Ok,
    getProxies: Proxies,
    getProxyLink: HttpUrl,
    pingProxy: Seconds,
    setLogStream: Ok,
    getLogStream: LogStream,
    setLogVerbosityLevel: Ok,
    getLogVerbosityLevel: LogVerbosityLevel,
    getLogTags: LogTags,
    setLogTagVerbosityLevel: Ok,
    getLogTagVerbosityLevel: LogVerbosityLevel,
    addLogMessage: Ok,
    getUserSupportInfo: UserSupportInfo,
    setUserSupportInfo: UserSupportInfo,
    getSupportName: Text,
    testCallEmpty: Ok,
    testCallString: TestString,
    testCallBytes: TestBytes,
    testCallVectorInt: TestVectorInt,
    testCallVectorIntObject: TestVectorIntObject,
    testCallVectorString: TestVectorString,
    testCallVectorStringObject: TestVectorStringObject,
    testSquareInt: TestInt,
    testNetwork: Ok,
    testProxy: Ok,
    testGetDifference: Ok,
    testUseUpdate: Update,
    testReturnError: Error,
  }

  export type $FunctionInputByName = {
    getAuthorizationState: getAuthorizationState,
    setTdlibParameters: setTdlibParameters,
    setAuthenticationPhoneNumber: setAuthenticationPhoneNumber,
    checkAuthenticationPremiumPurchase: checkAuthenticationPremiumPurchase,
    setAuthenticationPremiumPurchaseTransaction: setAuthenticationPremiumPurchaseTransaction,
    setAuthenticationEmailAddress: setAuthenticationEmailAddress,
    resendAuthenticationCode: resendAuthenticationCode,
    checkAuthenticationEmailCode: checkAuthenticationEmailCode,
    checkAuthenticationCode: checkAuthenticationCode,
    requestQrCodeAuthentication: requestQrCodeAuthentication,
    registerUser: registerUser,
    resetAuthenticationEmailAddress: resetAuthenticationEmailAddress,
    checkAuthenticationPassword: checkAuthenticationPassword,
    requestAuthenticationPasswordRecovery: requestAuthenticationPasswordRecovery,
    checkAuthenticationPasswordRecoveryCode: checkAuthenticationPasswordRecoveryCode,
    recoverAuthenticationPassword: recoverAuthenticationPassword,
    sendAuthenticationFirebaseSms: sendAuthenticationFirebaseSms,
    reportAuthenticationCodeMissing: reportAuthenticationCodeMissing,
    checkAuthenticationBotToken: checkAuthenticationBotToken,
    logOut: logOut,
    close: close,
    destroy: destroy,
    confirmQrCodeAuthentication: confirmQrCodeAuthentication,
    getCurrentState: getCurrentState,
    setDatabaseEncryptionKey: setDatabaseEncryptionKey,
    getPasswordState: getPasswordState,
    setPassword: setPassword,
    setLoginEmailAddress: setLoginEmailAddress,
    resendLoginEmailAddressCode: resendLoginEmailAddressCode,
    checkLoginEmailAddressCode: checkLoginEmailAddressCode,
    getRecoveryEmailAddress: getRecoveryEmailAddress,
    setRecoveryEmailAddress: setRecoveryEmailAddress,
    checkRecoveryEmailAddressCode: checkRecoveryEmailAddressCode,
    resendRecoveryEmailAddressCode: resendRecoveryEmailAddressCode,
    cancelRecoveryEmailAddressVerification: cancelRecoveryEmailAddressVerification,
    requestPasswordRecovery: requestPasswordRecovery,
    checkPasswordRecoveryCode: checkPasswordRecoveryCode,
    recoverPassword: recoverPassword,
    resetPassword: resetPassword,
    cancelPasswordReset: cancelPasswordReset,
    createTemporaryPassword: createTemporaryPassword,
    getTemporaryPasswordState: getTemporaryPasswordState,
    getMe: getMe,
    getUser: getUser,
    getUserFullInfo: getUserFullInfo,
    getBasicGroup: getBasicGroup,
    getBasicGroupFullInfo: getBasicGroupFullInfo,
    getSupergroup: getSupergroup,
    getSupergroupFullInfo: getSupergroupFullInfo,
    getSecretChat: getSecretChat,
    getChat: getChat,
    getMessage: getMessage,
    getMessageLocally: getMessageLocally,
    getRepliedMessage: getRepliedMessage,
    getChatPinnedMessage: getChatPinnedMessage,
    getCallbackQueryMessage: getCallbackQueryMessage,
    getMessages: getMessages,
    getMessageProperties: getMessageProperties,
    getMessageThread: getMessageThread,
    getMessageReadDate: getMessageReadDate,
    getMessageViewers: getMessageViewers,
    getMessageAuthor: getMessageAuthor,
    getFile: getFile,
    getRemoteFile: getRemoteFile,
    loadChats: loadChats,
    getChats: getChats,
    searchPublicChat: searchPublicChat,
    searchPublicChats: searchPublicChats,
    searchChats: searchChats,
    searchChatsOnServer: searchChatsOnServer,
    getRecommendedChats: getRecommendedChats,
    getChatSimilarChats: getChatSimilarChats,
    getChatSimilarChatCount: getChatSimilarChatCount,
    openChatSimilarChat: openChatSimilarChat,
    getBotSimilarBots: getBotSimilarBots,
    getBotSimilarBotCount: getBotSimilarBotCount,
    openBotSimilarBot: openBotSimilarBot,
    getTopChats: getTopChats,
    removeTopChat: removeTopChat,
    searchRecentlyFoundChats: searchRecentlyFoundChats,
    addRecentlyFoundChat: addRecentlyFoundChat,
    removeRecentlyFoundChat: removeRecentlyFoundChat,
    clearRecentlyFoundChats: clearRecentlyFoundChats,
    getRecentlyOpenedChats: getRecentlyOpenedChats,
    checkChatUsername: checkChatUsername,
    getCreatedPublicChats: getCreatedPublicChats,
    checkCreatedPublicChatsLimit: checkCreatedPublicChatsLimit,
    getSuitableDiscussionChats: getSuitableDiscussionChats,
    getInactiveSupergroupChats: getInactiveSupergroupChats,
    getSuitablePersonalChats: getSuitablePersonalChats,
    loadDirectMessagesChatTopics: loadDirectMessagesChatTopics,
    getDirectMessagesChatTopic: getDirectMessagesChatTopic,
    getDirectMessagesChatTopicHistory: getDirectMessagesChatTopicHistory,
    getDirectMessagesChatTopicMessageByDate: getDirectMessagesChatTopicMessageByDate,
    deleteDirectMessagesChatTopicHistory: deleteDirectMessagesChatTopicHistory,
    deleteDirectMessagesChatTopicMessagesByDate: deleteDirectMessagesChatTopicMessagesByDate,
    setDirectMessagesChatTopicIsMarkedAsUnread: setDirectMessagesChatTopicIsMarkedAsUnread,
    setDirectMessagesChatTopicDraftMessage: setDirectMessagesChatTopicDraftMessage,
    unpinAllDirectMessagesChatTopicMessages: unpinAllDirectMessagesChatTopicMessages,
    readAllDirectMessagesChatTopicReactions: readAllDirectMessagesChatTopicReactions,
    getDirectMessagesChatTopicRevenue: getDirectMessagesChatTopicRevenue,
    toggleDirectMessagesChatTopicCanSendUnpaidMessages: toggleDirectMessagesChatTopicCanSendUnpaidMessages,
    loadSavedMessagesTopics: loadSavedMessagesTopics,
    getSavedMessagesTopicHistory: getSavedMessagesTopicHistory,
    getSavedMessagesTopicMessageByDate: getSavedMessagesTopicMessageByDate,
    deleteSavedMessagesTopicHistory: deleteSavedMessagesTopicHistory,
    deleteSavedMessagesTopicMessagesByDate: deleteSavedMessagesTopicMessagesByDate,
    toggleSavedMessagesTopicIsPinned: toggleSavedMessagesTopicIsPinned,
    setPinnedSavedMessagesTopics: setPinnedSavedMessagesTopics,
    getGroupsInCommon: getGroupsInCommon,
    getChatHistory: getChatHistory,
    getMessageThreadHistory: getMessageThreadHistory,
    deleteChatHistory: deleteChatHistory,
    deleteChat: deleteChat,
    searchChatMessages: searchChatMessages,
    searchMessages: searchMessages,
    searchSecretMessages: searchSecretMessages,
    searchSavedMessages: searchSavedMessages,
    searchCallMessages: searchCallMessages,
    searchOutgoingDocumentMessages: searchOutgoingDocumentMessages,
    searchPublicMessagesByTag: searchPublicMessagesByTag,
    searchPublicStoriesByTag: searchPublicStoriesByTag,
    searchPublicStoriesByLocation: searchPublicStoriesByLocation,
    searchPublicStoriesByVenue: searchPublicStoriesByVenue,
    getSearchedForTags: getSearchedForTags,
    removeSearchedForTag: removeSearchedForTag,
    clearSearchedForTags: clearSearchedForTags,
    deleteAllCallMessages: deleteAllCallMessages,
    searchChatRecentLocationMessages: searchChatRecentLocationMessages,
    getChatMessageByDate: getChatMessageByDate,
    getChatSparseMessagePositions: getChatSparseMessagePositions,
    getChatMessageCalendar: getChatMessageCalendar,
    getChatMessageCount: getChatMessageCount,
    getChatMessagePosition: getChatMessagePosition,
    getChatScheduledMessages: getChatScheduledMessages,
    getChatSponsoredMessages: getChatSponsoredMessages,
    clickChatSponsoredMessage: clickChatSponsoredMessage,
    reportChatSponsoredMessage: reportChatSponsoredMessage,
    getSearchSponsoredChats: getSearchSponsoredChats,
    viewSponsoredChat: viewSponsoredChat,
    openSponsoredChat: openSponsoredChat,
    reportSponsoredChat: reportSponsoredChat,
    getVideoMessageAdvertisements: getVideoMessageAdvertisements,
    viewVideoMessageAdvertisement: viewVideoMessageAdvertisement,
    clickVideoMessageAdvertisement: clickVideoMessageAdvertisement,
    reportVideoMessageAdvertisement: reportVideoMessageAdvertisement,
    removeNotification: removeNotification,
    removeNotificationGroup: removeNotificationGroup,
    getMessageLink: getMessageLink,
    getMessageEmbeddingCode: getMessageEmbeddingCode,
    getMessageLinkInfo: getMessageLinkInfo,
    translateText: translateText,
    translateMessageText: translateMessageText,
    recognizeSpeech: recognizeSpeech,
    rateSpeechRecognition: rateSpeechRecognition,
    getChatAvailableMessageSenders: getChatAvailableMessageSenders,
    setChatMessageSender: setChatMessageSender,
    sendMessage: sendMessage,
    sendMessageAlbum: sendMessageAlbum,
    sendBotStartMessage: sendBotStartMessage,
    sendInlineQueryResultMessage: sendInlineQueryResultMessage,
    forwardMessages: forwardMessages,
    sendQuickReplyShortcutMessages: sendQuickReplyShortcutMessages,
    resendMessages: resendMessages,
    addLocalMessage: addLocalMessage,
    deleteMessages: deleteMessages,
    deleteChatMessagesBySender: deleteChatMessagesBySender,
    deleteChatMessagesByDate: deleteChatMessagesByDate,
    editMessageText: editMessageText,
    editMessageLiveLocation: editMessageLiveLocation,
    editMessageChecklist: editMessageChecklist,
    editMessageMedia: editMessageMedia,
    editMessageCaption: editMessageCaption,
    editMessageReplyMarkup: editMessageReplyMarkup,
    editInlineMessageText: editInlineMessageText,
    editInlineMessageLiveLocation: editInlineMessageLiveLocation,
    editInlineMessageMedia: editInlineMessageMedia,
    editInlineMessageCaption: editInlineMessageCaption,
    editInlineMessageReplyMarkup: editInlineMessageReplyMarkup,
    editMessageSchedulingState: editMessageSchedulingState,
    setMessageFactCheck: setMessageFactCheck,
    sendBusinessMessage: sendBusinessMessage,
    sendBusinessMessageAlbum: sendBusinessMessageAlbum,
    editBusinessMessageText: editBusinessMessageText,
    editBusinessMessageLiveLocation: editBusinessMessageLiveLocation,
    editBusinessMessageChecklist: editBusinessMessageChecklist,
    editBusinessMessageMedia: editBusinessMessageMedia,
    editBusinessMessageCaption: editBusinessMessageCaption,
    editBusinessMessageReplyMarkup: editBusinessMessageReplyMarkup,
    stopBusinessPoll: stopBusinessPoll,
    setBusinessMessageIsPinned: setBusinessMessageIsPinned,
    readBusinessMessage: readBusinessMessage,
    deleteBusinessMessages: deleteBusinessMessages,
    editBusinessStory: editBusinessStory,
    deleteBusinessStory: deleteBusinessStory,
    setBusinessAccountName: setBusinessAccountName,
    setBusinessAccountBio: setBusinessAccountBio,
    setBusinessAccountProfilePhoto: setBusinessAccountProfilePhoto,
    setBusinessAccountUsername: setBusinessAccountUsername,
    setBusinessAccountGiftSettings: setBusinessAccountGiftSettings,
    getBusinessAccountStarAmount: getBusinessAccountStarAmount,
    transferBusinessAccountStars: transferBusinessAccountStars,
    checkQuickReplyShortcutName: checkQuickReplyShortcutName,
    loadQuickReplyShortcuts: loadQuickReplyShortcuts,
    setQuickReplyShortcutName: setQuickReplyShortcutName,
    deleteQuickReplyShortcut: deleteQuickReplyShortcut,
    reorderQuickReplyShortcuts: reorderQuickReplyShortcuts,
    loadQuickReplyShortcutMessages: loadQuickReplyShortcutMessages,
    deleteQuickReplyShortcutMessages: deleteQuickReplyShortcutMessages,
    addQuickReplyShortcutMessage: addQuickReplyShortcutMessage,
    addQuickReplyShortcutInlineQueryResultMessage: addQuickReplyShortcutInlineQueryResultMessage,
    addQuickReplyShortcutMessageAlbum: addQuickReplyShortcutMessageAlbum,
    readdQuickReplyShortcutMessages: readdQuickReplyShortcutMessages,
    editQuickReplyMessage: editQuickReplyMessage,
    getForumTopicDefaultIcons: getForumTopicDefaultIcons,
    createForumTopic: createForumTopic,
    editForumTopic: editForumTopic,
    getForumTopic: getForumTopic,
    getForumTopicLink: getForumTopicLink,
    getForumTopics: getForumTopics,
    setForumTopicNotificationSettings: setForumTopicNotificationSettings,
    toggleForumTopicIsClosed: toggleForumTopicIsClosed,
    toggleGeneralForumTopicIsHidden: toggleGeneralForumTopicIsHidden,
    toggleForumTopicIsPinned: toggleForumTopicIsPinned,
    setPinnedForumTopics: setPinnedForumTopics,
    deleteForumTopic: deleteForumTopic,
    getEmojiReaction: getEmojiReaction,
    getCustomEmojiReactionAnimations: getCustomEmojiReactionAnimations,
    getMessageAvailableReactions: getMessageAvailableReactions,
    clearRecentReactions: clearRecentReactions,
    addMessageReaction: addMessageReaction,
    removeMessageReaction: removeMessageReaction,
    getChatAvailablePaidMessageReactionSenders: getChatAvailablePaidMessageReactionSenders,
    addPendingPaidMessageReaction: addPendingPaidMessageReaction,
    commitPendingPaidMessageReactions: commitPendingPaidMessageReactions,
    removePendingPaidMessageReactions: removePendingPaidMessageReactions,
    setPaidMessageReactionType: setPaidMessageReactionType,
    setMessageReactions: setMessageReactions,
    getMessageAddedReactions: getMessageAddedReactions,
    setDefaultReactionType: setDefaultReactionType,
    getSavedMessagesTags: getSavedMessagesTags,
    setSavedMessagesTagLabel: setSavedMessagesTagLabel,
    getMessageEffect: getMessageEffect,
    searchQuote: searchQuote,
    getTextEntities: getTextEntities,
    parseTextEntities: parseTextEntities,
    parseMarkdown: parseMarkdown,
    getMarkdownText: getMarkdownText,
    getCountryFlagEmoji: getCountryFlagEmoji,
    getFileMimeType: getFileMimeType,
    getFileExtension: getFileExtension,
    cleanFileName: cleanFileName,
    getLanguagePackString: getLanguagePackString,
    getJsonValue: getJsonValue,
    getJsonString: getJsonString,
    getThemeParametersJsonString: getThemeParametersJsonString,
    setPollAnswer: setPollAnswer,
    getPollVoters: getPollVoters,
    stopPoll: stopPoll,
    addChecklistTasks: addChecklistTasks,
    markChecklistTasksAsDone: markChecklistTasksAsDone,
    hideSuggestedAction: hideSuggestedAction,
    hideContactCloseBirthdays: hideContactCloseBirthdays,
    getBusinessConnection: getBusinessConnection,
    getLoginUrlInfo: getLoginUrlInfo,
    getLoginUrl: getLoginUrl,
    shareUsersWithBot: shareUsersWithBot,
    shareChatWithBot: shareChatWithBot,
    getInlineQueryResults: getInlineQueryResults,
    answerInlineQuery: answerInlineQuery,
    savePreparedInlineMessage: savePreparedInlineMessage,
    getPreparedInlineMessage: getPreparedInlineMessage,
    getGrossingWebAppBots: getGrossingWebAppBots,
    searchWebApp: searchWebApp,
    getWebAppPlaceholder: getWebAppPlaceholder,
    getWebAppLinkUrl: getWebAppLinkUrl,
    getMainWebApp: getMainWebApp,
    getWebAppUrl: getWebAppUrl,
    sendWebAppData: sendWebAppData,
    openWebApp: openWebApp,
    closeWebApp: closeWebApp,
    answerWebAppQuery: answerWebAppQuery,
    checkWebAppFileDownload: checkWebAppFileDownload,
    getCallbackQueryAnswer: getCallbackQueryAnswer,
    answerCallbackQuery: answerCallbackQuery,
    answerShippingQuery: answerShippingQuery,
    answerPreCheckoutQuery: answerPreCheckoutQuery,
    setGameScore: setGameScore,
    setInlineGameScore: setInlineGameScore,
    getGameHighScores: getGameHighScores,
    getInlineGameHighScores: getInlineGameHighScores,
    deleteChatReplyMarkup: deleteChatReplyMarkup,
    sendChatAction: sendChatAction,
    openChat: openChat,
    closeChat: closeChat,
    viewMessages: viewMessages,
    openMessageContent: openMessageContent,
    clickAnimatedEmojiMessage: clickAnimatedEmojiMessage,
    getInternalLink: getInternalLink,
    getInternalLinkType: getInternalLinkType,
    getExternalLinkInfo: getExternalLinkInfo,
    getExternalLink: getExternalLink,
    readAllChatMentions: readAllChatMentions,
    readAllMessageThreadMentions: readAllMessageThreadMentions,
    readAllChatReactions: readAllChatReactions,
    readAllMessageThreadReactions: readAllMessageThreadReactions,
    createPrivateChat: createPrivateChat,
    createBasicGroupChat: createBasicGroupChat,
    createSupergroupChat: createSupergroupChat,
    createSecretChat: createSecretChat,
    createNewBasicGroupChat: createNewBasicGroupChat,
    createNewSupergroupChat: createNewSupergroupChat,
    createNewSecretChat: createNewSecretChat,
    upgradeBasicGroupChatToSupergroupChat: upgradeBasicGroupChatToSupergroupChat,
    getChatListsToAddChat: getChatListsToAddChat,
    addChatToList: addChatToList,
    getChatFolder: getChatFolder,
    createChatFolder: createChatFolder,
    editChatFolder: editChatFolder,
    deleteChatFolder: deleteChatFolder,
    getChatFolderChatsToLeave: getChatFolderChatsToLeave,
    getChatFolderChatCount: getChatFolderChatCount,
    reorderChatFolders: reorderChatFolders,
    toggleChatFolderTags: toggleChatFolderTags,
    getRecommendedChatFolders: getRecommendedChatFolders,
    getChatFolderDefaultIconName: getChatFolderDefaultIconName,
    getChatsForChatFolderInviteLink: getChatsForChatFolderInviteLink,
    createChatFolderInviteLink: createChatFolderInviteLink,
    getChatFolderInviteLinks: getChatFolderInviteLinks,
    editChatFolderInviteLink: editChatFolderInviteLink,
    deleteChatFolderInviteLink: deleteChatFolderInviteLink,
    checkChatFolderInviteLink: checkChatFolderInviteLink,
    addChatFolderByInviteLink: addChatFolderByInviteLink,
    getChatFolderNewChats: getChatFolderNewChats,
    processChatFolderNewChats: processChatFolderNewChats,
    getArchiveChatListSettings: getArchiveChatListSettings,
    setArchiveChatListSettings: setArchiveChatListSettings,
    setChatTitle: setChatTitle,
    setChatPhoto: setChatPhoto,
    setChatAccentColor: setChatAccentColor,
    setChatProfileAccentColor: setChatProfileAccentColor,
    setChatMessageAutoDeleteTime: setChatMessageAutoDeleteTime,
    setChatEmojiStatus: setChatEmojiStatus,
    setChatPermissions: setChatPermissions,
    setChatBackground: setChatBackground,
    deleteChatBackground: deleteChatBackground,
    setChatTheme: setChatTheme,
    setChatDraftMessage: setChatDraftMessage,
    setChatNotificationSettings: setChatNotificationSettings,
    toggleChatHasProtectedContent: toggleChatHasProtectedContent,
    toggleChatViewAsTopics: toggleChatViewAsTopics,
    toggleChatIsTranslatable: toggleChatIsTranslatable,
    toggleChatIsMarkedAsUnread: toggleChatIsMarkedAsUnread,
    toggleChatDefaultDisableNotification: toggleChatDefaultDisableNotification,
    setChatAvailableReactions: setChatAvailableReactions,
    setChatClientData: setChatClientData,
    setChatDescription: setChatDescription,
    setChatDiscussionGroup: setChatDiscussionGroup,
    setChatDirectMessagesGroup: setChatDirectMessagesGroup,
    setChatLocation: setChatLocation,
    setChatSlowModeDelay: setChatSlowModeDelay,
    pinChatMessage: pinChatMessage,
    unpinChatMessage: unpinChatMessage,
    unpinAllChatMessages: unpinAllChatMessages,
    unpinAllMessageThreadMessages: unpinAllMessageThreadMessages,
    joinChat: joinChat,
    leaveChat: leaveChat,
    addChatMember: addChatMember,
    addChatMembers: addChatMembers,
    setChatMemberStatus: setChatMemberStatus,
    banChatMember: banChatMember,
    canTransferOwnership: canTransferOwnership,
    transferChatOwnership: transferChatOwnership,
    getChatMember: getChatMember,
    searchChatMembers: searchChatMembers,
    getChatAdministrators: getChatAdministrators,
    clearAllDraftMessages: clearAllDraftMessages,
    getSavedNotificationSound: getSavedNotificationSound,
    getSavedNotificationSounds: getSavedNotificationSounds,
    addSavedNotificationSound: addSavedNotificationSound,
    removeSavedNotificationSound: removeSavedNotificationSound,
    getChatNotificationSettingsExceptions: getChatNotificationSettingsExceptions,
    getScopeNotificationSettings: getScopeNotificationSettings,
    setScopeNotificationSettings: setScopeNotificationSettings,
    setReactionNotificationSettings: setReactionNotificationSettings,
    resetAllNotificationSettings: resetAllNotificationSettings,
    toggleChatIsPinned: toggleChatIsPinned,
    setPinnedChats: setPinnedChats,
    readChatList: readChatList,
    getCurrentWeather: getCurrentWeather,
    getStory: getStory,
    getChatsToPostStories: getChatsToPostStories,
    canPostStory: canPostStory,
    postStory: postStory,
    editStory: editStory,
    editStoryCover: editStoryCover,
    setStoryPrivacySettings: setStoryPrivacySettings,
    toggleStoryIsPostedToChatPage: toggleStoryIsPostedToChatPage,
    deleteStory: deleteStory,
    getStoryNotificationSettingsExceptions: getStoryNotificationSettingsExceptions,
    loadActiveStories: loadActiveStories,
    setChatActiveStoriesList: setChatActiveStoriesList,
    getChatActiveStories: getChatActiveStories,
    getChatPostedToChatPageStories: getChatPostedToChatPageStories,
    getChatArchivedStories: getChatArchivedStories,
    setChatPinnedStories: setChatPinnedStories,
    openStory: openStory,
    closeStory: closeStory,
    getStoryAvailableReactions: getStoryAvailableReactions,
    setStoryReaction: setStoryReaction,
    getStoryInteractions: getStoryInteractions,
    getChatStoryInteractions: getChatStoryInteractions,
    reportStory: reportStory,
    activateStoryStealthMode: activateStoryStealthMode,
    getStoryPublicForwards: getStoryPublicForwards,
    getChatBoostLevelFeatures: getChatBoostLevelFeatures,
    getChatBoostFeatures: getChatBoostFeatures,
    getAvailableChatBoostSlots: getAvailableChatBoostSlots,
    getChatBoostStatus: getChatBoostStatus,
    boostChat: boostChat,
    getChatBoostLink: getChatBoostLink,
    getChatBoostLinkInfo: getChatBoostLinkInfo,
    getChatBoosts: getChatBoosts,
    getUserChatBoosts: getUserChatBoosts,
    getAttachmentMenuBot: getAttachmentMenuBot,
    toggleBotIsAddedToAttachmentMenu: toggleBotIsAddedToAttachmentMenu,
    getThemedEmojiStatuses: getThemedEmojiStatuses,
    getRecentEmojiStatuses: getRecentEmojiStatuses,
    getUpgradedGiftEmojiStatuses: getUpgradedGiftEmojiStatuses,
    getDefaultEmojiStatuses: getDefaultEmojiStatuses,
    clearRecentEmojiStatuses: clearRecentEmojiStatuses,
    getThemedChatEmojiStatuses: getThemedChatEmojiStatuses,
    getDefaultChatEmojiStatuses: getDefaultChatEmojiStatuses,
    getDisallowedChatEmojiStatuses: getDisallowedChatEmojiStatuses,
    downloadFile: downloadFile,
    getFileDownloadedPrefixSize: getFileDownloadedPrefixSize,
    cancelDownloadFile: cancelDownloadFile,
    getSuggestedFileName: getSuggestedFileName,
    preliminaryUploadFile: preliminaryUploadFile,
    cancelPreliminaryUploadFile: cancelPreliminaryUploadFile,
    writeGeneratedFilePart: writeGeneratedFilePart,
    setFileGenerationProgress: setFileGenerationProgress,
    finishFileGeneration: finishFileGeneration,
    readFilePart: readFilePart,
    deleteFile: deleteFile,
    addFileToDownloads: addFileToDownloads,
    toggleDownloadIsPaused: toggleDownloadIsPaused,
    toggleAllDownloadsArePaused: toggleAllDownloadsArePaused,
    removeFileFromDownloads: removeFileFromDownloads,
    removeAllFilesFromDownloads: removeAllFilesFromDownloads,
    searchFileDownloads: searchFileDownloads,
    setApplicationVerificationToken: setApplicationVerificationToken,
    getMessageFileType: getMessageFileType,
    getMessageImportConfirmationText: getMessageImportConfirmationText,
    importMessages: importMessages,
    replacePrimaryChatInviteLink: replacePrimaryChatInviteLink,
    createChatInviteLink: createChatInviteLink,
    createChatSubscriptionInviteLink: createChatSubscriptionInviteLink,
    editChatInviteLink: editChatInviteLink,
    editChatSubscriptionInviteLink: editChatSubscriptionInviteLink,
    getChatInviteLink: getChatInviteLink,
    getChatInviteLinkCounts: getChatInviteLinkCounts,
    getChatInviteLinks: getChatInviteLinks,
    getChatInviteLinkMembers: getChatInviteLinkMembers,
    revokeChatInviteLink: revokeChatInviteLink,
    deleteRevokedChatInviteLink: deleteRevokedChatInviteLink,
    deleteAllRevokedChatInviteLinks: deleteAllRevokedChatInviteLinks,
    checkChatInviteLink: checkChatInviteLink,
    joinChatByInviteLink: joinChatByInviteLink,
    getChatJoinRequests: getChatJoinRequests,
    processChatJoinRequest: processChatJoinRequest,
    processChatJoinRequests: processChatJoinRequests,
    createCall: createCall,
    acceptCall: acceptCall,
    sendCallSignalingData: sendCallSignalingData,
    discardCall: discardCall,
    sendCallRating: sendCallRating,
    sendCallDebugInformation: sendCallDebugInformation,
    sendCallLog: sendCallLog,
    getVideoChatAvailableParticipants: getVideoChatAvailableParticipants,
    setVideoChatDefaultParticipant: setVideoChatDefaultParticipant,
    createVideoChat: createVideoChat,
    createGroupCall: createGroupCall,
    getVideoChatRtmpUrl: getVideoChatRtmpUrl,
    replaceVideoChatRtmpUrl: replaceVideoChatRtmpUrl,
    getGroupCall: getGroupCall,
    startScheduledVideoChat: startScheduledVideoChat,
    toggleVideoChatEnabledStartNotification: toggleVideoChatEnabledStartNotification,
    joinGroupCall: joinGroupCall,
    joinVideoChat: joinVideoChat,
    startGroupCallScreenSharing: startGroupCallScreenSharing,
    toggleGroupCallScreenSharingIsPaused: toggleGroupCallScreenSharingIsPaused,
    endGroupCallScreenSharing: endGroupCallScreenSharing,
    setVideoChatTitle: setVideoChatTitle,
    toggleVideoChatMuteNewParticipants: toggleVideoChatMuteNewParticipants,
    inviteGroupCallParticipant: inviteGroupCallParticipant,
    declineGroupCallInvitation: declineGroupCallInvitation,
    banGroupCallParticipants: banGroupCallParticipants,
    inviteVideoChatParticipants: inviteVideoChatParticipants,
    getVideoChatInviteLink: getVideoChatInviteLink,
    revokeGroupCallInviteLink: revokeGroupCallInviteLink,
    startGroupCallRecording: startGroupCallRecording,
    endGroupCallRecording: endGroupCallRecording,
    toggleGroupCallIsMyVideoPaused: toggleGroupCallIsMyVideoPaused,
    toggleGroupCallIsMyVideoEnabled: toggleGroupCallIsMyVideoEnabled,
    setGroupCallParticipantIsSpeaking: setGroupCallParticipantIsSpeaking,
    toggleGroupCallParticipantIsMuted: toggleGroupCallParticipantIsMuted,
    setGroupCallParticipantVolumeLevel: setGroupCallParticipantVolumeLevel,
    toggleGroupCallParticipantIsHandRaised: toggleGroupCallParticipantIsHandRaised,
    getGroupCallParticipants: getGroupCallParticipants,
    loadGroupCallParticipants: loadGroupCallParticipants,
    leaveGroupCall: leaveGroupCall,
    endGroupCall: endGroupCall,
    getVideoChatStreams: getVideoChatStreams,
    getVideoChatStreamSegment: getVideoChatStreamSegment,
    encryptGroupCallData: encryptGroupCallData,
    decryptGroupCallData: decryptGroupCallData,
    setMessageSenderBlockList: setMessageSenderBlockList,
    blockMessageSenderFromReplies: blockMessageSenderFromReplies,
    getBlockedMessageSenders: getBlockedMessageSenders,
    addContact: addContact,
    importContacts: importContacts,
    getContacts: getContacts,
    searchContacts: searchContacts,
    removeContacts: removeContacts,
    getImportedContactCount: getImportedContactCount,
    changeImportedContacts: changeImportedContacts,
    clearImportedContacts: clearImportedContacts,
    setCloseFriends: setCloseFriends,
    getCloseFriends: getCloseFriends,
    setUserPersonalProfilePhoto: setUserPersonalProfilePhoto,
    suggestUserProfilePhoto: suggestUserProfilePhoto,
    toggleBotCanManageEmojiStatus: toggleBotCanManageEmojiStatus,
    setUserEmojiStatus: setUserEmojiStatus,
    searchUserByPhoneNumber: searchUserByPhoneNumber,
    sharePhoneNumber: sharePhoneNumber,
    getUserProfilePhotos: getUserProfilePhotos,
    getStickerOutline: getStickerOutline,
    getStickers: getStickers,
    getAllStickerEmojis: getAllStickerEmojis,
    searchStickers: searchStickers,
    getGreetingStickers: getGreetingStickers,
    getPremiumStickers: getPremiumStickers,
    getInstalledStickerSets: getInstalledStickerSets,
    getArchivedStickerSets: getArchivedStickerSets,
    getTrendingStickerSets: getTrendingStickerSets,
    getAttachedStickerSets: getAttachedStickerSets,
    getStickerSet: getStickerSet,
    getStickerSetName: getStickerSetName,
    searchStickerSet: searchStickerSet,
    searchInstalledStickerSets: searchInstalledStickerSets,
    searchStickerSets: searchStickerSets,
    changeStickerSet: changeStickerSet,
    viewTrendingStickerSets: viewTrendingStickerSets,
    reorderInstalledStickerSets: reorderInstalledStickerSets,
    getRecentStickers: getRecentStickers,
    addRecentSticker: addRecentSticker,
    removeRecentSticker: removeRecentSticker,
    clearRecentStickers: clearRecentStickers,
    getFavoriteStickers: getFavoriteStickers,
    addFavoriteSticker: addFavoriteSticker,
    removeFavoriteSticker: removeFavoriteSticker,
    getStickerEmojis: getStickerEmojis,
    searchEmojis: searchEmojis,
    getKeywordEmojis: getKeywordEmojis,
    getEmojiCategories: getEmojiCategories,
    getAnimatedEmoji: getAnimatedEmoji,
    getEmojiSuggestionsUrl: getEmojiSuggestionsUrl,
    getCustomEmojiStickers: getCustomEmojiStickers,
    getDefaultChatPhotoCustomEmojiStickers: getDefaultChatPhotoCustomEmojiStickers,
    getDefaultProfilePhotoCustomEmojiStickers: getDefaultProfilePhotoCustomEmojiStickers,
    getDefaultBackgroundCustomEmojiStickers: getDefaultBackgroundCustomEmojiStickers,
    getSavedAnimations: getSavedAnimations,
    addSavedAnimation: addSavedAnimation,
    removeSavedAnimation: removeSavedAnimation,
    getRecentInlineBots: getRecentInlineBots,
    getOwnedBots: getOwnedBots,
    searchHashtags: searchHashtags,
    removeRecentHashtag: removeRecentHashtag,
    getLinkPreview: getLinkPreview,
    getWebPageInstantView: getWebPageInstantView,
    setProfilePhoto: setProfilePhoto,
    deleteProfilePhoto: deleteProfilePhoto,
    setAccentColor: setAccentColor,
    setProfileAccentColor: setProfileAccentColor,
    setName: setName,
    setBio: setBio,
    setUsername: setUsername,
    toggleUsernameIsActive: toggleUsernameIsActive,
    reorderActiveUsernames: reorderActiveUsernames,
    setBirthdate: setBirthdate,
    setPersonalChat: setPersonalChat,
    setEmojiStatus: setEmojiStatus,
    toggleHasSponsoredMessagesEnabled: toggleHasSponsoredMessagesEnabled,
    setBusinessLocation: setBusinessLocation,
    setBusinessOpeningHours: setBusinessOpeningHours,
    setBusinessGreetingMessageSettings: setBusinessGreetingMessageSettings,
    setBusinessAwayMessageSettings: setBusinessAwayMessageSettings,
    setBusinessStartPage: setBusinessStartPage,
    sendPhoneNumberCode: sendPhoneNumberCode,
    sendPhoneNumberFirebaseSms: sendPhoneNumberFirebaseSms,
    reportPhoneNumberCodeMissing: reportPhoneNumberCodeMissing,
    resendPhoneNumberCode: resendPhoneNumberCode,
    checkPhoneNumberCode: checkPhoneNumberCode,
    getBusinessConnectedBot: getBusinessConnectedBot,
    setBusinessConnectedBot: setBusinessConnectedBot,
    deleteBusinessConnectedBot: deleteBusinessConnectedBot,
    toggleBusinessConnectedBotChatIsPaused: toggleBusinessConnectedBotChatIsPaused,
    removeBusinessConnectedBotFromChat: removeBusinessConnectedBotFromChat,
    getBusinessChatLinks: getBusinessChatLinks,
    createBusinessChatLink: createBusinessChatLink,
    editBusinessChatLink: editBusinessChatLink,
    deleteBusinessChatLink: deleteBusinessChatLink,
    getBusinessChatLinkInfo: getBusinessChatLinkInfo,
    getUserLink: getUserLink,
    searchUserByToken: searchUserByToken,
    setCommands: setCommands,
    deleteCommands: deleteCommands,
    getCommands: getCommands,
    setMenuButton: setMenuButton,
    getMenuButton: getMenuButton,
    setDefaultGroupAdministratorRights: setDefaultGroupAdministratorRights,
    setDefaultChannelAdministratorRights: setDefaultChannelAdministratorRights,
    canBotSendMessages: canBotSendMessages,
    allowBotToSendMessages: allowBotToSendMessages,
    sendWebAppCustomRequest: sendWebAppCustomRequest,
    getBotMediaPreviews: getBotMediaPreviews,
    getBotMediaPreviewInfo: getBotMediaPreviewInfo,
    addBotMediaPreview: addBotMediaPreview,
    editBotMediaPreview: editBotMediaPreview,
    reorderBotMediaPreviews: reorderBotMediaPreviews,
    deleteBotMediaPreviews: deleteBotMediaPreviews,
    setBotName: setBotName,
    getBotName: getBotName,
    setBotProfilePhoto: setBotProfilePhoto,
    toggleBotUsernameIsActive: toggleBotUsernameIsActive,
    reorderBotActiveUsernames: reorderBotActiveUsernames,
    setBotInfoDescription: setBotInfoDescription,
    getBotInfoDescription: getBotInfoDescription,
    setBotInfoShortDescription: setBotInfoShortDescription,
    getBotInfoShortDescription: getBotInfoShortDescription,
    setMessageSenderBotVerification: setMessageSenderBotVerification,
    removeMessageSenderBotVerification: removeMessageSenderBotVerification,
    getActiveSessions: getActiveSessions,
    terminateSession: terminateSession,
    terminateAllOtherSessions: terminateAllOtherSessions,
    confirmSession: confirmSession,
    toggleSessionCanAcceptCalls: toggleSessionCanAcceptCalls,
    toggleSessionCanAcceptSecretChats: toggleSessionCanAcceptSecretChats,
    setInactiveSessionTtl: setInactiveSessionTtl,
    getConnectedWebsites: getConnectedWebsites,
    disconnectWebsite: disconnectWebsite,
    disconnectAllWebsites: disconnectAllWebsites,
    setSupergroupUsername: setSupergroupUsername,
    toggleSupergroupUsernameIsActive: toggleSupergroupUsernameIsActive,
    disableAllSupergroupUsernames: disableAllSupergroupUsernames,
    reorderSupergroupActiveUsernames: reorderSupergroupActiveUsernames,
    setSupergroupStickerSet: setSupergroupStickerSet,
    setSupergroupCustomEmojiStickerSet: setSupergroupCustomEmojiStickerSet,
    setSupergroupUnrestrictBoostCount: setSupergroupUnrestrictBoostCount,
    toggleSupergroupSignMessages: toggleSupergroupSignMessages,
    toggleSupergroupJoinToSendMessages: toggleSupergroupJoinToSendMessages,
    toggleSupergroupJoinByRequest: toggleSupergroupJoinByRequest,
    toggleSupergroupIsAllHistoryAvailable: toggleSupergroupIsAllHistoryAvailable,
    toggleSupergroupCanHaveSponsoredMessages: toggleSupergroupCanHaveSponsoredMessages,
    toggleSupergroupHasAutomaticTranslation: toggleSupergroupHasAutomaticTranslation,
    toggleSupergroupHasHiddenMembers: toggleSupergroupHasHiddenMembers,
    toggleSupergroupHasAggressiveAntiSpamEnabled: toggleSupergroupHasAggressiveAntiSpamEnabled,
    toggleSupergroupIsForum: toggleSupergroupIsForum,
    toggleSupergroupIsBroadcastGroup: toggleSupergroupIsBroadcastGroup,
    reportSupergroupSpam: reportSupergroupSpam,
    reportSupergroupAntiSpamFalsePositive: reportSupergroupAntiSpamFalsePositive,
    getSupergroupMembers: getSupergroupMembers,
    closeSecretChat: closeSecretChat,
    getChatEventLog: getChatEventLog,
    getTimeZones: getTimeZones,
    getPaymentForm: getPaymentForm,
    validateOrderInfo: validateOrderInfo,
    sendPaymentForm: sendPaymentForm,
    getPaymentReceipt: getPaymentReceipt,
    getSavedOrderInfo: getSavedOrderInfo,
    deleteSavedOrderInfo: deleteSavedOrderInfo,
    deleteSavedCredentials: deleteSavedCredentials,
    setGiftSettings: setGiftSettings,
    getAvailableGifts: getAvailableGifts,
    sendGift: sendGift,
    sellGift: sellGift,
    toggleGiftIsSaved: toggleGiftIsSaved,
    setPinnedGifts: setPinnedGifts,
    toggleChatGiftNotifications: toggleChatGiftNotifications,
    getGiftUpgradePreview: getGiftUpgradePreview,
    upgradeGift: upgradeGift,
    transferGift: transferGift,
    sendResoldGift: sendResoldGift,
    getReceivedGifts: getReceivedGifts,
    getReceivedGift: getReceivedGift,
    getUpgradedGift: getUpgradedGift,
    getUpgradedGiftWithdrawalUrl: getUpgradedGiftWithdrawalUrl,
    setGiftResalePrice: setGiftResalePrice,
    searchGiftsForResale: searchGiftsForResale,
    createInvoiceLink: createInvoiceLink,
    refundStarPayment: refundStarPayment,
    getSupportUser: getSupportUser,
    getBackgroundUrl: getBackgroundUrl,
    searchBackground: searchBackground,
    setDefaultBackground: setDefaultBackground,
    deleteDefaultBackground: deleteDefaultBackground,
    getInstalledBackgrounds: getInstalledBackgrounds,
    removeInstalledBackground: removeInstalledBackground,
    resetInstalledBackgrounds: resetInstalledBackgrounds,
    getLocalizationTargetInfo: getLocalizationTargetInfo,
    getLanguagePackInfo: getLanguagePackInfo,
    getLanguagePackStrings: getLanguagePackStrings,
    synchronizeLanguagePack: synchronizeLanguagePack,
    addCustomServerLanguagePack: addCustomServerLanguagePack,
    setCustomLanguagePack: setCustomLanguagePack,
    editCustomLanguagePackInfo: editCustomLanguagePackInfo,
    setCustomLanguagePackString: setCustomLanguagePackString,
    deleteLanguagePack: deleteLanguagePack,
    registerDevice: registerDevice,
    processPushNotification: processPushNotification,
    getPushReceiverId: getPushReceiverId,
    getRecentlyVisitedTMeUrls: getRecentlyVisitedTMeUrls,
    setUserPrivacySettingRules: setUserPrivacySettingRules,
    getUserPrivacySettingRules: getUserPrivacySettingRules,
    setReadDatePrivacySettings: setReadDatePrivacySettings,
    getReadDatePrivacySettings: getReadDatePrivacySettings,
    setNewChatPrivacySettings: setNewChatPrivacySettings,
    getNewChatPrivacySettings: getNewChatPrivacySettings,
    getPaidMessageRevenue: getPaidMessageRevenue,
    allowUnpaidMessagesFromUser: allowUnpaidMessagesFromUser,
    setChatPaidMessageStarCount: setChatPaidMessageStarCount,
    canSendMessageToUser: canSendMessageToUser,
    getOption: getOption,
    setOption: setOption,
    setAccountTtl: setAccountTtl,
    getAccountTtl: getAccountTtl,
    deleteAccount: deleteAccount,
    setDefaultMessageAutoDeleteTime: setDefaultMessageAutoDeleteTime,
    getDefaultMessageAutoDeleteTime: getDefaultMessageAutoDeleteTime,
    removeChatActionBar: removeChatActionBar,
    reportChat: reportChat,
    reportChatPhoto: reportChatPhoto,
    reportMessageReactions: reportMessageReactions,
    getChatRevenueStatistics: getChatRevenueStatistics,
    getChatRevenueWithdrawalUrl: getChatRevenueWithdrawalUrl,
    getChatRevenueTransactions: getChatRevenueTransactions,
    getStarRevenueStatistics: getStarRevenueStatistics,
    getStarWithdrawalUrl: getStarWithdrawalUrl,
    getStarAdAccountUrl: getStarAdAccountUrl,
    getChatStatistics: getChatStatistics,
    getMessageStatistics: getMessageStatistics,
    getMessagePublicForwards: getMessagePublicForwards,
    getStoryStatistics: getStoryStatistics,
    getStatisticalGraph: getStatisticalGraph,
    getStorageStatistics: getStorageStatistics,
    getStorageStatisticsFast: getStorageStatisticsFast,
    getDatabaseStatistics: getDatabaseStatistics,
    optimizeStorage: optimizeStorage,
    setNetworkType: setNetworkType,
    getNetworkStatistics: getNetworkStatistics,
    addNetworkStatistics: addNetworkStatistics,
    resetNetworkStatistics: resetNetworkStatistics,
    getAutoDownloadSettingsPresets: getAutoDownloadSettingsPresets,
    setAutoDownloadSettings: setAutoDownloadSettings,
    getAutosaveSettings: getAutosaveSettings,
    setAutosaveSettings: setAutosaveSettings,
    clearAutosaveSettingsExceptions: clearAutosaveSettingsExceptions,
    getBankCardInfo: getBankCardInfo,
    getPassportElement: getPassportElement,
    getAllPassportElements: getAllPassportElements,
    setPassportElement: setPassportElement,
    deletePassportElement: deletePassportElement,
    setPassportElementErrors: setPassportElementErrors,
    getPreferredCountryLanguage: getPreferredCountryLanguage,
    sendEmailAddressVerificationCode: sendEmailAddressVerificationCode,
    resendEmailAddressVerificationCode: resendEmailAddressVerificationCode,
    checkEmailAddressVerificationCode: checkEmailAddressVerificationCode,
    getPassportAuthorizationForm: getPassportAuthorizationForm,
    getPassportAuthorizationFormAvailableElements: getPassportAuthorizationFormAvailableElements,
    sendPassportAuthorizationForm: sendPassportAuthorizationForm,
    setBotUpdatesStatus: setBotUpdatesStatus,
    uploadStickerFile: uploadStickerFile,
    getSuggestedStickerSetName: getSuggestedStickerSetName,
    checkStickerSetName: checkStickerSetName,
    createNewStickerSet: createNewStickerSet,
    addStickerToSet: addStickerToSet,
    replaceStickerInSet: replaceStickerInSet,
    setStickerSetThumbnail: setStickerSetThumbnail,
    setCustomEmojiStickerSetThumbnail: setCustomEmojiStickerSetThumbnail,
    setStickerSetTitle: setStickerSetTitle,
    deleteStickerSet: deleteStickerSet,
    setStickerPositionInSet: setStickerPositionInSet,
    removeStickerFromSet: removeStickerFromSet,
    setStickerEmojis: setStickerEmojis,
    setStickerKeywords: setStickerKeywords,
    setStickerMaskPosition: setStickerMaskPosition,
    getOwnedStickerSets: getOwnedStickerSets,
    getMapThumbnailFile: getMapThumbnailFile,
    getPremiumLimit: getPremiumLimit,
    getPremiumFeatures: getPremiumFeatures,
    getPremiumStickerExamples: getPremiumStickerExamples,
    getPremiumInfoSticker: getPremiumInfoSticker,
    viewPremiumFeature: viewPremiumFeature,
    clickPremiumSubscriptionButton: clickPremiumSubscriptionButton,
    getPremiumState: getPremiumState,
    getPremiumGiftPaymentOptions: getPremiumGiftPaymentOptions,
    getPremiumGiveawayPaymentOptions: getPremiumGiveawayPaymentOptions,
    checkPremiumGiftCode: checkPremiumGiftCode,
    applyPremiumGiftCode: applyPremiumGiftCode,
    giftPremiumWithStars: giftPremiumWithStars,
    launchPrepaidGiveaway: launchPrepaidGiveaway,
    getGiveawayInfo: getGiveawayInfo,
    getStarPaymentOptions: getStarPaymentOptions,
    getStarGiftPaymentOptions: getStarGiftPaymentOptions,
    getStarGiveawayPaymentOptions: getStarGiveawayPaymentOptions,
    getStarTransactions: getStarTransactions,
    getStarSubscriptions: getStarSubscriptions,
    canPurchaseFromStore: canPurchaseFromStore,
    assignStoreTransaction: assignStoreTransaction,
    editStarSubscription: editStarSubscription,
    editUserStarSubscription: editUserStarSubscription,
    reuseStarSubscription: reuseStarSubscription,
    setChatAffiliateProgram: setChatAffiliateProgram,
    searchChatAffiliateProgram: searchChatAffiliateProgram,
    searchAffiliatePrograms: searchAffiliatePrograms,
    connectAffiliateProgram: connectAffiliateProgram,
    disconnectAffiliateProgram: disconnectAffiliateProgram,
    getConnectedAffiliateProgram: getConnectedAffiliateProgram,
    getConnectedAffiliatePrograms: getConnectedAffiliatePrograms,
    getBusinessFeatures: getBusinessFeatures,
    acceptTermsOfService: acceptTermsOfService,
    searchStringsByPrefix: searchStringsByPrefix,
    sendCustomRequest: sendCustomRequest,
    answerCustomQuery: answerCustomQuery,
    setAlarm: setAlarm,
    getCountries: getCountries,
    getCountryCode: getCountryCode,
    getPhoneNumberInfo: getPhoneNumberInfo,
    getPhoneNumberInfoSync: getPhoneNumberInfoSync,
    getCollectibleItemInfo: getCollectibleItemInfo,
    getDeepLinkInfo: getDeepLinkInfo,
    getApplicationConfig: getApplicationConfig,
    saveApplicationLogEvent: saveApplicationLogEvent,
    getApplicationDownloadLink: getApplicationDownloadLink,
    addProxy: addProxy,
    editProxy: editProxy,
    enableProxy: enableProxy,
    disableProxy: disableProxy,
    removeProxy: removeProxy,
    getProxies: getProxies,
    getProxyLink: getProxyLink,
    pingProxy: pingProxy,
    setLogStream: setLogStream,
    getLogStream: getLogStream,
    setLogVerbosityLevel: setLogVerbosityLevel,
    getLogVerbosityLevel: getLogVerbosityLevel,
    getLogTags: getLogTags,
    setLogTagVerbosityLevel: setLogTagVerbosityLevel,
    getLogTagVerbosityLevel: getLogTagVerbosityLevel,
    addLogMessage: addLogMessage,
    getUserSupportInfo: getUserSupportInfo,
    setUserSupportInfo: setUserSupportInfo,
    getSupportName: getSupportName,
    testCallEmpty: testCallEmpty,
    testCallString: testCallString,
    testCallBytes: testCallBytes,
    testCallVectorInt: testCallVectorInt,
    testCallVectorIntObject: testCallVectorIntObject,
    testCallVectorString: testCallVectorString,
    testCallVectorStringObject: testCallVectorStringObject,
    testSquareInt: testSquareInt,
    testNetwork: testNetwork,
    testProxy: testProxy,
    testGetDifference: testGetDifference,
    testUseUpdate: testUseUpdate,
    testReturnError: testReturnError,
  }

  export type $FunctionName = keyof $FunctionResultByName

  export type $SyncFunctionName =
    | 'checkQuickReplyShortcutName'
    | 'searchQuote'
    | 'getTextEntities'
    | 'parseTextEntities'
    | 'parseMarkdown'
    | 'getMarkdownText'
    | 'getCountryFlagEmoji'
    | 'getFileMimeType'
    | 'getFileExtension'
    | 'cleanFileName'
    | 'getLanguagePackString'
    | 'getJsonValue'
    | 'getJsonString'
    | 'getThemeParametersJsonString'
    | 'getChatFolderDefaultIconName'
    | 'getPushReceiverId'
    | 'getOption'
    | 'searchStringsByPrefix'
    | 'getPhoneNumberInfoSync'
    | 'setLogStream'
    | 'getLogStream'
    | 'setLogVerbosityLevel'
    | 'getLogVerbosityLevel'
    | 'getLogTags'
    | 'setLogTagVerbosityLevel'
    | 'getLogTagVerbosityLevel'
    | 'addLogMessage'
    | 'testReturnError'

  export type Invoke = <T extends $FunctionName>(
    query: { readonly _: T } & $FunctionInputByName[T]
  ) => Promise<$FunctionResultByName[T]>

  export type Execute = <T extends $SyncFunctionName>(
    query: { readonly _: T } & $FunctionInputByName[T]
  ) => error | $FunctionResultByName[T]
}
